
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model YearPlan
 * 
 */
export type YearPlan = $Result.DefaultSelection<Prisma.$YearPlanPayload>
/**
 * Model Goal
 * 
 */
export type Goal = $Result.DefaultSelection<Prisma.$GoalPayload>
/**
 * Model Milestone
 * 
 */
export type Milestone = $Result.DefaultSelection<Prisma.$MilestonePayload>
/**
 * Model KeyStep
 * 
 */
export type KeyStep = $Result.DefaultSelection<Prisma.$KeyStepPayload>
/**
 * Model Note
 * 
 */
export type Note = $Result.DefaultSelection<Prisma.$NotePayload>
/**
 * Model QuarterPlan
 * 
 */
export type QuarterPlan = $Result.DefaultSelection<Prisma.$QuarterPlanPayload>
/**
 * Model QuarterObjective
 * 
 */
export type QuarterObjective = $Result.DefaultSelection<Prisma.$QuarterObjectivePayload>
/**
 * Model QuarterFocus
 * 
 */
export type QuarterFocus = $Result.DefaultSelection<Prisma.$QuarterFocusPayload>
/**
 * Model MonthPlan
 * 
 */
export type MonthPlan = $Result.DefaultSelection<Prisma.$MonthPlanPayload>
/**
 * Model MonthFocus
 * 
 */
export type MonthFocus = $Result.DefaultSelection<Prisma.$MonthFocusPayload>
/**
 * Model WeekPlan
 * 
 */
export type WeekPlan = $Result.DefaultSelection<Prisma.$WeekPlanPayload>
/**
 * Model WeekFocus
 * 
 */
export type WeekFocus = $Result.DefaultSelection<Prisma.$WeekFocusPayload>
/**
 * Model DayPlan
 * 
 */
export type DayPlan = $Result.DefaultSelection<Prisma.$DayPlanPayload>
/**
 * Model DayFocus
 * 
 */
export type DayFocus = $Result.DefaultSelection<Prisma.$DayFocusPayload>
/**
 * Model TimeBlock
 * 
 */
export type TimeBlock = $Result.DefaultSelection<Prisma.$TimeBlockPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model TimeEntry
 * 
 */
export type TimeEntry = $Result.DefaultSelection<Prisma.$TimeEntryPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model Communication
 * 
 */
export type Communication = $Result.DefaultSelection<Prisma.$CommunicationPayload>
/**
 * Model Meeting
 * 
 */
export type Meeting = $Result.DefaultSelection<Prisma.$MeetingPayload>
/**
 * Model WellBeingEntry
 * 
 */
export type WellBeingEntry = $Result.DefaultSelection<Prisma.$WellBeingEntryPayload>
/**
 * Model Capture
 * 
 */
export type Capture = $Result.DefaultSelection<Prisma.$CapturePayload>
/**
 * Model VoiceSession
 * 
 */
export type VoiceSession = $Result.DefaultSelection<Prisma.$VoiceSessionPayload>
/**
 * Model CalendarEvent
 * 
 */
export type CalendarEvent = $Result.DefaultSelection<Prisma.$CalendarEventPayload>
/**
 * Model AnalyticsEvent
 * 
 */
export type AnalyticsEvent = $Result.DefaultSelection<Prisma.$AnalyticsEventPayload>
/**
 * Model Research
 * 
 */
export type Research = $Result.DefaultSelection<Prisma.$ResearchPayload>
/**
 * Model ResearchSource
 * 
 */
export type ResearchSource = $Result.DefaultSelection<Prisma.$ResearchSourcePayload>
/**
 * Model ResearchInsight
 * 
 */
export type ResearchInsight = $Result.DefaultSelection<Prisma.$ResearchInsightPayload>
/**
 * Model ActionItem
 * 
 */
export type ActionItem = $Result.DefaultSelection<Prisma.$ActionItemPayload>
/**
 * Model LeadData
 * 
 */
export type LeadData = $Result.DefaultSelection<Prisma.$LeadDataPayload>
/**
 * Model Lead
 * 
 */
export type Lead = $Result.DefaultSelection<Prisma.$LeadPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ResearchScope: {
  MARKET_ANALYSIS: 'MARKET_ANALYSIS',
  LEAD_GENERATION: 'LEAD_GENERATION',
  COMPETITIVE_INTELLIGENCE: 'COMPETITIVE_INTELLIGENCE',
  BUSINESS_STRATEGY: 'BUSINESS_STRATEGY',
  INDUSTRY_TRENDS: 'INDUSTRY_TRENDS',
  CUSTOMER_INSIGHTS: 'CUSTOMER_INSIGHTS',
  GENERAL_RESEARCH: 'GENERAL_RESEARCH'
};

export type ResearchScope = (typeof ResearchScope)[keyof typeof ResearchScope]


export const ResearchStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type ResearchStatus = (typeof ResearchStatus)[keyof typeof ResearchStatus]


export const ActionPriority: {
  HIGH: 'HIGH',
  MEDIUM: 'MEDIUM',
  LOW: 'LOW'
};

export type ActionPriority = (typeof ActionPriority)[keyof typeof ActionPriority]


export const SearchMethod: {
  GEMINI_GROUNDING: 'GEMINI_GROUNDING',
  SERPER_API: 'SERPER_API',
  GEMINI_DEEP_RESEARCH: 'GEMINI_DEEP_RESEARCH',
  JINA_SERPER: 'JINA_SERPER'
};

export type SearchMethod = (typeof SearchMethod)[keyof typeof SearchMethod]

}

export type ResearchScope = $Enums.ResearchScope

export const ResearchScope: typeof $Enums.ResearchScope

export type ResearchStatus = $Enums.ResearchStatus

export const ResearchStatus: typeof $Enums.ResearchStatus

export type ActionPriority = $Enums.ActionPriority

export const ActionPriority: typeof $Enums.ActionPriority

export type SearchMethod = $Enums.SearchMethod

export const SearchMethod: typeof $Enums.SearchMethod

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.yearPlan`: Exposes CRUD operations for the **YearPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YearPlans
    * const yearPlans = await prisma.yearPlan.findMany()
    * ```
    */
  get yearPlan(): Prisma.YearPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.goal`: Exposes CRUD operations for the **Goal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Goals
    * const goals = await prisma.goal.findMany()
    * ```
    */
  get goal(): Prisma.GoalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.milestone`: Exposes CRUD operations for the **Milestone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Milestones
    * const milestones = await prisma.milestone.findMany()
    * ```
    */
  get milestone(): Prisma.MilestoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.keyStep`: Exposes CRUD operations for the **KeyStep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KeySteps
    * const keySteps = await prisma.keyStep.findMany()
    * ```
    */
  get keyStep(): Prisma.KeyStepDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.note`: Exposes CRUD operations for the **Note** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notes
    * const notes = await prisma.note.findMany()
    * ```
    */
  get note(): Prisma.NoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quarterPlan`: Exposes CRUD operations for the **QuarterPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuarterPlans
    * const quarterPlans = await prisma.quarterPlan.findMany()
    * ```
    */
  get quarterPlan(): Prisma.QuarterPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quarterObjective`: Exposes CRUD operations for the **QuarterObjective** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuarterObjectives
    * const quarterObjectives = await prisma.quarterObjective.findMany()
    * ```
    */
  get quarterObjective(): Prisma.QuarterObjectiveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quarterFocus`: Exposes CRUD operations for the **QuarterFocus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuarterFoci
    * const quarterFoci = await prisma.quarterFocus.findMany()
    * ```
    */
  get quarterFocus(): Prisma.QuarterFocusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.monthPlan`: Exposes CRUD operations for the **MonthPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MonthPlans
    * const monthPlans = await prisma.monthPlan.findMany()
    * ```
    */
  get monthPlan(): Prisma.MonthPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.monthFocus`: Exposes CRUD operations for the **MonthFocus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MonthFoci
    * const monthFoci = await prisma.monthFocus.findMany()
    * ```
    */
  get monthFocus(): Prisma.MonthFocusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.weekPlan`: Exposes CRUD operations for the **WeekPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WeekPlans
    * const weekPlans = await prisma.weekPlan.findMany()
    * ```
    */
  get weekPlan(): Prisma.WeekPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.weekFocus`: Exposes CRUD operations for the **WeekFocus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WeekFoci
    * const weekFoci = await prisma.weekFocus.findMany()
    * ```
    */
  get weekFocus(): Prisma.WeekFocusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dayPlan`: Exposes CRUD operations for the **DayPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DayPlans
    * const dayPlans = await prisma.dayPlan.findMany()
    * ```
    */
  get dayPlan(): Prisma.DayPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dayFocus`: Exposes CRUD operations for the **DayFocus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DayFoci
    * const dayFoci = await prisma.dayFocus.findMany()
    * ```
    */
  get dayFocus(): Prisma.DayFocusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.timeBlock`: Exposes CRUD operations for the **TimeBlock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimeBlocks
    * const timeBlocks = await prisma.timeBlock.findMany()
    * ```
    */
  get timeBlock(): Prisma.TimeBlockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.timeEntry`: Exposes CRUD operations for the **TimeEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimeEntries
    * const timeEntries = await prisma.timeEntry.findMany()
    * ```
    */
  get timeEntry(): Prisma.TimeEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.communication`: Exposes CRUD operations for the **Communication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Communications
    * const communications = await prisma.communication.findMany()
    * ```
    */
  get communication(): Prisma.CommunicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.meeting`: Exposes CRUD operations for the **Meeting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Meetings
    * const meetings = await prisma.meeting.findMany()
    * ```
    */
  get meeting(): Prisma.MeetingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wellBeingEntry`: Exposes CRUD operations for the **WellBeingEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WellBeingEntries
    * const wellBeingEntries = await prisma.wellBeingEntry.findMany()
    * ```
    */
  get wellBeingEntry(): Prisma.WellBeingEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.capture`: Exposes CRUD operations for the **Capture** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Captures
    * const captures = await prisma.capture.findMany()
    * ```
    */
  get capture(): Prisma.CaptureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.voiceSession`: Exposes CRUD operations for the **VoiceSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VoiceSessions
    * const voiceSessions = await prisma.voiceSession.findMany()
    * ```
    */
  get voiceSession(): Prisma.VoiceSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.calendarEvent`: Exposes CRUD operations for the **CalendarEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CalendarEvents
    * const calendarEvents = await prisma.calendarEvent.findMany()
    * ```
    */
  get calendarEvent(): Prisma.CalendarEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.analyticsEvent`: Exposes CRUD operations for the **AnalyticsEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalyticsEvents
    * const analyticsEvents = await prisma.analyticsEvent.findMany()
    * ```
    */
  get analyticsEvent(): Prisma.AnalyticsEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.research`: Exposes CRUD operations for the **Research** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Research
    * const research = await prisma.research.findMany()
    * ```
    */
  get research(): Prisma.ResearchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.researchSource`: Exposes CRUD operations for the **ResearchSource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResearchSources
    * const researchSources = await prisma.researchSource.findMany()
    * ```
    */
  get researchSource(): Prisma.ResearchSourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.researchInsight`: Exposes CRUD operations for the **ResearchInsight** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResearchInsights
    * const researchInsights = await prisma.researchInsight.findMany()
    * ```
    */
  get researchInsight(): Prisma.ResearchInsightDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.actionItem`: Exposes CRUD operations for the **ActionItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActionItems
    * const actionItems = await prisma.actionItem.findMany()
    * ```
    */
  get actionItem(): Prisma.ActionItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leadData`: Exposes CRUD operations for the **LeadData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeadData
    * const leadData = await prisma.leadData.findMany()
    * ```
    */
  get leadData(): Prisma.LeadDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lead`: Exposes CRUD operations for the **Lead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leads
    * const leads = await prisma.lead.findMany()
    * ```
    */
  get lead(): Prisma.LeadDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.3.0
   * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    YearPlan: 'YearPlan',
    Goal: 'Goal',
    Milestone: 'Milestone',
    KeyStep: 'KeyStep',
    Note: 'Note',
    QuarterPlan: 'QuarterPlan',
    QuarterObjective: 'QuarterObjective',
    QuarterFocus: 'QuarterFocus',
    MonthPlan: 'MonthPlan',
    MonthFocus: 'MonthFocus',
    WeekPlan: 'WeekPlan',
    WeekFocus: 'WeekFocus',
    DayPlan: 'DayPlan',
    DayFocus: 'DayFocus',
    TimeBlock: 'TimeBlock',
    Project: 'Project',
    Task: 'Task',
    TimeEntry: 'TimeEntry',
    Client: 'Client',
    Communication: 'Communication',
    Meeting: 'Meeting',
    WellBeingEntry: 'WellBeingEntry',
    Capture: 'Capture',
    VoiceSession: 'VoiceSession',
    CalendarEvent: 'CalendarEvent',
    AnalyticsEvent: 'AnalyticsEvent',
    Research: 'Research',
    ResearchSource: 'ResearchSource',
    ResearchInsight: 'ResearchInsight',
    ActionItem: 'ActionItem',
    LeadData: 'LeadData',
    Lead: 'Lead'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "yearPlan" | "goal" | "milestone" | "keyStep" | "note" | "quarterPlan" | "quarterObjective" | "quarterFocus" | "monthPlan" | "monthFocus" | "weekPlan" | "weekFocus" | "dayPlan" | "dayFocus" | "timeBlock" | "project" | "task" | "timeEntry" | "client" | "communication" | "meeting" | "wellBeingEntry" | "capture" | "voiceSession" | "calendarEvent" | "analyticsEvent" | "research" | "researchSource" | "researchInsight" | "actionItem" | "leadData" | "lead"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      YearPlan: {
        payload: Prisma.$YearPlanPayload<ExtArgs>
        fields: Prisma.YearPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.YearPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.YearPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearPlanPayload>
          }
          findFirst: {
            args: Prisma.YearPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.YearPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearPlanPayload>
          }
          findMany: {
            args: Prisma.YearPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearPlanPayload>[]
          }
          create: {
            args: Prisma.YearPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearPlanPayload>
          }
          createMany: {
            args: Prisma.YearPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.YearPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearPlanPayload>[]
          }
          delete: {
            args: Prisma.YearPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearPlanPayload>
          }
          update: {
            args: Prisma.YearPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearPlanPayload>
          }
          deleteMany: {
            args: Prisma.YearPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.YearPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.YearPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearPlanPayload>[]
          }
          upsert: {
            args: Prisma.YearPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearPlanPayload>
          }
          aggregate: {
            args: Prisma.YearPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateYearPlan>
          }
          groupBy: {
            args: Prisma.YearPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<YearPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.YearPlanCountArgs<ExtArgs>
            result: $Utils.Optional<YearPlanCountAggregateOutputType> | number
          }
        }
      }
      Goal: {
        payload: Prisma.$GoalPayload<ExtArgs>
        fields: Prisma.GoalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GoalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GoalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          findFirst: {
            args: Prisma.GoalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GoalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          findMany: {
            args: Prisma.GoalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>[]
          }
          create: {
            args: Prisma.GoalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          createMany: {
            args: Prisma.GoalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GoalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>[]
          }
          delete: {
            args: Prisma.GoalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          update: {
            args: Prisma.GoalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          deleteMany: {
            args: Prisma.GoalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GoalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GoalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>[]
          }
          upsert: {
            args: Prisma.GoalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          aggregate: {
            args: Prisma.GoalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGoal>
          }
          groupBy: {
            args: Prisma.GoalGroupByArgs<ExtArgs>
            result: $Utils.Optional<GoalGroupByOutputType>[]
          }
          count: {
            args: Prisma.GoalCountArgs<ExtArgs>
            result: $Utils.Optional<GoalCountAggregateOutputType> | number
          }
        }
      }
      Milestone: {
        payload: Prisma.$MilestonePayload<ExtArgs>
        fields: Prisma.MilestoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MilestoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MilestoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          findFirst: {
            args: Prisma.MilestoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MilestoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          findMany: {
            args: Prisma.MilestoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>[]
          }
          create: {
            args: Prisma.MilestoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          createMany: {
            args: Prisma.MilestoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MilestoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>[]
          }
          delete: {
            args: Prisma.MilestoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          update: {
            args: Prisma.MilestoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          deleteMany: {
            args: Prisma.MilestoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MilestoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MilestoneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>[]
          }
          upsert: {
            args: Prisma.MilestoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          aggregate: {
            args: Prisma.MilestoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMilestone>
          }
          groupBy: {
            args: Prisma.MilestoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<MilestoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.MilestoneCountArgs<ExtArgs>
            result: $Utils.Optional<MilestoneCountAggregateOutputType> | number
          }
        }
      }
      KeyStep: {
        payload: Prisma.$KeyStepPayload<ExtArgs>
        fields: Prisma.KeyStepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KeyStepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyStepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KeyStepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyStepPayload>
          }
          findFirst: {
            args: Prisma.KeyStepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyStepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KeyStepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyStepPayload>
          }
          findMany: {
            args: Prisma.KeyStepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyStepPayload>[]
          }
          create: {
            args: Prisma.KeyStepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyStepPayload>
          }
          createMany: {
            args: Prisma.KeyStepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KeyStepCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyStepPayload>[]
          }
          delete: {
            args: Prisma.KeyStepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyStepPayload>
          }
          update: {
            args: Prisma.KeyStepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyStepPayload>
          }
          deleteMany: {
            args: Prisma.KeyStepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KeyStepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KeyStepUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyStepPayload>[]
          }
          upsert: {
            args: Prisma.KeyStepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyStepPayload>
          }
          aggregate: {
            args: Prisma.KeyStepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKeyStep>
          }
          groupBy: {
            args: Prisma.KeyStepGroupByArgs<ExtArgs>
            result: $Utils.Optional<KeyStepGroupByOutputType>[]
          }
          count: {
            args: Prisma.KeyStepCountArgs<ExtArgs>
            result: $Utils.Optional<KeyStepCountAggregateOutputType> | number
          }
        }
      }
      Note: {
        payload: Prisma.$NotePayload<ExtArgs>
        fields: Prisma.NoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          findFirst: {
            args: Prisma.NoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          findMany: {
            args: Prisma.NoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>[]
          }
          create: {
            args: Prisma.NoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          createMany: {
            args: Prisma.NoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>[]
          }
          delete: {
            args: Prisma.NoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          update: {
            args: Prisma.NoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          deleteMany: {
            args: Prisma.NoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>[]
          }
          upsert: {
            args: Prisma.NoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          aggregate: {
            args: Prisma.NoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNote>
          }
          groupBy: {
            args: Prisma.NoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.NoteCountArgs<ExtArgs>
            result: $Utils.Optional<NoteCountAggregateOutputType> | number
          }
        }
      }
      QuarterPlan: {
        payload: Prisma.$QuarterPlanPayload<ExtArgs>
        fields: Prisma.QuarterPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuarterPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuarterPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuarterPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuarterPlanPayload>
          }
          findFirst: {
            args: Prisma.QuarterPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuarterPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuarterPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuarterPlanPayload>
          }
          findMany: {
            args: Prisma.QuarterPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuarterPlanPayload>[]
          }
          create: {
            args: Prisma.QuarterPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuarterPlanPayload>
          }
          createMany: {
            args: Prisma.QuarterPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuarterPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuarterPlanPayload>[]
          }
          delete: {
            args: Prisma.QuarterPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuarterPlanPayload>
          }
          update: {
            args: Prisma.QuarterPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuarterPlanPayload>
          }
          deleteMany: {
            args: Prisma.QuarterPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuarterPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuarterPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuarterPlanPayload>[]
          }
          upsert: {
            args: Prisma.QuarterPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuarterPlanPayload>
          }
          aggregate: {
            args: Prisma.QuarterPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuarterPlan>
          }
          groupBy: {
            args: Prisma.QuarterPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuarterPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuarterPlanCountArgs<ExtArgs>
            result: $Utils.Optional<QuarterPlanCountAggregateOutputType> | number
          }
        }
      }
      QuarterObjective: {
        payload: Prisma.$QuarterObjectivePayload<ExtArgs>
        fields: Prisma.QuarterObjectiveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuarterObjectiveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuarterObjectivePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuarterObjectiveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuarterObjectivePayload>
          }
          findFirst: {
            args: Prisma.QuarterObjectiveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuarterObjectivePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuarterObjectiveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuarterObjectivePayload>
          }
          findMany: {
            args: Prisma.QuarterObjectiveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuarterObjectivePayload>[]
          }
          create: {
            args: Prisma.QuarterObjectiveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuarterObjectivePayload>
          }
          createMany: {
            args: Prisma.QuarterObjectiveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuarterObjectiveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuarterObjectivePayload>[]
          }
          delete: {
            args: Prisma.QuarterObjectiveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuarterObjectivePayload>
          }
          update: {
            args: Prisma.QuarterObjectiveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuarterObjectivePayload>
          }
          deleteMany: {
            args: Prisma.QuarterObjectiveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuarterObjectiveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuarterObjectiveUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuarterObjectivePayload>[]
          }
          upsert: {
            args: Prisma.QuarterObjectiveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuarterObjectivePayload>
          }
          aggregate: {
            args: Prisma.QuarterObjectiveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuarterObjective>
          }
          groupBy: {
            args: Prisma.QuarterObjectiveGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuarterObjectiveGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuarterObjectiveCountArgs<ExtArgs>
            result: $Utils.Optional<QuarterObjectiveCountAggregateOutputType> | number
          }
        }
      }
      QuarterFocus: {
        payload: Prisma.$QuarterFocusPayload<ExtArgs>
        fields: Prisma.QuarterFocusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuarterFocusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuarterFocusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuarterFocusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuarterFocusPayload>
          }
          findFirst: {
            args: Prisma.QuarterFocusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuarterFocusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuarterFocusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuarterFocusPayload>
          }
          findMany: {
            args: Prisma.QuarterFocusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuarterFocusPayload>[]
          }
          create: {
            args: Prisma.QuarterFocusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuarterFocusPayload>
          }
          createMany: {
            args: Prisma.QuarterFocusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuarterFocusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuarterFocusPayload>[]
          }
          delete: {
            args: Prisma.QuarterFocusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuarterFocusPayload>
          }
          update: {
            args: Prisma.QuarterFocusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuarterFocusPayload>
          }
          deleteMany: {
            args: Prisma.QuarterFocusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuarterFocusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuarterFocusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuarterFocusPayload>[]
          }
          upsert: {
            args: Prisma.QuarterFocusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuarterFocusPayload>
          }
          aggregate: {
            args: Prisma.QuarterFocusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuarterFocus>
          }
          groupBy: {
            args: Prisma.QuarterFocusGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuarterFocusGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuarterFocusCountArgs<ExtArgs>
            result: $Utils.Optional<QuarterFocusCountAggregateOutputType> | number
          }
        }
      }
      MonthPlan: {
        payload: Prisma.$MonthPlanPayload<ExtArgs>
        fields: Prisma.MonthPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MonthPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MonthPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthPlanPayload>
          }
          findFirst: {
            args: Prisma.MonthPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MonthPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthPlanPayload>
          }
          findMany: {
            args: Prisma.MonthPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthPlanPayload>[]
          }
          create: {
            args: Prisma.MonthPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthPlanPayload>
          }
          createMany: {
            args: Prisma.MonthPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MonthPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthPlanPayload>[]
          }
          delete: {
            args: Prisma.MonthPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthPlanPayload>
          }
          update: {
            args: Prisma.MonthPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthPlanPayload>
          }
          deleteMany: {
            args: Prisma.MonthPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MonthPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MonthPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthPlanPayload>[]
          }
          upsert: {
            args: Prisma.MonthPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthPlanPayload>
          }
          aggregate: {
            args: Prisma.MonthPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMonthPlan>
          }
          groupBy: {
            args: Prisma.MonthPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<MonthPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.MonthPlanCountArgs<ExtArgs>
            result: $Utils.Optional<MonthPlanCountAggregateOutputType> | number
          }
        }
      }
      MonthFocus: {
        payload: Prisma.$MonthFocusPayload<ExtArgs>
        fields: Prisma.MonthFocusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MonthFocusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthFocusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MonthFocusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthFocusPayload>
          }
          findFirst: {
            args: Prisma.MonthFocusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthFocusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MonthFocusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthFocusPayload>
          }
          findMany: {
            args: Prisma.MonthFocusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthFocusPayload>[]
          }
          create: {
            args: Prisma.MonthFocusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthFocusPayload>
          }
          createMany: {
            args: Prisma.MonthFocusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MonthFocusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthFocusPayload>[]
          }
          delete: {
            args: Prisma.MonthFocusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthFocusPayload>
          }
          update: {
            args: Prisma.MonthFocusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthFocusPayload>
          }
          deleteMany: {
            args: Prisma.MonthFocusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MonthFocusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MonthFocusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthFocusPayload>[]
          }
          upsert: {
            args: Prisma.MonthFocusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthFocusPayload>
          }
          aggregate: {
            args: Prisma.MonthFocusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMonthFocus>
          }
          groupBy: {
            args: Prisma.MonthFocusGroupByArgs<ExtArgs>
            result: $Utils.Optional<MonthFocusGroupByOutputType>[]
          }
          count: {
            args: Prisma.MonthFocusCountArgs<ExtArgs>
            result: $Utils.Optional<MonthFocusCountAggregateOutputType> | number
          }
        }
      }
      WeekPlan: {
        payload: Prisma.$WeekPlanPayload<ExtArgs>
        fields: Prisma.WeekPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeekPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeekPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekPlanPayload>
          }
          findFirst: {
            args: Prisma.WeekPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeekPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekPlanPayload>
          }
          findMany: {
            args: Prisma.WeekPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekPlanPayload>[]
          }
          create: {
            args: Prisma.WeekPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekPlanPayload>
          }
          createMany: {
            args: Prisma.WeekPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WeekPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekPlanPayload>[]
          }
          delete: {
            args: Prisma.WeekPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekPlanPayload>
          }
          update: {
            args: Prisma.WeekPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekPlanPayload>
          }
          deleteMany: {
            args: Prisma.WeekPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeekPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WeekPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekPlanPayload>[]
          }
          upsert: {
            args: Prisma.WeekPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekPlanPayload>
          }
          aggregate: {
            args: Prisma.WeekPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeekPlan>
          }
          groupBy: {
            args: Prisma.WeekPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeekPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeekPlanCountArgs<ExtArgs>
            result: $Utils.Optional<WeekPlanCountAggregateOutputType> | number
          }
        }
      }
      WeekFocus: {
        payload: Prisma.$WeekFocusPayload<ExtArgs>
        fields: Prisma.WeekFocusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeekFocusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekFocusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeekFocusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekFocusPayload>
          }
          findFirst: {
            args: Prisma.WeekFocusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekFocusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeekFocusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekFocusPayload>
          }
          findMany: {
            args: Prisma.WeekFocusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekFocusPayload>[]
          }
          create: {
            args: Prisma.WeekFocusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekFocusPayload>
          }
          createMany: {
            args: Prisma.WeekFocusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WeekFocusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekFocusPayload>[]
          }
          delete: {
            args: Prisma.WeekFocusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekFocusPayload>
          }
          update: {
            args: Prisma.WeekFocusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekFocusPayload>
          }
          deleteMany: {
            args: Prisma.WeekFocusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeekFocusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WeekFocusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekFocusPayload>[]
          }
          upsert: {
            args: Prisma.WeekFocusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekFocusPayload>
          }
          aggregate: {
            args: Prisma.WeekFocusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeekFocus>
          }
          groupBy: {
            args: Prisma.WeekFocusGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeekFocusGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeekFocusCountArgs<ExtArgs>
            result: $Utils.Optional<WeekFocusCountAggregateOutputType> | number
          }
        }
      }
      DayPlan: {
        payload: Prisma.$DayPlanPayload<ExtArgs>
        fields: Prisma.DayPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DayPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DayPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayPlanPayload>
          }
          findFirst: {
            args: Prisma.DayPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DayPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayPlanPayload>
          }
          findMany: {
            args: Prisma.DayPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayPlanPayload>[]
          }
          create: {
            args: Prisma.DayPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayPlanPayload>
          }
          createMany: {
            args: Prisma.DayPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DayPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayPlanPayload>[]
          }
          delete: {
            args: Prisma.DayPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayPlanPayload>
          }
          update: {
            args: Prisma.DayPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayPlanPayload>
          }
          deleteMany: {
            args: Prisma.DayPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DayPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DayPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayPlanPayload>[]
          }
          upsert: {
            args: Prisma.DayPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayPlanPayload>
          }
          aggregate: {
            args: Prisma.DayPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDayPlan>
          }
          groupBy: {
            args: Prisma.DayPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<DayPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.DayPlanCountArgs<ExtArgs>
            result: $Utils.Optional<DayPlanCountAggregateOutputType> | number
          }
        }
      }
      DayFocus: {
        payload: Prisma.$DayFocusPayload<ExtArgs>
        fields: Prisma.DayFocusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DayFocusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayFocusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DayFocusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayFocusPayload>
          }
          findFirst: {
            args: Prisma.DayFocusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayFocusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DayFocusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayFocusPayload>
          }
          findMany: {
            args: Prisma.DayFocusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayFocusPayload>[]
          }
          create: {
            args: Prisma.DayFocusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayFocusPayload>
          }
          createMany: {
            args: Prisma.DayFocusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DayFocusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayFocusPayload>[]
          }
          delete: {
            args: Prisma.DayFocusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayFocusPayload>
          }
          update: {
            args: Prisma.DayFocusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayFocusPayload>
          }
          deleteMany: {
            args: Prisma.DayFocusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DayFocusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DayFocusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayFocusPayload>[]
          }
          upsert: {
            args: Prisma.DayFocusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayFocusPayload>
          }
          aggregate: {
            args: Prisma.DayFocusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDayFocus>
          }
          groupBy: {
            args: Prisma.DayFocusGroupByArgs<ExtArgs>
            result: $Utils.Optional<DayFocusGroupByOutputType>[]
          }
          count: {
            args: Prisma.DayFocusCountArgs<ExtArgs>
            result: $Utils.Optional<DayFocusCountAggregateOutputType> | number
          }
        }
      }
      TimeBlock: {
        payload: Prisma.$TimeBlockPayload<ExtArgs>
        fields: Prisma.TimeBlockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimeBlockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeBlockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimeBlockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeBlockPayload>
          }
          findFirst: {
            args: Prisma.TimeBlockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeBlockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimeBlockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeBlockPayload>
          }
          findMany: {
            args: Prisma.TimeBlockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeBlockPayload>[]
          }
          create: {
            args: Prisma.TimeBlockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeBlockPayload>
          }
          createMany: {
            args: Prisma.TimeBlockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TimeBlockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeBlockPayload>[]
          }
          delete: {
            args: Prisma.TimeBlockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeBlockPayload>
          }
          update: {
            args: Prisma.TimeBlockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeBlockPayload>
          }
          deleteMany: {
            args: Prisma.TimeBlockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimeBlockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TimeBlockUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeBlockPayload>[]
          }
          upsert: {
            args: Prisma.TimeBlockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeBlockPayload>
          }
          aggregate: {
            args: Prisma.TimeBlockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimeBlock>
          }
          groupBy: {
            args: Prisma.TimeBlockGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimeBlockGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimeBlockCountArgs<ExtArgs>
            result: $Utils.Optional<TimeBlockCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      TimeEntry: {
        payload: Prisma.$TimeEntryPayload<ExtArgs>
        fields: Prisma.TimeEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimeEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimeEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload>
          }
          findFirst: {
            args: Prisma.TimeEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimeEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload>
          }
          findMany: {
            args: Prisma.TimeEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload>[]
          }
          create: {
            args: Prisma.TimeEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload>
          }
          createMany: {
            args: Prisma.TimeEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TimeEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload>[]
          }
          delete: {
            args: Prisma.TimeEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload>
          }
          update: {
            args: Prisma.TimeEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload>
          }
          deleteMany: {
            args: Prisma.TimeEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimeEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TimeEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload>[]
          }
          upsert: {
            args: Prisma.TimeEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload>
          }
          aggregate: {
            args: Prisma.TimeEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimeEntry>
          }
          groupBy: {
            args: Prisma.TimeEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimeEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimeEntryCountArgs<ExtArgs>
            result: $Utils.Optional<TimeEntryCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      Communication: {
        payload: Prisma.$CommunicationPayload<ExtArgs>
        fields: Prisma.CommunicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload>
          }
          findFirst: {
            args: Prisma.CommunicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload>
          }
          findMany: {
            args: Prisma.CommunicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload>[]
          }
          create: {
            args: Prisma.CommunicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload>
          }
          createMany: {
            args: Prisma.CommunicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommunicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload>[]
          }
          delete: {
            args: Prisma.CommunicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload>
          }
          update: {
            args: Prisma.CommunicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload>
          }
          deleteMany: {
            args: Prisma.CommunicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommunicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommunicationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload>[]
          }
          upsert: {
            args: Prisma.CommunicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload>
          }
          aggregate: {
            args: Prisma.CommunicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommunication>
          }
          groupBy: {
            args: Prisma.CommunicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommunicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunicationCountArgs<ExtArgs>
            result: $Utils.Optional<CommunicationCountAggregateOutputType> | number
          }
        }
      }
      Meeting: {
        payload: Prisma.$MeetingPayload<ExtArgs>
        fields: Prisma.MeetingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MeetingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MeetingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          findFirst: {
            args: Prisma.MeetingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MeetingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          findMany: {
            args: Prisma.MeetingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>[]
          }
          create: {
            args: Prisma.MeetingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          createMany: {
            args: Prisma.MeetingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MeetingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>[]
          }
          delete: {
            args: Prisma.MeetingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          update: {
            args: Prisma.MeetingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          deleteMany: {
            args: Prisma.MeetingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MeetingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MeetingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>[]
          }
          upsert: {
            args: Prisma.MeetingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          aggregate: {
            args: Prisma.MeetingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeeting>
          }
          groupBy: {
            args: Prisma.MeetingGroupByArgs<ExtArgs>
            result: $Utils.Optional<MeetingGroupByOutputType>[]
          }
          count: {
            args: Prisma.MeetingCountArgs<ExtArgs>
            result: $Utils.Optional<MeetingCountAggregateOutputType> | number
          }
        }
      }
      WellBeingEntry: {
        payload: Prisma.$WellBeingEntryPayload<ExtArgs>
        fields: Prisma.WellBeingEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WellBeingEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBeingEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WellBeingEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBeingEntryPayload>
          }
          findFirst: {
            args: Prisma.WellBeingEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBeingEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WellBeingEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBeingEntryPayload>
          }
          findMany: {
            args: Prisma.WellBeingEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBeingEntryPayload>[]
          }
          create: {
            args: Prisma.WellBeingEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBeingEntryPayload>
          }
          createMany: {
            args: Prisma.WellBeingEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WellBeingEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBeingEntryPayload>[]
          }
          delete: {
            args: Prisma.WellBeingEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBeingEntryPayload>
          }
          update: {
            args: Prisma.WellBeingEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBeingEntryPayload>
          }
          deleteMany: {
            args: Prisma.WellBeingEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WellBeingEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WellBeingEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBeingEntryPayload>[]
          }
          upsert: {
            args: Prisma.WellBeingEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBeingEntryPayload>
          }
          aggregate: {
            args: Prisma.WellBeingEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWellBeingEntry>
          }
          groupBy: {
            args: Prisma.WellBeingEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<WellBeingEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.WellBeingEntryCountArgs<ExtArgs>
            result: $Utils.Optional<WellBeingEntryCountAggregateOutputType> | number
          }
        }
      }
      Capture: {
        payload: Prisma.$CapturePayload<ExtArgs>
        fields: Prisma.CaptureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CaptureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CaptureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapturePayload>
          }
          findFirst: {
            args: Prisma.CaptureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CaptureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapturePayload>
          }
          findMany: {
            args: Prisma.CaptureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapturePayload>[]
          }
          create: {
            args: Prisma.CaptureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapturePayload>
          }
          createMany: {
            args: Prisma.CaptureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CaptureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapturePayload>[]
          }
          delete: {
            args: Prisma.CaptureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapturePayload>
          }
          update: {
            args: Prisma.CaptureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapturePayload>
          }
          deleteMany: {
            args: Prisma.CaptureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CaptureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CaptureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapturePayload>[]
          }
          upsert: {
            args: Prisma.CaptureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapturePayload>
          }
          aggregate: {
            args: Prisma.CaptureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCapture>
          }
          groupBy: {
            args: Prisma.CaptureGroupByArgs<ExtArgs>
            result: $Utils.Optional<CaptureGroupByOutputType>[]
          }
          count: {
            args: Prisma.CaptureCountArgs<ExtArgs>
            result: $Utils.Optional<CaptureCountAggregateOutputType> | number
          }
        }
      }
      VoiceSession: {
        payload: Prisma.$VoiceSessionPayload<ExtArgs>
        fields: Prisma.VoiceSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoiceSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoiceSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceSessionPayload>
          }
          findFirst: {
            args: Prisma.VoiceSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoiceSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceSessionPayload>
          }
          findMany: {
            args: Prisma.VoiceSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceSessionPayload>[]
          }
          create: {
            args: Prisma.VoiceSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceSessionPayload>
          }
          createMany: {
            args: Prisma.VoiceSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VoiceSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceSessionPayload>[]
          }
          delete: {
            args: Prisma.VoiceSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceSessionPayload>
          }
          update: {
            args: Prisma.VoiceSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceSessionPayload>
          }
          deleteMany: {
            args: Prisma.VoiceSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VoiceSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VoiceSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceSessionPayload>[]
          }
          upsert: {
            args: Prisma.VoiceSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceSessionPayload>
          }
          aggregate: {
            args: Prisma.VoiceSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVoiceSession>
          }
          groupBy: {
            args: Prisma.VoiceSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<VoiceSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.VoiceSessionCountArgs<ExtArgs>
            result: $Utils.Optional<VoiceSessionCountAggregateOutputType> | number
          }
        }
      }
      CalendarEvent: {
        payload: Prisma.$CalendarEventPayload<ExtArgs>
        fields: Prisma.CalendarEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CalendarEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CalendarEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          findFirst: {
            args: Prisma.CalendarEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CalendarEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          findMany: {
            args: Prisma.CalendarEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>[]
          }
          create: {
            args: Prisma.CalendarEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          createMany: {
            args: Prisma.CalendarEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CalendarEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>[]
          }
          delete: {
            args: Prisma.CalendarEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          update: {
            args: Prisma.CalendarEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          deleteMany: {
            args: Prisma.CalendarEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CalendarEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CalendarEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>[]
          }
          upsert: {
            args: Prisma.CalendarEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          aggregate: {
            args: Prisma.CalendarEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalendarEvent>
          }
          groupBy: {
            args: Prisma.CalendarEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalendarEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.CalendarEventCountArgs<ExtArgs>
            result: $Utils.Optional<CalendarEventCountAggregateOutputType> | number
          }
        }
      }
      AnalyticsEvent: {
        payload: Prisma.$AnalyticsEventPayload<ExtArgs>
        fields: Prisma.AnalyticsEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalyticsEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalyticsEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          findFirst: {
            args: Prisma.AnalyticsEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalyticsEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          findMany: {
            args: Prisma.AnalyticsEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>[]
          }
          create: {
            args: Prisma.AnalyticsEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          createMany: {
            args: Prisma.AnalyticsEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalyticsEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>[]
          }
          delete: {
            args: Prisma.AnalyticsEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          update: {
            args: Prisma.AnalyticsEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          deleteMany: {
            args: Prisma.AnalyticsEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalyticsEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnalyticsEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>[]
          }
          upsert: {
            args: Prisma.AnalyticsEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          aggregate: {
            args: Prisma.AnalyticsEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalyticsEvent>
          }
          groupBy: {
            args: Prisma.AnalyticsEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalyticsEventCountArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsEventCountAggregateOutputType> | number
          }
        }
      }
      Research: {
        payload: Prisma.$ResearchPayload<ExtArgs>
        fields: Prisma.ResearchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResearchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResearchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchPayload>
          }
          findFirst: {
            args: Prisma.ResearchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResearchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchPayload>
          }
          findMany: {
            args: Prisma.ResearchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchPayload>[]
          }
          create: {
            args: Prisma.ResearchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchPayload>
          }
          createMany: {
            args: Prisma.ResearchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResearchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchPayload>[]
          }
          delete: {
            args: Prisma.ResearchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchPayload>
          }
          update: {
            args: Prisma.ResearchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchPayload>
          }
          deleteMany: {
            args: Prisma.ResearchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResearchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResearchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchPayload>[]
          }
          upsert: {
            args: Prisma.ResearchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchPayload>
          }
          aggregate: {
            args: Prisma.ResearchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResearch>
          }
          groupBy: {
            args: Prisma.ResearchGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResearchGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResearchCountArgs<ExtArgs>
            result: $Utils.Optional<ResearchCountAggregateOutputType> | number
          }
        }
      }
      ResearchSource: {
        payload: Prisma.$ResearchSourcePayload<ExtArgs>
        fields: Prisma.ResearchSourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResearchSourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchSourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResearchSourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchSourcePayload>
          }
          findFirst: {
            args: Prisma.ResearchSourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchSourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResearchSourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchSourcePayload>
          }
          findMany: {
            args: Prisma.ResearchSourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchSourcePayload>[]
          }
          create: {
            args: Prisma.ResearchSourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchSourcePayload>
          }
          createMany: {
            args: Prisma.ResearchSourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResearchSourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchSourcePayload>[]
          }
          delete: {
            args: Prisma.ResearchSourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchSourcePayload>
          }
          update: {
            args: Prisma.ResearchSourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchSourcePayload>
          }
          deleteMany: {
            args: Prisma.ResearchSourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResearchSourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResearchSourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchSourcePayload>[]
          }
          upsert: {
            args: Prisma.ResearchSourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchSourcePayload>
          }
          aggregate: {
            args: Prisma.ResearchSourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResearchSource>
          }
          groupBy: {
            args: Prisma.ResearchSourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResearchSourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResearchSourceCountArgs<ExtArgs>
            result: $Utils.Optional<ResearchSourceCountAggregateOutputType> | number
          }
        }
      }
      ResearchInsight: {
        payload: Prisma.$ResearchInsightPayload<ExtArgs>
        fields: Prisma.ResearchInsightFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResearchInsightFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchInsightPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResearchInsightFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchInsightPayload>
          }
          findFirst: {
            args: Prisma.ResearchInsightFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchInsightPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResearchInsightFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchInsightPayload>
          }
          findMany: {
            args: Prisma.ResearchInsightFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchInsightPayload>[]
          }
          create: {
            args: Prisma.ResearchInsightCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchInsightPayload>
          }
          createMany: {
            args: Prisma.ResearchInsightCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResearchInsightCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchInsightPayload>[]
          }
          delete: {
            args: Prisma.ResearchInsightDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchInsightPayload>
          }
          update: {
            args: Prisma.ResearchInsightUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchInsightPayload>
          }
          deleteMany: {
            args: Prisma.ResearchInsightDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResearchInsightUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResearchInsightUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchInsightPayload>[]
          }
          upsert: {
            args: Prisma.ResearchInsightUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchInsightPayload>
          }
          aggregate: {
            args: Prisma.ResearchInsightAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResearchInsight>
          }
          groupBy: {
            args: Prisma.ResearchInsightGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResearchInsightGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResearchInsightCountArgs<ExtArgs>
            result: $Utils.Optional<ResearchInsightCountAggregateOutputType> | number
          }
        }
      }
      ActionItem: {
        payload: Prisma.$ActionItemPayload<ExtArgs>
        fields: Prisma.ActionItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActionItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActionItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionItemPayload>
          }
          findFirst: {
            args: Prisma.ActionItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActionItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionItemPayload>
          }
          findMany: {
            args: Prisma.ActionItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionItemPayload>[]
          }
          create: {
            args: Prisma.ActionItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionItemPayload>
          }
          createMany: {
            args: Prisma.ActionItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActionItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionItemPayload>[]
          }
          delete: {
            args: Prisma.ActionItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionItemPayload>
          }
          update: {
            args: Prisma.ActionItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionItemPayload>
          }
          deleteMany: {
            args: Prisma.ActionItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActionItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActionItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionItemPayload>[]
          }
          upsert: {
            args: Prisma.ActionItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionItemPayload>
          }
          aggregate: {
            args: Prisma.ActionItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActionItem>
          }
          groupBy: {
            args: Prisma.ActionItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActionItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActionItemCountArgs<ExtArgs>
            result: $Utils.Optional<ActionItemCountAggregateOutputType> | number
          }
        }
      }
      LeadData: {
        payload: Prisma.$LeadDataPayload<ExtArgs>
        fields: Prisma.LeadDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadDataPayload>
          }
          findFirst: {
            args: Prisma.LeadDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadDataPayload>
          }
          findMany: {
            args: Prisma.LeadDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadDataPayload>[]
          }
          create: {
            args: Prisma.LeadDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadDataPayload>
          }
          createMany: {
            args: Prisma.LeadDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeadDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadDataPayload>[]
          }
          delete: {
            args: Prisma.LeadDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadDataPayload>
          }
          update: {
            args: Prisma.LeadDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadDataPayload>
          }
          deleteMany: {
            args: Prisma.LeadDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeadDataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadDataPayload>[]
          }
          upsert: {
            args: Prisma.LeadDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadDataPayload>
          }
          aggregate: {
            args: Prisma.LeadDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeadData>
          }
          groupBy: {
            args: Prisma.LeadDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadDataCountArgs<ExtArgs>
            result: $Utils.Optional<LeadDataCountAggregateOutputType> | number
          }
        }
      }
      Lead: {
        payload: Prisma.$LeadPayload<ExtArgs>
        fields: Prisma.LeadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findFirst: {
            args: Prisma.LeadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findMany: {
            args: Prisma.LeadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          create: {
            args: Prisma.LeadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          createMany: {
            args: Prisma.LeadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          delete: {
            args: Prisma.LeadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          update: {
            args: Prisma.LeadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          deleteMany: {
            args: Prisma.LeadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeadUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          upsert: {
            args: Prisma.LeadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          aggregate: {
            args: Prisma.LeadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLead>
          }
          groupBy: {
            args: Prisma.LeadGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadCountArgs<ExtArgs>
            result: $Utils.Optional<LeadCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    yearPlan?: YearPlanOmit
    goal?: GoalOmit
    milestone?: MilestoneOmit
    keyStep?: KeyStepOmit
    note?: NoteOmit
    quarterPlan?: QuarterPlanOmit
    quarterObjective?: QuarterObjectiveOmit
    quarterFocus?: QuarterFocusOmit
    monthPlan?: MonthPlanOmit
    monthFocus?: MonthFocusOmit
    weekPlan?: WeekPlanOmit
    weekFocus?: WeekFocusOmit
    dayPlan?: DayPlanOmit
    dayFocus?: DayFocusOmit
    timeBlock?: TimeBlockOmit
    project?: ProjectOmit
    task?: TaskOmit
    timeEntry?: TimeEntryOmit
    client?: ClientOmit
    communication?: CommunicationOmit
    meeting?: MeetingOmit
    wellBeingEntry?: WellBeingEntryOmit
    capture?: CaptureOmit
    voiceSession?: VoiceSessionOmit
    calendarEvent?: CalendarEventOmit
    analyticsEvent?: AnalyticsEventOmit
    research?: ResearchOmit
    researchSource?: ResearchSourceOmit
    researchInsight?: ResearchInsightOmit
    actionItem?: ActionItemOmit
    leadData?: LeadDataOmit
    lead?: LeadOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    analyticsEvents: number
    calendarEvents: number
    captures: number
    clients: number
    dayPlans: number
    meetings: number
    notes: number
    projects: number
    researches: number
    tasks: number
    timeEntries: number
    voiceSessions: number
    weekPlans: number
    wellBeingEntries: number
    yearPlans: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    analyticsEvents?: boolean | UserCountOutputTypeCountAnalyticsEventsArgs
    calendarEvents?: boolean | UserCountOutputTypeCountCalendarEventsArgs
    captures?: boolean | UserCountOutputTypeCountCapturesArgs
    clients?: boolean | UserCountOutputTypeCountClientsArgs
    dayPlans?: boolean | UserCountOutputTypeCountDayPlansArgs
    meetings?: boolean | UserCountOutputTypeCountMeetingsArgs
    notes?: boolean | UserCountOutputTypeCountNotesArgs
    projects?: boolean | UserCountOutputTypeCountProjectsArgs
    researches?: boolean | UserCountOutputTypeCountResearchesArgs
    tasks?: boolean | UserCountOutputTypeCountTasksArgs
    timeEntries?: boolean | UserCountOutputTypeCountTimeEntriesArgs
    voiceSessions?: boolean | UserCountOutputTypeCountVoiceSessionsArgs
    weekPlans?: boolean | UserCountOutputTypeCountWeekPlansArgs
    wellBeingEntries?: boolean | UserCountOutputTypeCountWellBeingEntriesArgs
    yearPlans?: boolean | UserCountOutputTypeCountYearPlansArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnalyticsEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsEventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCalendarEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarEventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCapturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaptureWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDayPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DayPlanWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMeetingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountResearchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResearchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTimeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVoiceSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoiceSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWeekPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeekPlanWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWellBeingEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WellBeingEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountYearPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: YearPlanWhereInput
  }


  /**
   * Count Type YearPlanCountOutputType
   */

  export type YearPlanCountOutputType = {
    goals: number
    quarterPlans: number
  }

  export type YearPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goals?: boolean | YearPlanCountOutputTypeCountGoalsArgs
    quarterPlans?: boolean | YearPlanCountOutputTypeCountQuarterPlansArgs
  }

  // Custom InputTypes
  /**
   * YearPlanCountOutputType without action
   */
  export type YearPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearPlanCountOutputType
     */
    select?: YearPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * YearPlanCountOutputType without action
   */
  export type YearPlanCountOutputTypeCountGoalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoalWhereInput
  }

  /**
   * YearPlanCountOutputType without action
   */
  export type YearPlanCountOutputTypeCountQuarterPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuarterPlanWhereInput
  }


  /**
   * Count Type GoalCountOutputType
   */

  export type GoalCountOutputType = {
    keySteps: number
    milestones: number
    notes: number
    quarterFocuses: number
    researches: number
    tasks: number
  }

  export type GoalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    keySteps?: boolean | GoalCountOutputTypeCountKeyStepsArgs
    milestones?: boolean | GoalCountOutputTypeCountMilestonesArgs
    notes?: boolean | GoalCountOutputTypeCountNotesArgs
    quarterFocuses?: boolean | GoalCountOutputTypeCountQuarterFocusesArgs
    researches?: boolean | GoalCountOutputTypeCountResearchesArgs
    tasks?: boolean | GoalCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * GoalCountOutputType without action
   */
  export type GoalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalCountOutputType
     */
    select?: GoalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GoalCountOutputType without action
   */
  export type GoalCountOutputTypeCountKeyStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KeyStepWhereInput
  }

  /**
   * GoalCountOutputType without action
   */
  export type GoalCountOutputTypeCountMilestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MilestoneWhereInput
  }

  /**
   * GoalCountOutputType without action
   */
  export type GoalCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
  }

  /**
   * GoalCountOutputType without action
   */
  export type GoalCountOutputTypeCountQuarterFocusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuarterFocusWhereInput
  }

  /**
   * GoalCountOutputType without action
   */
  export type GoalCountOutputTypeCountResearchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResearchWhereInput
  }

  /**
   * GoalCountOutputType without action
   */
  export type GoalCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type KeyStepCountOutputType
   */

  export type KeyStepCountOutputType = {
    notes: number
    tasks: number
  }

  export type KeyStepCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notes?: boolean | KeyStepCountOutputTypeCountNotesArgs
    tasks?: boolean | KeyStepCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * KeyStepCountOutputType without action
   */
  export type KeyStepCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyStepCountOutputType
     */
    select?: KeyStepCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KeyStepCountOutputType without action
   */
  export type KeyStepCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
  }

  /**
   * KeyStepCountOutputType without action
   */
  export type KeyStepCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type QuarterPlanCountOutputType
   */

  export type QuarterPlanCountOutputType = {
    monthPlans: number
    quarterFocuses: number
    objectives: number
  }

  export type QuarterPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monthPlans?: boolean | QuarterPlanCountOutputTypeCountMonthPlansArgs
    quarterFocuses?: boolean | QuarterPlanCountOutputTypeCountQuarterFocusesArgs
    objectives?: boolean | QuarterPlanCountOutputTypeCountObjectivesArgs
  }

  // Custom InputTypes
  /**
   * QuarterPlanCountOutputType without action
   */
  export type QuarterPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterPlanCountOutputType
     */
    select?: QuarterPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuarterPlanCountOutputType without action
   */
  export type QuarterPlanCountOutputTypeCountMonthPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonthPlanWhereInput
  }

  /**
   * QuarterPlanCountOutputType without action
   */
  export type QuarterPlanCountOutputTypeCountQuarterFocusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuarterFocusWhereInput
  }

  /**
   * QuarterPlanCountOutputType without action
   */
  export type QuarterPlanCountOutputTypeCountObjectivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuarterObjectiveWhereInput
  }


  /**
   * Count Type QuarterFocusCountOutputType
   */

  export type QuarterFocusCountOutputType = {
    monthFocuses: number
  }

  export type QuarterFocusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monthFocuses?: boolean | QuarterFocusCountOutputTypeCountMonthFocusesArgs
  }

  // Custom InputTypes
  /**
   * QuarterFocusCountOutputType without action
   */
  export type QuarterFocusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterFocusCountOutputType
     */
    select?: QuarterFocusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuarterFocusCountOutputType without action
   */
  export type QuarterFocusCountOutputTypeCountMonthFocusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonthFocusWhereInput
  }


  /**
   * Count Type MonthPlanCountOutputType
   */

  export type MonthPlanCountOutputType = {
    monthFocuses: number
    weekPlans: number
  }

  export type MonthPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monthFocuses?: boolean | MonthPlanCountOutputTypeCountMonthFocusesArgs
    weekPlans?: boolean | MonthPlanCountOutputTypeCountWeekPlansArgs
  }

  // Custom InputTypes
  /**
   * MonthPlanCountOutputType without action
   */
  export type MonthPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthPlanCountOutputType
     */
    select?: MonthPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MonthPlanCountOutputType without action
   */
  export type MonthPlanCountOutputTypeCountMonthFocusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonthFocusWhereInput
  }

  /**
   * MonthPlanCountOutputType without action
   */
  export type MonthPlanCountOutputTypeCountWeekPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeekPlanWhereInput
  }


  /**
   * Count Type MonthFocusCountOutputType
   */

  export type MonthFocusCountOutputType = {
    weekFocuses: number
  }

  export type MonthFocusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    weekFocuses?: boolean | MonthFocusCountOutputTypeCountWeekFocusesArgs
  }

  // Custom InputTypes
  /**
   * MonthFocusCountOutputType without action
   */
  export type MonthFocusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthFocusCountOutputType
     */
    select?: MonthFocusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MonthFocusCountOutputType without action
   */
  export type MonthFocusCountOutputTypeCountWeekFocusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeekFocusWhereInput
  }


  /**
   * Count Type WeekPlanCountOutputType
   */

  export type WeekPlanCountOutputType = {
    dayPlans: number
    weekFocuses: number
  }

  export type WeekPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dayPlans?: boolean | WeekPlanCountOutputTypeCountDayPlansArgs
    weekFocuses?: boolean | WeekPlanCountOutputTypeCountWeekFocusesArgs
  }

  // Custom InputTypes
  /**
   * WeekPlanCountOutputType without action
   */
  export type WeekPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekPlanCountOutputType
     */
    select?: WeekPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WeekPlanCountOutputType without action
   */
  export type WeekPlanCountOutputTypeCountDayPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DayPlanWhereInput
  }

  /**
   * WeekPlanCountOutputType without action
   */
  export type WeekPlanCountOutputTypeCountWeekFocusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeekFocusWhereInput
  }


  /**
   * Count Type WeekFocusCountOutputType
   */

  export type WeekFocusCountOutputType = {
    dayFocuses: number
  }

  export type WeekFocusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dayFocuses?: boolean | WeekFocusCountOutputTypeCountDayFocusesArgs
  }

  // Custom InputTypes
  /**
   * WeekFocusCountOutputType without action
   */
  export type WeekFocusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekFocusCountOutputType
     */
    select?: WeekFocusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WeekFocusCountOutputType without action
   */
  export type WeekFocusCountOutputTypeCountDayFocusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DayFocusWhereInput
  }


  /**
   * Count Type DayPlanCountOutputType
   */

  export type DayPlanCountOutputType = {
    dayFocuses: number
    notes: number
    timeBlocks: number
  }

  export type DayPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dayFocuses?: boolean | DayPlanCountOutputTypeCountDayFocusesArgs
    notes?: boolean | DayPlanCountOutputTypeCountNotesArgs
    timeBlocks?: boolean | DayPlanCountOutputTypeCountTimeBlocksArgs
  }

  // Custom InputTypes
  /**
   * DayPlanCountOutputType without action
   */
  export type DayPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayPlanCountOutputType
     */
    select?: DayPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DayPlanCountOutputType without action
   */
  export type DayPlanCountOutputTypeCountDayFocusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DayFocusWhereInput
  }

  /**
   * DayPlanCountOutputType without action
   */
  export type DayPlanCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
  }

  /**
   * DayPlanCountOutputType without action
   */
  export type DayPlanCountOutputTypeCountTimeBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeBlockWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    tasks: number
    timeBlocks: number
    timeEntries: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | ProjectCountOutputTypeCountTasksArgs
    timeBlocks?: boolean | ProjectCountOutputTypeCountTimeBlocksArgs
    timeEntries?: boolean | ProjectCountOutputTypeCountTimeEntriesArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTimeBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeBlockWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTimeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeEntryWhereInput
  }


  /**
   * Count Type TaskCountOutputType
   */

  export type TaskCountOutputType = {
    timeBlocks: number
    timeEntries: number
  }

  export type TaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    timeBlocks?: boolean | TaskCountOutputTypeCountTimeBlocksArgs
    timeEntries?: boolean | TaskCountOutputTypeCountTimeEntriesArgs
  }

  // Custom InputTypes
  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCountOutputType
     */
    select?: TaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountTimeBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeBlockWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountTimeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeEntryWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    communications: number
    meetings: number
    projects: number
    timeBlocks: number
    timeEntries: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    communications?: boolean | ClientCountOutputTypeCountCommunicationsArgs
    meetings?: boolean | ClientCountOutputTypeCountMeetingsArgs
    projects?: boolean | ClientCountOutputTypeCountProjectsArgs
    timeBlocks?: boolean | ClientCountOutputTypeCountTimeBlocksArgs
    timeEntries?: boolean | ClientCountOutputTypeCountTimeEntriesArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountCommunicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunicationWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountMeetingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountTimeBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeBlockWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountTimeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeEntryWhereInput
  }


  /**
   * Count Type MeetingCountOutputType
   */

  export type MeetingCountOutputType = {
    tasks: number
  }

  export type MeetingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | MeetingCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * MeetingCountOutputType without action
   */
  export type MeetingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingCountOutputType
     */
    select?: MeetingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MeetingCountOutputType without action
   */
  export type MeetingCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type ResearchCountOutputType
   */

  export type ResearchCountOutputType = {
    actionItems: number
    insights: number
    sources: number
  }

  export type ResearchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actionItems?: boolean | ResearchCountOutputTypeCountActionItemsArgs
    insights?: boolean | ResearchCountOutputTypeCountInsightsArgs
    sources?: boolean | ResearchCountOutputTypeCountSourcesArgs
  }

  // Custom InputTypes
  /**
   * ResearchCountOutputType without action
   */
  export type ResearchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchCountOutputType
     */
    select?: ResearchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResearchCountOutputType without action
   */
  export type ResearchCountOutputTypeCountActionItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionItemWhereInput
  }

  /**
   * ResearchCountOutputType without action
   */
  export type ResearchCountOutputTypeCountInsightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResearchInsightWhereInput
  }

  /**
   * ResearchCountOutputType without action
   */
  export type ResearchCountOutputTypeCountSourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResearchSourceWhereInput
  }


  /**
   * Count Type LeadDataCountOutputType
   */

  export type LeadDataCountOutputType = {
    leads: number
  }

  export type LeadDataCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leads?: boolean | LeadDataCountOutputTypeCountLeadsArgs
  }

  // Custom InputTypes
  /**
   * LeadDataCountOutputType without action
   */
  export type LeadDataCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadDataCountOutputType
     */
    select?: LeadDataCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LeadDataCountOutputType without action
   */
  export type LeadDataCountOutputTypeCountLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    researchLimit: number | null
  }

  export type UserSumAggregateOutputType = {
    researchLimit: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    avatar: string | null
    timezone: string | null
    createdAt: Date | null
    updatedAt: Date | null
    geminiApiKey: string | null
    geminiModel: string | null
    groqApiKey: string | null
    llmProvider: string | null
    serperApiKey: string | null
    researchLimit: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    avatar: string | null
    timezone: string | null
    createdAt: Date | null
    updatedAt: Date | null
    geminiApiKey: string | null
    geminiModel: string | null
    groqApiKey: string | null
    llmProvider: string | null
    serperApiKey: string | null
    researchLimit: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    avatar: number
    timezone: number
    createdAt: number
    updatedAt: number
    geminiApiKey: number
    geminiModel: number
    groqApiKey: number
    llmProvider: number
    serperApiKey: number
    researchLimit: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    researchLimit?: true
  }

  export type UserSumAggregateInputType = {
    researchLimit?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    avatar?: true
    timezone?: true
    createdAt?: true
    updatedAt?: true
    geminiApiKey?: true
    geminiModel?: true
    groqApiKey?: true
    llmProvider?: true
    serperApiKey?: true
    researchLimit?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    avatar?: true
    timezone?: true
    createdAt?: true
    updatedAt?: true
    geminiApiKey?: true
    geminiModel?: true
    groqApiKey?: true
    llmProvider?: true
    serperApiKey?: true
    researchLimit?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    avatar?: true
    timezone?: true
    createdAt?: true
    updatedAt?: true
    geminiApiKey?: true
    geminiModel?: true
    groqApiKey?: true
    llmProvider?: true
    serperApiKey?: true
    researchLimit?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string | null
    avatar: string | null
    timezone: string
    createdAt: Date
    updatedAt: Date
    geminiApiKey: string | null
    geminiModel: string
    groqApiKey: string | null
    llmProvider: string
    serperApiKey: string | null
    researchLimit: number
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    avatar?: boolean
    timezone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    geminiApiKey?: boolean
    geminiModel?: boolean
    groqApiKey?: boolean
    llmProvider?: boolean
    serperApiKey?: boolean
    researchLimit?: boolean
    analyticsEvents?: boolean | User$analyticsEventsArgs<ExtArgs>
    calendarEvents?: boolean | User$calendarEventsArgs<ExtArgs>
    captures?: boolean | User$capturesArgs<ExtArgs>
    clients?: boolean | User$clientsArgs<ExtArgs>
    dayPlans?: boolean | User$dayPlansArgs<ExtArgs>
    meetings?: boolean | User$meetingsArgs<ExtArgs>
    notes?: boolean | User$notesArgs<ExtArgs>
    projects?: boolean | User$projectsArgs<ExtArgs>
    researches?: boolean | User$researchesArgs<ExtArgs>
    tasks?: boolean | User$tasksArgs<ExtArgs>
    timeEntries?: boolean | User$timeEntriesArgs<ExtArgs>
    voiceSessions?: boolean | User$voiceSessionsArgs<ExtArgs>
    weekPlans?: boolean | User$weekPlansArgs<ExtArgs>
    wellBeingEntries?: boolean | User$wellBeingEntriesArgs<ExtArgs>
    yearPlans?: boolean | User$yearPlansArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    avatar?: boolean
    timezone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    geminiApiKey?: boolean
    geminiModel?: boolean
    groqApiKey?: boolean
    llmProvider?: boolean
    serperApiKey?: boolean
    researchLimit?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    avatar?: boolean
    timezone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    geminiApiKey?: boolean
    geminiModel?: boolean
    groqApiKey?: boolean
    llmProvider?: boolean
    serperApiKey?: boolean
    researchLimit?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    avatar?: boolean
    timezone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    geminiApiKey?: boolean
    geminiModel?: boolean
    groqApiKey?: boolean
    llmProvider?: boolean
    serperApiKey?: boolean
    researchLimit?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "avatar" | "timezone" | "createdAt" | "updatedAt" | "geminiApiKey" | "geminiModel" | "groqApiKey" | "llmProvider" | "serperApiKey" | "researchLimit", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    analyticsEvents?: boolean | User$analyticsEventsArgs<ExtArgs>
    calendarEvents?: boolean | User$calendarEventsArgs<ExtArgs>
    captures?: boolean | User$capturesArgs<ExtArgs>
    clients?: boolean | User$clientsArgs<ExtArgs>
    dayPlans?: boolean | User$dayPlansArgs<ExtArgs>
    meetings?: boolean | User$meetingsArgs<ExtArgs>
    notes?: boolean | User$notesArgs<ExtArgs>
    projects?: boolean | User$projectsArgs<ExtArgs>
    researches?: boolean | User$researchesArgs<ExtArgs>
    tasks?: boolean | User$tasksArgs<ExtArgs>
    timeEntries?: boolean | User$timeEntriesArgs<ExtArgs>
    voiceSessions?: boolean | User$voiceSessionsArgs<ExtArgs>
    weekPlans?: boolean | User$weekPlansArgs<ExtArgs>
    wellBeingEntries?: boolean | User$wellBeingEntriesArgs<ExtArgs>
    yearPlans?: boolean | User$yearPlansArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      analyticsEvents: Prisma.$AnalyticsEventPayload<ExtArgs>[]
      calendarEvents: Prisma.$CalendarEventPayload<ExtArgs>[]
      captures: Prisma.$CapturePayload<ExtArgs>[]
      clients: Prisma.$ClientPayload<ExtArgs>[]
      dayPlans: Prisma.$DayPlanPayload<ExtArgs>[]
      meetings: Prisma.$MeetingPayload<ExtArgs>[]
      notes: Prisma.$NotePayload<ExtArgs>[]
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      researches: Prisma.$ResearchPayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      timeEntries: Prisma.$TimeEntryPayload<ExtArgs>[]
      voiceSessions: Prisma.$VoiceSessionPayload<ExtArgs>[]
      weekPlans: Prisma.$WeekPlanPayload<ExtArgs>[]
      wellBeingEntries: Prisma.$WellBeingEntryPayload<ExtArgs>[]
      yearPlans: Prisma.$YearPlanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      avatar: string | null
      timezone: string
      createdAt: Date
      updatedAt: Date
      geminiApiKey: string | null
      geminiModel: string
      groqApiKey: string | null
      llmProvider: string
      serperApiKey: string | null
      researchLimit: number
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    analyticsEvents<T extends User$analyticsEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$analyticsEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    calendarEvents<T extends User$calendarEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$calendarEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    captures<T extends User$capturesArgs<ExtArgs> = {}>(args?: Subset<T, User$capturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CapturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clients<T extends User$clientsArgs<ExtArgs> = {}>(args?: Subset<T, User$clientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dayPlans<T extends User$dayPlansArgs<ExtArgs> = {}>(args?: Subset<T, User$dayPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DayPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    meetings<T extends User$meetingsArgs<ExtArgs> = {}>(args?: Subset<T, User$meetingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notes<T extends User$notesArgs<ExtArgs> = {}>(args?: Subset<T, User$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projects<T extends User$projectsArgs<ExtArgs> = {}>(args?: Subset<T, User$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    researches<T extends User$researchesArgs<ExtArgs> = {}>(args?: Subset<T, User$researchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasks<T extends User$tasksArgs<ExtArgs> = {}>(args?: Subset<T, User$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    timeEntries<T extends User$timeEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$timeEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    voiceSessions<T extends User$voiceSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$voiceSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoiceSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    weekPlans<T extends User$weekPlansArgs<ExtArgs> = {}>(args?: Subset<T, User$weekPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeekPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    wellBeingEntries<T extends User$wellBeingEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$wellBeingEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WellBeingEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    yearPlans<T extends User$yearPlansArgs<ExtArgs> = {}>(args?: Subset<T, User$yearPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly timezone: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly geminiApiKey: FieldRef<"User", 'String'>
    readonly geminiModel: FieldRef<"User", 'String'>
    readonly groqApiKey: FieldRef<"User", 'String'>
    readonly llmProvider: FieldRef<"User", 'String'>
    readonly serperApiKey: FieldRef<"User", 'String'>
    readonly researchLimit: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.analyticsEvents
   */
  export type User$analyticsEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    where?: AnalyticsEventWhereInput
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    cursor?: AnalyticsEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnalyticsEventScalarFieldEnum | AnalyticsEventScalarFieldEnum[]
  }

  /**
   * User.calendarEvents
   */
  export type User$calendarEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    where?: CalendarEventWhereInput
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    cursor?: CalendarEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * User.captures
   */
  export type User$capturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capture
     */
    select?: CaptureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Capture
     */
    omit?: CaptureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaptureInclude<ExtArgs> | null
    where?: CaptureWhereInput
    orderBy?: CaptureOrderByWithRelationInput | CaptureOrderByWithRelationInput[]
    cursor?: CaptureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CaptureScalarFieldEnum | CaptureScalarFieldEnum[]
  }

  /**
   * User.clients
   */
  export type User$clientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    cursor?: ClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * User.dayPlans
   */
  export type User$dayPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayPlan
     */
    select?: DayPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayPlan
     */
    omit?: DayPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayPlanInclude<ExtArgs> | null
    where?: DayPlanWhereInput
    orderBy?: DayPlanOrderByWithRelationInput | DayPlanOrderByWithRelationInput[]
    cursor?: DayPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DayPlanScalarFieldEnum | DayPlanScalarFieldEnum[]
  }

  /**
   * User.meetings
   */
  export type User$meetingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    where?: MeetingWhereInput
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    cursor?: MeetingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * User.notes
   */
  export type User$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    cursor?: NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * User.projects
   */
  export type User$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.researches
   */
  export type User$researchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Research
     */
    select?: ResearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Research
     */
    omit?: ResearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchInclude<ExtArgs> | null
    where?: ResearchWhereInput
    orderBy?: ResearchOrderByWithRelationInput | ResearchOrderByWithRelationInput[]
    cursor?: ResearchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResearchScalarFieldEnum | ResearchScalarFieldEnum[]
  }

  /**
   * User.tasks
   */
  export type User$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * User.timeEntries
   */
  export type User$timeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeEntry
     */
    omit?: TimeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    where?: TimeEntryWhereInput
    orderBy?: TimeEntryOrderByWithRelationInput | TimeEntryOrderByWithRelationInput[]
    cursor?: TimeEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeEntryScalarFieldEnum | TimeEntryScalarFieldEnum[]
  }

  /**
   * User.voiceSessions
   */
  export type User$voiceSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceSession
     */
    select?: VoiceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceSession
     */
    omit?: VoiceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceSessionInclude<ExtArgs> | null
    where?: VoiceSessionWhereInput
    orderBy?: VoiceSessionOrderByWithRelationInput | VoiceSessionOrderByWithRelationInput[]
    cursor?: VoiceSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoiceSessionScalarFieldEnum | VoiceSessionScalarFieldEnum[]
  }

  /**
   * User.weekPlans
   */
  export type User$weekPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekPlan
     */
    select?: WeekPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekPlan
     */
    omit?: WeekPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekPlanInclude<ExtArgs> | null
    where?: WeekPlanWhereInput
    orderBy?: WeekPlanOrderByWithRelationInput | WeekPlanOrderByWithRelationInput[]
    cursor?: WeekPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeekPlanScalarFieldEnum | WeekPlanScalarFieldEnum[]
  }

  /**
   * User.wellBeingEntries
   */
  export type User$wellBeingEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBeingEntry
     */
    select?: WellBeingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBeingEntry
     */
    omit?: WellBeingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBeingEntryInclude<ExtArgs> | null
    where?: WellBeingEntryWhereInput
    orderBy?: WellBeingEntryOrderByWithRelationInput | WellBeingEntryOrderByWithRelationInput[]
    cursor?: WellBeingEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WellBeingEntryScalarFieldEnum | WellBeingEntryScalarFieldEnum[]
  }

  /**
   * User.yearPlans
   */
  export type User$yearPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearPlan
     */
    select?: YearPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearPlan
     */
    omit?: YearPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearPlanInclude<ExtArgs> | null
    where?: YearPlanWhereInput
    orderBy?: YearPlanOrderByWithRelationInput | YearPlanOrderByWithRelationInput[]
    cursor?: YearPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: YearPlanScalarFieldEnum | YearPlanScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model YearPlan
   */

  export type AggregateYearPlan = {
    _count: YearPlanCountAggregateOutputType | null
    _avg: YearPlanAvgAggregateOutputType | null
    _sum: YearPlanSumAggregateOutputType | null
    _min: YearPlanMinAggregateOutputType | null
    _max: YearPlanMaxAggregateOutputType | null
  }

  export type YearPlanAvgAggregateOutputType = {
    year: number | null
  }

  export type YearPlanSumAggregateOutputType = {
    year: number | null
  }

  export type YearPlanMinAggregateOutputType = {
    id: string | null
    userId: string | null
    year: number | null
    theme: string | null
    vision: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type YearPlanMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    year: number | null
    theme: string | null
    vision: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type YearPlanCountAggregateOutputType = {
    id: number
    userId: number
    year: number
    theme: number
    vision: number
    focusAreas: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type YearPlanAvgAggregateInputType = {
    year?: true
  }

  export type YearPlanSumAggregateInputType = {
    year?: true
  }

  export type YearPlanMinAggregateInputType = {
    id?: true
    userId?: true
    year?: true
    theme?: true
    vision?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type YearPlanMaxAggregateInputType = {
    id?: true
    userId?: true
    year?: true
    theme?: true
    vision?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type YearPlanCountAggregateInputType = {
    id?: true
    userId?: true
    year?: true
    theme?: true
    vision?: true
    focusAreas?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type YearPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which YearPlan to aggregate.
     */
    where?: YearPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearPlans to fetch.
     */
    orderBy?: YearPlanOrderByWithRelationInput | YearPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YearPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YearPlans
    **/
    _count?: true | YearPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YearPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YearPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YearPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YearPlanMaxAggregateInputType
  }

  export type GetYearPlanAggregateType<T extends YearPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateYearPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYearPlan[P]>
      : GetScalarType<T[P], AggregateYearPlan[P]>
  }




  export type YearPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: YearPlanWhereInput
    orderBy?: YearPlanOrderByWithAggregationInput | YearPlanOrderByWithAggregationInput[]
    by: YearPlanScalarFieldEnum[] | YearPlanScalarFieldEnum
    having?: YearPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YearPlanCountAggregateInputType | true
    _avg?: YearPlanAvgAggregateInputType
    _sum?: YearPlanSumAggregateInputType
    _min?: YearPlanMinAggregateInputType
    _max?: YearPlanMaxAggregateInputType
  }

  export type YearPlanGroupByOutputType = {
    id: string
    userId: string
    year: number
    theme: string
    vision: string
    focusAreas: string[]
    createdAt: Date
    updatedAt: Date
    status: string
    _count: YearPlanCountAggregateOutputType | null
    _avg: YearPlanAvgAggregateOutputType | null
    _sum: YearPlanSumAggregateOutputType | null
    _min: YearPlanMinAggregateOutputType | null
    _max: YearPlanMaxAggregateOutputType | null
  }

  type GetYearPlanGroupByPayload<T extends YearPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<YearPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YearPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YearPlanGroupByOutputType[P]>
            : GetScalarType<T[P], YearPlanGroupByOutputType[P]>
        }
      >
    >


  export type YearPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    year?: boolean
    theme?: boolean
    vision?: boolean
    focusAreas?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    goals?: boolean | YearPlan$goalsArgs<ExtArgs>
    quarterPlans?: boolean | YearPlan$quarterPlansArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | YearPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["yearPlan"]>

  export type YearPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    year?: boolean
    theme?: boolean
    vision?: boolean
    focusAreas?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["yearPlan"]>

  export type YearPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    year?: boolean
    theme?: boolean
    vision?: boolean
    focusAreas?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["yearPlan"]>

  export type YearPlanSelectScalar = {
    id?: boolean
    userId?: boolean
    year?: boolean
    theme?: boolean
    vision?: boolean
    focusAreas?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type YearPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "year" | "theme" | "vision" | "focusAreas" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["yearPlan"]>
  export type YearPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goals?: boolean | YearPlan$goalsArgs<ExtArgs>
    quarterPlans?: boolean | YearPlan$quarterPlansArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | YearPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type YearPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type YearPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $YearPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "YearPlan"
    objects: {
      goals: Prisma.$GoalPayload<ExtArgs>[]
      quarterPlans: Prisma.$QuarterPlanPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      year: number
      theme: string
      vision: string
      focusAreas: string[]
      createdAt: Date
      updatedAt: Date
      status: string
    }, ExtArgs["result"]["yearPlan"]>
    composites: {}
  }

  type YearPlanGetPayload<S extends boolean | null | undefined | YearPlanDefaultArgs> = $Result.GetResult<Prisma.$YearPlanPayload, S>

  type YearPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<YearPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: YearPlanCountAggregateInputType | true
    }

  export interface YearPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['YearPlan'], meta: { name: 'YearPlan' } }
    /**
     * Find zero or one YearPlan that matches the filter.
     * @param {YearPlanFindUniqueArgs} args - Arguments to find a YearPlan
     * @example
     * // Get one YearPlan
     * const yearPlan = await prisma.yearPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends YearPlanFindUniqueArgs>(args: SelectSubset<T, YearPlanFindUniqueArgs<ExtArgs>>): Prisma__YearPlanClient<$Result.GetResult<Prisma.$YearPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one YearPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {YearPlanFindUniqueOrThrowArgs} args - Arguments to find a YearPlan
     * @example
     * // Get one YearPlan
     * const yearPlan = await prisma.yearPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends YearPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, YearPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__YearPlanClient<$Result.GetResult<Prisma.$YearPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first YearPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearPlanFindFirstArgs} args - Arguments to find a YearPlan
     * @example
     * // Get one YearPlan
     * const yearPlan = await prisma.yearPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends YearPlanFindFirstArgs>(args?: SelectSubset<T, YearPlanFindFirstArgs<ExtArgs>>): Prisma__YearPlanClient<$Result.GetResult<Prisma.$YearPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first YearPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearPlanFindFirstOrThrowArgs} args - Arguments to find a YearPlan
     * @example
     * // Get one YearPlan
     * const yearPlan = await prisma.yearPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends YearPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, YearPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__YearPlanClient<$Result.GetResult<Prisma.$YearPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more YearPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YearPlans
     * const yearPlans = await prisma.yearPlan.findMany()
     * 
     * // Get first 10 YearPlans
     * const yearPlans = await prisma.yearPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const yearPlanWithIdOnly = await prisma.yearPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends YearPlanFindManyArgs>(args?: SelectSubset<T, YearPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a YearPlan.
     * @param {YearPlanCreateArgs} args - Arguments to create a YearPlan.
     * @example
     * // Create one YearPlan
     * const YearPlan = await prisma.yearPlan.create({
     *   data: {
     *     // ... data to create a YearPlan
     *   }
     * })
     * 
     */
    create<T extends YearPlanCreateArgs>(args: SelectSubset<T, YearPlanCreateArgs<ExtArgs>>): Prisma__YearPlanClient<$Result.GetResult<Prisma.$YearPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many YearPlans.
     * @param {YearPlanCreateManyArgs} args - Arguments to create many YearPlans.
     * @example
     * // Create many YearPlans
     * const yearPlan = await prisma.yearPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends YearPlanCreateManyArgs>(args?: SelectSubset<T, YearPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many YearPlans and returns the data saved in the database.
     * @param {YearPlanCreateManyAndReturnArgs} args - Arguments to create many YearPlans.
     * @example
     * // Create many YearPlans
     * const yearPlan = await prisma.yearPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many YearPlans and only return the `id`
     * const yearPlanWithIdOnly = await prisma.yearPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends YearPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, YearPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a YearPlan.
     * @param {YearPlanDeleteArgs} args - Arguments to delete one YearPlan.
     * @example
     * // Delete one YearPlan
     * const YearPlan = await prisma.yearPlan.delete({
     *   where: {
     *     // ... filter to delete one YearPlan
     *   }
     * })
     * 
     */
    delete<T extends YearPlanDeleteArgs>(args: SelectSubset<T, YearPlanDeleteArgs<ExtArgs>>): Prisma__YearPlanClient<$Result.GetResult<Prisma.$YearPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one YearPlan.
     * @param {YearPlanUpdateArgs} args - Arguments to update one YearPlan.
     * @example
     * // Update one YearPlan
     * const yearPlan = await prisma.yearPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends YearPlanUpdateArgs>(args: SelectSubset<T, YearPlanUpdateArgs<ExtArgs>>): Prisma__YearPlanClient<$Result.GetResult<Prisma.$YearPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more YearPlans.
     * @param {YearPlanDeleteManyArgs} args - Arguments to filter YearPlans to delete.
     * @example
     * // Delete a few YearPlans
     * const { count } = await prisma.yearPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends YearPlanDeleteManyArgs>(args?: SelectSubset<T, YearPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YearPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YearPlans
     * const yearPlan = await prisma.yearPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends YearPlanUpdateManyArgs>(args: SelectSubset<T, YearPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YearPlans and returns the data updated in the database.
     * @param {YearPlanUpdateManyAndReturnArgs} args - Arguments to update many YearPlans.
     * @example
     * // Update many YearPlans
     * const yearPlan = await prisma.yearPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more YearPlans and only return the `id`
     * const yearPlanWithIdOnly = await prisma.yearPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends YearPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, YearPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one YearPlan.
     * @param {YearPlanUpsertArgs} args - Arguments to update or create a YearPlan.
     * @example
     * // Update or create a YearPlan
     * const yearPlan = await prisma.yearPlan.upsert({
     *   create: {
     *     // ... data to create a YearPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YearPlan we want to update
     *   }
     * })
     */
    upsert<T extends YearPlanUpsertArgs>(args: SelectSubset<T, YearPlanUpsertArgs<ExtArgs>>): Prisma__YearPlanClient<$Result.GetResult<Prisma.$YearPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of YearPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearPlanCountArgs} args - Arguments to filter YearPlans to count.
     * @example
     * // Count the number of YearPlans
     * const count = await prisma.yearPlan.count({
     *   where: {
     *     // ... the filter for the YearPlans we want to count
     *   }
     * })
    **/
    count<T extends YearPlanCountArgs>(
      args?: Subset<T, YearPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YearPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YearPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YearPlanAggregateArgs>(args: Subset<T, YearPlanAggregateArgs>): Prisma.PrismaPromise<GetYearPlanAggregateType<T>>

    /**
     * Group by YearPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YearPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YearPlanGroupByArgs['orderBy'] }
        : { orderBy?: YearPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YearPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYearPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the YearPlan model
   */
  readonly fields: YearPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for YearPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__YearPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    goals<T extends YearPlan$goalsArgs<ExtArgs> = {}>(args?: Subset<T, YearPlan$goalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quarterPlans<T extends YearPlan$quarterPlansArgs<ExtArgs> = {}>(args?: Subset<T, YearPlan$quarterPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuarterPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the YearPlan model
   */
  interface YearPlanFieldRefs {
    readonly id: FieldRef<"YearPlan", 'String'>
    readonly userId: FieldRef<"YearPlan", 'String'>
    readonly year: FieldRef<"YearPlan", 'Int'>
    readonly theme: FieldRef<"YearPlan", 'String'>
    readonly vision: FieldRef<"YearPlan", 'String'>
    readonly focusAreas: FieldRef<"YearPlan", 'String[]'>
    readonly createdAt: FieldRef<"YearPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"YearPlan", 'DateTime'>
    readonly status: FieldRef<"YearPlan", 'String'>
  }
    

  // Custom InputTypes
  /**
   * YearPlan findUnique
   */
  export type YearPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearPlan
     */
    select?: YearPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearPlan
     */
    omit?: YearPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearPlanInclude<ExtArgs> | null
    /**
     * Filter, which YearPlan to fetch.
     */
    where: YearPlanWhereUniqueInput
  }

  /**
   * YearPlan findUniqueOrThrow
   */
  export type YearPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearPlan
     */
    select?: YearPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearPlan
     */
    omit?: YearPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearPlanInclude<ExtArgs> | null
    /**
     * Filter, which YearPlan to fetch.
     */
    where: YearPlanWhereUniqueInput
  }

  /**
   * YearPlan findFirst
   */
  export type YearPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearPlan
     */
    select?: YearPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearPlan
     */
    omit?: YearPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearPlanInclude<ExtArgs> | null
    /**
     * Filter, which YearPlan to fetch.
     */
    where?: YearPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearPlans to fetch.
     */
    orderBy?: YearPlanOrderByWithRelationInput | YearPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YearPlans.
     */
    cursor?: YearPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YearPlans.
     */
    distinct?: YearPlanScalarFieldEnum | YearPlanScalarFieldEnum[]
  }

  /**
   * YearPlan findFirstOrThrow
   */
  export type YearPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearPlan
     */
    select?: YearPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearPlan
     */
    omit?: YearPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearPlanInclude<ExtArgs> | null
    /**
     * Filter, which YearPlan to fetch.
     */
    where?: YearPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearPlans to fetch.
     */
    orderBy?: YearPlanOrderByWithRelationInput | YearPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YearPlans.
     */
    cursor?: YearPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YearPlans.
     */
    distinct?: YearPlanScalarFieldEnum | YearPlanScalarFieldEnum[]
  }

  /**
   * YearPlan findMany
   */
  export type YearPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearPlan
     */
    select?: YearPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearPlan
     */
    omit?: YearPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearPlanInclude<ExtArgs> | null
    /**
     * Filter, which YearPlans to fetch.
     */
    where?: YearPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearPlans to fetch.
     */
    orderBy?: YearPlanOrderByWithRelationInput | YearPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YearPlans.
     */
    cursor?: YearPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearPlans.
     */
    skip?: number
    distinct?: YearPlanScalarFieldEnum | YearPlanScalarFieldEnum[]
  }

  /**
   * YearPlan create
   */
  export type YearPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearPlan
     */
    select?: YearPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearPlan
     */
    omit?: YearPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a YearPlan.
     */
    data: XOR<YearPlanCreateInput, YearPlanUncheckedCreateInput>
  }

  /**
   * YearPlan createMany
   */
  export type YearPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many YearPlans.
     */
    data: YearPlanCreateManyInput | YearPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * YearPlan createManyAndReturn
   */
  export type YearPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearPlan
     */
    select?: YearPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the YearPlan
     */
    omit?: YearPlanOmit<ExtArgs> | null
    /**
     * The data used to create many YearPlans.
     */
    data: YearPlanCreateManyInput | YearPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * YearPlan update
   */
  export type YearPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearPlan
     */
    select?: YearPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearPlan
     */
    omit?: YearPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a YearPlan.
     */
    data: XOR<YearPlanUpdateInput, YearPlanUncheckedUpdateInput>
    /**
     * Choose, which YearPlan to update.
     */
    where: YearPlanWhereUniqueInput
  }

  /**
   * YearPlan updateMany
   */
  export type YearPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update YearPlans.
     */
    data: XOR<YearPlanUpdateManyMutationInput, YearPlanUncheckedUpdateManyInput>
    /**
     * Filter which YearPlans to update
     */
    where?: YearPlanWhereInput
    /**
     * Limit how many YearPlans to update.
     */
    limit?: number
  }

  /**
   * YearPlan updateManyAndReturn
   */
  export type YearPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearPlan
     */
    select?: YearPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the YearPlan
     */
    omit?: YearPlanOmit<ExtArgs> | null
    /**
     * The data used to update YearPlans.
     */
    data: XOR<YearPlanUpdateManyMutationInput, YearPlanUncheckedUpdateManyInput>
    /**
     * Filter which YearPlans to update
     */
    where?: YearPlanWhereInput
    /**
     * Limit how many YearPlans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearPlanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * YearPlan upsert
   */
  export type YearPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearPlan
     */
    select?: YearPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearPlan
     */
    omit?: YearPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the YearPlan to update in case it exists.
     */
    where: YearPlanWhereUniqueInput
    /**
     * In case the YearPlan found by the `where` argument doesn't exist, create a new YearPlan with this data.
     */
    create: XOR<YearPlanCreateInput, YearPlanUncheckedCreateInput>
    /**
     * In case the YearPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YearPlanUpdateInput, YearPlanUncheckedUpdateInput>
  }

  /**
   * YearPlan delete
   */
  export type YearPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearPlan
     */
    select?: YearPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearPlan
     */
    omit?: YearPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearPlanInclude<ExtArgs> | null
    /**
     * Filter which YearPlan to delete.
     */
    where: YearPlanWhereUniqueInput
  }

  /**
   * YearPlan deleteMany
   */
  export type YearPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which YearPlans to delete
     */
    where?: YearPlanWhereInput
    /**
     * Limit how many YearPlans to delete.
     */
    limit?: number
  }

  /**
   * YearPlan.goals
   */
  export type YearPlan$goalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    where?: GoalWhereInput
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    cursor?: GoalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[]
  }

  /**
   * YearPlan.quarterPlans
   */
  export type YearPlan$quarterPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterPlan
     */
    select?: QuarterPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterPlan
     */
    omit?: QuarterPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterPlanInclude<ExtArgs> | null
    where?: QuarterPlanWhereInput
    orderBy?: QuarterPlanOrderByWithRelationInput | QuarterPlanOrderByWithRelationInput[]
    cursor?: QuarterPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuarterPlanScalarFieldEnum | QuarterPlanScalarFieldEnum[]
  }

  /**
   * YearPlan without action
   */
  export type YearPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearPlan
     */
    select?: YearPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearPlan
     */
    omit?: YearPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearPlanInclude<ExtArgs> | null
  }


  /**
   * Model Goal
   */

  export type AggregateGoal = {
    _count: GoalCountAggregateOutputType | null
    _avg: GoalAvgAggregateOutputType | null
    _sum: GoalSumAggregateOutputType | null
    _min: GoalMinAggregateOutputType | null
    _max: GoalMaxAggregateOutputType | null
  }

  export type GoalAvgAggregateOutputType = {
    progress: number | null
  }

  export type GoalSumAggregateOutputType = {
    progress: number | null
  }

  export type GoalMinAggregateOutputType = {
    id: string | null
    yearPlanId: string | null
    title: string | null
    description: string | null
    category: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    priority: string | null
    progress: number | null
    targetDate: Date | null
  }

  export type GoalMaxAggregateOutputType = {
    id: string | null
    yearPlanId: string | null
    title: string | null
    description: string | null
    category: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    priority: string | null
    progress: number | null
    targetDate: Date | null
  }

  export type GoalCountAggregateOutputType = {
    id: number
    yearPlanId: number
    title: number
    description: number
    category: number
    status: number
    createdAt: number
    updatedAt: number
    kpis: number
    priority: number
    progress: number
    risks: number
    strategies: number
    targetDate: number
    _all: number
  }


  export type GoalAvgAggregateInputType = {
    progress?: true
  }

  export type GoalSumAggregateInputType = {
    progress?: true
  }

  export type GoalMinAggregateInputType = {
    id?: true
    yearPlanId?: true
    title?: true
    description?: true
    category?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    priority?: true
    progress?: true
    targetDate?: true
  }

  export type GoalMaxAggregateInputType = {
    id?: true
    yearPlanId?: true
    title?: true
    description?: true
    category?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    priority?: true
    progress?: true
    targetDate?: true
  }

  export type GoalCountAggregateInputType = {
    id?: true
    yearPlanId?: true
    title?: true
    description?: true
    category?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    kpis?: true
    priority?: true
    progress?: true
    risks?: true
    strategies?: true
    targetDate?: true
    _all?: true
  }

  export type GoalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Goal to aggregate.
     */
    where?: GoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Goals
    **/
    _count?: true | GoalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GoalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GoalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GoalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GoalMaxAggregateInputType
  }

  export type GetGoalAggregateType<T extends GoalAggregateArgs> = {
        [P in keyof T & keyof AggregateGoal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGoal[P]>
      : GetScalarType<T[P], AggregateGoal[P]>
  }




  export type GoalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoalWhereInput
    orderBy?: GoalOrderByWithAggregationInput | GoalOrderByWithAggregationInput[]
    by: GoalScalarFieldEnum[] | GoalScalarFieldEnum
    having?: GoalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GoalCountAggregateInputType | true
    _avg?: GoalAvgAggregateInputType
    _sum?: GoalSumAggregateInputType
    _min?: GoalMinAggregateInputType
    _max?: GoalMaxAggregateInputType
  }

  export type GoalGroupByOutputType = {
    id: string
    yearPlanId: string
    title: string
    description: string | null
    category: string
    status: string
    createdAt: Date
    updatedAt: Date
    kpis: string[]
    priority: string
    progress: number
    risks: string[]
    strategies: string[]
    targetDate: Date | null
    _count: GoalCountAggregateOutputType | null
    _avg: GoalAvgAggregateOutputType | null
    _sum: GoalSumAggregateOutputType | null
    _min: GoalMinAggregateOutputType | null
    _max: GoalMaxAggregateOutputType | null
  }

  type GetGoalGroupByPayload<T extends GoalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GoalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GoalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GoalGroupByOutputType[P]>
            : GetScalarType<T[P], GoalGroupByOutputType[P]>
        }
      >
    >


  export type GoalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    yearPlanId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kpis?: boolean
    priority?: boolean
    progress?: boolean
    risks?: boolean
    strategies?: boolean
    targetDate?: boolean
    yearPlan?: boolean | YearPlanDefaultArgs<ExtArgs>
    keySteps?: boolean | Goal$keyStepsArgs<ExtArgs>
    milestones?: boolean | Goal$milestonesArgs<ExtArgs>
    notes?: boolean | Goal$notesArgs<ExtArgs>
    quarterFocuses?: boolean | Goal$quarterFocusesArgs<ExtArgs>
    researches?: boolean | Goal$researchesArgs<ExtArgs>
    tasks?: boolean | Goal$tasksArgs<ExtArgs>
    _count?: boolean | GoalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goal"]>

  export type GoalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    yearPlanId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kpis?: boolean
    priority?: boolean
    progress?: boolean
    risks?: boolean
    strategies?: boolean
    targetDate?: boolean
    yearPlan?: boolean | YearPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goal"]>

  export type GoalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    yearPlanId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kpis?: boolean
    priority?: boolean
    progress?: boolean
    risks?: boolean
    strategies?: boolean
    targetDate?: boolean
    yearPlan?: boolean | YearPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goal"]>

  export type GoalSelectScalar = {
    id?: boolean
    yearPlanId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kpis?: boolean
    priority?: boolean
    progress?: boolean
    risks?: boolean
    strategies?: boolean
    targetDate?: boolean
  }

  export type GoalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "yearPlanId" | "title" | "description" | "category" | "status" | "createdAt" | "updatedAt" | "kpis" | "priority" | "progress" | "risks" | "strategies" | "targetDate", ExtArgs["result"]["goal"]>
  export type GoalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    yearPlan?: boolean | YearPlanDefaultArgs<ExtArgs>
    keySteps?: boolean | Goal$keyStepsArgs<ExtArgs>
    milestones?: boolean | Goal$milestonesArgs<ExtArgs>
    notes?: boolean | Goal$notesArgs<ExtArgs>
    quarterFocuses?: boolean | Goal$quarterFocusesArgs<ExtArgs>
    researches?: boolean | Goal$researchesArgs<ExtArgs>
    tasks?: boolean | Goal$tasksArgs<ExtArgs>
    _count?: boolean | GoalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GoalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    yearPlan?: boolean | YearPlanDefaultArgs<ExtArgs>
  }
  export type GoalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    yearPlan?: boolean | YearPlanDefaultArgs<ExtArgs>
  }

  export type $GoalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Goal"
    objects: {
      yearPlan: Prisma.$YearPlanPayload<ExtArgs>
      keySteps: Prisma.$KeyStepPayload<ExtArgs>[]
      milestones: Prisma.$MilestonePayload<ExtArgs>[]
      notes: Prisma.$NotePayload<ExtArgs>[]
      quarterFocuses: Prisma.$QuarterFocusPayload<ExtArgs>[]
      researches: Prisma.$ResearchPayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      yearPlanId: string
      title: string
      description: string | null
      category: string
      status: string
      createdAt: Date
      updatedAt: Date
      kpis: string[]
      priority: string
      progress: number
      risks: string[]
      strategies: string[]
      targetDate: Date | null
    }, ExtArgs["result"]["goal"]>
    composites: {}
  }

  type GoalGetPayload<S extends boolean | null | undefined | GoalDefaultArgs> = $Result.GetResult<Prisma.$GoalPayload, S>

  type GoalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GoalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GoalCountAggregateInputType | true
    }

  export interface GoalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Goal'], meta: { name: 'Goal' } }
    /**
     * Find zero or one Goal that matches the filter.
     * @param {GoalFindUniqueArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GoalFindUniqueArgs>(args: SelectSubset<T, GoalFindUniqueArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Goal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GoalFindUniqueOrThrowArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GoalFindUniqueOrThrowArgs>(args: SelectSubset<T, GoalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Goal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalFindFirstArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GoalFindFirstArgs>(args?: SelectSubset<T, GoalFindFirstArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Goal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalFindFirstOrThrowArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GoalFindFirstOrThrowArgs>(args?: SelectSubset<T, GoalFindFirstOrThrowArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Goals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Goals
     * const goals = await prisma.goal.findMany()
     * 
     * // Get first 10 Goals
     * const goals = await prisma.goal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const goalWithIdOnly = await prisma.goal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GoalFindManyArgs>(args?: SelectSubset<T, GoalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Goal.
     * @param {GoalCreateArgs} args - Arguments to create a Goal.
     * @example
     * // Create one Goal
     * const Goal = await prisma.goal.create({
     *   data: {
     *     // ... data to create a Goal
     *   }
     * })
     * 
     */
    create<T extends GoalCreateArgs>(args: SelectSubset<T, GoalCreateArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Goals.
     * @param {GoalCreateManyArgs} args - Arguments to create many Goals.
     * @example
     * // Create many Goals
     * const goal = await prisma.goal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GoalCreateManyArgs>(args?: SelectSubset<T, GoalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Goals and returns the data saved in the database.
     * @param {GoalCreateManyAndReturnArgs} args - Arguments to create many Goals.
     * @example
     * // Create many Goals
     * const goal = await prisma.goal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Goals and only return the `id`
     * const goalWithIdOnly = await prisma.goal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GoalCreateManyAndReturnArgs>(args?: SelectSubset<T, GoalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Goal.
     * @param {GoalDeleteArgs} args - Arguments to delete one Goal.
     * @example
     * // Delete one Goal
     * const Goal = await prisma.goal.delete({
     *   where: {
     *     // ... filter to delete one Goal
     *   }
     * })
     * 
     */
    delete<T extends GoalDeleteArgs>(args: SelectSubset<T, GoalDeleteArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Goal.
     * @param {GoalUpdateArgs} args - Arguments to update one Goal.
     * @example
     * // Update one Goal
     * const goal = await prisma.goal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GoalUpdateArgs>(args: SelectSubset<T, GoalUpdateArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Goals.
     * @param {GoalDeleteManyArgs} args - Arguments to filter Goals to delete.
     * @example
     * // Delete a few Goals
     * const { count } = await prisma.goal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GoalDeleteManyArgs>(args?: SelectSubset<T, GoalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Goals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Goals
     * const goal = await prisma.goal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GoalUpdateManyArgs>(args: SelectSubset<T, GoalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Goals and returns the data updated in the database.
     * @param {GoalUpdateManyAndReturnArgs} args - Arguments to update many Goals.
     * @example
     * // Update many Goals
     * const goal = await prisma.goal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Goals and only return the `id`
     * const goalWithIdOnly = await prisma.goal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GoalUpdateManyAndReturnArgs>(args: SelectSubset<T, GoalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Goal.
     * @param {GoalUpsertArgs} args - Arguments to update or create a Goal.
     * @example
     * // Update or create a Goal
     * const goal = await prisma.goal.upsert({
     *   create: {
     *     // ... data to create a Goal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Goal we want to update
     *   }
     * })
     */
    upsert<T extends GoalUpsertArgs>(args: SelectSubset<T, GoalUpsertArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Goals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalCountArgs} args - Arguments to filter Goals to count.
     * @example
     * // Count the number of Goals
     * const count = await prisma.goal.count({
     *   where: {
     *     // ... the filter for the Goals we want to count
     *   }
     * })
    **/
    count<T extends GoalCountArgs>(
      args?: Subset<T, GoalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GoalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Goal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GoalAggregateArgs>(args: Subset<T, GoalAggregateArgs>): Prisma.PrismaPromise<GetGoalAggregateType<T>>

    /**
     * Group by Goal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GoalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GoalGroupByArgs['orderBy'] }
        : { orderBy?: GoalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GoalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGoalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Goal model
   */
  readonly fields: GoalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Goal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GoalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    yearPlan<T extends YearPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, YearPlanDefaultArgs<ExtArgs>>): Prisma__YearPlanClient<$Result.GetResult<Prisma.$YearPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    keySteps<T extends Goal$keyStepsArgs<ExtArgs> = {}>(args?: Subset<T, Goal$keyStepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeyStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    milestones<T extends Goal$milestonesArgs<ExtArgs> = {}>(args?: Subset<T, Goal$milestonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notes<T extends Goal$notesArgs<ExtArgs> = {}>(args?: Subset<T, Goal$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quarterFocuses<T extends Goal$quarterFocusesArgs<ExtArgs> = {}>(args?: Subset<T, Goal$quarterFocusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuarterFocusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    researches<T extends Goal$researchesArgs<ExtArgs> = {}>(args?: Subset<T, Goal$researchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasks<T extends Goal$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Goal$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Goal model
   */
  interface GoalFieldRefs {
    readonly id: FieldRef<"Goal", 'String'>
    readonly yearPlanId: FieldRef<"Goal", 'String'>
    readonly title: FieldRef<"Goal", 'String'>
    readonly description: FieldRef<"Goal", 'String'>
    readonly category: FieldRef<"Goal", 'String'>
    readonly status: FieldRef<"Goal", 'String'>
    readonly createdAt: FieldRef<"Goal", 'DateTime'>
    readonly updatedAt: FieldRef<"Goal", 'DateTime'>
    readonly kpis: FieldRef<"Goal", 'String[]'>
    readonly priority: FieldRef<"Goal", 'String'>
    readonly progress: FieldRef<"Goal", 'Float'>
    readonly risks: FieldRef<"Goal", 'String[]'>
    readonly strategies: FieldRef<"Goal", 'String[]'>
    readonly targetDate: FieldRef<"Goal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Goal findUnique
   */
  export type GoalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goal to fetch.
     */
    where: GoalWhereUniqueInput
  }

  /**
   * Goal findUniqueOrThrow
   */
  export type GoalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goal to fetch.
     */
    where: GoalWhereUniqueInput
  }

  /**
   * Goal findFirst
   */
  export type GoalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goal to fetch.
     */
    where?: GoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Goals.
     */
    cursor?: GoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Goals.
     */
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[]
  }

  /**
   * Goal findFirstOrThrow
   */
  export type GoalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goal to fetch.
     */
    where?: GoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Goals.
     */
    cursor?: GoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Goals.
     */
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[]
  }

  /**
   * Goal findMany
   */
  export type GoalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goals to fetch.
     */
    where?: GoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Goals.
     */
    cursor?: GoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goals.
     */
    skip?: number
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[]
  }

  /**
   * Goal create
   */
  export type GoalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * The data needed to create a Goal.
     */
    data: XOR<GoalCreateInput, GoalUncheckedCreateInput>
  }

  /**
   * Goal createMany
   */
  export type GoalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Goals.
     */
    data: GoalCreateManyInput | GoalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Goal createManyAndReturn
   */
  export type GoalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * The data used to create many Goals.
     */
    data: GoalCreateManyInput | GoalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Goal update
   */
  export type GoalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * The data needed to update a Goal.
     */
    data: XOR<GoalUpdateInput, GoalUncheckedUpdateInput>
    /**
     * Choose, which Goal to update.
     */
    where: GoalWhereUniqueInput
  }

  /**
   * Goal updateMany
   */
  export type GoalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Goals.
     */
    data: XOR<GoalUpdateManyMutationInput, GoalUncheckedUpdateManyInput>
    /**
     * Filter which Goals to update
     */
    where?: GoalWhereInput
    /**
     * Limit how many Goals to update.
     */
    limit?: number
  }

  /**
   * Goal updateManyAndReturn
   */
  export type GoalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * The data used to update Goals.
     */
    data: XOR<GoalUpdateManyMutationInput, GoalUncheckedUpdateManyInput>
    /**
     * Filter which Goals to update
     */
    where?: GoalWhereInput
    /**
     * Limit how many Goals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Goal upsert
   */
  export type GoalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * The filter to search for the Goal to update in case it exists.
     */
    where: GoalWhereUniqueInput
    /**
     * In case the Goal found by the `where` argument doesn't exist, create a new Goal with this data.
     */
    create: XOR<GoalCreateInput, GoalUncheckedCreateInput>
    /**
     * In case the Goal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GoalUpdateInput, GoalUncheckedUpdateInput>
  }

  /**
   * Goal delete
   */
  export type GoalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter which Goal to delete.
     */
    where: GoalWhereUniqueInput
  }

  /**
   * Goal deleteMany
   */
  export type GoalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Goals to delete
     */
    where?: GoalWhereInput
    /**
     * Limit how many Goals to delete.
     */
    limit?: number
  }

  /**
   * Goal.keySteps
   */
  export type Goal$keyStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyStep
     */
    select?: KeyStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyStep
     */
    omit?: KeyStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyStepInclude<ExtArgs> | null
    where?: KeyStepWhereInput
    orderBy?: KeyStepOrderByWithRelationInput | KeyStepOrderByWithRelationInput[]
    cursor?: KeyStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KeyStepScalarFieldEnum | KeyStepScalarFieldEnum[]
  }

  /**
   * Goal.milestones
   */
  export type Goal$milestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    where?: MilestoneWhereInput
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    cursor?: MilestoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Goal.notes
   */
  export type Goal$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    cursor?: NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Goal.quarterFocuses
   */
  export type Goal$quarterFocusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterFocus
     */
    select?: QuarterFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterFocus
     */
    omit?: QuarterFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterFocusInclude<ExtArgs> | null
    where?: QuarterFocusWhereInput
    orderBy?: QuarterFocusOrderByWithRelationInput | QuarterFocusOrderByWithRelationInput[]
    cursor?: QuarterFocusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuarterFocusScalarFieldEnum | QuarterFocusScalarFieldEnum[]
  }

  /**
   * Goal.researches
   */
  export type Goal$researchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Research
     */
    select?: ResearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Research
     */
    omit?: ResearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchInclude<ExtArgs> | null
    where?: ResearchWhereInput
    orderBy?: ResearchOrderByWithRelationInput | ResearchOrderByWithRelationInput[]
    cursor?: ResearchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResearchScalarFieldEnum | ResearchScalarFieldEnum[]
  }

  /**
   * Goal.tasks
   */
  export type Goal$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Goal without action
   */
  export type GoalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
  }


  /**
   * Model Milestone
   */

  export type AggregateMilestone = {
    _count: MilestoneCountAggregateOutputType | null
    _min: MilestoneMinAggregateOutputType | null
    _max: MilestoneMaxAggregateOutputType | null
  }

  export type MilestoneMinAggregateOutputType = {
    id: string | null
    goalId: string | null
    title: string | null
    targetDate: Date | null
    completed: boolean | null
    completedAt: Date | null
    createdAt: Date | null
  }

  export type MilestoneMaxAggregateOutputType = {
    id: string | null
    goalId: string | null
    title: string | null
    targetDate: Date | null
    completed: boolean | null
    completedAt: Date | null
    createdAt: Date | null
  }

  export type MilestoneCountAggregateOutputType = {
    id: number
    goalId: number
    title: number
    targetDate: number
    completed: number
    completedAt: number
    createdAt: number
    _all: number
  }


  export type MilestoneMinAggregateInputType = {
    id?: true
    goalId?: true
    title?: true
    targetDate?: true
    completed?: true
    completedAt?: true
    createdAt?: true
  }

  export type MilestoneMaxAggregateInputType = {
    id?: true
    goalId?: true
    title?: true
    targetDate?: true
    completed?: true
    completedAt?: true
    createdAt?: true
  }

  export type MilestoneCountAggregateInputType = {
    id?: true
    goalId?: true
    title?: true
    targetDate?: true
    completed?: true
    completedAt?: true
    createdAt?: true
    _all?: true
  }

  export type MilestoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Milestone to aggregate.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Milestones
    **/
    _count?: true | MilestoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MilestoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MilestoneMaxAggregateInputType
  }

  export type GetMilestoneAggregateType<T extends MilestoneAggregateArgs> = {
        [P in keyof T & keyof AggregateMilestone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMilestone[P]>
      : GetScalarType<T[P], AggregateMilestone[P]>
  }




  export type MilestoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MilestoneWhereInput
    orderBy?: MilestoneOrderByWithAggregationInput | MilestoneOrderByWithAggregationInput[]
    by: MilestoneScalarFieldEnum[] | MilestoneScalarFieldEnum
    having?: MilestoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MilestoneCountAggregateInputType | true
    _min?: MilestoneMinAggregateInputType
    _max?: MilestoneMaxAggregateInputType
  }

  export type MilestoneGroupByOutputType = {
    id: string
    goalId: string
    title: string
    targetDate: Date | null
    completed: boolean
    completedAt: Date | null
    createdAt: Date
    _count: MilestoneCountAggregateOutputType | null
    _min: MilestoneMinAggregateOutputType | null
    _max: MilestoneMaxAggregateOutputType | null
  }

  type GetMilestoneGroupByPayload<T extends MilestoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MilestoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MilestoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MilestoneGroupByOutputType[P]>
            : GetScalarType<T[P], MilestoneGroupByOutputType[P]>
        }
      >
    >


  export type MilestoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goalId?: boolean
    title?: boolean
    targetDate?: boolean
    completed?: boolean
    completedAt?: boolean
    createdAt?: boolean
    goal?: boolean | GoalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["milestone"]>

  export type MilestoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goalId?: boolean
    title?: boolean
    targetDate?: boolean
    completed?: boolean
    completedAt?: boolean
    createdAt?: boolean
    goal?: boolean | GoalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["milestone"]>

  export type MilestoneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goalId?: boolean
    title?: boolean
    targetDate?: boolean
    completed?: boolean
    completedAt?: boolean
    createdAt?: boolean
    goal?: boolean | GoalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["milestone"]>

  export type MilestoneSelectScalar = {
    id?: boolean
    goalId?: boolean
    title?: boolean
    targetDate?: boolean
    completed?: boolean
    completedAt?: boolean
    createdAt?: boolean
  }

  export type MilestoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "goalId" | "title" | "targetDate" | "completed" | "completedAt" | "createdAt", ExtArgs["result"]["milestone"]>
  export type MilestoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goal?: boolean | GoalDefaultArgs<ExtArgs>
  }
  export type MilestoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goal?: boolean | GoalDefaultArgs<ExtArgs>
  }
  export type MilestoneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goal?: boolean | GoalDefaultArgs<ExtArgs>
  }

  export type $MilestonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Milestone"
    objects: {
      goal: Prisma.$GoalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      goalId: string
      title: string
      targetDate: Date | null
      completed: boolean
      completedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["milestone"]>
    composites: {}
  }

  type MilestoneGetPayload<S extends boolean | null | undefined | MilestoneDefaultArgs> = $Result.GetResult<Prisma.$MilestonePayload, S>

  type MilestoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MilestoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MilestoneCountAggregateInputType | true
    }

  export interface MilestoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Milestone'], meta: { name: 'Milestone' } }
    /**
     * Find zero or one Milestone that matches the filter.
     * @param {MilestoneFindUniqueArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MilestoneFindUniqueArgs>(args: SelectSubset<T, MilestoneFindUniqueArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Milestone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MilestoneFindUniqueOrThrowArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MilestoneFindUniqueOrThrowArgs>(args: SelectSubset<T, MilestoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Milestone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindFirstArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MilestoneFindFirstArgs>(args?: SelectSubset<T, MilestoneFindFirstArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Milestone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindFirstOrThrowArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MilestoneFindFirstOrThrowArgs>(args?: SelectSubset<T, MilestoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Milestones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Milestones
     * const milestones = await prisma.milestone.findMany()
     * 
     * // Get first 10 Milestones
     * const milestones = await prisma.milestone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const milestoneWithIdOnly = await prisma.milestone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MilestoneFindManyArgs>(args?: SelectSubset<T, MilestoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Milestone.
     * @param {MilestoneCreateArgs} args - Arguments to create a Milestone.
     * @example
     * // Create one Milestone
     * const Milestone = await prisma.milestone.create({
     *   data: {
     *     // ... data to create a Milestone
     *   }
     * })
     * 
     */
    create<T extends MilestoneCreateArgs>(args: SelectSubset<T, MilestoneCreateArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Milestones.
     * @param {MilestoneCreateManyArgs} args - Arguments to create many Milestones.
     * @example
     * // Create many Milestones
     * const milestone = await prisma.milestone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MilestoneCreateManyArgs>(args?: SelectSubset<T, MilestoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Milestones and returns the data saved in the database.
     * @param {MilestoneCreateManyAndReturnArgs} args - Arguments to create many Milestones.
     * @example
     * // Create many Milestones
     * const milestone = await prisma.milestone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Milestones and only return the `id`
     * const milestoneWithIdOnly = await prisma.milestone.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MilestoneCreateManyAndReturnArgs>(args?: SelectSubset<T, MilestoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Milestone.
     * @param {MilestoneDeleteArgs} args - Arguments to delete one Milestone.
     * @example
     * // Delete one Milestone
     * const Milestone = await prisma.milestone.delete({
     *   where: {
     *     // ... filter to delete one Milestone
     *   }
     * })
     * 
     */
    delete<T extends MilestoneDeleteArgs>(args: SelectSubset<T, MilestoneDeleteArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Milestone.
     * @param {MilestoneUpdateArgs} args - Arguments to update one Milestone.
     * @example
     * // Update one Milestone
     * const milestone = await prisma.milestone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MilestoneUpdateArgs>(args: SelectSubset<T, MilestoneUpdateArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Milestones.
     * @param {MilestoneDeleteManyArgs} args - Arguments to filter Milestones to delete.
     * @example
     * // Delete a few Milestones
     * const { count } = await prisma.milestone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MilestoneDeleteManyArgs>(args?: SelectSubset<T, MilestoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Milestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Milestones
     * const milestone = await prisma.milestone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MilestoneUpdateManyArgs>(args: SelectSubset<T, MilestoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Milestones and returns the data updated in the database.
     * @param {MilestoneUpdateManyAndReturnArgs} args - Arguments to update many Milestones.
     * @example
     * // Update many Milestones
     * const milestone = await prisma.milestone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Milestones and only return the `id`
     * const milestoneWithIdOnly = await prisma.milestone.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MilestoneUpdateManyAndReturnArgs>(args: SelectSubset<T, MilestoneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Milestone.
     * @param {MilestoneUpsertArgs} args - Arguments to update or create a Milestone.
     * @example
     * // Update or create a Milestone
     * const milestone = await prisma.milestone.upsert({
     *   create: {
     *     // ... data to create a Milestone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Milestone we want to update
     *   }
     * })
     */
    upsert<T extends MilestoneUpsertArgs>(args: SelectSubset<T, MilestoneUpsertArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Milestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneCountArgs} args - Arguments to filter Milestones to count.
     * @example
     * // Count the number of Milestones
     * const count = await prisma.milestone.count({
     *   where: {
     *     // ... the filter for the Milestones we want to count
     *   }
     * })
    **/
    count<T extends MilestoneCountArgs>(
      args?: Subset<T, MilestoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MilestoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Milestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MilestoneAggregateArgs>(args: Subset<T, MilestoneAggregateArgs>): Prisma.PrismaPromise<GetMilestoneAggregateType<T>>

    /**
     * Group by Milestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MilestoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MilestoneGroupByArgs['orderBy'] }
        : { orderBy?: MilestoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MilestoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMilestoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Milestone model
   */
  readonly fields: MilestoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Milestone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MilestoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    goal<T extends GoalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GoalDefaultArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Milestone model
   */
  interface MilestoneFieldRefs {
    readonly id: FieldRef<"Milestone", 'String'>
    readonly goalId: FieldRef<"Milestone", 'String'>
    readonly title: FieldRef<"Milestone", 'String'>
    readonly targetDate: FieldRef<"Milestone", 'DateTime'>
    readonly completed: FieldRef<"Milestone", 'Boolean'>
    readonly completedAt: FieldRef<"Milestone", 'DateTime'>
    readonly createdAt: FieldRef<"Milestone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Milestone findUnique
   */
  export type MilestoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone findUniqueOrThrow
   */
  export type MilestoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone findFirst
   */
  export type MilestoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Milestones.
     */
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone findFirstOrThrow
   */
  export type MilestoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Milestones.
     */
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone findMany
   */
  export type MilestoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestones to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone create
   */
  export type MilestoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The data needed to create a Milestone.
     */
    data: XOR<MilestoneCreateInput, MilestoneUncheckedCreateInput>
  }

  /**
   * Milestone createMany
   */
  export type MilestoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Milestones.
     */
    data: MilestoneCreateManyInput | MilestoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Milestone createManyAndReturn
   */
  export type MilestoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * The data used to create many Milestones.
     */
    data: MilestoneCreateManyInput | MilestoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Milestone update
   */
  export type MilestoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The data needed to update a Milestone.
     */
    data: XOR<MilestoneUpdateInput, MilestoneUncheckedUpdateInput>
    /**
     * Choose, which Milestone to update.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone updateMany
   */
  export type MilestoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Milestones.
     */
    data: XOR<MilestoneUpdateManyMutationInput, MilestoneUncheckedUpdateManyInput>
    /**
     * Filter which Milestones to update
     */
    where?: MilestoneWhereInput
    /**
     * Limit how many Milestones to update.
     */
    limit?: number
  }

  /**
   * Milestone updateManyAndReturn
   */
  export type MilestoneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * The data used to update Milestones.
     */
    data: XOR<MilestoneUpdateManyMutationInput, MilestoneUncheckedUpdateManyInput>
    /**
     * Filter which Milestones to update
     */
    where?: MilestoneWhereInput
    /**
     * Limit how many Milestones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Milestone upsert
   */
  export type MilestoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The filter to search for the Milestone to update in case it exists.
     */
    where: MilestoneWhereUniqueInput
    /**
     * In case the Milestone found by the `where` argument doesn't exist, create a new Milestone with this data.
     */
    create: XOR<MilestoneCreateInput, MilestoneUncheckedCreateInput>
    /**
     * In case the Milestone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MilestoneUpdateInput, MilestoneUncheckedUpdateInput>
  }

  /**
   * Milestone delete
   */
  export type MilestoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter which Milestone to delete.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone deleteMany
   */
  export type MilestoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Milestones to delete
     */
    where?: MilestoneWhereInput
    /**
     * Limit how many Milestones to delete.
     */
    limit?: number
  }

  /**
   * Milestone without action
   */
  export type MilestoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
  }


  /**
   * Model KeyStep
   */

  export type AggregateKeyStep = {
    _count: KeyStepCountAggregateOutputType | null
    _avg: KeyStepAvgAggregateOutputType | null
    _sum: KeyStepSumAggregateOutputType | null
    _min: KeyStepMinAggregateOutputType | null
    _max: KeyStepMaxAggregateOutputType | null
  }

  export type KeyStepAvgAggregateOutputType = {
    order: number | null
    progress: number | null
  }

  export type KeyStepSumAggregateOutputType = {
    order: number | null
    progress: number | null
  }

  export type KeyStepMinAggregateOutputType = {
    id: string | null
    goalId: string | null
    title: string | null
    description: string | null
    order: number | null
    completed: boolean | null
    completedAt: Date | null
    progress: number | null
    targetDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KeyStepMaxAggregateOutputType = {
    id: string | null
    goalId: string | null
    title: string | null
    description: string | null
    order: number | null
    completed: boolean | null
    completedAt: Date | null
    progress: number | null
    targetDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KeyStepCountAggregateOutputType = {
    id: number
    goalId: number
    title: number
    description: number
    order: number
    completed: number
    completedAt: number
    progress: number
    targetDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KeyStepAvgAggregateInputType = {
    order?: true
    progress?: true
  }

  export type KeyStepSumAggregateInputType = {
    order?: true
    progress?: true
  }

  export type KeyStepMinAggregateInputType = {
    id?: true
    goalId?: true
    title?: true
    description?: true
    order?: true
    completed?: true
    completedAt?: true
    progress?: true
    targetDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KeyStepMaxAggregateInputType = {
    id?: true
    goalId?: true
    title?: true
    description?: true
    order?: true
    completed?: true
    completedAt?: true
    progress?: true
    targetDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KeyStepCountAggregateInputType = {
    id?: true
    goalId?: true
    title?: true
    description?: true
    order?: true
    completed?: true
    completedAt?: true
    progress?: true
    targetDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KeyStepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KeyStep to aggregate.
     */
    where?: KeyStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeySteps to fetch.
     */
    orderBy?: KeyStepOrderByWithRelationInput | KeyStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KeyStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeySteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeySteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KeySteps
    **/
    _count?: true | KeyStepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KeyStepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KeyStepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KeyStepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KeyStepMaxAggregateInputType
  }

  export type GetKeyStepAggregateType<T extends KeyStepAggregateArgs> = {
        [P in keyof T & keyof AggregateKeyStep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKeyStep[P]>
      : GetScalarType<T[P], AggregateKeyStep[P]>
  }




  export type KeyStepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KeyStepWhereInput
    orderBy?: KeyStepOrderByWithAggregationInput | KeyStepOrderByWithAggregationInput[]
    by: KeyStepScalarFieldEnum[] | KeyStepScalarFieldEnum
    having?: KeyStepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KeyStepCountAggregateInputType | true
    _avg?: KeyStepAvgAggregateInputType
    _sum?: KeyStepSumAggregateInputType
    _min?: KeyStepMinAggregateInputType
    _max?: KeyStepMaxAggregateInputType
  }

  export type KeyStepGroupByOutputType = {
    id: string
    goalId: string
    title: string
    description: string | null
    order: number
    completed: boolean
    completedAt: Date | null
    progress: number
    targetDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: KeyStepCountAggregateOutputType | null
    _avg: KeyStepAvgAggregateOutputType | null
    _sum: KeyStepSumAggregateOutputType | null
    _min: KeyStepMinAggregateOutputType | null
    _max: KeyStepMaxAggregateOutputType | null
  }

  type GetKeyStepGroupByPayload<T extends KeyStepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KeyStepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KeyStepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KeyStepGroupByOutputType[P]>
            : GetScalarType<T[P], KeyStepGroupByOutputType[P]>
        }
      >
    >


  export type KeyStepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goalId?: boolean
    title?: boolean
    description?: boolean
    order?: boolean
    completed?: boolean
    completedAt?: boolean
    progress?: boolean
    targetDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goal?: boolean | GoalDefaultArgs<ExtArgs>
    notes?: boolean | KeyStep$notesArgs<ExtArgs>
    tasks?: boolean | KeyStep$tasksArgs<ExtArgs>
    _count?: boolean | KeyStepCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["keyStep"]>

  export type KeyStepSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goalId?: boolean
    title?: boolean
    description?: boolean
    order?: boolean
    completed?: boolean
    completedAt?: boolean
    progress?: boolean
    targetDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goal?: boolean | GoalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["keyStep"]>

  export type KeyStepSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goalId?: boolean
    title?: boolean
    description?: boolean
    order?: boolean
    completed?: boolean
    completedAt?: boolean
    progress?: boolean
    targetDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goal?: boolean | GoalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["keyStep"]>

  export type KeyStepSelectScalar = {
    id?: boolean
    goalId?: boolean
    title?: boolean
    description?: boolean
    order?: boolean
    completed?: boolean
    completedAt?: boolean
    progress?: boolean
    targetDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KeyStepOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "goalId" | "title" | "description" | "order" | "completed" | "completedAt" | "progress" | "targetDate" | "createdAt" | "updatedAt", ExtArgs["result"]["keyStep"]>
  export type KeyStepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goal?: boolean | GoalDefaultArgs<ExtArgs>
    notes?: boolean | KeyStep$notesArgs<ExtArgs>
    tasks?: boolean | KeyStep$tasksArgs<ExtArgs>
    _count?: boolean | KeyStepCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KeyStepIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goal?: boolean | GoalDefaultArgs<ExtArgs>
  }
  export type KeyStepIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goal?: boolean | GoalDefaultArgs<ExtArgs>
  }

  export type $KeyStepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KeyStep"
    objects: {
      goal: Prisma.$GoalPayload<ExtArgs>
      notes: Prisma.$NotePayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      goalId: string
      title: string
      description: string | null
      order: number
      completed: boolean
      completedAt: Date | null
      progress: number
      targetDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["keyStep"]>
    composites: {}
  }

  type KeyStepGetPayload<S extends boolean | null | undefined | KeyStepDefaultArgs> = $Result.GetResult<Prisma.$KeyStepPayload, S>

  type KeyStepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KeyStepFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KeyStepCountAggregateInputType | true
    }

  export interface KeyStepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KeyStep'], meta: { name: 'KeyStep' } }
    /**
     * Find zero or one KeyStep that matches the filter.
     * @param {KeyStepFindUniqueArgs} args - Arguments to find a KeyStep
     * @example
     * // Get one KeyStep
     * const keyStep = await prisma.keyStep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KeyStepFindUniqueArgs>(args: SelectSubset<T, KeyStepFindUniqueArgs<ExtArgs>>): Prisma__KeyStepClient<$Result.GetResult<Prisma.$KeyStepPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KeyStep that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KeyStepFindUniqueOrThrowArgs} args - Arguments to find a KeyStep
     * @example
     * // Get one KeyStep
     * const keyStep = await prisma.keyStep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KeyStepFindUniqueOrThrowArgs>(args: SelectSubset<T, KeyStepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KeyStepClient<$Result.GetResult<Prisma.$KeyStepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KeyStep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyStepFindFirstArgs} args - Arguments to find a KeyStep
     * @example
     * // Get one KeyStep
     * const keyStep = await prisma.keyStep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KeyStepFindFirstArgs>(args?: SelectSubset<T, KeyStepFindFirstArgs<ExtArgs>>): Prisma__KeyStepClient<$Result.GetResult<Prisma.$KeyStepPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KeyStep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyStepFindFirstOrThrowArgs} args - Arguments to find a KeyStep
     * @example
     * // Get one KeyStep
     * const keyStep = await prisma.keyStep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KeyStepFindFirstOrThrowArgs>(args?: SelectSubset<T, KeyStepFindFirstOrThrowArgs<ExtArgs>>): Prisma__KeyStepClient<$Result.GetResult<Prisma.$KeyStepPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KeySteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyStepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KeySteps
     * const keySteps = await prisma.keyStep.findMany()
     * 
     * // Get first 10 KeySteps
     * const keySteps = await prisma.keyStep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const keyStepWithIdOnly = await prisma.keyStep.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KeyStepFindManyArgs>(args?: SelectSubset<T, KeyStepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeyStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KeyStep.
     * @param {KeyStepCreateArgs} args - Arguments to create a KeyStep.
     * @example
     * // Create one KeyStep
     * const KeyStep = await prisma.keyStep.create({
     *   data: {
     *     // ... data to create a KeyStep
     *   }
     * })
     * 
     */
    create<T extends KeyStepCreateArgs>(args: SelectSubset<T, KeyStepCreateArgs<ExtArgs>>): Prisma__KeyStepClient<$Result.GetResult<Prisma.$KeyStepPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KeySteps.
     * @param {KeyStepCreateManyArgs} args - Arguments to create many KeySteps.
     * @example
     * // Create many KeySteps
     * const keyStep = await prisma.keyStep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KeyStepCreateManyArgs>(args?: SelectSubset<T, KeyStepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KeySteps and returns the data saved in the database.
     * @param {KeyStepCreateManyAndReturnArgs} args - Arguments to create many KeySteps.
     * @example
     * // Create many KeySteps
     * const keyStep = await prisma.keyStep.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KeySteps and only return the `id`
     * const keyStepWithIdOnly = await prisma.keyStep.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KeyStepCreateManyAndReturnArgs>(args?: SelectSubset<T, KeyStepCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeyStepPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KeyStep.
     * @param {KeyStepDeleteArgs} args - Arguments to delete one KeyStep.
     * @example
     * // Delete one KeyStep
     * const KeyStep = await prisma.keyStep.delete({
     *   where: {
     *     // ... filter to delete one KeyStep
     *   }
     * })
     * 
     */
    delete<T extends KeyStepDeleteArgs>(args: SelectSubset<T, KeyStepDeleteArgs<ExtArgs>>): Prisma__KeyStepClient<$Result.GetResult<Prisma.$KeyStepPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KeyStep.
     * @param {KeyStepUpdateArgs} args - Arguments to update one KeyStep.
     * @example
     * // Update one KeyStep
     * const keyStep = await prisma.keyStep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KeyStepUpdateArgs>(args: SelectSubset<T, KeyStepUpdateArgs<ExtArgs>>): Prisma__KeyStepClient<$Result.GetResult<Prisma.$KeyStepPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KeySteps.
     * @param {KeyStepDeleteManyArgs} args - Arguments to filter KeySteps to delete.
     * @example
     * // Delete a few KeySteps
     * const { count } = await prisma.keyStep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KeyStepDeleteManyArgs>(args?: SelectSubset<T, KeyStepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KeySteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyStepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KeySteps
     * const keyStep = await prisma.keyStep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KeyStepUpdateManyArgs>(args: SelectSubset<T, KeyStepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KeySteps and returns the data updated in the database.
     * @param {KeyStepUpdateManyAndReturnArgs} args - Arguments to update many KeySteps.
     * @example
     * // Update many KeySteps
     * const keyStep = await prisma.keyStep.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KeySteps and only return the `id`
     * const keyStepWithIdOnly = await prisma.keyStep.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KeyStepUpdateManyAndReturnArgs>(args: SelectSubset<T, KeyStepUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeyStepPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KeyStep.
     * @param {KeyStepUpsertArgs} args - Arguments to update or create a KeyStep.
     * @example
     * // Update or create a KeyStep
     * const keyStep = await prisma.keyStep.upsert({
     *   create: {
     *     // ... data to create a KeyStep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KeyStep we want to update
     *   }
     * })
     */
    upsert<T extends KeyStepUpsertArgs>(args: SelectSubset<T, KeyStepUpsertArgs<ExtArgs>>): Prisma__KeyStepClient<$Result.GetResult<Prisma.$KeyStepPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KeySteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyStepCountArgs} args - Arguments to filter KeySteps to count.
     * @example
     * // Count the number of KeySteps
     * const count = await prisma.keyStep.count({
     *   where: {
     *     // ... the filter for the KeySteps we want to count
     *   }
     * })
    **/
    count<T extends KeyStepCountArgs>(
      args?: Subset<T, KeyStepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KeyStepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KeyStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyStepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KeyStepAggregateArgs>(args: Subset<T, KeyStepAggregateArgs>): Prisma.PrismaPromise<GetKeyStepAggregateType<T>>

    /**
     * Group by KeyStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyStepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KeyStepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KeyStepGroupByArgs['orderBy'] }
        : { orderBy?: KeyStepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KeyStepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKeyStepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KeyStep model
   */
  readonly fields: KeyStepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KeyStep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KeyStepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    goal<T extends GoalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GoalDefaultArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    notes<T extends KeyStep$notesArgs<ExtArgs> = {}>(args?: Subset<T, KeyStep$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasks<T extends KeyStep$tasksArgs<ExtArgs> = {}>(args?: Subset<T, KeyStep$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KeyStep model
   */
  interface KeyStepFieldRefs {
    readonly id: FieldRef<"KeyStep", 'String'>
    readonly goalId: FieldRef<"KeyStep", 'String'>
    readonly title: FieldRef<"KeyStep", 'String'>
    readonly description: FieldRef<"KeyStep", 'String'>
    readonly order: FieldRef<"KeyStep", 'Int'>
    readonly completed: FieldRef<"KeyStep", 'Boolean'>
    readonly completedAt: FieldRef<"KeyStep", 'DateTime'>
    readonly progress: FieldRef<"KeyStep", 'Float'>
    readonly targetDate: FieldRef<"KeyStep", 'DateTime'>
    readonly createdAt: FieldRef<"KeyStep", 'DateTime'>
    readonly updatedAt: FieldRef<"KeyStep", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KeyStep findUnique
   */
  export type KeyStepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyStep
     */
    select?: KeyStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyStep
     */
    omit?: KeyStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyStepInclude<ExtArgs> | null
    /**
     * Filter, which KeyStep to fetch.
     */
    where: KeyStepWhereUniqueInput
  }

  /**
   * KeyStep findUniqueOrThrow
   */
  export type KeyStepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyStep
     */
    select?: KeyStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyStep
     */
    omit?: KeyStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyStepInclude<ExtArgs> | null
    /**
     * Filter, which KeyStep to fetch.
     */
    where: KeyStepWhereUniqueInput
  }

  /**
   * KeyStep findFirst
   */
  export type KeyStepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyStep
     */
    select?: KeyStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyStep
     */
    omit?: KeyStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyStepInclude<ExtArgs> | null
    /**
     * Filter, which KeyStep to fetch.
     */
    where?: KeyStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeySteps to fetch.
     */
    orderBy?: KeyStepOrderByWithRelationInput | KeyStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KeySteps.
     */
    cursor?: KeyStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeySteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeySteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KeySteps.
     */
    distinct?: KeyStepScalarFieldEnum | KeyStepScalarFieldEnum[]
  }

  /**
   * KeyStep findFirstOrThrow
   */
  export type KeyStepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyStep
     */
    select?: KeyStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyStep
     */
    omit?: KeyStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyStepInclude<ExtArgs> | null
    /**
     * Filter, which KeyStep to fetch.
     */
    where?: KeyStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeySteps to fetch.
     */
    orderBy?: KeyStepOrderByWithRelationInput | KeyStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KeySteps.
     */
    cursor?: KeyStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeySteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeySteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KeySteps.
     */
    distinct?: KeyStepScalarFieldEnum | KeyStepScalarFieldEnum[]
  }

  /**
   * KeyStep findMany
   */
  export type KeyStepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyStep
     */
    select?: KeyStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyStep
     */
    omit?: KeyStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyStepInclude<ExtArgs> | null
    /**
     * Filter, which KeySteps to fetch.
     */
    where?: KeyStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeySteps to fetch.
     */
    orderBy?: KeyStepOrderByWithRelationInput | KeyStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KeySteps.
     */
    cursor?: KeyStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeySteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeySteps.
     */
    skip?: number
    distinct?: KeyStepScalarFieldEnum | KeyStepScalarFieldEnum[]
  }

  /**
   * KeyStep create
   */
  export type KeyStepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyStep
     */
    select?: KeyStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyStep
     */
    omit?: KeyStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyStepInclude<ExtArgs> | null
    /**
     * The data needed to create a KeyStep.
     */
    data: XOR<KeyStepCreateInput, KeyStepUncheckedCreateInput>
  }

  /**
   * KeyStep createMany
   */
  export type KeyStepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KeySteps.
     */
    data: KeyStepCreateManyInput | KeyStepCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KeyStep createManyAndReturn
   */
  export type KeyStepCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyStep
     */
    select?: KeyStepSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KeyStep
     */
    omit?: KeyStepOmit<ExtArgs> | null
    /**
     * The data used to create many KeySteps.
     */
    data: KeyStepCreateManyInput | KeyStepCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyStepIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KeyStep update
   */
  export type KeyStepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyStep
     */
    select?: KeyStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyStep
     */
    omit?: KeyStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyStepInclude<ExtArgs> | null
    /**
     * The data needed to update a KeyStep.
     */
    data: XOR<KeyStepUpdateInput, KeyStepUncheckedUpdateInput>
    /**
     * Choose, which KeyStep to update.
     */
    where: KeyStepWhereUniqueInput
  }

  /**
   * KeyStep updateMany
   */
  export type KeyStepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KeySteps.
     */
    data: XOR<KeyStepUpdateManyMutationInput, KeyStepUncheckedUpdateManyInput>
    /**
     * Filter which KeySteps to update
     */
    where?: KeyStepWhereInput
    /**
     * Limit how many KeySteps to update.
     */
    limit?: number
  }

  /**
   * KeyStep updateManyAndReturn
   */
  export type KeyStepUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyStep
     */
    select?: KeyStepSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KeyStep
     */
    omit?: KeyStepOmit<ExtArgs> | null
    /**
     * The data used to update KeySteps.
     */
    data: XOR<KeyStepUpdateManyMutationInput, KeyStepUncheckedUpdateManyInput>
    /**
     * Filter which KeySteps to update
     */
    where?: KeyStepWhereInput
    /**
     * Limit how many KeySteps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyStepIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KeyStep upsert
   */
  export type KeyStepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyStep
     */
    select?: KeyStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyStep
     */
    omit?: KeyStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyStepInclude<ExtArgs> | null
    /**
     * The filter to search for the KeyStep to update in case it exists.
     */
    where: KeyStepWhereUniqueInput
    /**
     * In case the KeyStep found by the `where` argument doesn't exist, create a new KeyStep with this data.
     */
    create: XOR<KeyStepCreateInput, KeyStepUncheckedCreateInput>
    /**
     * In case the KeyStep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KeyStepUpdateInput, KeyStepUncheckedUpdateInput>
  }

  /**
   * KeyStep delete
   */
  export type KeyStepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyStep
     */
    select?: KeyStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyStep
     */
    omit?: KeyStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyStepInclude<ExtArgs> | null
    /**
     * Filter which KeyStep to delete.
     */
    where: KeyStepWhereUniqueInput
  }

  /**
   * KeyStep deleteMany
   */
  export type KeyStepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KeySteps to delete
     */
    where?: KeyStepWhereInput
    /**
     * Limit how many KeySteps to delete.
     */
    limit?: number
  }

  /**
   * KeyStep.notes
   */
  export type KeyStep$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    cursor?: NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * KeyStep.tasks
   */
  export type KeyStep$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * KeyStep without action
   */
  export type KeyStepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyStep
     */
    select?: KeyStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyStep
     */
    omit?: KeyStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyStepInclude<ExtArgs> | null
  }


  /**
   * Model Note
   */

  export type AggregateNote = {
    _count: NoteCountAggregateOutputType | null
    _min: NoteMinAggregateOutputType | null
    _max: NoteMaxAggregateOutputType | null
  }

  export type NoteMinAggregateOutputType = {
    id: string | null
    userId: string | null
    content: string | null
    goalId: string | null
    keyStepId: string | null
    dayPlanId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NoteMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    content: string | null
    goalId: string | null
    keyStepId: string | null
    dayPlanId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NoteCountAggregateOutputType = {
    id: number
    userId: number
    content: number
    goalId: number
    keyStepId: number
    dayPlanId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NoteMinAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    goalId?: true
    keyStepId?: true
    dayPlanId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NoteMaxAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    goalId?: true
    keyStepId?: true
    dayPlanId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NoteCountAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    goalId?: true
    keyStepId?: true
    dayPlanId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Note to aggregate.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notes
    **/
    _count?: true | NoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoteMaxAggregateInputType
  }

  export type GetNoteAggregateType<T extends NoteAggregateArgs> = {
        [P in keyof T & keyof AggregateNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNote[P]>
      : GetScalarType<T[P], AggregateNote[P]>
  }




  export type NoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithAggregationInput | NoteOrderByWithAggregationInput[]
    by: NoteScalarFieldEnum[] | NoteScalarFieldEnum
    having?: NoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoteCountAggregateInputType | true
    _min?: NoteMinAggregateInputType
    _max?: NoteMaxAggregateInputType
  }

  export type NoteGroupByOutputType = {
    id: string
    userId: string
    content: string
    goalId: string | null
    keyStepId: string | null
    dayPlanId: string | null
    createdAt: Date
    updatedAt: Date
    _count: NoteCountAggregateOutputType | null
    _min: NoteMinAggregateOutputType | null
    _max: NoteMaxAggregateOutputType | null
  }

  type GetNoteGroupByPayload<T extends NoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoteGroupByOutputType[P]>
            : GetScalarType<T[P], NoteGroupByOutputType[P]>
        }
      >
    >


  export type NoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    content?: boolean
    goalId?: boolean
    keyStepId?: boolean
    dayPlanId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dayPlan?: boolean | Note$dayPlanArgs<ExtArgs>
    goal?: boolean | Note$goalArgs<ExtArgs>
    keyStep?: boolean | Note$keyStepArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["note"]>

  export type NoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    content?: boolean
    goalId?: boolean
    keyStepId?: boolean
    dayPlanId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dayPlan?: boolean | Note$dayPlanArgs<ExtArgs>
    goal?: boolean | Note$goalArgs<ExtArgs>
    keyStep?: boolean | Note$keyStepArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["note"]>

  export type NoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    content?: boolean
    goalId?: boolean
    keyStepId?: boolean
    dayPlanId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dayPlan?: boolean | Note$dayPlanArgs<ExtArgs>
    goal?: boolean | Note$goalArgs<ExtArgs>
    keyStep?: boolean | Note$keyStepArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["note"]>

  export type NoteSelectScalar = {
    id?: boolean
    userId?: boolean
    content?: boolean
    goalId?: boolean
    keyStepId?: boolean
    dayPlanId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "content" | "goalId" | "keyStepId" | "dayPlanId" | "createdAt" | "updatedAt", ExtArgs["result"]["note"]>
  export type NoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dayPlan?: boolean | Note$dayPlanArgs<ExtArgs>
    goal?: boolean | Note$goalArgs<ExtArgs>
    keyStep?: boolean | Note$keyStepArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dayPlan?: boolean | Note$dayPlanArgs<ExtArgs>
    goal?: boolean | Note$goalArgs<ExtArgs>
    keyStep?: boolean | Note$keyStepArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dayPlan?: boolean | Note$dayPlanArgs<ExtArgs>
    goal?: boolean | Note$goalArgs<ExtArgs>
    keyStep?: boolean | Note$keyStepArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Note"
    objects: {
      dayPlan: Prisma.$DayPlanPayload<ExtArgs> | null
      goal: Prisma.$GoalPayload<ExtArgs> | null
      keyStep: Prisma.$KeyStepPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      content: string
      goalId: string | null
      keyStepId: string | null
      dayPlanId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["note"]>
    composites: {}
  }

  type NoteGetPayload<S extends boolean | null | undefined | NoteDefaultArgs> = $Result.GetResult<Prisma.$NotePayload, S>

  type NoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NoteCountAggregateInputType | true
    }

  export interface NoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Note'], meta: { name: 'Note' } }
    /**
     * Find zero or one Note that matches the filter.
     * @param {NoteFindUniqueArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NoteFindUniqueArgs>(args: SelectSubset<T, NoteFindUniqueArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Note that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NoteFindUniqueOrThrowArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NoteFindUniqueOrThrowArgs>(args: SelectSubset<T, NoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Note that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindFirstArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NoteFindFirstArgs>(args?: SelectSubset<T, NoteFindFirstArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Note that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindFirstOrThrowArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NoteFindFirstOrThrowArgs>(args?: SelectSubset<T, NoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notes
     * const notes = await prisma.note.findMany()
     * 
     * // Get first 10 Notes
     * const notes = await prisma.note.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noteWithIdOnly = await prisma.note.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NoteFindManyArgs>(args?: SelectSubset<T, NoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Note.
     * @param {NoteCreateArgs} args - Arguments to create a Note.
     * @example
     * // Create one Note
     * const Note = await prisma.note.create({
     *   data: {
     *     // ... data to create a Note
     *   }
     * })
     * 
     */
    create<T extends NoteCreateArgs>(args: SelectSubset<T, NoteCreateArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notes.
     * @param {NoteCreateManyArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const note = await prisma.note.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NoteCreateManyArgs>(args?: SelectSubset<T, NoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notes and returns the data saved in the database.
     * @param {NoteCreateManyAndReturnArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const note = await prisma.note.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notes and only return the `id`
     * const noteWithIdOnly = await prisma.note.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NoteCreateManyAndReturnArgs>(args?: SelectSubset<T, NoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Note.
     * @param {NoteDeleteArgs} args - Arguments to delete one Note.
     * @example
     * // Delete one Note
     * const Note = await prisma.note.delete({
     *   where: {
     *     // ... filter to delete one Note
     *   }
     * })
     * 
     */
    delete<T extends NoteDeleteArgs>(args: SelectSubset<T, NoteDeleteArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Note.
     * @param {NoteUpdateArgs} args - Arguments to update one Note.
     * @example
     * // Update one Note
     * const note = await prisma.note.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NoteUpdateArgs>(args: SelectSubset<T, NoteUpdateArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notes.
     * @param {NoteDeleteManyArgs} args - Arguments to filter Notes to delete.
     * @example
     * // Delete a few Notes
     * const { count } = await prisma.note.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NoteDeleteManyArgs>(args?: SelectSubset<T, NoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notes
     * const note = await prisma.note.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NoteUpdateManyArgs>(args: SelectSubset<T, NoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes and returns the data updated in the database.
     * @param {NoteUpdateManyAndReturnArgs} args - Arguments to update many Notes.
     * @example
     * // Update many Notes
     * const note = await prisma.note.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notes and only return the `id`
     * const noteWithIdOnly = await prisma.note.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NoteUpdateManyAndReturnArgs>(args: SelectSubset<T, NoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Note.
     * @param {NoteUpsertArgs} args - Arguments to update or create a Note.
     * @example
     * // Update or create a Note
     * const note = await prisma.note.upsert({
     *   create: {
     *     // ... data to create a Note
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Note we want to update
     *   }
     * })
     */
    upsert<T extends NoteUpsertArgs>(args: SelectSubset<T, NoteUpsertArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteCountArgs} args - Arguments to filter Notes to count.
     * @example
     * // Count the number of Notes
     * const count = await prisma.note.count({
     *   where: {
     *     // ... the filter for the Notes we want to count
     *   }
     * })
    **/
    count<T extends NoteCountArgs>(
      args?: Subset<T, NoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoteAggregateArgs>(args: Subset<T, NoteAggregateArgs>): Prisma.PrismaPromise<GetNoteAggregateType<T>>

    /**
     * Group by Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoteGroupByArgs['orderBy'] }
        : { orderBy?: NoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Note model
   */
  readonly fields: NoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Note.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dayPlan<T extends Note$dayPlanArgs<ExtArgs> = {}>(args?: Subset<T, Note$dayPlanArgs<ExtArgs>>): Prisma__DayPlanClient<$Result.GetResult<Prisma.$DayPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    goal<T extends Note$goalArgs<ExtArgs> = {}>(args?: Subset<T, Note$goalArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    keyStep<T extends Note$keyStepArgs<ExtArgs> = {}>(args?: Subset<T, Note$keyStepArgs<ExtArgs>>): Prisma__KeyStepClient<$Result.GetResult<Prisma.$KeyStepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Note model
   */
  interface NoteFieldRefs {
    readonly id: FieldRef<"Note", 'String'>
    readonly userId: FieldRef<"Note", 'String'>
    readonly content: FieldRef<"Note", 'String'>
    readonly goalId: FieldRef<"Note", 'String'>
    readonly keyStepId: FieldRef<"Note", 'String'>
    readonly dayPlanId: FieldRef<"Note", 'String'>
    readonly createdAt: FieldRef<"Note", 'DateTime'>
    readonly updatedAt: FieldRef<"Note", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Note findUnique
   */
  export type NoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note findUniqueOrThrow
   */
  export type NoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note findFirst
   */
  export type NoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Note findFirstOrThrow
   */
  export type NoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Note findMany
   */
  export type NoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Notes to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Note create
   */
  export type NoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The data needed to create a Note.
     */
    data: XOR<NoteCreateInput, NoteUncheckedCreateInput>
  }

  /**
   * Note createMany
   */
  export type NoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notes.
     */
    data: NoteCreateManyInput | NoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Note createManyAndReturn
   */
  export type NoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * The data used to create many Notes.
     */
    data: NoteCreateManyInput | NoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Note update
   */
  export type NoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The data needed to update a Note.
     */
    data: XOR<NoteUpdateInput, NoteUncheckedUpdateInput>
    /**
     * Choose, which Note to update.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note updateMany
   */
  export type NoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notes.
     */
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyInput>
    /**
     * Filter which Notes to update
     */
    where?: NoteWhereInput
    /**
     * Limit how many Notes to update.
     */
    limit?: number
  }

  /**
   * Note updateManyAndReturn
   */
  export type NoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * The data used to update Notes.
     */
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyInput>
    /**
     * Filter which Notes to update
     */
    where?: NoteWhereInput
    /**
     * Limit how many Notes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Note upsert
   */
  export type NoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The filter to search for the Note to update in case it exists.
     */
    where: NoteWhereUniqueInput
    /**
     * In case the Note found by the `where` argument doesn't exist, create a new Note with this data.
     */
    create: XOR<NoteCreateInput, NoteUncheckedCreateInput>
    /**
     * In case the Note was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoteUpdateInput, NoteUncheckedUpdateInput>
  }

  /**
   * Note delete
   */
  export type NoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter which Note to delete.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note deleteMany
   */
  export type NoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notes to delete
     */
    where?: NoteWhereInput
    /**
     * Limit how many Notes to delete.
     */
    limit?: number
  }

  /**
   * Note.dayPlan
   */
  export type Note$dayPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayPlan
     */
    select?: DayPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayPlan
     */
    omit?: DayPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayPlanInclude<ExtArgs> | null
    where?: DayPlanWhereInput
  }

  /**
   * Note.goal
   */
  export type Note$goalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    where?: GoalWhereInput
  }

  /**
   * Note.keyStep
   */
  export type Note$keyStepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyStep
     */
    select?: KeyStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyStep
     */
    omit?: KeyStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyStepInclude<ExtArgs> | null
    where?: KeyStepWhereInput
  }

  /**
   * Note without action
   */
  export type NoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
  }


  /**
   * Model QuarterPlan
   */

  export type AggregateQuarterPlan = {
    _count: QuarterPlanCountAggregateOutputType | null
    _avg: QuarterPlanAvgAggregateOutputType | null
    _sum: QuarterPlanSumAggregateOutputType | null
    _min: QuarterPlanMinAggregateOutputType | null
    _max: QuarterPlanMaxAggregateOutputType | null
  }

  export type QuarterPlanAvgAggregateOutputType = {
    quarter: number | null
  }

  export type QuarterPlanSumAggregateOutputType = {
    quarter: number | null
  }

  export type QuarterPlanMinAggregateOutputType = {
    id: string | null
    yearPlanId: string | null
    quarter: number | null
    theme: string | null
    startDate: Date | null
    endDate: Date | null
  }

  export type QuarterPlanMaxAggregateOutputType = {
    id: string | null
    yearPlanId: string | null
    quarter: number | null
    theme: string | null
    startDate: Date | null
    endDate: Date | null
  }

  export type QuarterPlanCountAggregateOutputType = {
    id: number
    yearPlanId: number
    quarter: number
    theme: number
    startDate: number
    endDate: number
    _all: number
  }


  export type QuarterPlanAvgAggregateInputType = {
    quarter?: true
  }

  export type QuarterPlanSumAggregateInputType = {
    quarter?: true
  }

  export type QuarterPlanMinAggregateInputType = {
    id?: true
    yearPlanId?: true
    quarter?: true
    theme?: true
    startDate?: true
    endDate?: true
  }

  export type QuarterPlanMaxAggregateInputType = {
    id?: true
    yearPlanId?: true
    quarter?: true
    theme?: true
    startDate?: true
    endDate?: true
  }

  export type QuarterPlanCountAggregateInputType = {
    id?: true
    yearPlanId?: true
    quarter?: true
    theme?: true
    startDate?: true
    endDate?: true
    _all?: true
  }

  export type QuarterPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuarterPlan to aggregate.
     */
    where?: QuarterPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuarterPlans to fetch.
     */
    orderBy?: QuarterPlanOrderByWithRelationInput | QuarterPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuarterPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuarterPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuarterPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuarterPlans
    **/
    _count?: true | QuarterPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuarterPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuarterPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuarterPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuarterPlanMaxAggregateInputType
  }

  export type GetQuarterPlanAggregateType<T extends QuarterPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateQuarterPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuarterPlan[P]>
      : GetScalarType<T[P], AggregateQuarterPlan[P]>
  }




  export type QuarterPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuarterPlanWhereInput
    orderBy?: QuarterPlanOrderByWithAggregationInput | QuarterPlanOrderByWithAggregationInput[]
    by: QuarterPlanScalarFieldEnum[] | QuarterPlanScalarFieldEnum
    having?: QuarterPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuarterPlanCountAggregateInputType | true
    _avg?: QuarterPlanAvgAggregateInputType
    _sum?: QuarterPlanSumAggregateInputType
    _min?: QuarterPlanMinAggregateInputType
    _max?: QuarterPlanMaxAggregateInputType
  }

  export type QuarterPlanGroupByOutputType = {
    id: string
    yearPlanId: string
    quarter: number
    theme: string
    startDate: Date
    endDate: Date
    _count: QuarterPlanCountAggregateOutputType | null
    _avg: QuarterPlanAvgAggregateOutputType | null
    _sum: QuarterPlanSumAggregateOutputType | null
    _min: QuarterPlanMinAggregateOutputType | null
    _max: QuarterPlanMaxAggregateOutputType | null
  }

  type GetQuarterPlanGroupByPayload<T extends QuarterPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuarterPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuarterPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuarterPlanGroupByOutputType[P]>
            : GetScalarType<T[P], QuarterPlanGroupByOutputType[P]>
        }
      >
    >


  export type QuarterPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    yearPlanId?: boolean
    quarter?: boolean
    theme?: boolean
    startDate?: boolean
    endDate?: boolean
    monthPlans?: boolean | QuarterPlan$monthPlansArgs<ExtArgs>
    quarterFocuses?: boolean | QuarterPlan$quarterFocusesArgs<ExtArgs>
    objectives?: boolean | QuarterPlan$objectivesArgs<ExtArgs>
    yearPlan?: boolean | YearPlanDefaultArgs<ExtArgs>
    _count?: boolean | QuarterPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quarterPlan"]>

  export type QuarterPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    yearPlanId?: boolean
    quarter?: boolean
    theme?: boolean
    startDate?: boolean
    endDate?: boolean
    yearPlan?: boolean | YearPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quarterPlan"]>

  export type QuarterPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    yearPlanId?: boolean
    quarter?: boolean
    theme?: boolean
    startDate?: boolean
    endDate?: boolean
    yearPlan?: boolean | YearPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quarterPlan"]>

  export type QuarterPlanSelectScalar = {
    id?: boolean
    yearPlanId?: boolean
    quarter?: boolean
    theme?: boolean
    startDate?: boolean
    endDate?: boolean
  }

  export type QuarterPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "yearPlanId" | "quarter" | "theme" | "startDate" | "endDate", ExtArgs["result"]["quarterPlan"]>
  export type QuarterPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monthPlans?: boolean | QuarterPlan$monthPlansArgs<ExtArgs>
    quarterFocuses?: boolean | QuarterPlan$quarterFocusesArgs<ExtArgs>
    objectives?: boolean | QuarterPlan$objectivesArgs<ExtArgs>
    yearPlan?: boolean | YearPlanDefaultArgs<ExtArgs>
    _count?: boolean | QuarterPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuarterPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    yearPlan?: boolean | YearPlanDefaultArgs<ExtArgs>
  }
  export type QuarterPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    yearPlan?: boolean | YearPlanDefaultArgs<ExtArgs>
  }

  export type $QuarterPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuarterPlan"
    objects: {
      monthPlans: Prisma.$MonthPlanPayload<ExtArgs>[]
      quarterFocuses: Prisma.$QuarterFocusPayload<ExtArgs>[]
      objectives: Prisma.$QuarterObjectivePayload<ExtArgs>[]
      yearPlan: Prisma.$YearPlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      yearPlanId: string
      quarter: number
      theme: string
      startDate: Date
      endDate: Date
    }, ExtArgs["result"]["quarterPlan"]>
    composites: {}
  }

  type QuarterPlanGetPayload<S extends boolean | null | undefined | QuarterPlanDefaultArgs> = $Result.GetResult<Prisma.$QuarterPlanPayload, S>

  type QuarterPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuarterPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuarterPlanCountAggregateInputType | true
    }

  export interface QuarterPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuarterPlan'], meta: { name: 'QuarterPlan' } }
    /**
     * Find zero or one QuarterPlan that matches the filter.
     * @param {QuarterPlanFindUniqueArgs} args - Arguments to find a QuarterPlan
     * @example
     * // Get one QuarterPlan
     * const quarterPlan = await prisma.quarterPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuarterPlanFindUniqueArgs>(args: SelectSubset<T, QuarterPlanFindUniqueArgs<ExtArgs>>): Prisma__QuarterPlanClient<$Result.GetResult<Prisma.$QuarterPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuarterPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuarterPlanFindUniqueOrThrowArgs} args - Arguments to find a QuarterPlan
     * @example
     * // Get one QuarterPlan
     * const quarterPlan = await prisma.quarterPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuarterPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, QuarterPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuarterPlanClient<$Result.GetResult<Prisma.$QuarterPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuarterPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuarterPlanFindFirstArgs} args - Arguments to find a QuarterPlan
     * @example
     * // Get one QuarterPlan
     * const quarterPlan = await prisma.quarterPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuarterPlanFindFirstArgs>(args?: SelectSubset<T, QuarterPlanFindFirstArgs<ExtArgs>>): Prisma__QuarterPlanClient<$Result.GetResult<Prisma.$QuarterPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuarterPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuarterPlanFindFirstOrThrowArgs} args - Arguments to find a QuarterPlan
     * @example
     * // Get one QuarterPlan
     * const quarterPlan = await prisma.quarterPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuarterPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, QuarterPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuarterPlanClient<$Result.GetResult<Prisma.$QuarterPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuarterPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuarterPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuarterPlans
     * const quarterPlans = await prisma.quarterPlan.findMany()
     * 
     * // Get first 10 QuarterPlans
     * const quarterPlans = await prisma.quarterPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quarterPlanWithIdOnly = await prisma.quarterPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuarterPlanFindManyArgs>(args?: SelectSubset<T, QuarterPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuarterPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuarterPlan.
     * @param {QuarterPlanCreateArgs} args - Arguments to create a QuarterPlan.
     * @example
     * // Create one QuarterPlan
     * const QuarterPlan = await prisma.quarterPlan.create({
     *   data: {
     *     // ... data to create a QuarterPlan
     *   }
     * })
     * 
     */
    create<T extends QuarterPlanCreateArgs>(args: SelectSubset<T, QuarterPlanCreateArgs<ExtArgs>>): Prisma__QuarterPlanClient<$Result.GetResult<Prisma.$QuarterPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuarterPlans.
     * @param {QuarterPlanCreateManyArgs} args - Arguments to create many QuarterPlans.
     * @example
     * // Create many QuarterPlans
     * const quarterPlan = await prisma.quarterPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuarterPlanCreateManyArgs>(args?: SelectSubset<T, QuarterPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuarterPlans and returns the data saved in the database.
     * @param {QuarterPlanCreateManyAndReturnArgs} args - Arguments to create many QuarterPlans.
     * @example
     * // Create many QuarterPlans
     * const quarterPlan = await prisma.quarterPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuarterPlans and only return the `id`
     * const quarterPlanWithIdOnly = await prisma.quarterPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuarterPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, QuarterPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuarterPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuarterPlan.
     * @param {QuarterPlanDeleteArgs} args - Arguments to delete one QuarterPlan.
     * @example
     * // Delete one QuarterPlan
     * const QuarterPlan = await prisma.quarterPlan.delete({
     *   where: {
     *     // ... filter to delete one QuarterPlan
     *   }
     * })
     * 
     */
    delete<T extends QuarterPlanDeleteArgs>(args: SelectSubset<T, QuarterPlanDeleteArgs<ExtArgs>>): Prisma__QuarterPlanClient<$Result.GetResult<Prisma.$QuarterPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuarterPlan.
     * @param {QuarterPlanUpdateArgs} args - Arguments to update one QuarterPlan.
     * @example
     * // Update one QuarterPlan
     * const quarterPlan = await prisma.quarterPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuarterPlanUpdateArgs>(args: SelectSubset<T, QuarterPlanUpdateArgs<ExtArgs>>): Prisma__QuarterPlanClient<$Result.GetResult<Prisma.$QuarterPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuarterPlans.
     * @param {QuarterPlanDeleteManyArgs} args - Arguments to filter QuarterPlans to delete.
     * @example
     * // Delete a few QuarterPlans
     * const { count } = await prisma.quarterPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuarterPlanDeleteManyArgs>(args?: SelectSubset<T, QuarterPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuarterPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuarterPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuarterPlans
     * const quarterPlan = await prisma.quarterPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuarterPlanUpdateManyArgs>(args: SelectSubset<T, QuarterPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuarterPlans and returns the data updated in the database.
     * @param {QuarterPlanUpdateManyAndReturnArgs} args - Arguments to update many QuarterPlans.
     * @example
     * // Update many QuarterPlans
     * const quarterPlan = await prisma.quarterPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuarterPlans and only return the `id`
     * const quarterPlanWithIdOnly = await prisma.quarterPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuarterPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, QuarterPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuarterPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuarterPlan.
     * @param {QuarterPlanUpsertArgs} args - Arguments to update or create a QuarterPlan.
     * @example
     * // Update or create a QuarterPlan
     * const quarterPlan = await prisma.quarterPlan.upsert({
     *   create: {
     *     // ... data to create a QuarterPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuarterPlan we want to update
     *   }
     * })
     */
    upsert<T extends QuarterPlanUpsertArgs>(args: SelectSubset<T, QuarterPlanUpsertArgs<ExtArgs>>): Prisma__QuarterPlanClient<$Result.GetResult<Prisma.$QuarterPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuarterPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuarterPlanCountArgs} args - Arguments to filter QuarterPlans to count.
     * @example
     * // Count the number of QuarterPlans
     * const count = await prisma.quarterPlan.count({
     *   where: {
     *     // ... the filter for the QuarterPlans we want to count
     *   }
     * })
    **/
    count<T extends QuarterPlanCountArgs>(
      args?: Subset<T, QuarterPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuarterPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuarterPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuarterPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuarterPlanAggregateArgs>(args: Subset<T, QuarterPlanAggregateArgs>): Prisma.PrismaPromise<GetQuarterPlanAggregateType<T>>

    /**
     * Group by QuarterPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuarterPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuarterPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuarterPlanGroupByArgs['orderBy'] }
        : { orderBy?: QuarterPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuarterPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuarterPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuarterPlan model
   */
  readonly fields: QuarterPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuarterPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuarterPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    monthPlans<T extends QuarterPlan$monthPlansArgs<ExtArgs> = {}>(args?: Subset<T, QuarterPlan$monthPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonthPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quarterFocuses<T extends QuarterPlan$quarterFocusesArgs<ExtArgs> = {}>(args?: Subset<T, QuarterPlan$quarterFocusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuarterFocusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    objectives<T extends QuarterPlan$objectivesArgs<ExtArgs> = {}>(args?: Subset<T, QuarterPlan$objectivesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuarterObjectivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    yearPlan<T extends YearPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, YearPlanDefaultArgs<ExtArgs>>): Prisma__YearPlanClient<$Result.GetResult<Prisma.$YearPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuarterPlan model
   */
  interface QuarterPlanFieldRefs {
    readonly id: FieldRef<"QuarterPlan", 'String'>
    readonly yearPlanId: FieldRef<"QuarterPlan", 'String'>
    readonly quarter: FieldRef<"QuarterPlan", 'Int'>
    readonly theme: FieldRef<"QuarterPlan", 'String'>
    readonly startDate: FieldRef<"QuarterPlan", 'DateTime'>
    readonly endDate: FieldRef<"QuarterPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuarterPlan findUnique
   */
  export type QuarterPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterPlan
     */
    select?: QuarterPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterPlan
     */
    omit?: QuarterPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterPlanInclude<ExtArgs> | null
    /**
     * Filter, which QuarterPlan to fetch.
     */
    where: QuarterPlanWhereUniqueInput
  }

  /**
   * QuarterPlan findUniqueOrThrow
   */
  export type QuarterPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterPlan
     */
    select?: QuarterPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterPlan
     */
    omit?: QuarterPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterPlanInclude<ExtArgs> | null
    /**
     * Filter, which QuarterPlan to fetch.
     */
    where: QuarterPlanWhereUniqueInput
  }

  /**
   * QuarterPlan findFirst
   */
  export type QuarterPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterPlan
     */
    select?: QuarterPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterPlan
     */
    omit?: QuarterPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterPlanInclude<ExtArgs> | null
    /**
     * Filter, which QuarterPlan to fetch.
     */
    where?: QuarterPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuarterPlans to fetch.
     */
    orderBy?: QuarterPlanOrderByWithRelationInput | QuarterPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuarterPlans.
     */
    cursor?: QuarterPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuarterPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuarterPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuarterPlans.
     */
    distinct?: QuarterPlanScalarFieldEnum | QuarterPlanScalarFieldEnum[]
  }

  /**
   * QuarterPlan findFirstOrThrow
   */
  export type QuarterPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterPlan
     */
    select?: QuarterPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterPlan
     */
    omit?: QuarterPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterPlanInclude<ExtArgs> | null
    /**
     * Filter, which QuarterPlan to fetch.
     */
    where?: QuarterPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuarterPlans to fetch.
     */
    orderBy?: QuarterPlanOrderByWithRelationInput | QuarterPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuarterPlans.
     */
    cursor?: QuarterPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuarterPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuarterPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuarterPlans.
     */
    distinct?: QuarterPlanScalarFieldEnum | QuarterPlanScalarFieldEnum[]
  }

  /**
   * QuarterPlan findMany
   */
  export type QuarterPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterPlan
     */
    select?: QuarterPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterPlan
     */
    omit?: QuarterPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterPlanInclude<ExtArgs> | null
    /**
     * Filter, which QuarterPlans to fetch.
     */
    where?: QuarterPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuarterPlans to fetch.
     */
    orderBy?: QuarterPlanOrderByWithRelationInput | QuarterPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuarterPlans.
     */
    cursor?: QuarterPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuarterPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuarterPlans.
     */
    skip?: number
    distinct?: QuarterPlanScalarFieldEnum | QuarterPlanScalarFieldEnum[]
  }

  /**
   * QuarterPlan create
   */
  export type QuarterPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterPlan
     */
    select?: QuarterPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterPlan
     */
    omit?: QuarterPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a QuarterPlan.
     */
    data: XOR<QuarterPlanCreateInput, QuarterPlanUncheckedCreateInput>
  }

  /**
   * QuarterPlan createMany
   */
  export type QuarterPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuarterPlans.
     */
    data: QuarterPlanCreateManyInput | QuarterPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuarterPlan createManyAndReturn
   */
  export type QuarterPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterPlan
     */
    select?: QuarterPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterPlan
     */
    omit?: QuarterPlanOmit<ExtArgs> | null
    /**
     * The data used to create many QuarterPlans.
     */
    data: QuarterPlanCreateManyInput | QuarterPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuarterPlan update
   */
  export type QuarterPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterPlan
     */
    select?: QuarterPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterPlan
     */
    omit?: QuarterPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a QuarterPlan.
     */
    data: XOR<QuarterPlanUpdateInput, QuarterPlanUncheckedUpdateInput>
    /**
     * Choose, which QuarterPlan to update.
     */
    where: QuarterPlanWhereUniqueInput
  }

  /**
   * QuarterPlan updateMany
   */
  export type QuarterPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuarterPlans.
     */
    data: XOR<QuarterPlanUpdateManyMutationInput, QuarterPlanUncheckedUpdateManyInput>
    /**
     * Filter which QuarterPlans to update
     */
    where?: QuarterPlanWhereInput
    /**
     * Limit how many QuarterPlans to update.
     */
    limit?: number
  }

  /**
   * QuarterPlan updateManyAndReturn
   */
  export type QuarterPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterPlan
     */
    select?: QuarterPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterPlan
     */
    omit?: QuarterPlanOmit<ExtArgs> | null
    /**
     * The data used to update QuarterPlans.
     */
    data: XOR<QuarterPlanUpdateManyMutationInput, QuarterPlanUncheckedUpdateManyInput>
    /**
     * Filter which QuarterPlans to update
     */
    where?: QuarterPlanWhereInput
    /**
     * Limit how many QuarterPlans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterPlanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuarterPlan upsert
   */
  export type QuarterPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterPlan
     */
    select?: QuarterPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterPlan
     */
    omit?: QuarterPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the QuarterPlan to update in case it exists.
     */
    where: QuarterPlanWhereUniqueInput
    /**
     * In case the QuarterPlan found by the `where` argument doesn't exist, create a new QuarterPlan with this data.
     */
    create: XOR<QuarterPlanCreateInput, QuarterPlanUncheckedCreateInput>
    /**
     * In case the QuarterPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuarterPlanUpdateInput, QuarterPlanUncheckedUpdateInput>
  }

  /**
   * QuarterPlan delete
   */
  export type QuarterPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterPlan
     */
    select?: QuarterPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterPlan
     */
    omit?: QuarterPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterPlanInclude<ExtArgs> | null
    /**
     * Filter which QuarterPlan to delete.
     */
    where: QuarterPlanWhereUniqueInput
  }

  /**
   * QuarterPlan deleteMany
   */
  export type QuarterPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuarterPlans to delete
     */
    where?: QuarterPlanWhereInput
    /**
     * Limit how many QuarterPlans to delete.
     */
    limit?: number
  }

  /**
   * QuarterPlan.monthPlans
   */
  export type QuarterPlan$monthPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthPlan
     */
    select?: MonthPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthPlan
     */
    omit?: MonthPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthPlanInclude<ExtArgs> | null
    where?: MonthPlanWhereInput
    orderBy?: MonthPlanOrderByWithRelationInput | MonthPlanOrderByWithRelationInput[]
    cursor?: MonthPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MonthPlanScalarFieldEnum | MonthPlanScalarFieldEnum[]
  }

  /**
   * QuarterPlan.quarterFocuses
   */
  export type QuarterPlan$quarterFocusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterFocus
     */
    select?: QuarterFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterFocus
     */
    omit?: QuarterFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterFocusInclude<ExtArgs> | null
    where?: QuarterFocusWhereInput
    orderBy?: QuarterFocusOrderByWithRelationInput | QuarterFocusOrderByWithRelationInput[]
    cursor?: QuarterFocusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuarterFocusScalarFieldEnum | QuarterFocusScalarFieldEnum[]
  }

  /**
   * QuarterPlan.objectives
   */
  export type QuarterPlan$objectivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterObjective
     */
    select?: QuarterObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterObjective
     */
    omit?: QuarterObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterObjectiveInclude<ExtArgs> | null
    where?: QuarterObjectiveWhereInput
    orderBy?: QuarterObjectiveOrderByWithRelationInput | QuarterObjectiveOrderByWithRelationInput[]
    cursor?: QuarterObjectiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuarterObjectiveScalarFieldEnum | QuarterObjectiveScalarFieldEnum[]
  }

  /**
   * QuarterPlan without action
   */
  export type QuarterPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterPlan
     */
    select?: QuarterPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterPlan
     */
    omit?: QuarterPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterPlanInclude<ExtArgs> | null
  }


  /**
   * Model QuarterObjective
   */

  export type AggregateQuarterObjective = {
    _count: QuarterObjectiveCountAggregateOutputType | null
    _min: QuarterObjectiveMinAggregateOutputType | null
    _max: QuarterObjectiveMaxAggregateOutputType | null
  }

  export type QuarterObjectiveMinAggregateOutputType = {
    id: string | null
    quarterPlanId: string | null
    title: string | null
    description: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuarterObjectiveMaxAggregateOutputType = {
    id: string | null
    quarterPlanId: string | null
    title: string | null
    description: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuarterObjectiveCountAggregateOutputType = {
    id: number
    quarterPlanId: number
    title: number
    description: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuarterObjectiveMinAggregateInputType = {
    id?: true
    quarterPlanId?: true
    title?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuarterObjectiveMaxAggregateInputType = {
    id?: true
    quarterPlanId?: true
    title?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuarterObjectiveCountAggregateInputType = {
    id?: true
    quarterPlanId?: true
    title?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuarterObjectiveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuarterObjective to aggregate.
     */
    where?: QuarterObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuarterObjectives to fetch.
     */
    orderBy?: QuarterObjectiveOrderByWithRelationInput | QuarterObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuarterObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuarterObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuarterObjectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuarterObjectives
    **/
    _count?: true | QuarterObjectiveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuarterObjectiveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuarterObjectiveMaxAggregateInputType
  }

  export type GetQuarterObjectiveAggregateType<T extends QuarterObjectiveAggregateArgs> = {
        [P in keyof T & keyof AggregateQuarterObjective]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuarterObjective[P]>
      : GetScalarType<T[P], AggregateQuarterObjective[P]>
  }




  export type QuarterObjectiveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuarterObjectiveWhereInput
    orderBy?: QuarterObjectiveOrderByWithAggregationInput | QuarterObjectiveOrderByWithAggregationInput[]
    by: QuarterObjectiveScalarFieldEnum[] | QuarterObjectiveScalarFieldEnum
    having?: QuarterObjectiveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuarterObjectiveCountAggregateInputType | true
    _min?: QuarterObjectiveMinAggregateInputType
    _max?: QuarterObjectiveMaxAggregateInputType
  }

  export type QuarterObjectiveGroupByOutputType = {
    id: string
    quarterPlanId: string
    title: string
    description: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: QuarterObjectiveCountAggregateOutputType | null
    _min: QuarterObjectiveMinAggregateOutputType | null
    _max: QuarterObjectiveMaxAggregateOutputType | null
  }

  type GetQuarterObjectiveGroupByPayload<T extends QuarterObjectiveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuarterObjectiveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuarterObjectiveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuarterObjectiveGroupByOutputType[P]>
            : GetScalarType<T[P], QuarterObjectiveGroupByOutputType[P]>
        }
      >
    >


  export type QuarterObjectiveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quarterPlanId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quarterPlan?: boolean | QuarterPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quarterObjective"]>

  export type QuarterObjectiveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quarterPlanId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quarterPlan?: boolean | QuarterPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quarterObjective"]>

  export type QuarterObjectiveSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quarterPlanId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quarterPlan?: boolean | QuarterPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quarterObjective"]>

  export type QuarterObjectiveSelectScalar = {
    id?: boolean
    quarterPlanId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuarterObjectiveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quarterPlanId" | "title" | "description" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["quarterObjective"]>
  export type QuarterObjectiveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quarterPlan?: boolean | QuarterPlanDefaultArgs<ExtArgs>
  }
  export type QuarterObjectiveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quarterPlan?: boolean | QuarterPlanDefaultArgs<ExtArgs>
  }
  export type QuarterObjectiveIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quarterPlan?: boolean | QuarterPlanDefaultArgs<ExtArgs>
  }

  export type $QuarterObjectivePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuarterObjective"
    objects: {
      quarterPlan: Prisma.$QuarterPlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quarterPlanId: string
      title: string
      description: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quarterObjective"]>
    composites: {}
  }

  type QuarterObjectiveGetPayload<S extends boolean | null | undefined | QuarterObjectiveDefaultArgs> = $Result.GetResult<Prisma.$QuarterObjectivePayload, S>

  type QuarterObjectiveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuarterObjectiveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuarterObjectiveCountAggregateInputType | true
    }

  export interface QuarterObjectiveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuarterObjective'], meta: { name: 'QuarterObjective' } }
    /**
     * Find zero or one QuarterObjective that matches the filter.
     * @param {QuarterObjectiveFindUniqueArgs} args - Arguments to find a QuarterObjective
     * @example
     * // Get one QuarterObjective
     * const quarterObjective = await prisma.quarterObjective.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuarterObjectiveFindUniqueArgs>(args: SelectSubset<T, QuarterObjectiveFindUniqueArgs<ExtArgs>>): Prisma__QuarterObjectiveClient<$Result.GetResult<Prisma.$QuarterObjectivePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuarterObjective that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuarterObjectiveFindUniqueOrThrowArgs} args - Arguments to find a QuarterObjective
     * @example
     * // Get one QuarterObjective
     * const quarterObjective = await prisma.quarterObjective.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuarterObjectiveFindUniqueOrThrowArgs>(args: SelectSubset<T, QuarterObjectiveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuarterObjectiveClient<$Result.GetResult<Prisma.$QuarterObjectivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuarterObjective that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuarterObjectiveFindFirstArgs} args - Arguments to find a QuarterObjective
     * @example
     * // Get one QuarterObjective
     * const quarterObjective = await prisma.quarterObjective.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuarterObjectiveFindFirstArgs>(args?: SelectSubset<T, QuarterObjectiveFindFirstArgs<ExtArgs>>): Prisma__QuarterObjectiveClient<$Result.GetResult<Prisma.$QuarterObjectivePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuarterObjective that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuarterObjectiveFindFirstOrThrowArgs} args - Arguments to find a QuarterObjective
     * @example
     * // Get one QuarterObjective
     * const quarterObjective = await prisma.quarterObjective.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuarterObjectiveFindFirstOrThrowArgs>(args?: SelectSubset<T, QuarterObjectiveFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuarterObjectiveClient<$Result.GetResult<Prisma.$QuarterObjectivePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuarterObjectives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuarterObjectiveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuarterObjectives
     * const quarterObjectives = await prisma.quarterObjective.findMany()
     * 
     * // Get first 10 QuarterObjectives
     * const quarterObjectives = await prisma.quarterObjective.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quarterObjectiveWithIdOnly = await prisma.quarterObjective.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuarterObjectiveFindManyArgs>(args?: SelectSubset<T, QuarterObjectiveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuarterObjectivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuarterObjective.
     * @param {QuarterObjectiveCreateArgs} args - Arguments to create a QuarterObjective.
     * @example
     * // Create one QuarterObjective
     * const QuarterObjective = await prisma.quarterObjective.create({
     *   data: {
     *     // ... data to create a QuarterObjective
     *   }
     * })
     * 
     */
    create<T extends QuarterObjectiveCreateArgs>(args: SelectSubset<T, QuarterObjectiveCreateArgs<ExtArgs>>): Prisma__QuarterObjectiveClient<$Result.GetResult<Prisma.$QuarterObjectivePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuarterObjectives.
     * @param {QuarterObjectiveCreateManyArgs} args - Arguments to create many QuarterObjectives.
     * @example
     * // Create many QuarterObjectives
     * const quarterObjective = await prisma.quarterObjective.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuarterObjectiveCreateManyArgs>(args?: SelectSubset<T, QuarterObjectiveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuarterObjectives and returns the data saved in the database.
     * @param {QuarterObjectiveCreateManyAndReturnArgs} args - Arguments to create many QuarterObjectives.
     * @example
     * // Create many QuarterObjectives
     * const quarterObjective = await prisma.quarterObjective.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuarterObjectives and only return the `id`
     * const quarterObjectiveWithIdOnly = await prisma.quarterObjective.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuarterObjectiveCreateManyAndReturnArgs>(args?: SelectSubset<T, QuarterObjectiveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuarterObjectivePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuarterObjective.
     * @param {QuarterObjectiveDeleteArgs} args - Arguments to delete one QuarterObjective.
     * @example
     * // Delete one QuarterObjective
     * const QuarterObjective = await prisma.quarterObjective.delete({
     *   where: {
     *     // ... filter to delete one QuarterObjective
     *   }
     * })
     * 
     */
    delete<T extends QuarterObjectiveDeleteArgs>(args: SelectSubset<T, QuarterObjectiveDeleteArgs<ExtArgs>>): Prisma__QuarterObjectiveClient<$Result.GetResult<Prisma.$QuarterObjectivePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuarterObjective.
     * @param {QuarterObjectiveUpdateArgs} args - Arguments to update one QuarterObjective.
     * @example
     * // Update one QuarterObjective
     * const quarterObjective = await prisma.quarterObjective.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuarterObjectiveUpdateArgs>(args: SelectSubset<T, QuarterObjectiveUpdateArgs<ExtArgs>>): Prisma__QuarterObjectiveClient<$Result.GetResult<Prisma.$QuarterObjectivePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuarterObjectives.
     * @param {QuarterObjectiveDeleteManyArgs} args - Arguments to filter QuarterObjectives to delete.
     * @example
     * // Delete a few QuarterObjectives
     * const { count } = await prisma.quarterObjective.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuarterObjectiveDeleteManyArgs>(args?: SelectSubset<T, QuarterObjectiveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuarterObjectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuarterObjectiveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuarterObjectives
     * const quarterObjective = await prisma.quarterObjective.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuarterObjectiveUpdateManyArgs>(args: SelectSubset<T, QuarterObjectiveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuarterObjectives and returns the data updated in the database.
     * @param {QuarterObjectiveUpdateManyAndReturnArgs} args - Arguments to update many QuarterObjectives.
     * @example
     * // Update many QuarterObjectives
     * const quarterObjective = await prisma.quarterObjective.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuarterObjectives and only return the `id`
     * const quarterObjectiveWithIdOnly = await prisma.quarterObjective.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuarterObjectiveUpdateManyAndReturnArgs>(args: SelectSubset<T, QuarterObjectiveUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuarterObjectivePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuarterObjective.
     * @param {QuarterObjectiveUpsertArgs} args - Arguments to update or create a QuarterObjective.
     * @example
     * // Update or create a QuarterObjective
     * const quarterObjective = await prisma.quarterObjective.upsert({
     *   create: {
     *     // ... data to create a QuarterObjective
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuarterObjective we want to update
     *   }
     * })
     */
    upsert<T extends QuarterObjectiveUpsertArgs>(args: SelectSubset<T, QuarterObjectiveUpsertArgs<ExtArgs>>): Prisma__QuarterObjectiveClient<$Result.GetResult<Prisma.$QuarterObjectivePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuarterObjectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuarterObjectiveCountArgs} args - Arguments to filter QuarterObjectives to count.
     * @example
     * // Count the number of QuarterObjectives
     * const count = await prisma.quarterObjective.count({
     *   where: {
     *     // ... the filter for the QuarterObjectives we want to count
     *   }
     * })
    **/
    count<T extends QuarterObjectiveCountArgs>(
      args?: Subset<T, QuarterObjectiveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuarterObjectiveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuarterObjective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuarterObjectiveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuarterObjectiveAggregateArgs>(args: Subset<T, QuarterObjectiveAggregateArgs>): Prisma.PrismaPromise<GetQuarterObjectiveAggregateType<T>>

    /**
     * Group by QuarterObjective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuarterObjectiveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuarterObjectiveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuarterObjectiveGroupByArgs['orderBy'] }
        : { orderBy?: QuarterObjectiveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuarterObjectiveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuarterObjectiveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuarterObjective model
   */
  readonly fields: QuarterObjectiveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuarterObjective.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuarterObjectiveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quarterPlan<T extends QuarterPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuarterPlanDefaultArgs<ExtArgs>>): Prisma__QuarterPlanClient<$Result.GetResult<Prisma.$QuarterPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuarterObjective model
   */
  interface QuarterObjectiveFieldRefs {
    readonly id: FieldRef<"QuarterObjective", 'String'>
    readonly quarterPlanId: FieldRef<"QuarterObjective", 'String'>
    readonly title: FieldRef<"QuarterObjective", 'String'>
    readonly description: FieldRef<"QuarterObjective", 'String'>
    readonly status: FieldRef<"QuarterObjective", 'String'>
    readonly createdAt: FieldRef<"QuarterObjective", 'DateTime'>
    readonly updatedAt: FieldRef<"QuarterObjective", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuarterObjective findUnique
   */
  export type QuarterObjectiveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterObjective
     */
    select?: QuarterObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterObjective
     */
    omit?: QuarterObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which QuarterObjective to fetch.
     */
    where: QuarterObjectiveWhereUniqueInput
  }

  /**
   * QuarterObjective findUniqueOrThrow
   */
  export type QuarterObjectiveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterObjective
     */
    select?: QuarterObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterObjective
     */
    omit?: QuarterObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which QuarterObjective to fetch.
     */
    where: QuarterObjectiveWhereUniqueInput
  }

  /**
   * QuarterObjective findFirst
   */
  export type QuarterObjectiveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterObjective
     */
    select?: QuarterObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterObjective
     */
    omit?: QuarterObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which QuarterObjective to fetch.
     */
    where?: QuarterObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuarterObjectives to fetch.
     */
    orderBy?: QuarterObjectiveOrderByWithRelationInput | QuarterObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuarterObjectives.
     */
    cursor?: QuarterObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuarterObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuarterObjectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuarterObjectives.
     */
    distinct?: QuarterObjectiveScalarFieldEnum | QuarterObjectiveScalarFieldEnum[]
  }

  /**
   * QuarterObjective findFirstOrThrow
   */
  export type QuarterObjectiveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterObjective
     */
    select?: QuarterObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterObjective
     */
    omit?: QuarterObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which QuarterObjective to fetch.
     */
    where?: QuarterObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuarterObjectives to fetch.
     */
    orderBy?: QuarterObjectiveOrderByWithRelationInput | QuarterObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuarterObjectives.
     */
    cursor?: QuarterObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuarterObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuarterObjectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuarterObjectives.
     */
    distinct?: QuarterObjectiveScalarFieldEnum | QuarterObjectiveScalarFieldEnum[]
  }

  /**
   * QuarterObjective findMany
   */
  export type QuarterObjectiveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterObjective
     */
    select?: QuarterObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterObjective
     */
    omit?: QuarterObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which QuarterObjectives to fetch.
     */
    where?: QuarterObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuarterObjectives to fetch.
     */
    orderBy?: QuarterObjectiveOrderByWithRelationInput | QuarterObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuarterObjectives.
     */
    cursor?: QuarterObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuarterObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuarterObjectives.
     */
    skip?: number
    distinct?: QuarterObjectiveScalarFieldEnum | QuarterObjectiveScalarFieldEnum[]
  }

  /**
   * QuarterObjective create
   */
  export type QuarterObjectiveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterObjective
     */
    select?: QuarterObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterObjective
     */
    omit?: QuarterObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterObjectiveInclude<ExtArgs> | null
    /**
     * The data needed to create a QuarterObjective.
     */
    data: XOR<QuarterObjectiveCreateInput, QuarterObjectiveUncheckedCreateInput>
  }

  /**
   * QuarterObjective createMany
   */
  export type QuarterObjectiveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuarterObjectives.
     */
    data: QuarterObjectiveCreateManyInput | QuarterObjectiveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuarterObjective createManyAndReturn
   */
  export type QuarterObjectiveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterObjective
     */
    select?: QuarterObjectiveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterObjective
     */
    omit?: QuarterObjectiveOmit<ExtArgs> | null
    /**
     * The data used to create many QuarterObjectives.
     */
    data: QuarterObjectiveCreateManyInput | QuarterObjectiveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterObjectiveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuarterObjective update
   */
  export type QuarterObjectiveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterObjective
     */
    select?: QuarterObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterObjective
     */
    omit?: QuarterObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterObjectiveInclude<ExtArgs> | null
    /**
     * The data needed to update a QuarterObjective.
     */
    data: XOR<QuarterObjectiveUpdateInput, QuarterObjectiveUncheckedUpdateInput>
    /**
     * Choose, which QuarterObjective to update.
     */
    where: QuarterObjectiveWhereUniqueInput
  }

  /**
   * QuarterObjective updateMany
   */
  export type QuarterObjectiveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuarterObjectives.
     */
    data: XOR<QuarterObjectiveUpdateManyMutationInput, QuarterObjectiveUncheckedUpdateManyInput>
    /**
     * Filter which QuarterObjectives to update
     */
    where?: QuarterObjectiveWhereInput
    /**
     * Limit how many QuarterObjectives to update.
     */
    limit?: number
  }

  /**
   * QuarterObjective updateManyAndReturn
   */
  export type QuarterObjectiveUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterObjective
     */
    select?: QuarterObjectiveSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterObjective
     */
    omit?: QuarterObjectiveOmit<ExtArgs> | null
    /**
     * The data used to update QuarterObjectives.
     */
    data: XOR<QuarterObjectiveUpdateManyMutationInput, QuarterObjectiveUncheckedUpdateManyInput>
    /**
     * Filter which QuarterObjectives to update
     */
    where?: QuarterObjectiveWhereInput
    /**
     * Limit how many QuarterObjectives to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterObjectiveIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuarterObjective upsert
   */
  export type QuarterObjectiveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterObjective
     */
    select?: QuarterObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterObjective
     */
    omit?: QuarterObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterObjectiveInclude<ExtArgs> | null
    /**
     * The filter to search for the QuarterObjective to update in case it exists.
     */
    where: QuarterObjectiveWhereUniqueInput
    /**
     * In case the QuarterObjective found by the `where` argument doesn't exist, create a new QuarterObjective with this data.
     */
    create: XOR<QuarterObjectiveCreateInput, QuarterObjectiveUncheckedCreateInput>
    /**
     * In case the QuarterObjective was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuarterObjectiveUpdateInput, QuarterObjectiveUncheckedUpdateInput>
  }

  /**
   * QuarterObjective delete
   */
  export type QuarterObjectiveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterObjective
     */
    select?: QuarterObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterObjective
     */
    omit?: QuarterObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterObjectiveInclude<ExtArgs> | null
    /**
     * Filter which QuarterObjective to delete.
     */
    where: QuarterObjectiveWhereUniqueInput
  }

  /**
   * QuarterObjective deleteMany
   */
  export type QuarterObjectiveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuarterObjectives to delete
     */
    where?: QuarterObjectiveWhereInput
    /**
     * Limit how many QuarterObjectives to delete.
     */
    limit?: number
  }

  /**
   * QuarterObjective without action
   */
  export type QuarterObjectiveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterObjective
     */
    select?: QuarterObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterObjective
     */
    omit?: QuarterObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterObjectiveInclude<ExtArgs> | null
  }


  /**
   * Model QuarterFocus
   */

  export type AggregateQuarterFocus = {
    _count: QuarterFocusCountAggregateOutputType | null
    _avg: QuarterFocusAvgAggregateOutputType | null
    _sum: QuarterFocusSumAggregateOutputType | null
    _min: QuarterFocusMinAggregateOutputType | null
    _max: QuarterFocusMaxAggregateOutputType | null
  }

  export type QuarterFocusAvgAggregateOutputType = {
    priority: number | null
    progress: number | null
  }

  export type QuarterFocusSumAggregateOutputType = {
    priority: number | null
    progress: number | null
  }

  export type QuarterFocusMinAggregateOutputType = {
    id: string | null
    quarterPlanId: string | null
    goalId: string | null
    priority: number | null
    progress: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuarterFocusMaxAggregateOutputType = {
    id: string | null
    quarterPlanId: string | null
    goalId: string | null
    priority: number | null
    progress: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuarterFocusCountAggregateOutputType = {
    id: number
    quarterPlanId: number
    goalId: number
    priority: number
    progress: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuarterFocusAvgAggregateInputType = {
    priority?: true
    progress?: true
  }

  export type QuarterFocusSumAggregateInputType = {
    priority?: true
    progress?: true
  }

  export type QuarterFocusMinAggregateInputType = {
    id?: true
    quarterPlanId?: true
    goalId?: true
    priority?: true
    progress?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuarterFocusMaxAggregateInputType = {
    id?: true
    quarterPlanId?: true
    goalId?: true
    priority?: true
    progress?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuarterFocusCountAggregateInputType = {
    id?: true
    quarterPlanId?: true
    goalId?: true
    priority?: true
    progress?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuarterFocusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuarterFocus to aggregate.
     */
    where?: QuarterFocusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuarterFoci to fetch.
     */
    orderBy?: QuarterFocusOrderByWithRelationInput | QuarterFocusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuarterFocusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuarterFoci from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuarterFoci.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuarterFoci
    **/
    _count?: true | QuarterFocusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuarterFocusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuarterFocusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuarterFocusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuarterFocusMaxAggregateInputType
  }

  export type GetQuarterFocusAggregateType<T extends QuarterFocusAggregateArgs> = {
        [P in keyof T & keyof AggregateQuarterFocus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuarterFocus[P]>
      : GetScalarType<T[P], AggregateQuarterFocus[P]>
  }




  export type QuarterFocusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuarterFocusWhereInput
    orderBy?: QuarterFocusOrderByWithAggregationInput | QuarterFocusOrderByWithAggregationInput[]
    by: QuarterFocusScalarFieldEnum[] | QuarterFocusScalarFieldEnum
    having?: QuarterFocusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuarterFocusCountAggregateInputType | true
    _avg?: QuarterFocusAvgAggregateInputType
    _sum?: QuarterFocusSumAggregateInputType
    _min?: QuarterFocusMinAggregateInputType
    _max?: QuarterFocusMaxAggregateInputType
  }

  export type QuarterFocusGroupByOutputType = {
    id: string
    quarterPlanId: string
    goalId: string
    priority: number
    progress: number
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: QuarterFocusCountAggregateOutputType | null
    _avg: QuarterFocusAvgAggregateOutputType | null
    _sum: QuarterFocusSumAggregateOutputType | null
    _min: QuarterFocusMinAggregateOutputType | null
    _max: QuarterFocusMaxAggregateOutputType | null
  }

  type GetQuarterFocusGroupByPayload<T extends QuarterFocusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuarterFocusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuarterFocusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuarterFocusGroupByOutputType[P]>
            : GetScalarType<T[P], QuarterFocusGroupByOutputType[P]>
        }
      >
    >


  export type QuarterFocusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quarterPlanId?: boolean
    goalId?: boolean
    priority?: boolean
    progress?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    monthFocuses?: boolean | QuarterFocus$monthFocusesArgs<ExtArgs>
    goal?: boolean | GoalDefaultArgs<ExtArgs>
    quarterPlan?: boolean | QuarterPlanDefaultArgs<ExtArgs>
    _count?: boolean | QuarterFocusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quarterFocus"]>

  export type QuarterFocusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quarterPlanId?: boolean
    goalId?: boolean
    priority?: boolean
    progress?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goal?: boolean | GoalDefaultArgs<ExtArgs>
    quarterPlan?: boolean | QuarterPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quarterFocus"]>

  export type QuarterFocusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quarterPlanId?: boolean
    goalId?: boolean
    priority?: boolean
    progress?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goal?: boolean | GoalDefaultArgs<ExtArgs>
    quarterPlan?: boolean | QuarterPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quarterFocus"]>

  export type QuarterFocusSelectScalar = {
    id?: boolean
    quarterPlanId?: boolean
    goalId?: boolean
    priority?: boolean
    progress?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuarterFocusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quarterPlanId" | "goalId" | "priority" | "progress" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["quarterFocus"]>
  export type QuarterFocusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monthFocuses?: boolean | QuarterFocus$monthFocusesArgs<ExtArgs>
    goal?: boolean | GoalDefaultArgs<ExtArgs>
    quarterPlan?: boolean | QuarterPlanDefaultArgs<ExtArgs>
    _count?: boolean | QuarterFocusCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuarterFocusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goal?: boolean | GoalDefaultArgs<ExtArgs>
    quarterPlan?: boolean | QuarterPlanDefaultArgs<ExtArgs>
  }
  export type QuarterFocusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goal?: boolean | GoalDefaultArgs<ExtArgs>
    quarterPlan?: boolean | QuarterPlanDefaultArgs<ExtArgs>
  }

  export type $QuarterFocusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuarterFocus"
    objects: {
      monthFocuses: Prisma.$MonthFocusPayload<ExtArgs>[]
      goal: Prisma.$GoalPayload<ExtArgs>
      quarterPlan: Prisma.$QuarterPlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quarterPlanId: string
      goalId: string
      priority: number
      progress: number
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quarterFocus"]>
    composites: {}
  }

  type QuarterFocusGetPayload<S extends boolean | null | undefined | QuarterFocusDefaultArgs> = $Result.GetResult<Prisma.$QuarterFocusPayload, S>

  type QuarterFocusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuarterFocusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuarterFocusCountAggregateInputType | true
    }

  export interface QuarterFocusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuarterFocus'], meta: { name: 'QuarterFocus' } }
    /**
     * Find zero or one QuarterFocus that matches the filter.
     * @param {QuarterFocusFindUniqueArgs} args - Arguments to find a QuarterFocus
     * @example
     * // Get one QuarterFocus
     * const quarterFocus = await prisma.quarterFocus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuarterFocusFindUniqueArgs>(args: SelectSubset<T, QuarterFocusFindUniqueArgs<ExtArgs>>): Prisma__QuarterFocusClient<$Result.GetResult<Prisma.$QuarterFocusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuarterFocus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuarterFocusFindUniqueOrThrowArgs} args - Arguments to find a QuarterFocus
     * @example
     * // Get one QuarterFocus
     * const quarterFocus = await prisma.quarterFocus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuarterFocusFindUniqueOrThrowArgs>(args: SelectSubset<T, QuarterFocusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuarterFocusClient<$Result.GetResult<Prisma.$QuarterFocusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuarterFocus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuarterFocusFindFirstArgs} args - Arguments to find a QuarterFocus
     * @example
     * // Get one QuarterFocus
     * const quarterFocus = await prisma.quarterFocus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuarterFocusFindFirstArgs>(args?: SelectSubset<T, QuarterFocusFindFirstArgs<ExtArgs>>): Prisma__QuarterFocusClient<$Result.GetResult<Prisma.$QuarterFocusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuarterFocus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuarterFocusFindFirstOrThrowArgs} args - Arguments to find a QuarterFocus
     * @example
     * // Get one QuarterFocus
     * const quarterFocus = await prisma.quarterFocus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuarterFocusFindFirstOrThrowArgs>(args?: SelectSubset<T, QuarterFocusFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuarterFocusClient<$Result.GetResult<Prisma.$QuarterFocusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuarterFoci that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuarterFocusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuarterFoci
     * const quarterFoci = await prisma.quarterFocus.findMany()
     * 
     * // Get first 10 QuarterFoci
     * const quarterFoci = await prisma.quarterFocus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quarterFocusWithIdOnly = await prisma.quarterFocus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuarterFocusFindManyArgs>(args?: SelectSubset<T, QuarterFocusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuarterFocusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuarterFocus.
     * @param {QuarterFocusCreateArgs} args - Arguments to create a QuarterFocus.
     * @example
     * // Create one QuarterFocus
     * const QuarterFocus = await prisma.quarterFocus.create({
     *   data: {
     *     // ... data to create a QuarterFocus
     *   }
     * })
     * 
     */
    create<T extends QuarterFocusCreateArgs>(args: SelectSubset<T, QuarterFocusCreateArgs<ExtArgs>>): Prisma__QuarterFocusClient<$Result.GetResult<Prisma.$QuarterFocusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuarterFoci.
     * @param {QuarterFocusCreateManyArgs} args - Arguments to create many QuarterFoci.
     * @example
     * // Create many QuarterFoci
     * const quarterFocus = await prisma.quarterFocus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuarterFocusCreateManyArgs>(args?: SelectSubset<T, QuarterFocusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuarterFoci and returns the data saved in the database.
     * @param {QuarterFocusCreateManyAndReturnArgs} args - Arguments to create many QuarterFoci.
     * @example
     * // Create many QuarterFoci
     * const quarterFocus = await prisma.quarterFocus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuarterFoci and only return the `id`
     * const quarterFocusWithIdOnly = await prisma.quarterFocus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuarterFocusCreateManyAndReturnArgs>(args?: SelectSubset<T, QuarterFocusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuarterFocusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuarterFocus.
     * @param {QuarterFocusDeleteArgs} args - Arguments to delete one QuarterFocus.
     * @example
     * // Delete one QuarterFocus
     * const QuarterFocus = await prisma.quarterFocus.delete({
     *   where: {
     *     // ... filter to delete one QuarterFocus
     *   }
     * })
     * 
     */
    delete<T extends QuarterFocusDeleteArgs>(args: SelectSubset<T, QuarterFocusDeleteArgs<ExtArgs>>): Prisma__QuarterFocusClient<$Result.GetResult<Prisma.$QuarterFocusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuarterFocus.
     * @param {QuarterFocusUpdateArgs} args - Arguments to update one QuarterFocus.
     * @example
     * // Update one QuarterFocus
     * const quarterFocus = await prisma.quarterFocus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuarterFocusUpdateArgs>(args: SelectSubset<T, QuarterFocusUpdateArgs<ExtArgs>>): Prisma__QuarterFocusClient<$Result.GetResult<Prisma.$QuarterFocusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuarterFoci.
     * @param {QuarterFocusDeleteManyArgs} args - Arguments to filter QuarterFoci to delete.
     * @example
     * // Delete a few QuarterFoci
     * const { count } = await prisma.quarterFocus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuarterFocusDeleteManyArgs>(args?: SelectSubset<T, QuarterFocusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuarterFoci.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuarterFocusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuarterFoci
     * const quarterFocus = await prisma.quarterFocus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuarterFocusUpdateManyArgs>(args: SelectSubset<T, QuarterFocusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuarterFoci and returns the data updated in the database.
     * @param {QuarterFocusUpdateManyAndReturnArgs} args - Arguments to update many QuarterFoci.
     * @example
     * // Update many QuarterFoci
     * const quarterFocus = await prisma.quarterFocus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuarterFoci and only return the `id`
     * const quarterFocusWithIdOnly = await prisma.quarterFocus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuarterFocusUpdateManyAndReturnArgs>(args: SelectSubset<T, QuarterFocusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuarterFocusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuarterFocus.
     * @param {QuarterFocusUpsertArgs} args - Arguments to update or create a QuarterFocus.
     * @example
     * // Update or create a QuarterFocus
     * const quarterFocus = await prisma.quarterFocus.upsert({
     *   create: {
     *     // ... data to create a QuarterFocus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuarterFocus we want to update
     *   }
     * })
     */
    upsert<T extends QuarterFocusUpsertArgs>(args: SelectSubset<T, QuarterFocusUpsertArgs<ExtArgs>>): Prisma__QuarterFocusClient<$Result.GetResult<Prisma.$QuarterFocusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuarterFoci.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuarterFocusCountArgs} args - Arguments to filter QuarterFoci to count.
     * @example
     * // Count the number of QuarterFoci
     * const count = await prisma.quarterFocus.count({
     *   where: {
     *     // ... the filter for the QuarterFoci we want to count
     *   }
     * })
    **/
    count<T extends QuarterFocusCountArgs>(
      args?: Subset<T, QuarterFocusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuarterFocusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuarterFocus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuarterFocusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuarterFocusAggregateArgs>(args: Subset<T, QuarterFocusAggregateArgs>): Prisma.PrismaPromise<GetQuarterFocusAggregateType<T>>

    /**
     * Group by QuarterFocus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuarterFocusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuarterFocusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuarterFocusGroupByArgs['orderBy'] }
        : { orderBy?: QuarterFocusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuarterFocusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuarterFocusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuarterFocus model
   */
  readonly fields: QuarterFocusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuarterFocus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuarterFocusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    monthFocuses<T extends QuarterFocus$monthFocusesArgs<ExtArgs> = {}>(args?: Subset<T, QuarterFocus$monthFocusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonthFocusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    goal<T extends GoalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GoalDefaultArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    quarterPlan<T extends QuarterPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuarterPlanDefaultArgs<ExtArgs>>): Prisma__QuarterPlanClient<$Result.GetResult<Prisma.$QuarterPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuarterFocus model
   */
  interface QuarterFocusFieldRefs {
    readonly id: FieldRef<"QuarterFocus", 'String'>
    readonly quarterPlanId: FieldRef<"QuarterFocus", 'String'>
    readonly goalId: FieldRef<"QuarterFocus", 'String'>
    readonly priority: FieldRef<"QuarterFocus", 'Int'>
    readonly progress: FieldRef<"QuarterFocus", 'Float'>
    readonly notes: FieldRef<"QuarterFocus", 'String'>
    readonly createdAt: FieldRef<"QuarterFocus", 'DateTime'>
    readonly updatedAt: FieldRef<"QuarterFocus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuarterFocus findUnique
   */
  export type QuarterFocusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterFocus
     */
    select?: QuarterFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterFocus
     */
    omit?: QuarterFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterFocusInclude<ExtArgs> | null
    /**
     * Filter, which QuarterFocus to fetch.
     */
    where: QuarterFocusWhereUniqueInput
  }

  /**
   * QuarterFocus findUniqueOrThrow
   */
  export type QuarterFocusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterFocus
     */
    select?: QuarterFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterFocus
     */
    omit?: QuarterFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterFocusInclude<ExtArgs> | null
    /**
     * Filter, which QuarterFocus to fetch.
     */
    where: QuarterFocusWhereUniqueInput
  }

  /**
   * QuarterFocus findFirst
   */
  export type QuarterFocusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterFocus
     */
    select?: QuarterFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterFocus
     */
    omit?: QuarterFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterFocusInclude<ExtArgs> | null
    /**
     * Filter, which QuarterFocus to fetch.
     */
    where?: QuarterFocusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuarterFoci to fetch.
     */
    orderBy?: QuarterFocusOrderByWithRelationInput | QuarterFocusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuarterFoci.
     */
    cursor?: QuarterFocusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuarterFoci from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuarterFoci.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuarterFoci.
     */
    distinct?: QuarterFocusScalarFieldEnum | QuarterFocusScalarFieldEnum[]
  }

  /**
   * QuarterFocus findFirstOrThrow
   */
  export type QuarterFocusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterFocus
     */
    select?: QuarterFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterFocus
     */
    omit?: QuarterFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterFocusInclude<ExtArgs> | null
    /**
     * Filter, which QuarterFocus to fetch.
     */
    where?: QuarterFocusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuarterFoci to fetch.
     */
    orderBy?: QuarterFocusOrderByWithRelationInput | QuarterFocusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuarterFoci.
     */
    cursor?: QuarterFocusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuarterFoci from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuarterFoci.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuarterFoci.
     */
    distinct?: QuarterFocusScalarFieldEnum | QuarterFocusScalarFieldEnum[]
  }

  /**
   * QuarterFocus findMany
   */
  export type QuarterFocusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterFocus
     */
    select?: QuarterFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterFocus
     */
    omit?: QuarterFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterFocusInclude<ExtArgs> | null
    /**
     * Filter, which QuarterFoci to fetch.
     */
    where?: QuarterFocusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuarterFoci to fetch.
     */
    orderBy?: QuarterFocusOrderByWithRelationInput | QuarterFocusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuarterFoci.
     */
    cursor?: QuarterFocusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuarterFoci from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuarterFoci.
     */
    skip?: number
    distinct?: QuarterFocusScalarFieldEnum | QuarterFocusScalarFieldEnum[]
  }

  /**
   * QuarterFocus create
   */
  export type QuarterFocusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterFocus
     */
    select?: QuarterFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterFocus
     */
    omit?: QuarterFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterFocusInclude<ExtArgs> | null
    /**
     * The data needed to create a QuarterFocus.
     */
    data: XOR<QuarterFocusCreateInput, QuarterFocusUncheckedCreateInput>
  }

  /**
   * QuarterFocus createMany
   */
  export type QuarterFocusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuarterFoci.
     */
    data: QuarterFocusCreateManyInput | QuarterFocusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuarterFocus createManyAndReturn
   */
  export type QuarterFocusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterFocus
     */
    select?: QuarterFocusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterFocus
     */
    omit?: QuarterFocusOmit<ExtArgs> | null
    /**
     * The data used to create many QuarterFoci.
     */
    data: QuarterFocusCreateManyInput | QuarterFocusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterFocusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuarterFocus update
   */
  export type QuarterFocusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterFocus
     */
    select?: QuarterFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterFocus
     */
    omit?: QuarterFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterFocusInclude<ExtArgs> | null
    /**
     * The data needed to update a QuarterFocus.
     */
    data: XOR<QuarterFocusUpdateInput, QuarterFocusUncheckedUpdateInput>
    /**
     * Choose, which QuarterFocus to update.
     */
    where: QuarterFocusWhereUniqueInput
  }

  /**
   * QuarterFocus updateMany
   */
  export type QuarterFocusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuarterFoci.
     */
    data: XOR<QuarterFocusUpdateManyMutationInput, QuarterFocusUncheckedUpdateManyInput>
    /**
     * Filter which QuarterFoci to update
     */
    where?: QuarterFocusWhereInput
    /**
     * Limit how many QuarterFoci to update.
     */
    limit?: number
  }

  /**
   * QuarterFocus updateManyAndReturn
   */
  export type QuarterFocusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterFocus
     */
    select?: QuarterFocusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterFocus
     */
    omit?: QuarterFocusOmit<ExtArgs> | null
    /**
     * The data used to update QuarterFoci.
     */
    data: XOR<QuarterFocusUpdateManyMutationInput, QuarterFocusUncheckedUpdateManyInput>
    /**
     * Filter which QuarterFoci to update
     */
    where?: QuarterFocusWhereInput
    /**
     * Limit how many QuarterFoci to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterFocusIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuarterFocus upsert
   */
  export type QuarterFocusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterFocus
     */
    select?: QuarterFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterFocus
     */
    omit?: QuarterFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterFocusInclude<ExtArgs> | null
    /**
     * The filter to search for the QuarterFocus to update in case it exists.
     */
    where: QuarterFocusWhereUniqueInput
    /**
     * In case the QuarterFocus found by the `where` argument doesn't exist, create a new QuarterFocus with this data.
     */
    create: XOR<QuarterFocusCreateInput, QuarterFocusUncheckedCreateInput>
    /**
     * In case the QuarterFocus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuarterFocusUpdateInput, QuarterFocusUncheckedUpdateInput>
  }

  /**
   * QuarterFocus delete
   */
  export type QuarterFocusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterFocus
     */
    select?: QuarterFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterFocus
     */
    omit?: QuarterFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterFocusInclude<ExtArgs> | null
    /**
     * Filter which QuarterFocus to delete.
     */
    where: QuarterFocusWhereUniqueInput
  }

  /**
   * QuarterFocus deleteMany
   */
  export type QuarterFocusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuarterFoci to delete
     */
    where?: QuarterFocusWhereInput
    /**
     * Limit how many QuarterFoci to delete.
     */
    limit?: number
  }

  /**
   * QuarterFocus.monthFocuses
   */
  export type QuarterFocus$monthFocusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthFocus
     */
    select?: MonthFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthFocus
     */
    omit?: MonthFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthFocusInclude<ExtArgs> | null
    where?: MonthFocusWhereInput
    orderBy?: MonthFocusOrderByWithRelationInput | MonthFocusOrderByWithRelationInput[]
    cursor?: MonthFocusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MonthFocusScalarFieldEnum | MonthFocusScalarFieldEnum[]
  }

  /**
   * QuarterFocus without action
   */
  export type QuarterFocusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuarterFocus
     */
    select?: QuarterFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuarterFocus
     */
    omit?: QuarterFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuarterFocusInclude<ExtArgs> | null
  }


  /**
   * Model MonthPlan
   */

  export type AggregateMonthPlan = {
    _count: MonthPlanCountAggregateOutputType | null
    _avg: MonthPlanAvgAggregateOutputType | null
    _sum: MonthPlanSumAggregateOutputType | null
    _min: MonthPlanMinAggregateOutputType | null
    _max: MonthPlanMaxAggregateOutputType | null
  }

  export type MonthPlanAvgAggregateOutputType = {
    month: number | null
    year: number | null
    completionRate: number | null
    energyRating: number | null
    rating: number | null
  }

  export type MonthPlanSumAggregateOutputType = {
    month: number | null
    year: number | null
    completionRate: number | null
    energyRating: number | null
    rating: number | null
  }

  export type MonthPlanMinAggregateOutputType = {
    id: string | null
    quarterPlanId: string | null
    month: number | null
    year: number | null
    completionRate: number | null
    energyRating: number | null
    rating: number | null
    reviewNotes: string | null
    theme: string | null
  }

  export type MonthPlanMaxAggregateOutputType = {
    id: string | null
    quarterPlanId: string | null
    month: number | null
    year: number | null
    completionRate: number | null
    energyRating: number | null
    rating: number | null
    reviewNotes: string | null
    theme: string | null
  }

  export type MonthPlanCountAggregateOutputType = {
    id: number
    quarterPlanId: number
    month: number
    year: number
    objectives: number
    completionRate: number
    energyRating: number
    rating: number
    reviewNotes: number
    theme: number
    _all: number
  }


  export type MonthPlanAvgAggregateInputType = {
    month?: true
    year?: true
    completionRate?: true
    energyRating?: true
    rating?: true
  }

  export type MonthPlanSumAggregateInputType = {
    month?: true
    year?: true
    completionRate?: true
    energyRating?: true
    rating?: true
  }

  export type MonthPlanMinAggregateInputType = {
    id?: true
    quarterPlanId?: true
    month?: true
    year?: true
    completionRate?: true
    energyRating?: true
    rating?: true
    reviewNotes?: true
    theme?: true
  }

  export type MonthPlanMaxAggregateInputType = {
    id?: true
    quarterPlanId?: true
    month?: true
    year?: true
    completionRate?: true
    energyRating?: true
    rating?: true
    reviewNotes?: true
    theme?: true
  }

  export type MonthPlanCountAggregateInputType = {
    id?: true
    quarterPlanId?: true
    month?: true
    year?: true
    objectives?: true
    completionRate?: true
    energyRating?: true
    rating?: true
    reviewNotes?: true
    theme?: true
    _all?: true
  }

  export type MonthPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MonthPlan to aggregate.
     */
    where?: MonthPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonthPlans to fetch.
     */
    orderBy?: MonthPlanOrderByWithRelationInput | MonthPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MonthPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonthPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonthPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MonthPlans
    **/
    _count?: true | MonthPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MonthPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MonthPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MonthPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MonthPlanMaxAggregateInputType
  }

  export type GetMonthPlanAggregateType<T extends MonthPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateMonthPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonthPlan[P]>
      : GetScalarType<T[P], AggregateMonthPlan[P]>
  }




  export type MonthPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonthPlanWhereInput
    orderBy?: MonthPlanOrderByWithAggregationInput | MonthPlanOrderByWithAggregationInput[]
    by: MonthPlanScalarFieldEnum[] | MonthPlanScalarFieldEnum
    having?: MonthPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MonthPlanCountAggregateInputType | true
    _avg?: MonthPlanAvgAggregateInputType
    _sum?: MonthPlanSumAggregateInputType
    _min?: MonthPlanMinAggregateInputType
    _max?: MonthPlanMaxAggregateInputType
  }

  export type MonthPlanGroupByOutputType = {
    id: string
    quarterPlanId: string
    month: number
    year: number
    objectives: string[]
    completionRate: number
    energyRating: number | null
    rating: number | null
    reviewNotes: string | null
    theme: string | null
    _count: MonthPlanCountAggregateOutputType | null
    _avg: MonthPlanAvgAggregateOutputType | null
    _sum: MonthPlanSumAggregateOutputType | null
    _min: MonthPlanMinAggregateOutputType | null
    _max: MonthPlanMaxAggregateOutputType | null
  }

  type GetMonthPlanGroupByPayload<T extends MonthPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MonthPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MonthPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MonthPlanGroupByOutputType[P]>
            : GetScalarType<T[P], MonthPlanGroupByOutputType[P]>
        }
      >
    >


  export type MonthPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quarterPlanId?: boolean
    month?: boolean
    year?: boolean
    objectives?: boolean
    completionRate?: boolean
    energyRating?: boolean
    rating?: boolean
    reviewNotes?: boolean
    theme?: boolean
    monthFocuses?: boolean | MonthPlan$monthFocusesArgs<ExtArgs>
    quarterPlan?: boolean | QuarterPlanDefaultArgs<ExtArgs>
    weekPlans?: boolean | MonthPlan$weekPlansArgs<ExtArgs>
    _count?: boolean | MonthPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monthPlan"]>

  export type MonthPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quarterPlanId?: boolean
    month?: boolean
    year?: boolean
    objectives?: boolean
    completionRate?: boolean
    energyRating?: boolean
    rating?: boolean
    reviewNotes?: boolean
    theme?: boolean
    quarterPlan?: boolean | QuarterPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monthPlan"]>

  export type MonthPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quarterPlanId?: boolean
    month?: boolean
    year?: boolean
    objectives?: boolean
    completionRate?: boolean
    energyRating?: boolean
    rating?: boolean
    reviewNotes?: boolean
    theme?: boolean
    quarterPlan?: boolean | QuarterPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monthPlan"]>

  export type MonthPlanSelectScalar = {
    id?: boolean
    quarterPlanId?: boolean
    month?: boolean
    year?: boolean
    objectives?: boolean
    completionRate?: boolean
    energyRating?: boolean
    rating?: boolean
    reviewNotes?: boolean
    theme?: boolean
  }

  export type MonthPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quarterPlanId" | "month" | "year" | "objectives" | "completionRate" | "energyRating" | "rating" | "reviewNotes" | "theme", ExtArgs["result"]["monthPlan"]>
  export type MonthPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monthFocuses?: boolean | MonthPlan$monthFocusesArgs<ExtArgs>
    quarterPlan?: boolean | QuarterPlanDefaultArgs<ExtArgs>
    weekPlans?: boolean | MonthPlan$weekPlansArgs<ExtArgs>
    _count?: boolean | MonthPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MonthPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quarterPlan?: boolean | QuarterPlanDefaultArgs<ExtArgs>
  }
  export type MonthPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quarterPlan?: boolean | QuarterPlanDefaultArgs<ExtArgs>
  }

  export type $MonthPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MonthPlan"
    objects: {
      monthFocuses: Prisma.$MonthFocusPayload<ExtArgs>[]
      quarterPlan: Prisma.$QuarterPlanPayload<ExtArgs>
      weekPlans: Prisma.$WeekPlanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quarterPlanId: string
      month: number
      year: number
      objectives: string[]
      completionRate: number
      energyRating: number | null
      rating: number | null
      reviewNotes: string | null
      theme: string | null
    }, ExtArgs["result"]["monthPlan"]>
    composites: {}
  }

  type MonthPlanGetPayload<S extends boolean | null | undefined | MonthPlanDefaultArgs> = $Result.GetResult<Prisma.$MonthPlanPayload, S>

  type MonthPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MonthPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MonthPlanCountAggregateInputType | true
    }

  export interface MonthPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MonthPlan'], meta: { name: 'MonthPlan' } }
    /**
     * Find zero or one MonthPlan that matches the filter.
     * @param {MonthPlanFindUniqueArgs} args - Arguments to find a MonthPlan
     * @example
     * // Get one MonthPlan
     * const monthPlan = await prisma.monthPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MonthPlanFindUniqueArgs>(args: SelectSubset<T, MonthPlanFindUniqueArgs<ExtArgs>>): Prisma__MonthPlanClient<$Result.GetResult<Prisma.$MonthPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MonthPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MonthPlanFindUniqueOrThrowArgs} args - Arguments to find a MonthPlan
     * @example
     * // Get one MonthPlan
     * const monthPlan = await prisma.monthPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MonthPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, MonthPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MonthPlanClient<$Result.GetResult<Prisma.$MonthPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MonthPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthPlanFindFirstArgs} args - Arguments to find a MonthPlan
     * @example
     * // Get one MonthPlan
     * const monthPlan = await prisma.monthPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MonthPlanFindFirstArgs>(args?: SelectSubset<T, MonthPlanFindFirstArgs<ExtArgs>>): Prisma__MonthPlanClient<$Result.GetResult<Prisma.$MonthPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MonthPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthPlanFindFirstOrThrowArgs} args - Arguments to find a MonthPlan
     * @example
     * // Get one MonthPlan
     * const monthPlan = await prisma.monthPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MonthPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, MonthPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__MonthPlanClient<$Result.GetResult<Prisma.$MonthPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MonthPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MonthPlans
     * const monthPlans = await prisma.monthPlan.findMany()
     * 
     * // Get first 10 MonthPlans
     * const monthPlans = await prisma.monthPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const monthPlanWithIdOnly = await prisma.monthPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MonthPlanFindManyArgs>(args?: SelectSubset<T, MonthPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonthPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MonthPlan.
     * @param {MonthPlanCreateArgs} args - Arguments to create a MonthPlan.
     * @example
     * // Create one MonthPlan
     * const MonthPlan = await prisma.monthPlan.create({
     *   data: {
     *     // ... data to create a MonthPlan
     *   }
     * })
     * 
     */
    create<T extends MonthPlanCreateArgs>(args: SelectSubset<T, MonthPlanCreateArgs<ExtArgs>>): Prisma__MonthPlanClient<$Result.GetResult<Prisma.$MonthPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MonthPlans.
     * @param {MonthPlanCreateManyArgs} args - Arguments to create many MonthPlans.
     * @example
     * // Create many MonthPlans
     * const monthPlan = await prisma.monthPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MonthPlanCreateManyArgs>(args?: SelectSubset<T, MonthPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MonthPlans and returns the data saved in the database.
     * @param {MonthPlanCreateManyAndReturnArgs} args - Arguments to create many MonthPlans.
     * @example
     * // Create many MonthPlans
     * const monthPlan = await prisma.monthPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MonthPlans and only return the `id`
     * const monthPlanWithIdOnly = await prisma.monthPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MonthPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, MonthPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonthPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MonthPlan.
     * @param {MonthPlanDeleteArgs} args - Arguments to delete one MonthPlan.
     * @example
     * // Delete one MonthPlan
     * const MonthPlan = await prisma.monthPlan.delete({
     *   where: {
     *     // ... filter to delete one MonthPlan
     *   }
     * })
     * 
     */
    delete<T extends MonthPlanDeleteArgs>(args: SelectSubset<T, MonthPlanDeleteArgs<ExtArgs>>): Prisma__MonthPlanClient<$Result.GetResult<Prisma.$MonthPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MonthPlan.
     * @param {MonthPlanUpdateArgs} args - Arguments to update one MonthPlan.
     * @example
     * // Update one MonthPlan
     * const monthPlan = await prisma.monthPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MonthPlanUpdateArgs>(args: SelectSubset<T, MonthPlanUpdateArgs<ExtArgs>>): Prisma__MonthPlanClient<$Result.GetResult<Prisma.$MonthPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MonthPlans.
     * @param {MonthPlanDeleteManyArgs} args - Arguments to filter MonthPlans to delete.
     * @example
     * // Delete a few MonthPlans
     * const { count } = await prisma.monthPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MonthPlanDeleteManyArgs>(args?: SelectSubset<T, MonthPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MonthPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MonthPlans
     * const monthPlan = await prisma.monthPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MonthPlanUpdateManyArgs>(args: SelectSubset<T, MonthPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MonthPlans and returns the data updated in the database.
     * @param {MonthPlanUpdateManyAndReturnArgs} args - Arguments to update many MonthPlans.
     * @example
     * // Update many MonthPlans
     * const monthPlan = await prisma.monthPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MonthPlans and only return the `id`
     * const monthPlanWithIdOnly = await prisma.monthPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MonthPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, MonthPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonthPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MonthPlan.
     * @param {MonthPlanUpsertArgs} args - Arguments to update or create a MonthPlan.
     * @example
     * // Update or create a MonthPlan
     * const monthPlan = await prisma.monthPlan.upsert({
     *   create: {
     *     // ... data to create a MonthPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MonthPlan we want to update
     *   }
     * })
     */
    upsert<T extends MonthPlanUpsertArgs>(args: SelectSubset<T, MonthPlanUpsertArgs<ExtArgs>>): Prisma__MonthPlanClient<$Result.GetResult<Prisma.$MonthPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MonthPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthPlanCountArgs} args - Arguments to filter MonthPlans to count.
     * @example
     * // Count the number of MonthPlans
     * const count = await prisma.monthPlan.count({
     *   where: {
     *     // ... the filter for the MonthPlans we want to count
     *   }
     * })
    **/
    count<T extends MonthPlanCountArgs>(
      args?: Subset<T, MonthPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MonthPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MonthPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MonthPlanAggregateArgs>(args: Subset<T, MonthPlanAggregateArgs>): Prisma.PrismaPromise<GetMonthPlanAggregateType<T>>

    /**
     * Group by MonthPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MonthPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MonthPlanGroupByArgs['orderBy'] }
        : { orderBy?: MonthPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MonthPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonthPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MonthPlan model
   */
  readonly fields: MonthPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MonthPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MonthPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    monthFocuses<T extends MonthPlan$monthFocusesArgs<ExtArgs> = {}>(args?: Subset<T, MonthPlan$monthFocusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonthFocusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quarterPlan<T extends QuarterPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuarterPlanDefaultArgs<ExtArgs>>): Prisma__QuarterPlanClient<$Result.GetResult<Prisma.$QuarterPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    weekPlans<T extends MonthPlan$weekPlansArgs<ExtArgs> = {}>(args?: Subset<T, MonthPlan$weekPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeekPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MonthPlan model
   */
  interface MonthPlanFieldRefs {
    readonly id: FieldRef<"MonthPlan", 'String'>
    readonly quarterPlanId: FieldRef<"MonthPlan", 'String'>
    readonly month: FieldRef<"MonthPlan", 'Int'>
    readonly year: FieldRef<"MonthPlan", 'Int'>
    readonly objectives: FieldRef<"MonthPlan", 'String[]'>
    readonly completionRate: FieldRef<"MonthPlan", 'Float'>
    readonly energyRating: FieldRef<"MonthPlan", 'Float'>
    readonly rating: FieldRef<"MonthPlan", 'Int'>
    readonly reviewNotes: FieldRef<"MonthPlan", 'String'>
    readonly theme: FieldRef<"MonthPlan", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MonthPlan findUnique
   */
  export type MonthPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthPlan
     */
    select?: MonthPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthPlan
     */
    omit?: MonthPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthPlanInclude<ExtArgs> | null
    /**
     * Filter, which MonthPlan to fetch.
     */
    where: MonthPlanWhereUniqueInput
  }

  /**
   * MonthPlan findUniqueOrThrow
   */
  export type MonthPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthPlan
     */
    select?: MonthPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthPlan
     */
    omit?: MonthPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthPlanInclude<ExtArgs> | null
    /**
     * Filter, which MonthPlan to fetch.
     */
    where: MonthPlanWhereUniqueInput
  }

  /**
   * MonthPlan findFirst
   */
  export type MonthPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthPlan
     */
    select?: MonthPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthPlan
     */
    omit?: MonthPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthPlanInclude<ExtArgs> | null
    /**
     * Filter, which MonthPlan to fetch.
     */
    where?: MonthPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonthPlans to fetch.
     */
    orderBy?: MonthPlanOrderByWithRelationInput | MonthPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MonthPlans.
     */
    cursor?: MonthPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonthPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonthPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MonthPlans.
     */
    distinct?: MonthPlanScalarFieldEnum | MonthPlanScalarFieldEnum[]
  }

  /**
   * MonthPlan findFirstOrThrow
   */
  export type MonthPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthPlan
     */
    select?: MonthPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthPlan
     */
    omit?: MonthPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthPlanInclude<ExtArgs> | null
    /**
     * Filter, which MonthPlan to fetch.
     */
    where?: MonthPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonthPlans to fetch.
     */
    orderBy?: MonthPlanOrderByWithRelationInput | MonthPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MonthPlans.
     */
    cursor?: MonthPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonthPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonthPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MonthPlans.
     */
    distinct?: MonthPlanScalarFieldEnum | MonthPlanScalarFieldEnum[]
  }

  /**
   * MonthPlan findMany
   */
  export type MonthPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthPlan
     */
    select?: MonthPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthPlan
     */
    omit?: MonthPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthPlanInclude<ExtArgs> | null
    /**
     * Filter, which MonthPlans to fetch.
     */
    where?: MonthPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonthPlans to fetch.
     */
    orderBy?: MonthPlanOrderByWithRelationInput | MonthPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MonthPlans.
     */
    cursor?: MonthPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonthPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonthPlans.
     */
    skip?: number
    distinct?: MonthPlanScalarFieldEnum | MonthPlanScalarFieldEnum[]
  }

  /**
   * MonthPlan create
   */
  export type MonthPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthPlan
     */
    select?: MonthPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthPlan
     */
    omit?: MonthPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a MonthPlan.
     */
    data: XOR<MonthPlanCreateInput, MonthPlanUncheckedCreateInput>
  }

  /**
   * MonthPlan createMany
   */
  export type MonthPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MonthPlans.
     */
    data: MonthPlanCreateManyInput | MonthPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MonthPlan createManyAndReturn
   */
  export type MonthPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthPlan
     */
    select?: MonthPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MonthPlan
     */
    omit?: MonthPlanOmit<ExtArgs> | null
    /**
     * The data used to create many MonthPlans.
     */
    data: MonthPlanCreateManyInput | MonthPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MonthPlan update
   */
  export type MonthPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthPlan
     */
    select?: MonthPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthPlan
     */
    omit?: MonthPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a MonthPlan.
     */
    data: XOR<MonthPlanUpdateInput, MonthPlanUncheckedUpdateInput>
    /**
     * Choose, which MonthPlan to update.
     */
    where: MonthPlanWhereUniqueInput
  }

  /**
   * MonthPlan updateMany
   */
  export type MonthPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MonthPlans.
     */
    data: XOR<MonthPlanUpdateManyMutationInput, MonthPlanUncheckedUpdateManyInput>
    /**
     * Filter which MonthPlans to update
     */
    where?: MonthPlanWhereInput
    /**
     * Limit how many MonthPlans to update.
     */
    limit?: number
  }

  /**
   * MonthPlan updateManyAndReturn
   */
  export type MonthPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthPlan
     */
    select?: MonthPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MonthPlan
     */
    omit?: MonthPlanOmit<ExtArgs> | null
    /**
     * The data used to update MonthPlans.
     */
    data: XOR<MonthPlanUpdateManyMutationInput, MonthPlanUncheckedUpdateManyInput>
    /**
     * Filter which MonthPlans to update
     */
    where?: MonthPlanWhereInput
    /**
     * Limit how many MonthPlans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthPlanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MonthPlan upsert
   */
  export type MonthPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthPlan
     */
    select?: MonthPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthPlan
     */
    omit?: MonthPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the MonthPlan to update in case it exists.
     */
    where: MonthPlanWhereUniqueInput
    /**
     * In case the MonthPlan found by the `where` argument doesn't exist, create a new MonthPlan with this data.
     */
    create: XOR<MonthPlanCreateInput, MonthPlanUncheckedCreateInput>
    /**
     * In case the MonthPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MonthPlanUpdateInput, MonthPlanUncheckedUpdateInput>
  }

  /**
   * MonthPlan delete
   */
  export type MonthPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthPlan
     */
    select?: MonthPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthPlan
     */
    omit?: MonthPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthPlanInclude<ExtArgs> | null
    /**
     * Filter which MonthPlan to delete.
     */
    where: MonthPlanWhereUniqueInput
  }

  /**
   * MonthPlan deleteMany
   */
  export type MonthPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MonthPlans to delete
     */
    where?: MonthPlanWhereInput
    /**
     * Limit how many MonthPlans to delete.
     */
    limit?: number
  }

  /**
   * MonthPlan.monthFocuses
   */
  export type MonthPlan$monthFocusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthFocus
     */
    select?: MonthFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthFocus
     */
    omit?: MonthFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthFocusInclude<ExtArgs> | null
    where?: MonthFocusWhereInput
    orderBy?: MonthFocusOrderByWithRelationInput | MonthFocusOrderByWithRelationInput[]
    cursor?: MonthFocusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MonthFocusScalarFieldEnum | MonthFocusScalarFieldEnum[]
  }

  /**
   * MonthPlan.weekPlans
   */
  export type MonthPlan$weekPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekPlan
     */
    select?: WeekPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekPlan
     */
    omit?: WeekPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekPlanInclude<ExtArgs> | null
    where?: WeekPlanWhereInput
    orderBy?: WeekPlanOrderByWithRelationInput | WeekPlanOrderByWithRelationInput[]
    cursor?: WeekPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeekPlanScalarFieldEnum | WeekPlanScalarFieldEnum[]
  }

  /**
   * MonthPlan without action
   */
  export type MonthPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthPlan
     */
    select?: MonthPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthPlan
     */
    omit?: MonthPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthPlanInclude<ExtArgs> | null
  }


  /**
   * Model MonthFocus
   */

  export type AggregateMonthFocus = {
    _count: MonthFocusCountAggregateOutputType | null
    _avg: MonthFocusAvgAggregateOutputType | null
    _sum: MonthFocusSumAggregateOutputType | null
    _min: MonthFocusMinAggregateOutputType | null
    _max: MonthFocusMaxAggregateOutputType | null
  }

  export type MonthFocusAvgAggregateOutputType = {
    priority: number | null
    progress: number | null
  }

  export type MonthFocusSumAggregateOutputType = {
    priority: number | null
    progress: number | null
  }

  export type MonthFocusMinAggregateOutputType = {
    id: string | null
    monthPlanId: string | null
    quarterFocusId: string | null
    priority: number | null
    progress: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MonthFocusMaxAggregateOutputType = {
    id: string | null
    monthPlanId: string | null
    quarterFocusId: string | null
    priority: number | null
    progress: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MonthFocusCountAggregateOutputType = {
    id: number
    monthPlanId: number
    quarterFocusId: number
    priority: number
    progress: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MonthFocusAvgAggregateInputType = {
    priority?: true
    progress?: true
  }

  export type MonthFocusSumAggregateInputType = {
    priority?: true
    progress?: true
  }

  export type MonthFocusMinAggregateInputType = {
    id?: true
    monthPlanId?: true
    quarterFocusId?: true
    priority?: true
    progress?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MonthFocusMaxAggregateInputType = {
    id?: true
    monthPlanId?: true
    quarterFocusId?: true
    priority?: true
    progress?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MonthFocusCountAggregateInputType = {
    id?: true
    monthPlanId?: true
    quarterFocusId?: true
    priority?: true
    progress?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MonthFocusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MonthFocus to aggregate.
     */
    where?: MonthFocusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonthFoci to fetch.
     */
    orderBy?: MonthFocusOrderByWithRelationInput | MonthFocusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MonthFocusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonthFoci from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonthFoci.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MonthFoci
    **/
    _count?: true | MonthFocusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MonthFocusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MonthFocusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MonthFocusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MonthFocusMaxAggregateInputType
  }

  export type GetMonthFocusAggregateType<T extends MonthFocusAggregateArgs> = {
        [P in keyof T & keyof AggregateMonthFocus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonthFocus[P]>
      : GetScalarType<T[P], AggregateMonthFocus[P]>
  }




  export type MonthFocusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonthFocusWhereInput
    orderBy?: MonthFocusOrderByWithAggregationInput | MonthFocusOrderByWithAggregationInput[]
    by: MonthFocusScalarFieldEnum[] | MonthFocusScalarFieldEnum
    having?: MonthFocusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MonthFocusCountAggregateInputType | true
    _avg?: MonthFocusAvgAggregateInputType
    _sum?: MonthFocusSumAggregateInputType
    _min?: MonthFocusMinAggregateInputType
    _max?: MonthFocusMaxAggregateInputType
  }

  export type MonthFocusGroupByOutputType = {
    id: string
    monthPlanId: string
    quarterFocusId: string
    priority: number
    progress: number
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: MonthFocusCountAggregateOutputType | null
    _avg: MonthFocusAvgAggregateOutputType | null
    _sum: MonthFocusSumAggregateOutputType | null
    _min: MonthFocusMinAggregateOutputType | null
    _max: MonthFocusMaxAggregateOutputType | null
  }

  type GetMonthFocusGroupByPayload<T extends MonthFocusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MonthFocusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MonthFocusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MonthFocusGroupByOutputType[P]>
            : GetScalarType<T[P], MonthFocusGroupByOutputType[P]>
        }
      >
    >


  export type MonthFocusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    monthPlanId?: boolean
    quarterFocusId?: boolean
    priority?: boolean
    progress?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    monthPlan?: boolean | MonthPlanDefaultArgs<ExtArgs>
    quarterFocus?: boolean | QuarterFocusDefaultArgs<ExtArgs>
    weekFocuses?: boolean | MonthFocus$weekFocusesArgs<ExtArgs>
    _count?: boolean | MonthFocusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monthFocus"]>

  export type MonthFocusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    monthPlanId?: boolean
    quarterFocusId?: boolean
    priority?: boolean
    progress?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    monthPlan?: boolean | MonthPlanDefaultArgs<ExtArgs>
    quarterFocus?: boolean | QuarterFocusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monthFocus"]>

  export type MonthFocusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    monthPlanId?: boolean
    quarterFocusId?: boolean
    priority?: boolean
    progress?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    monthPlan?: boolean | MonthPlanDefaultArgs<ExtArgs>
    quarterFocus?: boolean | QuarterFocusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monthFocus"]>

  export type MonthFocusSelectScalar = {
    id?: boolean
    monthPlanId?: boolean
    quarterFocusId?: boolean
    priority?: boolean
    progress?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MonthFocusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "monthPlanId" | "quarterFocusId" | "priority" | "progress" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["monthFocus"]>
  export type MonthFocusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monthPlan?: boolean | MonthPlanDefaultArgs<ExtArgs>
    quarterFocus?: boolean | QuarterFocusDefaultArgs<ExtArgs>
    weekFocuses?: boolean | MonthFocus$weekFocusesArgs<ExtArgs>
    _count?: boolean | MonthFocusCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MonthFocusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monthPlan?: boolean | MonthPlanDefaultArgs<ExtArgs>
    quarterFocus?: boolean | QuarterFocusDefaultArgs<ExtArgs>
  }
  export type MonthFocusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monthPlan?: boolean | MonthPlanDefaultArgs<ExtArgs>
    quarterFocus?: boolean | QuarterFocusDefaultArgs<ExtArgs>
  }

  export type $MonthFocusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MonthFocus"
    objects: {
      monthPlan: Prisma.$MonthPlanPayload<ExtArgs>
      quarterFocus: Prisma.$QuarterFocusPayload<ExtArgs>
      weekFocuses: Prisma.$WeekFocusPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      monthPlanId: string
      quarterFocusId: string
      priority: number
      progress: number
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["monthFocus"]>
    composites: {}
  }

  type MonthFocusGetPayload<S extends boolean | null | undefined | MonthFocusDefaultArgs> = $Result.GetResult<Prisma.$MonthFocusPayload, S>

  type MonthFocusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MonthFocusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MonthFocusCountAggregateInputType | true
    }

  export interface MonthFocusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MonthFocus'], meta: { name: 'MonthFocus' } }
    /**
     * Find zero or one MonthFocus that matches the filter.
     * @param {MonthFocusFindUniqueArgs} args - Arguments to find a MonthFocus
     * @example
     * // Get one MonthFocus
     * const monthFocus = await prisma.monthFocus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MonthFocusFindUniqueArgs>(args: SelectSubset<T, MonthFocusFindUniqueArgs<ExtArgs>>): Prisma__MonthFocusClient<$Result.GetResult<Prisma.$MonthFocusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MonthFocus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MonthFocusFindUniqueOrThrowArgs} args - Arguments to find a MonthFocus
     * @example
     * // Get one MonthFocus
     * const monthFocus = await prisma.monthFocus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MonthFocusFindUniqueOrThrowArgs>(args: SelectSubset<T, MonthFocusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MonthFocusClient<$Result.GetResult<Prisma.$MonthFocusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MonthFocus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthFocusFindFirstArgs} args - Arguments to find a MonthFocus
     * @example
     * // Get one MonthFocus
     * const monthFocus = await prisma.monthFocus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MonthFocusFindFirstArgs>(args?: SelectSubset<T, MonthFocusFindFirstArgs<ExtArgs>>): Prisma__MonthFocusClient<$Result.GetResult<Prisma.$MonthFocusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MonthFocus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthFocusFindFirstOrThrowArgs} args - Arguments to find a MonthFocus
     * @example
     * // Get one MonthFocus
     * const monthFocus = await prisma.monthFocus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MonthFocusFindFirstOrThrowArgs>(args?: SelectSubset<T, MonthFocusFindFirstOrThrowArgs<ExtArgs>>): Prisma__MonthFocusClient<$Result.GetResult<Prisma.$MonthFocusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MonthFoci that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthFocusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MonthFoci
     * const monthFoci = await prisma.monthFocus.findMany()
     * 
     * // Get first 10 MonthFoci
     * const monthFoci = await prisma.monthFocus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const monthFocusWithIdOnly = await prisma.monthFocus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MonthFocusFindManyArgs>(args?: SelectSubset<T, MonthFocusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonthFocusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MonthFocus.
     * @param {MonthFocusCreateArgs} args - Arguments to create a MonthFocus.
     * @example
     * // Create one MonthFocus
     * const MonthFocus = await prisma.monthFocus.create({
     *   data: {
     *     // ... data to create a MonthFocus
     *   }
     * })
     * 
     */
    create<T extends MonthFocusCreateArgs>(args: SelectSubset<T, MonthFocusCreateArgs<ExtArgs>>): Prisma__MonthFocusClient<$Result.GetResult<Prisma.$MonthFocusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MonthFoci.
     * @param {MonthFocusCreateManyArgs} args - Arguments to create many MonthFoci.
     * @example
     * // Create many MonthFoci
     * const monthFocus = await prisma.monthFocus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MonthFocusCreateManyArgs>(args?: SelectSubset<T, MonthFocusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MonthFoci and returns the data saved in the database.
     * @param {MonthFocusCreateManyAndReturnArgs} args - Arguments to create many MonthFoci.
     * @example
     * // Create many MonthFoci
     * const monthFocus = await prisma.monthFocus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MonthFoci and only return the `id`
     * const monthFocusWithIdOnly = await prisma.monthFocus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MonthFocusCreateManyAndReturnArgs>(args?: SelectSubset<T, MonthFocusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonthFocusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MonthFocus.
     * @param {MonthFocusDeleteArgs} args - Arguments to delete one MonthFocus.
     * @example
     * // Delete one MonthFocus
     * const MonthFocus = await prisma.monthFocus.delete({
     *   where: {
     *     // ... filter to delete one MonthFocus
     *   }
     * })
     * 
     */
    delete<T extends MonthFocusDeleteArgs>(args: SelectSubset<T, MonthFocusDeleteArgs<ExtArgs>>): Prisma__MonthFocusClient<$Result.GetResult<Prisma.$MonthFocusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MonthFocus.
     * @param {MonthFocusUpdateArgs} args - Arguments to update one MonthFocus.
     * @example
     * // Update one MonthFocus
     * const monthFocus = await prisma.monthFocus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MonthFocusUpdateArgs>(args: SelectSubset<T, MonthFocusUpdateArgs<ExtArgs>>): Prisma__MonthFocusClient<$Result.GetResult<Prisma.$MonthFocusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MonthFoci.
     * @param {MonthFocusDeleteManyArgs} args - Arguments to filter MonthFoci to delete.
     * @example
     * // Delete a few MonthFoci
     * const { count } = await prisma.monthFocus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MonthFocusDeleteManyArgs>(args?: SelectSubset<T, MonthFocusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MonthFoci.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthFocusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MonthFoci
     * const monthFocus = await prisma.monthFocus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MonthFocusUpdateManyArgs>(args: SelectSubset<T, MonthFocusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MonthFoci and returns the data updated in the database.
     * @param {MonthFocusUpdateManyAndReturnArgs} args - Arguments to update many MonthFoci.
     * @example
     * // Update many MonthFoci
     * const monthFocus = await prisma.monthFocus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MonthFoci and only return the `id`
     * const monthFocusWithIdOnly = await prisma.monthFocus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MonthFocusUpdateManyAndReturnArgs>(args: SelectSubset<T, MonthFocusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonthFocusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MonthFocus.
     * @param {MonthFocusUpsertArgs} args - Arguments to update or create a MonthFocus.
     * @example
     * // Update or create a MonthFocus
     * const monthFocus = await prisma.monthFocus.upsert({
     *   create: {
     *     // ... data to create a MonthFocus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MonthFocus we want to update
     *   }
     * })
     */
    upsert<T extends MonthFocusUpsertArgs>(args: SelectSubset<T, MonthFocusUpsertArgs<ExtArgs>>): Prisma__MonthFocusClient<$Result.GetResult<Prisma.$MonthFocusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MonthFoci.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthFocusCountArgs} args - Arguments to filter MonthFoci to count.
     * @example
     * // Count the number of MonthFoci
     * const count = await prisma.monthFocus.count({
     *   where: {
     *     // ... the filter for the MonthFoci we want to count
     *   }
     * })
    **/
    count<T extends MonthFocusCountArgs>(
      args?: Subset<T, MonthFocusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MonthFocusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MonthFocus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthFocusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MonthFocusAggregateArgs>(args: Subset<T, MonthFocusAggregateArgs>): Prisma.PrismaPromise<GetMonthFocusAggregateType<T>>

    /**
     * Group by MonthFocus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthFocusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MonthFocusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MonthFocusGroupByArgs['orderBy'] }
        : { orderBy?: MonthFocusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MonthFocusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonthFocusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MonthFocus model
   */
  readonly fields: MonthFocusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MonthFocus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MonthFocusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    monthPlan<T extends MonthPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MonthPlanDefaultArgs<ExtArgs>>): Prisma__MonthPlanClient<$Result.GetResult<Prisma.$MonthPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    quarterFocus<T extends QuarterFocusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuarterFocusDefaultArgs<ExtArgs>>): Prisma__QuarterFocusClient<$Result.GetResult<Prisma.$QuarterFocusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    weekFocuses<T extends MonthFocus$weekFocusesArgs<ExtArgs> = {}>(args?: Subset<T, MonthFocus$weekFocusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeekFocusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MonthFocus model
   */
  interface MonthFocusFieldRefs {
    readonly id: FieldRef<"MonthFocus", 'String'>
    readonly monthPlanId: FieldRef<"MonthFocus", 'String'>
    readonly quarterFocusId: FieldRef<"MonthFocus", 'String'>
    readonly priority: FieldRef<"MonthFocus", 'Int'>
    readonly progress: FieldRef<"MonthFocus", 'Float'>
    readonly notes: FieldRef<"MonthFocus", 'String'>
    readonly createdAt: FieldRef<"MonthFocus", 'DateTime'>
    readonly updatedAt: FieldRef<"MonthFocus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MonthFocus findUnique
   */
  export type MonthFocusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthFocus
     */
    select?: MonthFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthFocus
     */
    omit?: MonthFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthFocusInclude<ExtArgs> | null
    /**
     * Filter, which MonthFocus to fetch.
     */
    where: MonthFocusWhereUniqueInput
  }

  /**
   * MonthFocus findUniqueOrThrow
   */
  export type MonthFocusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthFocus
     */
    select?: MonthFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthFocus
     */
    omit?: MonthFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthFocusInclude<ExtArgs> | null
    /**
     * Filter, which MonthFocus to fetch.
     */
    where: MonthFocusWhereUniqueInput
  }

  /**
   * MonthFocus findFirst
   */
  export type MonthFocusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthFocus
     */
    select?: MonthFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthFocus
     */
    omit?: MonthFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthFocusInclude<ExtArgs> | null
    /**
     * Filter, which MonthFocus to fetch.
     */
    where?: MonthFocusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonthFoci to fetch.
     */
    orderBy?: MonthFocusOrderByWithRelationInput | MonthFocusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MonthFoci.
     */
    cursor?: MonthFocusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonthFoci from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonthFoci.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MonthFoci.
     */
    distinct?: MonthFocusScalarFieldEnum | MonthFocusScalarFieldEnum[]
  }

  /**
   * MonthFocus findFirstOrThrow
   */
  export type MonthFocusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthFocus
     */
    select?: MonthFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthFocus
     */
    omit?: MonthFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthFocusInclude<ExtArgs> | null
    /**
     * Filter, which MonthFocus to fetch.
     */
    where?: MonthFocusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonthFoci to fetch.
     */
    orderBy?: MonthFocusOrderByWithRelationInput | MonthFocusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MonthFoci.
     */
    cursor?: MonthFocusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonthFoci from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonthFoci.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MonthFoci.
     */
    distinct?: MonthFocusScalarFieldEnum | MonthFocusScalarFieldEnum[]
  }

  /**
   * MonthFocus findMany
   */
  export type MonthFocusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthFocus
     */
    select?: MonthFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthFocus
     */
    omit?: MonthFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthFocusInclude<ExtArgs> | null
    /**
     * Filter, which MonthFoci to fetch.
     */
    where?: MonthFocusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonthFoci to fetch.
     */
    orderBy?: MonthFocusOrderByWithRelationInput | MonthFocusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MonthFoci.
     */
    cursor?: MonthFocusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonthFoci from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonthFoci.
     */
    skip?: number
    distinct?: MonthFocusScalarFieldEnum | MonthFocusScalarFieldEnum[]
  }

  /**
   * MonthFocus create
   */
  export type MonthFocusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthFocus
     */
    select?: MonthFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthFocus
     */
    omit?: MonthFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthFocusInclude<ExtArgs> | null
    /**
     * The data needed to create a MonthFocus.
     */
    data: XOR<MonthFocusCreateInput, MonthFocusUncheckedCreateInput>
  }

  /**
   * MonthFocus createMany
   */
  export type MonthFocusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MonthFoci.
     */
    data: MonthFocusCreateManyInput | MonthFocusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MonthFocus createManyAndReturn
   */
  export type MonthFocusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthFocus
     */
    select?: MonthFocusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MonthFocus
     */
    omit?: MonthFocusOmit<ExtArgs> | null
    /**
     * The data used to create many MonthFoci.
     */
    data: MonthFocusCreateManyInput | MonthFocusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthFocusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MonthFocus update
   */
  export type MonthFocusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthFocus
     */
    select?: MonthFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthFocus
     */
    omit?: MonthFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthFocusInclude<ExtArgs> | null
    /**
     * The data needed to update a MonthFocus.
     */
    data: XOR<MonthFocusUpdateInput, MonthFocusUncheckedUpdateInput>
    /**
     * Choose, which MonthFocus to update.
     */
    where: MonthFocusWhereUniqueInput
  }

  /**
   * MonthFocus updateMany
   */
  export type MonthFocusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MonthFoci.
     */
    data: XOR<MonthFocusUpdateManyMutationInput, MonthFocusUncheckedUpdateManyInput>
    /**
     * Filter which MonthFoci to update
     */
    where?: MonthFocusWhereInput
    /**
     * Limit how many MonthFoci to update.
     */
    limit?: number
  }

  /**
   * MonthFocus updateManyAndReturn
   */
  export type MonthFocusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthFocus
     */
    select?: MonthFocusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MonthFocus
     */
    omit?: MonthFocusOmit<ExtArgs> | null
    /**
     * The data used to update MonthFoci.
     */
    data: XOR<MonthFocusUpdateManyMutationInput, MonthFocusUncheckedUpdateManyInput>
    /**
     * Filter which MonthFoci to update
     */
    where?: MonthFocusWhereInput
    /**
     * Limit how many MonthFoci to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthFocusIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MonthFocus upsert
   */
  export type MonthFocusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthFocus
     */
    select?: MonthFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthFocus
     */
    omit?: MonthFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthFocusInclude<ExtArgs> | null
    /**
     * The filter to search for the MonthFocus to update in case it exists.
     */
    where: MonthFocusWhereUniqueInput
    /**
     * In case the MonthFocus found by the `where` argument doesn't exist, create a new MonthFocus with this data.
     */
    create: XOR<MonthFocusCreateInput, MonthFocusUncheckedCreateInput>
    /**
     * In case the MonthFocus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MonthFocusUpdateInput, MonthFocusUncheckedUpdateInput>
  }

  /**
   * MonthFocus delete
   */
  export type MonthFocusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthFocus
     */
    select?: MonthFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthFocus
     */
    omit?: MonthFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthFocusInclude<ExtArgs> | null
    /**
     * Filter which MonthFocus to delete.
     */
    where: MonthFocusWhereUniqueInput
  }

  /**
   * MonthFocus deleteMany
   */
  export type MonthFocusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MonthFoci to delete
     */
    where?: MonthFocusWhereInput
    /**
     * Limit how many MonthFoci to delete.
     */
    limit?: number
  }

  /**
   * MonthFocus.weekFocuses
   */
  export type MonthFocus$weekFocusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekFocus
     */
    select?: WeekFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekFocus
     */
    omit?: WeekFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekFocusInclude<ExtArgs> | null
    where?: WeekFocusWhereInput
    orderBy?: WeekFocusOrderByWithRelationInput | WeekFocusOrderByWithRelationInput[]
    cursor?: WeekFocusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeekFocusScalarFieldEnum | WeekFocusScalarFieldEnum[]
  }

  /**
   * MonthFocus without action
   */
  export type MonthFocusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthFocus
     */
    select?: MonthFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthFocus
     */
    omit?: MonthFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthFocusInclude<ExtArgs> | null
  }


  /**
   * Model WeekPlan
   */

  export type AggregateWeekPlan = {
    _count: WeekPlanCountAggregateOutputType | null
    _avg: WeekPlanAvgAggregateOutputType | null
    _sum: WeekPlanSumAggregateOutputType | null
    _min: WeekPlanMinAggregateOutputType | null
    _max: WeekPlanMaxAggregateOutputType | null
  }

  export type WeekPlanAvgAggregateOutputType = {
    weekNumber: number | null
    year: number | null
    plannedClientHours: number | null
    plannedPersonalHours: number | null
    rating: number | null
  }

  export type WeekPlanSumAggregateOutputType = {
    weekNumber: number | null
    year: number | null
    plannedClientHours: number | null
    plannedPersonalHours: number | null
    rating: number | null
  }

  export type WeekPlanMinAggregateOutputType = {
    id: string | null
    monthPlanId: string | null
    weekNumber: number | null
    year: number | null
    startDate: Date | null
    endDate: Date | null
    plannedClientHours: number | null
    plannedPersonalHours: number | null
    userId: string | null
    rating: number | null
    reviewNotes: string | null
  }

  export type WeekPlanMaxAggregateOutputType = {
    id: string | null
    monthPlanId: string | null
    weekNumber: number | null
    year: number | null
    startDate: Date | null
    endDate: Date | null
    plannedClientHours: number | null
    plannedPersonalHours: number | null
    userId: string | null
    rating: number | null
    reviewNotes: string | null
  }

  export type WeekPlanCountAggregateOutputType = {
    id: number
    monthPlanId: number
    weekNumber: number
    year: number
    startDate: number
    endDate: number
    topOutcomes: number
    plannedClientHours: number
    plannedPersonalHours: number
    userId: number
    challenges: number
    keyWins: number
    lessonsLearned: number
    rating: number
    reviewNotes: number
    _all: number
  }


  export type WeekPlanAvgAggregateInputType = {
    weekNumber?: true
    year?: true
    plannedClientHours?: true
    plannedPersonalHours?: true
    rating?: true
  }

  export type WeekPlanSumAggregateInputType = {
    weekNumber?: true
    year?: true
    plannedClientHours?: true
    plannedPersonalHours?: true
    rating?: true
  }

  export type WeekPlanMinAggregateInputType = {
    id?: true
    monthPlanId?: true
    weekNumber?: true
    year?: true
    startDate?: true
    endDate?: true
    plannedClientHours?: true
    plannedPersonalHours?: true
    userId?: true
    rating?: true
    reviewNotes?: true
  }

  export type WeekPlanMaxAggregateInputType = {
    id?: true
    monthPlanId?: true
    weekNumber?: true
    year?: true
    startDate?: true
    endDate?: true
    plannedClientHours?: true
    plannedPersonalHours?: true
    userId?: true
    rating?: true
    reviewNotes?: true
  }

  export type WeekPlanCountAggregateInputType = {
    id?: true
    monthPlanId?: true
    weekNumber?: true
    year?: true
    startDate?: true
    endDate?: true
    topOutcomes?: true
    plannedClientHours?: true
    plannedPersonalHours?: true
    userId?: true
    challenges?: true
    keyWins?: true
    lessonsLearned?: true
    rating?: true
    reviewNotes?: true
    _all?: true
  }

  export type WeekPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeekPlan to aggregate.
     */
    where?: WeekPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeekPlans to fetch.
     */
    orderBy?: WeekPlanOrderByWithRelationInput | WeekPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeekPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeekPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeekPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WeekPlans
    **/
    _count?: true | WeekPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WeekPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WeekPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeekPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeekPlanMaxAggregateInputType
  }

  export type GetWeekPlanAggregateType<T extends WeekPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateWeekPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeekPlan[P]>
      : GetScalarType<T[P], AggregateWeekPlan[P]>
  }




  export type WeekPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeekPlanWhereInput
    orderBy?: WeekPlanOrderByWithAggregationInput | WeekPlanOrderByWithAggregationInput[]
    by: WeekPlanScalarFieldEnum[] | WeekPlanScalarFieldEnum
    having?: WeekPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeekPlanCountAggregateInputType | true
    _avg?: WeekPlanAvgAggregateInputType
    _sum?: WeekPlanSumAggregateInputType
    _min?: WeekPlanMinAggregateInputType
    _max?: WeekPlanMaxAggregateInputType
  }

  export type WeekPlanGroupByOutputType = {
    id: string
    monthPlanId: string
    weekNumber: number
    year: number
    startDate: Date
    endDate: Date
    topOutcomes: string[]
    plannedClientHours: number | null
    plannedPersonalHours: number | null
    userId: string
    challenges: string[]
    keyWins: string[]
    lessonsLearned: string[]
    rating: number | null
    reviewNotes: string | null
    _count: WeekPlanCountAggregateOutputType | null
    _avg: WeekPlanAvgAggregateOutputType | null
    _sum: WeekPlanSumAggregateOutputType | null
    _min: WeekPlanMinAggregateOutputType | null
    _max: WeekPlanMaxAggregateOutputType | null
  }

  type GetWeekPlanGroupByPayload<T extends WeekPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeekPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeekPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeekPlanGroupByOutputType[P]>
            : GetScalarType<T[P], WeekPlanGroupByOutputType[P]>
        }
      >
    >


  export type WeekPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    monthPlanId?: boolean
    weekNumber?: boolean
    year?: boolean
    startDate?: boolean
    endDate?: boolean
    topOutcomes?: boolean
    plannedClientHours?: boolean
    plannedPersonalHours?: boolean
    userId?: boolean
    challenges?: boolean
    keyWins?: boolean
    lessonsLearned?: boolean
    rating?: boolean
    reviewNotes?: boolean
    dayPlans?: boolean | WeekPlan$dayPlansArgs<ExtArgs>
    weekFocuses?: boolean | WeekPlan$weekFocusesArgs<ExtArgs>
    monthPlan?: boolean | MonthPlanDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | WeekPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weekPlan"]>

  export type WeekPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    monthPlanId?: boolean
    weekNumber?: boolean
    year?: boolean
    startDate?: boolean
    endDate?: boolean
    topOutcomes?: boolean
    plannedClientHours?: boolean
    plannedPersonalHours?: boolean
    userId?: boolean
    challenges?: boolean
    keyWins?: boolean
    lessonsLearned?: boolean
    rating?: boolean
    reviewNotes?: boolean
    monthPlan?: boolean | MonthPlanDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weekPlan"]>

  export type WeekPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    monthPlanId?: boolean
    weekNumber?: boolean
    year?: boolean
    startDate?: boolean
    endDate?: boolean
    topOutcomes?: boolean
    plannedClientHours?: boolean
    plannedPersonalHours?: boolean
    userId?: boolean
    challenges?: boolean
    keyWins?: boolean
    lessonsLearned?: boolean
    rating?: boolean
    reviewNotes?: boolean
    monthPlan?: boolean | MonthPlanDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weekPlan"]>

  export type WeekPlanSelectScalar = {
    id?: boolean
    monthPlanId?: boolean
    weekNumber?: boolean
    year?: boolean
    startDate?: boolean
    endDate?: boolean
    topOutcomes?: boolean
    plannedClientHours?: boolean
    plannedPersonalHours?: boolean
    userId?: boolean
    challenges?: boolean
    keyWins?: boolean
    lessonsLearned?: boolean
    rating?: boolean
    reviewNotes?: boolean
  }

  export type WeekPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "monthPlanId" | "weekNumber" | "year" | "startDate" | "endDate" | "topOutcomes" | "plannedClientHours" | "plannedPersonalHours" | "userId" | "challenges" | "keyWins" | "lessonsLearned" | "rating" | "reviewNotes", ExtArgs["result"]["weekPlan"]>
  export type WeekPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dayPlans?: boolean | WeekPlan$dayPlansArgs<ExtArgs>
    weekFocuses?: boolean | WeekPlan$weekFocusesArgs<ExtArgs>
    monthPlan?: boolean | MonthPlanDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | WeekPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WeekPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monthPlan?: boolean | MonthPlanDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WeekPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monthPlan?: boolean | MonthPlanDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WeekPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WeekPlan"
    objects: {
      dayPlans: Prisma.$DayPlanPayload<ExtArgs>[]
      weekFocuses: Prisma.$WeekFocusPayload<ExtArgs>[]
      monthPlan: Prisma.$MonthPlanPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      monthPlanId: string
      weekNumber: number
      year: number
      startDate: Date
      endDate: Date
      topOutcomes: string[]
      plannedClientHours: number | null
      plannedPersonalHours: number | null
      userId: string
      challenges: string[]
      keyWins: string[]
      lessonsLearned: string[]
      rating: number | null
      reviewNotes: string | null
    }, ExtArgs["result"]["weekPlan"]>
    composites: {}
  }

  type WeekPlanGetPayload<S extends boolean | null | undefined | WeekPlanDefaultArgs> = $Result.GetResult<Prisma.$WeekPlanPayload, S>

  type WeekPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WeekPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WeekPlanCountAggregateInputType | true
    }

  export interface WeekPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WeekPlan'], meta: { name: 'WeekPlan' } }
    /**
     * Find zero or one WeekPlan that matches the filter.
     * @param {WeekPlanFindUniqueArgs} args - Arguments to find a WeekPlan
     * @example
     * // Get one WeekPlan
     * const weekPlan = await prisma.weekPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeekPlanFindUniqueArgs>(args: SelectSubset<T, WeekPlanFindUniqueArgs<ExtArgs>>): Prisma__WeekPlanClient<$Result.GetResult<Prisma.$WeekPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WeekPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WeekPlanFindUniqueOrThrowArgs} args - Arguments to find a WeekPlan
     * @example
     * // Get one WeekPlan
     * const weekPlan = await prisma.weekPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeekPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, WeekPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeekPlanClient<$Result.GetResult<Prisma.$WeekPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WeekPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekPlanFindFirstArgs} args - Arguments to find a WeekPlan
     * @example
     * // Get one WeekPlan
     * const weekPlan = await prisma.weekPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeekPlanFindFirstArgs>(args?: SelectSubset<T, WeekPlanFindFirstArgs<ExtArgs>>): Prisma__WeekPlanClient<$Result.GetResult<Prisma.$WeekPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WeekPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekPlanFindFirstOrThrowArgs} args - Arguments to find a WeekPlan
     * @example
     * // Get one WeekPlan
     * const weekPlan = await prisma.weekPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeekPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, WeekPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeekPlanClient<$Result.GetResult<Prisma.$WeekPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WeekPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WeekPlans
     * const weekPlans = await prisma.weekPlan.findMany()
     * 
     * // Get first 10 WeekPlans
     * const weekPlans = await prisma.weekPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weekPlanWithIdOnly = await prisma.weekPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WeekPlanFindManyArgs>(args?: SelectSubset<T, WeekPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeekPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WeekPlan.
     * @param {WeekPlanCreateArgs} args - Arguments to create a WeekPlan.
     * @example
     * // Create one WeekPlan
     * const WeekPlan = await prisma.weekPlan.create({
     *   data: {
     *     // ... data to create a WeekPlan
     *   }
     * })
     * 
     */
    create<T extends WeekPlanCreateArgs>(args: SelectSubset<T, WeekPlanCreateArgs<ExtArgs>>): Prisma__WeekPlanClient<$Result.GetResult<Prisma.$WeekPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WeekPlans.
     * @param {WeekPlanCreateManyArgs} args - Arguments to create many WeekPlans.
     * @example
     * // Create many WeekPlans
     * const weekPlan = await prisma.weekPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeekPlanCreateManyArgs>(args?: SelectSubset<T, WeekPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WeekPlans and returns the data saved in the database.
     * @param {WeekPlanCreateManyAndReturnArgs} args - Arguments to create many WeekPlans.
     * @example
     * // Create many WeekPlans
     * const weekPlan = await prisma.weekPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WeekPlans and only return the `id`
     * const weekPlanWithIdOnly = await prisma.weekPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WeekPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, WeekPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeekPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WeekPlan.
     * @param {WeekPlanDeleteArgs} args - Arguments to delete one WeekPlan.
     * @example
     * // Delete one WeekPlan
     * const WeekPlan = await prisma.weekPlan.delete({
     *   where: {
     *     // ... filter to delete one WeekPlan
     *   }
     * })
     * 
     */
    delete<T extends WeekPlanDeleteArgs>(args: SelectSubset<T, WeekPlanDeleteArgs<ExtArgs>>): Prisma__WeekPlanClient<$Result.GetResult<Prisma.$WeekPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WeekPlan.
     * @param {WeekPlanUpdateArgs} args - Arguments to update one WeekPlan.
     * @example
     * // Update one WeekPlan
     * const weekPlan = await prisma.weekPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeekPlanUpdateArgs>(args: SelectSubset<T, WeekPlanUpdateArgs<ExtArgs>>): Prisma__WeekPlanClient<$Result.GetResult<Prisma.$WeekPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WeekPlans.
     * @param {WeekPlanDeleteManyArgs} args - Arguments to filter WeekPlans to delete.
     * @example
     * // Delete a few WeekPlans
     * const { count } = await prisma.weekPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeekPlanDeleteManyArgs>(args?: SelectSubset<T, WeekPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeekPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WeekPlans
     * const weekPlan = await prisma.weekPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeekPlanUpdateManyArgs>(args: SelectSubset<T, WeekPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeekPlans and returns the data updated in the database.
     * @param {WeekPlanUpdateManyAndReturnArgs} args - Arguments to update many WeekPlans.
     * @example
     * // Update many WeekPlans
     * const weekPlan = await prisma.weekPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WeekPlans and only return the `id`
     * const weekPlanWithIdOnly = await prisma.weekPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WeekPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, WeekPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeekPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WeekPlan.
     * @param {WeekPlanUpsertArgs} args - Arguments to update or create a WeekPlan.
     * @example
     * // Update or create a WeekPlan
     * const weekPlan = await prisma.weekPlan.upsert({
     *   create: {
     *     // ... data to create a WeekPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WeekPlan we want to update
     *   }
     * })
     */
    upsert<T extends WeekPlanUpsertArgs>(args: SelectSubset<T, WeekPlanUpsertArgs<ExtArgs>>): Prisma__WeekPlanClient<$Result.GetResult<Prisma.$WeekPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WeekPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekPlanCountArgs} args - Arguments to filter WeekPlans to count.
     * @example
     * // Count the number of WeekPlans
     * const count = await prisma.weekPlan.count({
     *   where: {
     *     // ... the filter for the WeekPlans we want to count
     *   }
     * })
    **/
    count<T extends WeekPlanCountArgs>(
      args?: Subset<T, WeekPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeekPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WeekPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeekPlanAggregateArgs>(args: Subset<T, WeekPlanAggregateArgs>): Prisma.PrismaPromise<GetWeekPlanAggregateType<T>>

    /**
     * Group by WeekPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeekPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeekPlanGroupByArgs['orderBy'] }
        : { orderBy?: WeekPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeekPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeekPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WeekPlan model
   */
  readonly fields: WeekPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WeekPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeekPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dayPlans<T extends WeekPlan$dayPlansArgs<ExtArgs> = {}>(args?: Subset<T, WeekPlan$dayPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DayPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    weekFocuses<T extends WeekPlan$weekFocusesArgs<ExtArgs> = {}>(args?: Subset<T, WeekPlan$weekFocusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeekFocusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    monthPlan<T extends MonthPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MonthPlanDefaultArgs<ExtArgs>>): Prisma__MonthPlanClient<$Result.GetResult<Prisma.$MonthPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WeekPlan model
   */
  interface WeekPlanFieldRefs {
    readonly id: FieldRef<"WeekPlan", 'String'>
    readonly monthPlanId: FieldRef<"WeekPlan", 'String'>
    readonly weekNumber: FieldRef<"WeekPlan", 'Int'>
    readonly year: FieldRef<"WeekPlan", 'Int'>
    readonly startDate: FieldRef<"WeekPlan", 'DateTime'>
    readonly endDate: FieldRef<"WeekPlan", 'DateTime'>
    readonly topOutcomes: FieldRef<"WeekPlan", 'String[]'>
    readonly plannedClientHours: FieldRef<"WeekPlan", 'Float'>
    readonly plannedPersonalHours: FieldRef<"WeekPlan", 'Float'>
    readonly userId: FieldRef<"WeekPlan", 'String'>
    readonly challenges: FieldRef<"WeekPlan", 'String[]'>
    readonly keyWins: FieldRef<"WeekPlan", 'String[]'>
    readonly lessonsLearned: FieldRef<"WeekPlan", 'String[]'>
    readonly rating: FieldRef<"WeekPlan", 'Int'>
    readonly reviewNotes: FieldRef<"WeekPlan", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WeekPlan findUnique
   */
  export type WeekPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekPlan
     */
    select?: WeekPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekPlan
     */
    omit?: WeekPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekPlanInclude<ExtArgs> | null
    /**
     * Filter, which WeekPlan to fetch.
     */
    where: WeekPlanWhereUniqueInput
  }

  /**
   * WeekPlan findUniqueOrThrow
   */
  export type WeekPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekPlan
     */
    select?: WeekPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekPlan
     */
    omit?: WeekPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekPlanInclude<ExtArgs> | null
    /**
     * Filter, which WeekPlan to fetch.
     */
    where: WeekPlanWhereUniqueInput
  }

  /**
   * WeekPlan findFirst
   */
  export type WeekPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekPlan
     */
    select?: WeekPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekPlan
     */
    omit?: WeekPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekPlanInclude<ExtArgs> | null
    /**
     * Filter, which WeekPlan to fetch.
     */
    where?: WeekPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeekPlans to fetch.
     */
    orderBy?: WeekPlanOrderByWithRelationInput | WeekPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeekPlans.
     */
    cursor?: WeekPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeekPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeekPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeekPlans.
     */
    distinct?: WeekPlanScalarFieldEnum | WeekPlanScalarFieldEnum[]
  }

  /**
   * WeekPlan findFirstOrThrow
   */
  export type WeekPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekPlan
     */
    select?: WeekPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekPlan
     */
    omit?: WeekPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekPlanInclude<ExtArgs> | null
    /**
     * Filter, which WeekPlan to fetch.
     */
    where?: WeekPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeekPlans to fetch.
     */
    orderBy?: WeekPlanOrderByWithRelationInput | WeekPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeekPlans.
     */
    cursor?: WeekPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeekPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeekPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeekPlans.
     */
    distinct?: WeekPlanScalarFieldEnum | WeekPlanScalarFieldEnum[]
  }

  /**
   * WeekPlan findMany
   */
  export type WeekPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekPlan
     */
    select?: WeekPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekPlan
     */
    omit?: WeekPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekPlanInclude<ExtArgs> | null
    /**
     * Filter, which WeekPlans to fetch.
     */
    where?: WeekPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeekPlans to fetch.
     */
    orderBy?: WeekPlanOrderByWithRelationInput | WeekPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WeekPlans.
     */
    cursor?: WeekPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeekPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeekPlans.
     */
    skip?: number
    distinct?: WeekPlanScalarFieldEnum | WeekPlanScalarFieldEnum[]
  }

  /**
   * WeekPlan create
   */
  export type WeekPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekPlan
     */
    select?: WeekPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekPlan
     */
    omit?: WeekPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a WeekPlan.
     */
    data: XOR<WeekPlanCreateInput, WeekPlanUncheckedCreateInput>
  }

  /**
   * WeekPlan createMany
   */
  export type WeekPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WeekPlans.
     */
    data: WeekPlanCreateManyInput | WeekPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WeekPlan createManyAndReturn
   */
  export type WeekPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekPlan
     */
    select?: WeekPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WeekPlan
     */
    omit?: WeekPlanOmit<ExtArgs> | null
    /**
     * The data used to create many WeekPlans.
     */
    data: WeekPlanCreateManyInput | WeekPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WeekPlan update
   */
  export type WeekPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekPlan
     */
    select?: WeekPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekPlan
     */
    omit?: WeekPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a WeekPlan.
     */
    data: XOR<WeekPlanUpdateInput, WeekPlanUncheckedUpdateInput>
    /**
     * Choose, which WeekPlan to update.
     */
    where: WeekPlanWhereUniqueInput
  }

  /**
   * WeekPlan updateMany
   */
  export type WeekPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WeekPlans.
     */
    data: XOR<WeekPlanUpdateManyMutationInput, WeekPlanUncheckedUpdateManyInput>
    /**
     * Filter which WeekPlans to update
     */
    where?: WeekPlanWhereInput
    /**
     * Limit how many WeekPlans to update.
     */
    limit?: number
  }

  /**
   * WeekPlan updateManyAndReturn
   */
  export type WeekPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekPlan
     */
    select?: WeekPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WeekPlan
     */
    omit?: WeekPlanOmit<ExtArgs> | null
    /**
     * The data used to update WeekPlans.
     */
    data: XOR<WeekPlanUpdateManyMutationInput, WeekPlanUncheckedUpdateManyInput>
    /**
     * Filter which WeekPlans to update
     */
    where?: WeekPlanWhereInput
    /**
     * Limit how many WeekPlans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekPlanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WeekPlan upsert
   */
  export type WeekPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekPlan
     */
    select?: WeekPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekPlan
     */
    omit?: WeekPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the WeekPlan to update in case it exists.
     */
    where: WeekPlanWhereUniqueInput
    /**
     * In case the WeekPlan found by the `where` argument doesn't exist, create a new WeekPlan with this data.
     */
    create: XOR<WeekPlanCreateInput, WeekPlanUncheckedCreateInput>
    /**
     * In case the WeekPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeekPlanUpdateInput, WeekPlanUncheckedUpdateInput>
  }

  /**
   * WeekPlan delete
   */
  export type WeekPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekPlan
     */
    select?: WeekPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekPlan
     */
    omit?: WeekPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekPlanInclude<ExtArgs> | null
    /**
     * Filter which WeekPlan to delete.
     */
    where: WeekPlanWhereUniqueInput
  }

  /**
   * WeekPlan deleteMany
   */
  export type WeekPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeekPlans to delete
     */
    where?: WeekPlanWhereInput
    /**
     * Limit how many WeekPlans to delete.
     */
    limit?: number
  }

  /**
   * WeekPlan.dayPlans
   */
  export type WeekPlan$dayPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayPlan
     */
    select?: DayPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayPlan
     */
    omit?: DayPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayPlanInclude<ExtArgs> | null
    where?: DayPlanWhereInput
    orderBy?: DayPlanOrderByWithRelationInput | DayPlanOrderByWithRelationInput[]
    cursor?: DayPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DayPlanScalarFieldEnum | DayPlanScalarFieldEnum[]
  }

  /**
   * WeekPlan.weekFocuses
   */
  export type WeekPlan$weekFocusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekFocus
     */
    select?: WeekFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekFocus
     */
    omit?: WeekFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekFocusInclude<ExtArgs> | null
    where?: WeekFocusWhereInput
    orderBy?: WeekFocusOrderByWithRelationInput | WeekFocusOrderByWithRelationInput[]
    cursor?: WeekFocusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeekFocusScalarFieldEnum | WeekFocusScalarFieldEnum[]
  }

  /**
   * WeekPlan without action
   */
  export type WeekPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekPlan
     */
    select?: WeekPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekPlan
     */
    omit?: WeekPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekPlanInclude<ExtArgs> | null
  }


  /**
   * Model WeekFocus
   */

  export type AggregateWeekFocus = {
    _count: WeekFocusCountAggregateOutputType | null
    _avg: WeekFocusAvgAggregateOutputType | null
    _sum: WeekFocusSumAggregateOutputType | null
    _min: WeekFocusMinAggregateOutputType | null
    _max: WeekFocusMaxAggregateOutputType | null
  }

  export type WeekFocusAvgAggregateOutputType = {
    priority: number | null
    progress: number | null
  }

  export type WeekFocusSumAggregateOutputType = {
    priority: number | null
    progress: number | null
  }

  export type WeekFocusMinAggregateOutputType = {
    id: string | null
    weekPlanId: string | null
    monthFocusId: string | null
    priority: number | null
    progress: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WeekFocusMaxAggregateOutputType = {
    id: string | null
    weekPlanId: string | null
    monthFocusId: string | null
    priority: number | null
    progress: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WeekFocusCountAggregateOutputType = {
    id: number
    weekPlanId: number
    monthFocusId: number
    priority: number
    progress: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WeekFocusAvgAggregateInputType = {
    priority?: true
    progress?: true
  }

  export type WeekFocusSumAggregateInputType = {
    priority?: true
    progress?: true
  }

  export type WeekFocusMinAggregateInputType = {
    id?: true
    weekPlanId?: true
    monthFocusId?: true
    priority?: true
    progress?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WeekFocusMaxAggregateInputType = {
    id?: true
    weekPlanId?: true
    monthFocusId?: true
    priority?: true
    progress?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WeekFocusCountAggregateInputType = {
    id?: true
    weekPlanId?: true
    monthFocusId?: true
    priority?: true
    progress?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WeekFocusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeekFocus to aggregate.
     */
    where?: WeekFocusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeekFoci to fetch.
     */
    orderBy?: WeekFocusOrderByWithRelationInput | WeekFocusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeekFocusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeekFoci from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeekFoci.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WeekFoci
    **/
    _count?: true | WeekFocusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WeekFocusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WeekFocusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeekFocusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeekFocusMaxAggregateInputType
  }

  export type GetWeekFocusAggregateType<T extends WeekFocusAggregateArgs> = {
        [P in keyof T & keyof AggregateWeekFocus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeekFocus[P]>
      : GetScalarType<T[P], AggregateWeekFocus[P]>
  }




  export type WeekFocusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeekFocusWhereInput
    orderBy?: WeekFocusOrderByWithAggregationInput | WeekFocusOrderByWithAggregationInput[]
    by: WeekFocusScalarFieldEnum[] | WeekFocusScalarFieldEnum
    having?: WeekFocusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeekFocusCountAggregateInputType | true
    _avg?: WeekFocusAvgAggregateInputType
    _sum?: WeekFocusSumAggregateInputType
    _min?: WeekFocusMinAggregateInputType
    _max?: WeekFocusMaxAggregateInputType
  }

  export type WeekFocusGroupByOutputType = {
    id: string
    weekPlanId: string
    monthFocusId: string
    priority: number
    progress: number
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: WeekFocusCountAggregateOutputType | null
    _avg: WeekFocusAvgAggregateOutputType | null
    _sum: WeekFocusSumAggregateOutputType | null
    _min: WeekFocusMinAggregateOutputType | null
    _max: WeekFocusMaxAggregateOutputType | null
  }

  type GetWeekFocusGroupByPayload<T extends WeekFocusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeekFocusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeekFocusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeekFocusGroupByOutputType[P]>
            : GetScalarType<T[P], WeekFocusGroupByOutputType[P]>
        }
      >
    >


  export type WeekFocusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    weekPlanId?: boolean
    monthFocusId?: boolean
    priority?: boolean
    progress?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dayFocuses?: boolean | WeekFocus$dayFocusesArgs<ExtArgs>
    monthFocus?: boolean | MonthFocusDefaultArgs<ExtArgs>
    weekPlan?: boolean | WeekPlanDefaultArgs<ExtArgs>
    _count?: boolean | WeekFocusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weekFocus"]>

  export type WeekFocusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    weekPlanId?: boolean
    monthFocusId?: boolean
    priority?: boolean
    progress?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    monthFocus?: boolean | MonthFocusDefaultArgs<ExtArgs>
    weekPlan?: boolean | WeekPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weekFocus"]>

  export type WeekFocusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    weekPlanId?: boolean
    monthFocusId?: boolean
    priority?: boolean
    progress?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    monthFocus?: boolean | MonthFocusDefaultArgs<ExtArgs>
    weekPlan?: boolean | WeekPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weekFocus"]>

  export type WeekFocusSelectScalar = {
    id?: boolean
    weekPlanId?: boolean
    monthFocusId?: boolean
    priority?: boolean
    progress?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WeekFocusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "weekPlanId" | "monthFocusId" | "priority" | "progress" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["weekFocus"]>
  export type WeekFocusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dayFocuses?: boolean | WeekFocus$dayFocusesArgs<ExtArgs>
    monthFocus?: boolean | MonthFocusDefaultArgs<ExtArgs>
    weekPlan?: boolean | WeekPlanDefaultArgs<ExtArgs>
    _count?: boolean | WeekFocusCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WeekFocusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monthFocus?: boolean | MonthFocusDefaultArgs<ExtArgs>
    weekPlan?: boolean | WeekPlanDefaultArgs<ExtArgs>
  }
  export type WeekFocusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monthFocus?: boolean | MonthFocusDefaultArgs<ExtArgs>
    weekPlan?: boolean | WeekPlanDefaultArgs<ExtArgs>
  }

  export type $WeekFocusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WeekFocus"
    objects: {
      dayFocuses: Prisma.$DayFocusPayload<ExtArgs>[]
      monthFocus: Prisma.$MonthFocusPayload<ExtArgs>
      weekPlan: Prisma.$WeekPlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      weekPlanId: string
      monthFocusId: string
      priority: number
      progress: number
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["weekFocus"]>
    composites: {}
  }

  type WeekFocusGetPayload<S extends boolean | null | undefined | WeekFocusDefaultArgs> = $Result.GetResult<Prisma.$WeekFocusPayload, S>

  type WeekFocusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WeekFocusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WeekFocusCountAggregateInputType | true
    }

  export interface WeekFocusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WeekFocus'], meta: { name: 'WeekFocus' } }
    /**
     * Find zero or one WeekFocus that matches the filter.
     * @param {WeekFocusFindUniqueArgs} args - Arguments to find a WeekFocus
     * @example
     * // Get one WeekFocus
     * const weekFocus = await prisma.weekFocus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeekFocusFindUniqueArgs>(args: SelectSubset<T, WeekFocusFindUniqueArgs<ExtArgs>>): Prisma__WeekFocusClient<$Result.GetResult<Prisma.$WeekFocusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WeekFocus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WeekFocusFindUniqueOrThrowArgs} args - Arguments to find a WeekFocus
     * @example
     * // Get one WeekFocus
     * const weekFocus = await prisma.weekFocus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeekFocusFindUniqueOrThrowArgs>(args: SelectSubset<T, WeekFocusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeekFocusClient<$Result.GetResult<Prisma.$WeekFocusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WeekFocus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekFocusFindFirstArgs} args - Arguments to find a WeekFocus
     * @example
     * // Get one WeekFocus
     * const weekFocus = await prisma.weekFocus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeekFocusFindFirstArgs>(args?: SelectSubset<T, WeekFocusFindFirstArgs<ExtArgs>>): Prisma__WeekFocusClient<$Result.GetResult<Prisma.$WeekFocusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WeekFocus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekFocusFindFirstOrThrowArgs} args - Arguments to find a WeekFocus
     * @example
     * // Get one WeekFocus
     * const weekFocus = await prisma.weekFocus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeekFocusFindFirstOrThrowArgs>(args?: SelectSubset<T, WeekFocusFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeekFocusClient<$Result.GetResult<Prisma.$WeekFocusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WeekFoci that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekFocusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WeekFoci
     * const weekFoci = await prisma.weekFocus.findMany()
     * 
     * // Get first 10 WeekFoci
     * const weekFoci = await prisma.weekFocus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weekFocusWithIdOnly = await prisma.weekFocus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WeekFocusFindManyArgs>(args?: SelectSubset<T, WeekFocusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeekFocusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WeekFocus.
     * @param {WeekFocusCreateArgs} args - Arguments to create a WeekFocus.
     * @example
     * // Create one WeekFocus
     * const WeekFocus = await prisma.weekFocus.create({
     *   data: {
     *     // ... data to create a WeekFocus
     *   }
     * })
     * 
     */
    create<T extends WeekFocusCreateArgs>(args: SelectSubset<T, WeekFocusCreateArgs<ExtArgs>>): Prisma__WeekFocusClient<$Result.GetResult<Prisma.$WeekFocusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WeekFoci.
     * @param {WeekFocusCreateManyArgs} args - Arguments to create many WeekFoci.
     * @example
     * // Create many WeekFoci
     * const weekFocus = await prisma.weekFocus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeekFocusCreateManyArgs>(args?: SelectSubset<T, WeekFocusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WeekFoci and returns the data saved in the database.
     * @param {WeekFocusCreateManyAndReturnArgs} args - Arguments to create many WeekFoci.
     * @example
     * // Create many WeekFoci
     * const weekFocus = await prisma.weekFocus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WeekFoci and only return the `id`
     * const weekFocusWithIdOnly = await prisma.weekFocus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WeekFocusCreateManyAndReturnArgs>(args?: SelectSubset<T, WeekFocusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeekFocusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WeekFocus.
     * @param {WeekFocusDeleteArgs} args - Arguments to delete one WeekFocus.
     * @example
     * // Delete one WeekFocus
     * const WeekFocus = await prisma.weekFocus.delete({
     *   where: {
     *     // ... filter to delete one WeekFocus
     *   }
     * })
     * 
     */
    delete<T extends WeekFocusDeleteArgs>(args: SelectSubset<T, WeekFocusDeleteArgs<ExtArgs>>): Prisma__WeekFocusClient<$Result.GetResult<Prisma.$WeekFocusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WeekFocus.
     * @param {WeekFocusUpdateArgs} args - Arguments to update one WeekFocus.
     * @example
     * // Update one WeekFocus
     * const weekFocus = await prisma.weekFocus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeekFocusUpdateArgs>(args: SelectSubset<T, WeekFocusUpdateArgs<ExtArgs>>): Prisma__WeekFocusClient<$Result.GetResult<Prisma.$WeekFocusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WeekFoci.
     * @param {WeekFocusDeleteManyArgs} args - Arguments to filter WeekFoci to delete.
     * @example
     * // Delete a few WeekFoci
     * const { count } = await prisma.weekFocus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeekFocusDeleteManyArgs>(args?: SelectSubset<T, WeekFocusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeekFoci.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekFocusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WeekFoci
     * const weekFocus = await prisma.weekFocus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeekFocusUpdateManyArgs>(args: SelectSubset<T, WeekFocusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeekFoci and returns the data updated in the database.
     * @param {WeekFocusUpdateManyAndReturnArgs} args - Arguments to update many WeekFoci.
     * @example
     * // Update many WeekFoci
     * const weekFocus = await prisma.weekFocus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WeekFoci and only return the `id`
     * const weekFocusWithIdOnly = await prisma.weekFocus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WeekFocusUpdateManyAndReturnArgs>(args: SelectSubset<T, WeekFocusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeekFocusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WeekFocus.
     * @param {WeekFocusUpsertArgs} args - Arguments to update or create a WeekFocus.
     * @example
     * // Update or create a WeekFocus
     * const weekFocus = await prisma.weekFocus.upsert({
     *   create: {
     *     // ... data to create a WeekFocus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WeekFocus we want to update
     *   }
     * })
     */
    upsert<T extends WeekFocusUpsertArgs>(args: SelectSubset<T, WeekFocusUpsertArgs<ExtArgs>>): Prisma__WeekFocusClient<$Result.GetResult<Prisma.$WeekFocusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WeekFoci.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekFocusCountArgs} args - Arguments to filter WeekFoci to count.
     * @example
     * // Count the number of WeekFoci
     * const count = await prisma.weekFocus.count({
     *   where: {
     *     // ... the filter for the WeekFoci we want to count
     *   }
     * })
    **/
    count<T extends WeekFocusCountArgs>(
      args?: Subset<T, WeekFocusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeekFocusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WeekFocus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekFocusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeekFocusAggregateArgs>(args: Subset<T, WeekFocusAggregateArgs>): Prisma.PrismaPromise<GetWeekFocusAggregateType<T>>

    /**
     * Group by WeekFocus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekFocusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeekFocusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeekFocusGroupByArgs['orderBy'] }
        : { orderBy?: WeekFocusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeekFocusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeekFocusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WeekFocus model
   */
  readonly fields: WeekFocusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WeekFocus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeekFocusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dayFocuses<T extends WeekFocus$dayFocusesArgs<ExtArgs> = {}>(args?: Subset<T, WeekFocus$dayFocusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DayFocusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    monthFocus<T extends MonthFocusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MonthFocusDefaultArgs<ExtArgs>>): Prisma__MonthFocusClient<$Result.GetResult<Prisma.$MonthFocusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    weekPlan<T extends WeekPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WeekPlanDefaultArgs<ExtArgs>>): Prisma__WeekPlanClient<$Result.GetResult<Prisma.$WeekPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WeekFocus model
   */
  interface WeekFocusFieldRefs {
    readonly id: FieldRef<"WeekFocus", 'String'>
    readonly weekPlanId: FieldRef<"WeekFocus", 'String'>
    readonly monthFocusId: FieldRef<"WeekFocus", 'String'>
    readonly priority: FieldRef<"WeekFocus", 'Int'>
    readonly progress: FieldRef<"WeekFocus", 'Float'>
    readonly notes: FieldRef<"WeekFocus", 'String'>
    readonly createdAt: FieldRef<"WeekFocus", 'DateTime'>
    readonly updatedAt: FieldRef<"WeekFocus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WeekFocus findUnique
   */
  export type WeekFocusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekFocus
     */
    select?: WeekFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekFocus
     */
    omit?: WeekFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekFocusInclude<ExtArgs> | null
    /**
     * Filter, which WeekFocus to fetch.
     */
    where: WeekFocusWhereUniqueInput
  }

  /**
   * WeekFocus findUniqueOrThrow
   */
  export type WeekFocusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekFocus
     */
    select?: WeekFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekFocus
     */
    omit?: WeekFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekFocusInclude<ExtArgs> | null
    /**
     * Filter, which WeekFocus to fetch.
     */
    where: WeekFocusWhereUniqueInput
  }

  /**
   * WeekFocus findFirst
   */
  export type WeekFocusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekFocus
     */
    select?: WeekFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekFocus
     */
    omit?: WeekFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekFocusInclude<ExtArgs> | null
    /**
     * Filter, which WeekFocus to fetch.
     */
    where?: WeekFocusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeekFoci to fetch.
     */
    orderBy?: WeekFocusOrderByWithRelationInput | WeekFocusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeekFoci.
     */
    cursor?: WeekFocusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeekFoci from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeekFoci.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeekFoci.
     */
    distinct?: WeekFocusScalarFieldEnum | WeekFocusScalarFieldEnum[]
  }

  /**
   * WeekFocus findFirstOrThrow
   */
  export type WeekFocusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekFocus
     */
    select?: WeekFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekFocus
     */
    omit?: WeekFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekFocusInclude<ExtArgs> | null
    /**
     * Filter, which WeekFocus to fetch.
     */
    where?: WeekFocusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeekFoci to fetch.
     */
    orderBy?: WeekFocusOrderByWithRelationInput | WeekFocusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeekFoci.
     */
    cursor?: WeekFocusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeekFoci from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeekFoci.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeekFoci.
     */
    distinct?: WeekFocusScalarFieldEnum | WeekFocusScalarFieldEnum[]
  }

  /**
   * WeekFocus findMany
   */
  export type WeekFocusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekFocus
     */
    select?: WeekFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekFocus
     */
    omit?: WeekFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekFocusInclude<ExtArgs> | null
    /**
     * Filter, which WeekFoci to fetch.
     */
    where?: WeekFocusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeekFoci to fetch.
     */
    orderBy?: WeekFocusOrderByWithRelationInput | WeekFocusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WeekFoci.
     */
    cursor?: WeekFocusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeekFoci from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeekFoci.
     */
    skip?: number
    distinct?: WeekFocusScalarFieldEnum | WeekFocusScalarFieldEnum[]
  }

  /**
   * WeekFocus create
   */
  export type WeekFocusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekFocus
     */
    select?: WeekFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekFocus
     */
    omit?: WeekFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekFocusInclude<ExtArgs> | null
    /**
     * The data needed to create a WeekFocus.
     */
    data: XOR<WeekFocusCreateInput, WeekFocusUncheckedCreateInput>
  }

  /**
   * WeekFocus createMany
   */
  export type WeekFocusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WeekFoci.
     */
    data: WeekFocusCreateManyInput | WeekFocusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WeekFocus createManyAndReturn
   */
  export type WeekFocusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekFocus
     */
    select?: WeekFocusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WeekFocus
     */
    omit?: WeekFocusOmit<ExtArgs> | null
    /**
     * The data used to create many WeekFoci.
     */
    data: WeekFocusCreateManyInput | WeekFocusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekFocusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WeekFocus update
   */
  export type WeekFocusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekFocus
     */
    select?: WeekFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekFocus
     */
    omit?: WeekFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekFocusInclude<ExtArgs> | null
    /**
     * The data needed to update a WeekFocus.
     */
    data: XOR<WeekFocusUpdateInput, WeekFocusUncheckedUpdateInput>
    /**
     * Choose, which WeekFocus to update.
     */
    where: WeekFocusWhereUniqueInput
  }

  /**
   * WeekFocus updateMany
   */
  export type WeekFocusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WeekFoci.
     */
    data: XOR<WeekFocusUpdateManyMutationInput, WeekFocusUncheckedUpdateManyInput>
    /**
     * Filter which WeekFoci to update
     */
    where?: WeekFocusWhereInput
    /**
     * Limit how many WeekFoci to update.
     */
    limit?: number
  }

  /**
   * WeekFocus updateManyAndReturn
   */
  export type WeekFocusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekFocus
     */
    select?: WeekFocusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WeekFocus
     */
    omit?: WeekFocusOmit<ExtArgs> | null
    /**
     * The data used to update WeekFoci.
     */
    data: XOR<WeekFocusUpdateManyMutationInput, WeekFocusUncheckedUpdateManyInput>
    /**
     * Filter which WeekFoci to update
     */
    where?: WeekFocusWhereInput
    /**
     * Limit how many WeekFoci to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekFocusIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WeekFocus upsert
   */
  export type WeekFocusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekFocus
     */
    select?: WeekFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekFocus
     */
    omit?: WeekFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekFocusInclude<ExtArgs> | null
    /**
     * The filter to search for the WeekFocus to update in case it exists.
     */
    where: WeekFocusWhereUniqueInput
    /**
     * In case the WeekFocus found by the `where` argument doesn't exist, create a new WeekFocus with this data.
     */
    create: XOR<WeekFocusCreateInput, WeekFocusUncheckedCreateInput>
    /**
     * In case the WeekFocus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeekFocusUpdateInput, WeekFocusUncheckedUpdateInput>
  }

  /**
   * WeekFocus delete
   */
  export type WeekFocusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekFocus
     */
    select?: WeekFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekFocus
     */
    omit?: WeekFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekFocusInclude<ExtArgs> | null
    /**
     * Filter which WeekFocus to delete.
     */
    where: WeekFocusWhereUniqueInput
  }

  /**
   * WeekFocus deleteMany
   */
  export type WeekFocusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeekFoci to delete
     */
    where?: WeekFocusWhereInput
    /**
     * Limit how many WeekFoci to delete.
     */
    limit?: number
  }

  /**
   * WeekFocus.dayFocuses
   */
  export type WeekFocus$dayFocusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayFocus
     */
    select?: DayFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayFocus
     */
    omit?: DayFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayFocusInclude<ExtArgs> | null
    where?: DayFocusWhereInput
    orderBy?: DayFocusOrderByWithRelationInput | DayFocusOrderByWithRelationInput[]
    cursor?: DayFocusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DayFocusScalarFieldEnum | DayFocusScalarFieldEnum[]
  }

  /**
   * WeekFocus without action
   */
  export type WeekFocusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekFocus
     */
    select?: WeekFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekFocus
     */
    omit?: WeekFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekFocusInclude<ExtArgs> | null
  }


  /**
   * Model DayPlan
   */

  export type AggregateDayPlan = {
    _count: DayPlanCountAggregateOutputType | null
    _avg: DayPlanAvgAggregateOutputType | null
    _sum: DayPlanSumAggregateOutputType | null
    _min: DayPlanMinAggregateOutputType | null
    _max: DayPlanMaxAggregateOutputType | null
  }

  export type DayPlanAvgAggregateOutputType = {
    morningEnergy: number | null
    afternoonEnergy: number | null
    eveningEnergy: number | null
    completionRate: number | null
  }

  export type DayPlanSumAggregateOutputType = {
    morningEnergy: number | null
    afternoonEnergy: number | null
    eveningEnergy: number | null
    completionRate: number | null
  }

  export type DayPlanMinAggregateOutputType = {
    id: string | null
    weekPlanId: string | null
    date: Date | null
    morningEnergy: number | null
    afternoonEnergy: number | null
    eveningEnergy: number | null
    dailyWin: string | null
    completionRate: number | null
    userId: string | null
  }

  export type DayPlanMaxAggregateOutputType = {
    id: string | null
    weekPlanId: string | null
    date: Date | null
    morningEnergy: number | null
    afternoonEnergy: number | null
    eveningEnergy: number | null
    dailyWin: string | null
    completionRate: number | null
    userId: string | null
  }

  export type DayPlanCountAggregateOutputType = {
    id: number
    weekPlanId: number
    date: number
    topPriorities: number
    morningEnergy: number
    afternoonEnergy: number
    eveningEnergy: number
    dailyWin: number
    gratitude: number
    tomorrowPrep: number
    completionRate: number
    userId: number
    _all: number
  }


  export type DayPlanAvgAggregateInputType = {
    morningEnergy?: true
    afternoonEnergy?: true
    eveningEnergy?: true
    completionRate?: true
  }

  export type DayPlanSumAggregateInputType = {
    morningEnergy?: true
    afternoonEnergy?: true
    eveningEnergy?: true
    completionRate?: true
  }

  export type DayPlanMinAggregateInputType = {
    id?: true
    weekPlanId?: true
    date?: true
    morningEnergy?: true
    afternoonEnergy?: true
    eveningEnergy?: true
    dailyWin?: true
    completionRate?: true
    userId?: true
  }

  export type DayPlanMaxAggregateInputType = {
    id?: true
    weekPlanId?: true
    date?: true
    morningEnergy?: true
    afternoonEnergy?: true
    eveningEnergy?: true
    dailyWin?: true
    completionRate?: true
    userId?: true
  }

  export type DayPlanCountAggregateInputType = {
    id?: true
    weekPlanId?: true
    date?: true
    topPriorities?: true
    morningEnergy?: true
    afternoonEnergy?: true
    eveningEnergy?: true
    dailyWin?: true
    gratitude?: true
    tomorrowPrep?: true
    completionRate?: true
    userId?: true
    _all?: true
  }

  export type DayPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DayPlan to aggregate.
     */
    where?: DayPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DayPlans to fetch.
     */
    orderBy?: DayPlanOrderByWithRelationInput | DayPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DayPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DayPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DayPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DayPlans
    **/
    _count?: true | DayPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DayPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DayPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DayPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DayPlanMaxAggregateInputType
  }

  export type GetDayPlanAggregateType<T extends DayPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateDayPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDayPlan[P]>
      : GetScalarType<T[P], AggregateDayPlan[P]>
  }




  export type DayPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DayPlanWhereInput
    orderBy?: DayPlanOrderByWithAggregationInput | DayPlanOrderByWithAggregationInput[]
    by: DayPlanScalarFieldEnum[] | DayPlanScalarFieldEnum
    having?: DayPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DayPlanCountAggregateInputType | true
    _avg?: DayPlanAvgAggregateInputType
    _sum?: DayPlanSumAggregateInputType
    _min?: DayPlanMinAggregateInputType
    _max?: DayPlanMaxAggregateInputType
  }

  export type DayPlanGroupByOutputType = {
    id: string
    weekPlanId: string
    date: Date
    topPriorities: string[]
    morningEnergy: number | null
    afternoonEnergy: number | null
    eveningEnergy: number | null
    dailyWin: string | null
    gratitude: string[]
    tomorrowPrep: string[]
    completionRate: number
    userId: string
    _count: DayPlanCountAggregateOutputType | null
    _avg: DayPlanAvgAggregateOutputType | null
    _sum: DayPlanSumAggregateOutputType | null
    _min: DayPlanMinAggregateOutputType | null
    _max: DayPlanMaxAggregateOutputType | null
  }

  type GetDayPlanGroupByPayload<T extends DayPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DayPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DayPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DayPlanGroupByOutputType[P]>
            : GetScalarType<T[P], DayPlanGroupByOutputType[P]>
        }
      >
    >


  export type DayPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    weekPlanId?: boolean
    date?: boolean
    topPriorities?: boolean
    morningEnergy?: boolean
    afternoonEnergy?: boolean
    eveningEnergy?: boolean
    dailyWin?: boolean
    gratitude?: boolean
    tomorrowPrep?: boolean
    completionRate?: boolean
    userId?: boolean
    dayFocuses?: boolean | DayPlan$dayFocusesArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    weekPlan?: boolean | WeekPlanDefaultArgs<ExtArgs>
    notes?: boolean | DayPlan$notesArgs<ExtArgs>
    timeBlocks?: boolean | DayPlan$timeBlocksArgs<ExtArgs>
    _count?: boolean | DayPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dayPlan"]>

  export type DayPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    weekPlanId?: boolean
    date?: boolean
    topPriorities?: boolean
    morningEnergy?: boolean
    afternoonEnergy?: boolean
    eveningEnergy?: boolean
    dailyWin?: boolean
    gratitude?: boolean
    tomorrowPrep?: boolean
    completionRate?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    weekPlan?: boolean | WeekPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dayPlan"]>

  export type DayPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    weekPlanId?: boolean
    date?: boolean
    topPriorities?: boolean
    morningEnergy?: boolean
    afternoonEnergy?: boolean
    eveningEnergy?: boolean
    dailyWin?: boolean
    gratitude?: boolean
    tomorrowPrep?: boolean
    completionRate?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    weekPlan?: boolean | WeekPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dayPlan"]>

  export type DayPlanSelectScalar = {
    id?: boolean
    weekPlanId?: boolean
    date?: boolean
    topPriorities?: boolean
    morningEnergy?: boolean
    afternoonEnergy?: boolean
    eveningEnergy?: boolean
    dailyWin?: boolean
    gratitude?: boolean
    tomorrowPrep?: boolean
    completionRate?: boolean
    userId?: boolean
  }

  export type DayPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "weekPlanId" | "date" | "topPriorities" | "morningEnergy" | "afternoonEnergy" | "eveningEnergy" | "dailyWin" | "gratitude" | "tomorrowPrep" | "completionRate" | "userId", ExtArgs["result"]["dayPlan"]>
  export type DayPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dayFocuses?: boolean | DayPlan$dayFocusesArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    weekPlan?: boolean | WeekPlanDefaultArgs<ExtArgs>
    notes?: boolean | DayPlan$notesArgs<ExtArgs>
    timeBlocks?: boolean | DayPlan$timeBlocksArgs<ExtArgs>
    _count?: boolean | DayPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DayPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    weekPlan?: boolean | WeekPlanDefaultArgs<ExtArgs>
  }
  export type DayPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    weekPlan?: boolean | WeekPlanDefaultArgs<ExtArgs>
  }

  export type $DayPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DayPlan"
    objects: {
      dayFocuses: Prisma.$DayFocusPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
      weekPlan: Prisma.$WeekPlanPayload<ExtArgs>
      notes: Prisma.$NotePayload<ExtArgs>[]
      timeBlocks: Prisma.$TimeBlockPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      weekPlanId: string
      date: Date
      topPriorities: string[]
      morningEnergy: number | null
      afternoonEnergy: number | null
      eveningEnergy: number | null
      dailyWin: string | null
      gratitude: string[]
      tomorrowPrep: string[]
      completionRate: number
      userId: string
    }, ExtArgs["result"]["dayPlan"]>
    composites: {}
  }

  type DayPlanGetPayload<S extends boolean | null | undefined | DayPlanDefaultArgs> = $Result.GetResult<Prisma.$DayPlanPayload, S>

  type DayPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DayPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DayPlanCountAggregateInputType | true
    }

  export interface DayPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DayPlan'], meta: { name: 'DayPlan' } }
    /**
     * Find zero or one DayPlan that matches the filter.
     * @param {DayPlanFindUniqueArgs} args - Arguments to find a DayPlan
     * @example
     * // Get one DayPlan
     * const dayPlan = await prisma.dayPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DayPlanFindUniqueArgs>(args: SelectSubset<T, DayPlanFindUniqueArgs<ExtArgs>>): Prisma__DayPlanClient<$Result.GetResult<Prisma.$DayPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DayPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DayPlanFindUniqueOrThrowArgs} args - Arguments to find a DayPlan
     * @example
     * // Get one DayPlan
     * const dayPlan = await prisma.dayPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DayPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, DayPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DayPlanClient<$Result.GetResult<Prisma.$DayPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DayPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayPlanFindFirstArgs} args - Arguments to find a DayPlan
     * @example
     * // Get one DayPlan
     * const dayPlan = await prisma.dayPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DayPlanFindFirstArgs>(args?: SelectSubset<T, DayPlanFindFirstArgs<ExtArgs>>): Prisma__DayPlanClient<$Result.GetResult<Prisma.$DayPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DayPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayPlanFindFirstOrThrowArgs} args - Arguments to find a DayPlan
     * @example
     * // Get one DayPlan
     * const dayPlan = await prisma.dayPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DayPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, DayPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__DayPlanClient<$Result.GetResult<Prisma.$DayPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DayPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DayPlans
     * const dayPlans = await prisma.dayPlan.findMany()
     * 
     * // Get first 10 DayPlans
     * const dayPlans = await prisma.dayPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dayPlanWithIdOnly = await prisma.dayPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DayPlanFindManyArgs>(args?: SelectSubset<T, DayPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DayPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DayPlan.
     * @param {DayPlanCreateArgs} args - Arguments to create a DayPlan.
     * @example
     * // Create one DayPlan
     * const DayPlan = await prisma.dayPlan.create({
     *   data: {
     *     // ... data to create a DayPlan
     *   }
     * })
     * 
     */
    create<T extends DayPlanCreateArgs>(args: SelectSubset<T, DayPlanCreateArgs<ExtArgs>>): Prisma__DayPlanClient<$Result.GetResult<Prisma.$DayPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DayPlans.
     * @param {DayPlanCreateManyArgs} args - Arguments to create many DayPlans.
     * @example
     * // Create many DayPlans
     * const dayPlan = await prisma.dayPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DayPlanCreateManyArgs>(args?: SelectSubset<T, DayPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DayPlans and returns the data saved in the database.
     * @param {DayPlanCreateManyAndReturnArgs} args - Arguments to create many DayPlans.
     * @example
     * // Create many DayPlans
     * const dayPlan = await prisma.dayPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DayPlans and only return the `id`
     * const dayPlanWithIdOnly = await prisma.dayPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DayPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, DayPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DayPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DayPlan.
     * @param {DayPlanDeleteArgs} args - Arguments to delete one DayPlan.
     * @example
     * // Delete one DayPlan
     * const DayPlan = await prisma.dayPlan.delete({
     *   where: {
     *     // ... filter to delete one DayPlan
     *   }
     * })
     * 
     */
    delete<T extends DayPlanDeleteArgs>(args: SelectSubset<T, DayPlanDeleteArgs<ExtArgs>>): Prisma__DayPlanClient<$Result.GetResult<Prisma.$DayPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DayPlan.
     * @param {DayPlanUpdateArgs} args - Arguments to update one DayPlan.
     * @example
     * // Update one DayPlan
     * const dayPlan = await prisma.dayPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DayPlanUpdateArgs>(args: SelectSubset<T, DayPlanUpdateArgs<ExtArgs>>): Prisma__DayPlanClient<$Result.GetResult<Prisma.$DayPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DayPlans.
     * @param {DayPlanDeleteManyArgs} args - Arguments to filter DayPlans to delete.
     * @example
     * // Delete a few DayPlans
     * const { count } = await prisma.dayPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DayPlanDeleteManyArgs>(args?: SelectSubset<T, DayPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DayPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DayPlans
     * const dayPlan = await prisma.dayPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DayPlanUpdateManyArgs>(args: SelectSubset<T, DayPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DayPlans and returns the data updated in the database.
     * @param {DayPlanUpdateManyAndReturnArgs} args - Arguments to update many DayPlans.
     * @example
     * // Update many DayPlans
     * const dayPlan = await prisma.dayPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DayPlans and only return the `id`
     * const dayPlanWithIdOnly = await prisma.dayPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DayPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, DayPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DayPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DayPlan.
     * @param {DayPlanUpsertArgs} args - Arguments to update or create a DayPlan.
     * @example
     * // Update or create a DayPlan
     * const dayPlan = await prisma.dayPlan.upsert({
     *   create: {
     *     // ... data to create a DayPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DayPlan we want to update
     *   }
     * })
     */
    upsert<T extends DayPlanUpsertArgs>(args: SelectSubset<T, DayPlanUpsertArgs<ExtArgs>>): Prisma__DayPlanClient<$Result.GetResult<Prisma.$DayPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DayPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayPlanCountArgs} args - Arguments to filter DayPlans to count.
     * @example
     * // Count the number of DayPlans
     * const count = await prisma.dayPlan.count({
     *   where: {
     *     // ... the filter for the DayPlans we want to count
     *   }
     * })
    **/
    count<T extends DayPlanCountArgs>(
      args?: Subset<T, DayPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DayPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DayPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DayPlanAggregateArgs>(args: Subset<T, DayPlanAggregateArgs>): Prisma.PrismaPromise<GetDayPlanAggregateType<T>>

    /**
     * Group by DayPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DayPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DayPlanGroupByArgs['orderBy'] }
        : { orderBy?: DayPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DayPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDayPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DayPlan model
   */
  readonly fields: DayPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DayPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DayPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dayFocuses<T extends DayPlan$dayFocusesArgs<ExtArgs> = {}>(args?: Subset<T, DayPlan$dayFocusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DayFocusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    weekPlan<T extends WeekPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WeekPlanDefaultArgs<ExtArgs>>): Prisma__WeekPlanClient<$Result.GetResult<Prisma.$WeekPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    notes<T extends DayPlan$notesArgs<ExtArgs> = {}>(args?: Subset<T, DayPlan$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    timeBlocks<T extends DayPlan$timeBlocksArgs<ExtArgs> = {}>(args?: Subset<T, DayPlan$timeBlocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeBlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DayPlan model
   */
  interface DayPlanFieldRefs {
    readonly id: FieldRef<"DayPlan", 'String'>
    readonly weekPlanId: FieldRef<"DayPlan", 'String'>
    readonly date: FieldRef<"DayPlan", 'DateTime'>
    readonly topPriorities: FieldRef<"DayPlan", 'String[]'>
    readonly morningEnergy: FieldRef<"DayPlan", 'Float'>
    readonly afternoonEnergy: FieldRef<"DayPlan", 'Float'>
    readonly eveningEnergy: FieldRef<"DayPlan", 'Float'>
    readonly dailyWin: FieldRef<"DayPlan", 'String'>
    readonly gratitude: FieldRef<"DayPlan", 'String[]'>
    readonly tomorrowPrep: FieldRef<"DayPlan", 'String[]'>
    readonly completionRate: FieldRef<"DayPlan", 'Float'>
    readonly userId: FieldRef<"DayPlan", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DayPlan findUnique
   */
  export type DayPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayPlan
     */
    select?: DayPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayPlan
     */
    omit?: DayPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayPlanInclude<ExtArgs> | null
    /**
     * Filter, which DayPlan to fetch.
     */
    where: DayPlanWhereUniqueInput
  }

  /**
   * DayPlan findUniqueOrThrow
   */
  export type DayPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayPlan
     */
    select?: DayPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayPlan
     */
    omit?: DayPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayPlanInclude<ExtArgs> | null
    /**
     * Filter, which DayPlan to fetch.
     */
    where: DayPlanWhereUniqueInput
  }

  /**
   * DayPlan findFirst
   */
  export type DayPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayPlan
     */
    select?: DayPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayPlan
     */
    omit?: DayPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayPlanInclude<ExtArgs> | null
    /**
     * Filter, which DayPlan to fetch.
     */
    where?: DayPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DayPlans to fetch.
     */
    orderBy?: DayPlanOrderByWithRelationInput | DayPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DayPlans.
     */
    cursor?: DayPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DayPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DayPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DayPlans.
     */
    distinct?: DayPlanScalarFieldEnum | DayPlanScalarFieldEnum[]
  }

  /**
   * DayPlan findFirstOrThrow
   */
  export type DayPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayPlan
     */
    select?: DayPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayPlan
     */
    omit?: DayPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayPlanInclude<ExtArgs> | null
    /**
     * Filter, which DayPlan to fetch.
     */
    where?: DayPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DayPlans to fetch.
     */
    orderBy?: DayPlanOrderByWithRelationInput | DayPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DayPlans.
     */
    cursor?: DayPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DayPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DayPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DayPlans.
     */
    distinct?: DayPlanScalarFieldEnum | DayPlanScalarFieldEnum[]
  }

  /**
   * DayPlan findMany
   */
  export type DayPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayPlan
     */
    select?: DayPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayPlan
     */
    omit?: DayPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayPlanInclude<ExtArgs> | null
    /**
     * Filter, which DayPlans to fetch.
     */
    where?: DayPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DayPlans to fetch.
     */
    orderBy?: DayPlanOrderByWithRelationInput | DayPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DayPlans.
     */
    cursor?: DayPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DayPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DayPlans.
     */
    skip?: number
    distinct?: DayPlanScalarFieldEnum | DayPlanScalarFieldEnum[]
  }

  /**
   * DayPlan create
   */
  export type DayPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayPlan
     */
    select?: DayPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayPlan
     */
    omit?: DayPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a DayPlan.
     */
    data: XOR<DayPlanCreateInput, DayPlanUncheckedCreateInput>
  }

  /**
   * DayPlan createMany
   */
  export type DayPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DayPlans.
     */
    data: DayPlanCreateManyInput | DayPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DayPlan createManyAndReturn
   */
  export type DayPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayPlan
     */
    select?: DayPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DayPlan
     */
    omit?: DayPlanOmit<ExtArgs> | null
    /**
     * The data used to create many DayPlans.
     */
    data: DayPlanCreateManyInput | DayPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DayPlan update
   */
  export type DayPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayPlan
     */
    select?: DayPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayPlan
     */
    omit?: DayPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a DayPlan.
     */
    data: XOR<DayPlanUpdateInput, DayPlanUncheckedUpdateInput>
    /**
     * Choose, which DayPlan to update.
     */
    where: DayPlanWhereUniqueInput
  }

  /**
   * DayPlan updateMany
   */
  export type DayPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DayPlans.
     */
    data: XOR<DayPlanUpdateManyMutationInput, DayPlanUncheckedUpdateManyInput>
    /**
     * Filter which DayPlans to update
     */
    where?: DayPlanWhereInput
    /**
     * Limit how many DayPlans to update.
     */
    limit?: number
  }

  /**
   * DayPlan updateManyAndReturn
   */
  export type DayPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayPlan
     */
    select?: DayPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DayPlan
     */
    omit?: DayPlanOmit<ExtArgs> | null
    /**
     * The data used to update DayPlans.
     */
    data: XOR<DayPlanUpdateManyMutationInput, DayPlanUncheckedUpdateManyInput>
    /**
     * Filter which DayPlans to update
     */
    where?: DayPlanWhereInput
    /**
     * Limit how many DayPlans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayPlanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DayPlan upsert
   */
  export type DayPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayPlan
     */
    select?: DayPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayPlan
     */
    omit?: DayPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the DayPlan to update in case it exists.
     */
    where: DayPlanWhereUniqueInput
    /**
     * In case the DayPlan found by the `where` argument doesn't exist, create a new DayPlan with this data.
     */
    create: XOR<DayPlanCreateInput, DayPlanUncheckedCreateInput>
    /**
     * In case the DayPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DayPlanUpdateInput, DayPlanUncheckedUpdateInput>
  }

  /**
   * DayPlan delete
   */
  export type DayPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayPlan
     */
    select?: DayPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayPlan
     */
    omit?: DayPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayPlanInclude<ExtArgs> | null
    /**
     * Filter which DayPlan to delete.
     */
    where: DayPlanWhereUniqueInput
  }

  /**
   * DayPlan deleteMany
   */
  export type DayPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DayPlans to delete
     */
    where?: DayPlanWhereInput
    /**
     * Limit how many DayPlans to delete.
     */
    limit?: number
  }

  /**
   * DayPlan.dayFocuses
   */
  export type DayPlan$dayFocusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayFocus
     */
    select?: DayFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayFocus
     */
    omit?: DayFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayFocusInclude<ExtArgs> | null
    where?: DayFocusWhereInput
    orderBy?: DayFocusOrderByWithRelationInput | DayFocusOrderByWithRelationInput[]
    cursor?: DayFocusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DayFocusScalarFieldEnum | DayFocusScalarFieldEnum[]
  }

  /**
   * DayPlan.notes
   */
  export type DayPlan$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    cursor?: NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * DayPlan.timeBlocks
   */
  export type DayPlan$timeBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeBlock
     */
    select?: TimeBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeBlock
     */
    omit?: TimeBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeBlockInclude<ExtArgs> | null
    where?: TimeBlockWhereInput
    orderBy?: TimeBlockOrderByWithRelationInput | TimeBlockOrderByWithRelationInput[]
    cursor?: TimeBlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeBlockScalarFieldEnum | TimeBlockScalarFieldEnum[]
  }

  /**
   * DayPlan without action
   */
  export type DayPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayPlan
     */
    select?: DayPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayPlan
     */
    omit?: DayPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayPlanInclude<ExtArgs> | null
  }


  /**
   * Model DayFocus
   */

  export type AggregateDayFocus = {
    _count: DayFocusCountAggregateOutputType | null
    _avg: DayFocusAvgAggregateOutputType | null
    _sum: DayFocusSumAggregateOutputType | null
    _min: DayFocusMinAggregateOutputType | null
    _max: DayFocusMaxAggregateOutputType | null
  }

  export type DayFocusAvgAggregateOutputType = {
    priority: number | null
  }

  export type DayFocusSumAggregateOutputType = {
    priority: number | null
  }

  export type DayFocusMinAggregateOutputType = {
    id: string | null
    dayPlanId: string | null
    weekFocusId: string | null
    priority: number | null
    completed: boolean | null
    completedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DayFocusMaxAggregateOutputType = {
    id: string | null
    dayPlanId: string | null
    weekFocusId: string | null
    priority: number | null
    completed: boolean | null
    completedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DayFocusCountAggregateOutputType = {
    id: number
    dayPlanId: number
    weekFocusId: number
    priority: number
    completed: number
    completedAt: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DayFocusAvgAggregateInputType = {
    priority?: true
  }

  export type DayFocusSumAggregateInputType = {
    priority?: true
  }

  export type DayFocusMinAggregateInputType = {
    id?: true
    dayPlanId?: true
    weekFocusId?: true
    priority?: true
    completed?: true
    completedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DayFocusMaxAggregateInputType = {
    id?: true
    dayPlanId?: true
    weekFocusId?: true
    priority?: true
    completed?: true
    completedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DayFocusCountAggregateInputType = {
    id?: true
    dayPlanId?: true
    weekFocusId?: true
    priority?: true
    completed?: true
    completedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DayFocusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DayFocus to aggregate.
     */
    where?: DayFocusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DayFoci to fetch.
     */
    orderBy?: DayFocusOrderByWithRelationInput | DayFocusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DayFocusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DayFoci from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DayFoci.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DayFoci
    **/
    _count?: true | DayFocusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DayFocusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DayFocusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DayFocusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DayFocusMaxAggregateInputType
  }

  export type GetDayFocusAggregateType<T extends DayFocusAggregateArgs> = {
        [P in keyof T & keyof AggregateDayFocus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDayFocus[P]>
      : GetScalarType<T[P], AggregateDayFocus[P]>
  }




  export type DayFocusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DayFocusWhereInput
    orderBy?: DayFocusOrderByWithAggregationInput | DayFocusOrderByWithAggregationInput[]
    by: DayFocusScalarFieldEnum[] | DayFocusScalarFieldEnum
    having?: DayFocusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DayFocusCountAggregateInputType | true
    _avg?: DayFocusAvgAggregateInputType
    _sum?: DayFocusSumAggregateInputType
    _min?: DayFocusMinAggregateInputType
    _max?: DayFocusMaxAggregateInputType
  }

  export type DayFocusGroupByOutputType = {
    id: string
    dayPlanId: string
    weekFocusId: string
    priority: number
    completed: boolean
    completedAt: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: DayFocusCountAggregateOutputType | null
    _avg: DayFocusAvgAggregateOutputType | null
    _sum: DayFocusSumAggregateOutputType | null
    _min: DayFocusMinAggregateOutputType | null
    _max: DayFocusMaxAggregateOutputType | null
  }

  type GetDayFocusGroupByPayload<T extends DayFocusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DayFocusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DayFocusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DayFocusGroupByOutputType[P]>
            : GetScalarType<T[P], DayFocusGroupByOutputType[P]>
        }
      >
    >


  export type DayFocusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dayPlanId?: boolean
    weekFocusId?: boolean
    priority?: boolean
    completed?: boolean
    completedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dayPlan?: boolean | DayPlanDefaultArgs<ExtArgs>
    weekFocus?: boolean | WeekFocusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dayFocus"]>

  export type DayFocusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dayPlanId?: boolean
    weekFocusId?: boolean
    priority?: boolean
    completed?: boolean
    completedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dayPlan?: boolean | DayPlanDefaultArgs<ExtArgs>
    weekFocus?: boolean | WeekFocusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dayFocus"]>

  export type DayFocusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dayPlanId?: boolean
    weekFocusId?: boolean
    priority?: boolean
    completed?: boolean
    completedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dayPlan?: boolean | DayPlanDefaultArgs<ExtArgs>
    weekFocus?: boolean | WeekFocusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dayFocus"]>

  export type DayFocusSelectScalar = {
    id?: boolean
    dayPlanId?: boolean
    weekFocusId?: boolean
    priority?: boolean
    completed?: boolean
    completedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DayFocusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dayPlanId" | "weekFocusId" | "priority" | "completed" | "completedAt" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["dayFocus"]>
  export type DayFocusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dayPlan?: boolean | DayPlanDefaultArgs<ExtArgs>
    weekFocus?: boolean | WeekFocusDefaultArgs<ExtArgs>
  }
  export type DayFocusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dayPlan?: boolean | DayPlanDefaultArgs<ExtArgs>
    weekFocus?: boolean | WeekFocusDefaultArgs<ExtArgs>
  }
  export type DayFocusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dayPlan?: boolean | DayPlanDefaultArgs<ExtArgs>
    weekFocus?: boolean | WeekFocusDefaultArgs<ExtArgs>
  }

  export type $DayFocusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DayFocus"
    objects: {
      dayPlan: Prisma.$DayPlanPayload<ExtArgs>
      weekFocus: Prisma.$WeekFocusPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dayPlanId: string
      weekFocusId: string
      priority: number
      completed: boolean
      completedAt: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dayFocus"]>
    composites: {}
  }

  type DayFocusGetPayload<S extends boolean | null | undefined | DayFocusDefaultArgs> = $Result.GetResult<Prisma.$DayFocusPayload, S>

  type DayFocusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DayFocusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DayFocusCountAggregateInputType | true
    }

  export interface DayFocusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DayFocus'], meta: { name: 'DayFocus' } }
    /**
     * Find zero or one DayFocus that matches the filter.
     * @param {DayFocusFindUniqueArgs} args - Arguments to find a DayFocus
     * @example
     * // Get one DayFocus
     * const dayFocus = await prisma.dayFocus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DayFocusFindUniqueArgs>(args: SelectSubset<T, DayFocusFindUniqueArgs<ExtArgs>>): Prisma__DayFocusClient<$Result.GetResult<Prisma.$DayFocusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DayFocus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DayFocusFindUniqueOrThrowArgs} args - Arguments to find a DayFocus
     * @example
     * // Get one DayFocus
     * const dayFocus = await prisma.dayFocus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DayFocusFindUniqueOrThrowArgs>(args: SelectSubset<T, DayFocusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DayFocusClient<$Result.GetResult<Prisma.$DayFocusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DayFocus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayFocusFindFirstArgs} args - Arguments to find a DayFocus
     * @example
     * // Get one DayFocus
     * const dayFocus = await prisma.dayFocus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DayFocusFindFirstArgs>(args?: SelectSubset<T, DayFocusFindFirstArgs<ExtArgs>>): Prisma__DayFocusClient<$Result.GetResult<Prisma.$DayFocusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DayFocus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayFocusFindFirstOrThrowArgs} args - Arguments to find a DayFocus
     * @example
     * // Get one DayFocus
     * const dayFocus = await prisma.dayFocus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DayFocusFindFirstOrThrowArgs>(args?: SelectSubset<T, DayFocusFindFirstOrThrowArgs<ExtArgs>>): Prisma__DayFocusClient<$Result.GetResult<Prisma.$DayFocusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DayFoci that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayFocusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DayFoci
     * const dayFoci = await prisma.dayFocus.findMany()
     * 
     * // Get first 10 DayFoci
     * const dayFoci = await prisma.dayFocus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dayFocusWithIdOnly = await prisma.dayFocus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DayFocusFindManyArgs>(args?: SelectSubset<T, DayFocusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DayFocusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DayFocus.
     * @param {DayFocusCreateArgs} args - Arguments to create a DayFocus.
     * @example
     * // Create one DayFocus
     * const DayFocus = await prisma.dayFocus.create({
     *   data: {
     *     // ... data to create a DayFocus
     *   }
     * })
     * 
     */
    create<T extends DayFocusCreateArgs>(args: SelectSubset<T, DayFocusCreateArgs<ExtArgs>>): Prisma__DayFocusClient<$Result.GetResult<Prisma.$DayFocusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DayFoci.
     * @param {DayFocusCreateManyArgs} args - Arguments to create many DayFoci.
     * @example
     * // Create many DayFoci
     * const dayFocus = await prisma.dayFocus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DayFocusCreateManyArgs>(args?: SelectSubset<T, DayFocusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DayFoci and returns the data saved in the database.
     * @param {DayFocusCreateManyAndReturnArgs} args - Arguments to create many DayFoci.
     * @example
     * // Create many DayFoci
     * const dayFocus = await prisma.dayFocus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DayFoci and only return the `id`
     * const dayFocusWithIdOnly = await prisma.dayFocus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DayFocusCreateManyAndReturnArgs>(args?: SelectSubset<T, DayFocusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DayFocusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DayFocus.
     * @param {DayFocusDeleteArgs} args - Arguments to delete one DayFocus.
     * @example
     * // Delete one DayFocus
     * const DayFocus = await prisma.dayFocus.delete({
     *   where: {
     *     // ... filter to delete one DayFocus
     *   }
     * })
     * 
     */
    delete<T extends DayFocusDeleteArgs>(args: SelectSubset<T, DayFocusDeleteArgs<ExtArgs>>): Prisma__DayFocusClient<$Result.GetResult<Prisma.$DayFocusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DayFocus.
     * @param {DayFocusUpdateArgs} args - Arguments to update one DayFocus.
     * @example
     * // Update one DayFocus
     * const dayFocus = await prisma.dayFocus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DayFocusUpdateArgs>(args: SelectSubset<T, DayFocusUpdateArgs<ExtArgs>>): Prisma__DayFocusClient<$Result.GetResult<Prisma.$DayFocusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DayFoci.
     * @param {DayFocusDeleteManyArgs} args - Arguments to filter DayFoci to delete.
     * @example
     * // Delete a few DayFoci
     * const { count } = await prisma.dayFocus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DayFocusDeleteManyArgs>(args?: SelectSubset<T, DayFocusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DayFoci.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayFocusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DayFoci
     * const dayFocus = await prisma.dayFocus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DayFocusUpdateManyArgs>(args: SelectSubset<T, DayFocusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DayFoci and returns the data updated in the database.
     * @param {DayFocusUpdateManyAndReturnArgs} args - Arguments to update many DayFoci.
     * @example
     * // Update many DayFoci
     * const dayFocus = await prisma.dayFocus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DayFoci and only return the `id`
     * const dayFocusWithIdOnly = await prisma.dayFocus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DayFocusUpdateManyAndReturnArgs>(args: SelectSubset<T, DayFocusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DayFocusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DayFocus.
     * @param {DayFocusUpsertArgs} args - Arguments to update or create a DayFocus.
     * @example
     * // Update or create a DayFocus
     * const dayFocus = await prisma.dayFocus.upsert({
     *   create: {
     *     // ... data to create a DayFocus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DayFocus we want to update
     *   }
     * })
     */
    upsert<T extends DayFocusUpsertArgs>(args: SelectSubset<T, DayFocusUpsertArgs<ExtArgs>>): Prisma__DayFocusClient<$Result.GetResult<Prisma.$DayFocusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DayFoci.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayFocusCountArgs} args - Arguments to filter DayFoci to count.
     * @example
     * // Count the number of DayFoci
     * const count = await prisma.dayFocus.count({
     *   where: {
     *     // ... the filter for the DayFoci we want to count
     *   }
     * })
    **/
    count<T extends DayFocusCountArgs>(
      args?: Subset<T, DayFocusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DayFocusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DayFocus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayFocusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DayFocusAggregateArgs>(args: Subset<T, DayFocusAggregateArgs>): Prisma.PrismaPromise<GetDayFocusAggregateType<T>>

    /**
     * Group by DayFocus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayFocusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DayFocusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DayFocusGroupByArgs['orderBy'] }
        : { orderBy?: DayFocusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DayFocusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDayFocusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DayFocus model
   */
  readonly fields: DayFocusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DayFocus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DayFocusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dayPlan<T extends DayPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DayPlanDefaultArgs<ExtArgs>>): Prisma__DayPlanClient<$Result.GetResult<Prisma.$DayPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    weekFocus<T extends WeekFocusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WeekFocusDefaultArgs<ExtArgs>>): Prisma__WeekFocusClient<$Result.GetResult<Prisma.$WeekFocusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DayFocus model
   */
  interface DayFocusFieldRefs {
    readonly id: FieldRef<"DayFocus", 'String'>
    readonly dayPlanId: FieldRef<"DayFocus", 'String'>
    readonly weekFocusId: FieldRef<"DayFocus", 'String'>
    readonly priority: FieldRef<"DayFocus", 'Int'>
    readonly completed: FieldRef<"DayFocus", 'Boolean'>
    readonly completedAt: FieldRef<"DayFocus", 'DateTime'>
    readonly notes: FieldRef<"DayFocus", 'String'>
    readonly createdAt: FieldRef<"DayFocus", 'DateTime'>
    readonly updatedAt: FieldRef<"DayFocus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DayFocus findUnique
   */
  export type DayFocusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayFocus
     */
    select?: DayFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayFocus
     */
    omit?: DayFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayFocusInclude<ExtArgs> | null
    /**
     * Filter, which DayFocus to fetch.
     */
    where: DayFocusWhereUniqueInput
  }

  /**
   * DayFocus findUniqueOrThrow
   */
  export type DayFocusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayFocus
     */
    select?: DayFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayFocus
     */
    omit?: DayFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayFocusInclude<ExtArgs> | null
    /**
     * Filter, which DayFocus to fetch.
     */
    where: DayFocusWhereUniqueInput
  }

  /**
   * DayFocus findFirst
   */
  export type DayFocusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayFocus
     */
    select?: DayFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayFocus
     */
    omit?: DayFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayFocusInclude<ExtArgs> | null
    /**
     * Filter, which DayFocus to fetch.
     */
    where?: DayFocusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DayFoci to fetch.
     */
    orderBy?: DayFocusOrderByWithRelationInput | DayFocusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DayFoci.
     */
    cursor?: DayFocusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DayFoci from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DayFoci.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DayFoci.
     */
    distinct?: DayFocusScalarFieldEnum | DayFocusScalarFieldEnum[]
  }

  /**
   * DayFocus findFirstOrThrow
   */
  export type DayFocusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayFocus
     */
    select?: DayFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayFocus
     */
    omit?: DayFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayFocusInclude<ExtArgs> | null
    /**
     * Filter, which DayFocus to fetch.
     */
    where?: DayFocusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DayFoci to fetch.
     */
    orderBy?: DayFocusOrderByWithRelationInput | DayFocusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DayFoci.
     */
    cursor?: DayFocusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DayFoci from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DayFoci.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DayFoci.
     */
    distinct?: DayFocusScalarFieldEnum | DayFocusScalarFieldEnum[]
  }

  /**
   * DayFocus findMany
   */
  export type DayFocusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayFocus
     */
    select?: DayFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayFocus
     */
    omit?: DayFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayFocusInclude<ExtArgs> | null
    /**
     * Filter, which DayFoci to fetch.
     */
    where?: DayFocusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DayFoci to fetch.
     */
    orderBy?: DayFocusOrderByWithRelationInput | DayFocusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DayFoci.
     */
    cursor?: DayFocusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DayFoci from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DayFoci.
     */
    skip?: number
    distinct?: DayFocusScalarFieldEnum | DayFocusScalarFieldEnum[]
  }

  /**
   * DayFocus create
   */
  export type DayFocusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayFocus
     */
    select?: DayFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayFocus
     */
    omit?: DayFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayFocusInclude<ExtArgs> | null
    /**
     * The data needed to create a DayFocus.
     */
    data: XOR<DayFocusCreateInput, DayFocusUncheckedCreateInput>
  }

  /**
   * DayFocus createMany
   */
  export type DayFocusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DayFoci.
     */
    data: DayFocusCreateManyInput | DayFocusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DayFocus createManyAndReturn
   */
  export type DayFocusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayFocus
     */
    select?: DayFocusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DayFocus
     */
    omit?: DayFocusOmit<ExtArgs> | null
    /**
     * The data used to create many DayFoci.
     */
    data: DayFocusCreateManyInput | DayFocusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayFocusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DayFocus update
   */
  export type DayFocusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayFocus
     */
    select?: DayFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayFocus
     */
    omit?: DayFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayFocusInclude<ExtArgs> | null
    /**
     * The data needed to update a DayFocus.
     */
    data: XOR<DayFocusUpdateInput, DayFocusUncheckedUpdateInput>
    /**
     * Choose, which DayFocus to update.
     */
    where: DayFocusWhereUniqueInput
  }

  /**
   * DayFocus updateMany
   */
  export type DayFocusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DayFoci.
     */
    data: XOR<DayFocusUpdateManyMutationInput, DayFocusUncheckedUpdateManyInput>
    /**
     * Filter which DayFoci to update
     */
    where?: DayFocusWhereInput
    /**
     * Limit how many DayFoci to update.
     */
    limit?: number
  }

  /**
   * DayFocus updateManyAndReturn
   */
  export type DayFocusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayFocus
     */
    select?: DayFocusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DayFocus
     */
    omit?: DayFocusOmit<ExtArgs> | null
    /**
     * The data used to update DayFoci.
     */
    data: XOR<DayFocusUpdateManyMutationInput, DayFocusUncheckedUpdateManyInput>
    /**
     * Filter which DayFoci to update
     */
    where?: DayFocusWhereInput
    /**
     * Limit how many DayFoci to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayFocusIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DayFocus upsert
   */
  export type DayFocusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayFocus
     */
    select?: DayFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayFocus
     */
    omit?: DayFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayFocusInclude<ExtArgs> | null
    /**
     * The filter to search for the DayFocus to update in case it exists.
     */
    where: DayFocusWhereUniqueInput
    /**
     * In case the DayFocus found by the `where` argument doesn't exist, create a new DayFocus with this data.
     */
    create: XOR<DayFocusCreateInput, DayFocusUncheckedCreateInput>
    /**
     * In case the DayFocus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DayFocusUpdateInput, DayFocusUncheckedUpdateInput>
  }

  /**
   * DayFocus delete
   */
  export type DayFocusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayFocus
     */
    select?: DayFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayFocus
     */
    omit?: DayFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayFocusInclude<ExtArgs> | null
    /**
     * Filter which DayFocus to delete.
     */
    where: DayFocusWhereUniqueInput
  }

  /**
   * DayFocus deleteMany
   */
  export type DayFocusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DayFoci to delete
     */
    where?: DayFocusWhereInput
    /**
     * Limit how many DayFoci to delete.
     */
    limit?: number
  }

  /**
   * DayFocus without action
   */
  export type DayFocusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayFocus
     */
    select?: DayFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayFocus
     */
    omit?: DayFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayFocusInclude<ExtArgs> | null
  }


  /**
   * Model TimeBlock
   */

  export type AggregateTimeBlock = {
    _count: TimeBlockCountAggregateOutputType | null
    _avg: TimeBlockAvgAggregateOutputType | null
    _sum: TimeBlockSumAggregateOutputType | null
    _min: TimeBlockMinAggregateOutputType | null
    _max: TimeBlockMaxAggregateOutputType | null
  }

  export type TimeBlockAvgAggregateOutputType = {
    duration: number | null
    actualDuration: number | null
    energyBefore: number | null
    energyAfter: number | null
    focusQuality: number | null
  }

  export type TimeBlockSumAggregateOutputType = {
    duration: number | null
    actualDuration: number | null
    energyBefore: number | null
    energyAfter: number | null
    focusQuality: number | null
  }

  export type TimeBlockMinAggregateOutputType = {
    id: string | null
    dayPlanId: string | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    type: string | null
    taskId: string | null
    projectId: string | null
    clientId: string | null
    actualStartTime: Date | null
    actualEndTime: Date | null
    actualDuration: number | null
    energyBefore: number | null
    energyAfter: number | null
    focusQuality: number | null
    notes: string | null
  }

  export type TimeBlockMaxAggregateOutputType = {
    id: string | null
    dayPlanId: string | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    type: string | null
    taskId: string | null
    projectId: string | null
    clientId: string | null
    actualStartTime: Date | null
    actualEndTime: Date | null
    actualDuration: number | null
    energyBefore: number | null
    energyAfter: number | null
    focusQuality: number | null
    notes: string | null
  }

  export type TimeBlockCountAggregateOutputType = {
    id: number
    dayPlanId: number
    startTime: number
    endTime: number
    duration: number
    type: number
    taskId: number
    projectId: number
    clientId: number
    actualStartTime: number
    actualEndTime: number
    actualDuration: number
    energyBefore: number
    energyAfter: number
    focusQuality: number
    notes: number
    _all: number
  }


  export type TimeBlockAvgAggregateInputType = {
    duration?: true
    actualDuration?: true
    energyBefore?: true
    energyAfter?: true
    focusQuality?: true
  }

  export type TimeBlockSumAggregateInputType = {
    duration?: true
    actualDuration?: true
    energyBefore?: true
    energyAfter?: true
    focusQuality?: true
  }

  export type TimeBlockMinAggregateInputType = {
    id?: true
    dayPlanId?: true
    startTime?: true
    endTime?: true
    duration?: true
    type?: true
    taskId?: true
    projectId?: true
    clientId?: true
    actualStartTime?: true
    actualEndTime?: true
    actualDuration?: true
    energyBefore?: true
    energyAfter?: true
    focusQuality?: true
    notes?: true
  }

  export type TimeBlockMaxAggregateInputType = {
    id?: true
    dayPlanId?: true
    startTime?: true
    endTime?: true
    duration?: true
    type?: true
    taskId?: true
    projectId?: true
    clientId?: true
    actualStartTime?: true
    actualEndTime?: true
    actualDuration?: true
    energyBefore?: true
    energyAfter?: true
    focusQuality?: true
    notes?: true
  }

  export type TimeBlockCountAggregateInputType = {
    id?: true
    dayPlanId?: true
    startTime?: true
    endTime?: true
    duration?: true
    type?: true
    taskId?: true
    projectId?: true
    clientId?: true
    actualStartTime?: true
    actualEndTime?: true
    actualDuration?: true
    energyBefore?: true
    energyAfter?: true
    focusQuality?: true
    notes?: true
    _all?: true
  }

  export type TimeBlockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeBlock to aggregate.
     */
    where?: TimeBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeBlocks to fetch.
     */
    orderBy?: TimeBlockOrderByWithRelationInput | TimeBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimeBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TimeBlocks
    **/
    _count?: true | TimeBlockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TimeBlockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TimeBlockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimeBlockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimeBlockMaxAggregateInputType
  }

  export type GetTimeBlockAggregateType<T extends TimeBlockAggregateArgs> = {
        [P in keyof T & keyof AggregateTimeBlock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimeBlock[P]>
      : GetScalarType<T[P], AggregateTimeBlock[P]>
  }




  export type TimeBlockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeBlockWhereInput
    orderBy?: TimeBlockOrderByWithAggregationInput | TimeBlockOrderByWithAggregationInput[]
    by: TimeBlockScalarFieldEnum[] | TimeBlockScalarFieldEnum
    having?: TimeBlockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimeBlockCountAggregateInputType | true
    _avg?: TimeBlockAvgAggregateInputType
    _sum?: TimeBlockSumAggregateInputType
    _min?: TimeBlockMinAggregateInputType
    _max?: TimeBlockMaxAggregateInputType
  }

  export type TimeBlockGroupByOutputType = {
    id: string
    dayPlanId: string
    startTime: Date
    endTime: Date
    duration: number
    type: string
    taskId: string | null
    projectId: string | null
    clientId: string | null
    actualStartTime: Date | null
    actualEndTime: Date | null
    actualDuration: number | null
    energyBefore: number | null
    energyAfter: number | null
    focusQuality: number | null
    notes: string | null
    _count: TimeBlockCountAggregateOutputType | null
    _avg: TimeBlockAvgAggregateOutputType | null
    _sum: TimeBlockSumAggregateOutputType | null
    _min: TimeBlockMinAggregateOutputType | null
    _max: TimeBlockMaxAggregateOutputType | null
  }

  type GetTimeBlockGroupByPayload<T extends TimeBlockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimeBlockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimeBlockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimeBlockGroupByOutputType[P]>
            : GetScalarType<T[P], TimeBlockGroupByOutputType[P]>
        }
      >
    >


  export type TimeBlockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dayPlanId?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    type?: boolean
    taskId?: boolean
    projectId?: boolean
    clientId?: boolean
    actualStartTime?: boolean
    actualEndTime?: boolean
    actualDuration?: boolean
    energyBefore?: boolean
    energyAfter?: boolean
    focusQuality?: boolean
    notes?: boolean
    client?: boolean | TimeBlock$clientArgs<ExtArgs>
    dayPlan?: boolean | DayPlanDefaultArgs<ExtArgs>
    project?: boolean | TimeBlock$projectArgs<ExtArgs>
    task?: boolean | TimeBlock$taskArgs<ExtArgs>
  }, ExtArgs["result"]["timeBlock"]>

  export type TimeBlockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dayPlanId?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    type?: boolean
    taskId?: boolean
    projectId?: boolean
    clientId?: boolean
    actualStartTime?: boolean
    actualEndTime?: boolean
    actualDuration?: boolean
    energyBefore?: boolean
    energyAfter?: boolean
    focusQuality?: boolean
    notes?: boolean
    client?: boolean | TimeBlock$clientArgs<ExtArgs>
    dayPlan?: boolean | DayPlanDefaultArgs<ExtArgs>
    project?: boolean | TimeBlock$projectArgs<ExtArgs>
    task?: boolean | TimeBlock$taskArgs<ExtArgs>
  }, ExtArgs["result"]["timeBlock"]>

  export type TimeBlockSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dayPlanId?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    type?: boolean
    taskId?: boolean
    projectId?: boolean
    clientId?: boolean
    actualStartTime?: boolean
    actualEndTime?: boolean
    actualDuration?: boolean
    energyBefore?: boolean
    energyAfter?: boolean
    focusQuality?: boolean
    notes?: boolean
    client?: boolean | TimeBlock$clientArgs<ExtArgs>
    dayPlan?: boolean | DayPlanDefaultArgs<ExtArgs>
    project?: boolean | TimeBlock$projectArgs<ExtArgs>
    task?: boolean | TimeBlock$taskArgs<ExtArgs>
  }, ExtArgs["result"]["timeBlock"]>

  export type TimeBlockSelectScalar = {
    id?: boolean
    dayPlanId?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    type?: boolean
    taskId?: boolean
    projectId?: boolean
    clientId?: boolean
    actualStartTime?: boolean
    actualEndTime?: boolean
    actualDuration?: boolean
    energyBefore?: boolean
    energyAfter?: boolean
    focusQuality?: boolean
    notes?: boolean
  }

  export type TimeBlockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dayPlanId" | "startTime" | "endTime" | "duration" | "type" | "taskId" | "projectId" | "clientId" | "actualStartTime" | "actualEndTime" | "actualDuration" | "energyBefore" | "energyAfter" | "focusQuality" | "notes", ExtArgs["result"]["timeBlock"]>
  export type TimeBlockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | TimeBlock$clientArgs<ExtArgs>
    dayPlan?: boolean | DayPlanDefaultArgs<ExtArgs>
    project?: boolean | TimeBlock$projectArgs<ExtArgs>
    task?: boolean | TimeBlock$taskArgs<ExtArgs>
  }
  export type TimeBlockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | TimeBlock$clientArgs<ExtArgs>
    dayPlan?: boolean | DayPlanDefaultArgs<ExtArgs>
    project?: boolean | TimeBlock$projectArgs<ExtArgs>
    task?: boolean | TimeBlock$taskArgs<ExtArgs>
  }
  export type TimeBlockIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | TimeBlock$clientArgs<ExtArgs>
    dayPlan?: boolean | DayPlanDefaultArgs<ExtArgs>
    project?: boolean | TimeBlock$projectArgs<ExtArgs>
    task?: boolean | TimeBlock$taskArgs<ExtArgs>
  }

  export type $TimeBlockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TimeBlock"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs> | null
      dayPlan: Prisma.$DayPlanPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs> | null
      task: Prisma.$TaskPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dayPlanId: string
      startTime: Date
      endTime: Date
      duration: number
      type: string
      taskId: string | null
      projectId: string | null
      clientId: string | null
      actualStartTime: Date | null
      actualEndTime: Date | null
      actualDuration: number | null
      energyBefore: number | null
      energyAfter: number | null
      focusQuality: number | null
      notes: string | null
    }, ExtArgs["result"]["timeBlock"]>
    composites: {}
  }

  type TimeBlockGetPayload<S extends boolean | null | undefined | TimeBlockDefaultArgs> = $Result.GetResult<Prisma.$TimeBlockPayload, S>

  type TimeBlockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TimeBlockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TimeBlockCountAggregateInputType | true
    }

  export interface TimeBlockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TimeBlock'], meta: { name: 'TimeBlock' } }
    /**
     * Find zero or one TimeBlock that matches the filter.
     * @param {TimeBlockFindUniqueArgs} args - Arguments to find a TimeBlock
     * @example
     * // Get one TimeBlock
     * const timeBlock = await prisma.timeBlock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimeBlockFindUniqueArgs>(args: SelectSubset<T, TimeBlockFindUniqueArgs<ExtArgs>>): Prisma__TimeBlockClient<$Result.GetResult<Prisma.$TimeBlockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TimeBlock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TimeBlockFindUniqueOrThrowArgs} args - Arguments to find a TimeBlock
     * @example
     * // Get one TimeBlock
     * const timeBlock = await prisma.timeBlock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimeBlockFindUniqueOrThrowArgs>(args: SelectSubset<T, TimeBlockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimeBlockClient<$Result.GetResult<Prisma.$TimeBlockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimeBlock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeBlockFindFirstArgs} args - Arguments to find a TimeBlock
     * @example
     * // Get one TimeBlock
     * const timeBlock = await prisma.timeBlock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimeBlockFindFirstArgs>(args?: SelectSubset<T, TimeBlockFindFirstArgs<ExtArgs>>): Prisma__TimeBlockClient<$Result.GetResult<Prisma.$TimeBlockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimeBlock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeBlockFindFirstOrThrowArgs} args - Arguments to find a TimeBlock
     * @example
     * // Get one TimeBlock
     * const timeBlock = await prisma.timeBlock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimeBlockFindFirstOrThrowArgs>(args?: SelectSubset<T, TimeBlockFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimeBlockClient<$Result.GetResult<Prisma.$TimeBlockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TimeBlocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeBlockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TimeBlocks
     * const timeBlocks = await prisma.timeBlock.findMany()
     * 
     * // Get first 10 TimeBlocks
     * const timeBlocks = await prisma.timeBlock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timeBlockWithIdOnly = await prisma.timeBlock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimeBlockFindManyArgs>(args?: SelectSubset<T, TimeBlockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeBlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TimeBlock.
     * @param {TimeBlockCreateArgs} args - Arguments to create a TimeBlock.
     * @example
     * // Create one TimeBlock
     * const TimeBlock = await prisma.timeBlock.create({
     *   data: {
     *     // ... data to create a TimeBlock
     *   }
     * })
     * 
     */
    create<T extends TimeBlockCreateArgs>(args: SelectSubset<T, TimeBlockCreateArgs<ExtArgs>>): Prisma__TimeBlockClient<$Result.GetResult<Prisma.$TimeBlockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TimeBlocks.
     * @param {TimeBlockCreateManyArgs} args - Arguments to create many TimeBlocks.
     * @example
     * // Create many TimeBlocks
     * const timeBlock = await prisma.timeBlock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimeBlockCreateManyArgs>(args?: SelectSubset<T, TimeBlockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TimeBlocks and returns the data saved in the database.
     * @param {TimeBlockCreateManyAndReturnArgs} args - Arguments to create many TimeBlocks.
     * @example
     * // Create many TimeBlocks
     * const timeBlock = await prisma.timeBlock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TimeBlocks and only return the `id`
     * const timeBlockWithIdOnly = await prisma.timeBlock.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TimeBlockCreateManyAndReturnArgs>(args?: SelectSubset<T, TimeBlockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeBlockPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TimeBlock.
     * @param {TimeBlockDeleteArgs} args - Arguments to delete one TimeBlock.
     * @example
     * // Delete one TimeBlock
     * const TimeBlock = await prisma.timeBlock.delete({
     *   where: {
     *     // ... filter to delete one TimeBlock
     *   }
     * })
     * 
     */
    delete<T extends TimeBlockDeleteArgs>(args: SelectSubset<T, TimeBlockDeleteArgs<ExtArgs>>): Prisma__TimeBlockClient<$Result.GetResult<Prisma.$TimeBlockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TimeBlock.
     * @param {TimeBlockUpdateArgs} args - Arguments to update one TimeBlock.
     * @example
     * // Update one TimeBlock
     * const timeBlock = await prisma.timeBlock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimeBlockUpdateArgs>(args: SelectSubset<T, TimeBlockUpdateArgs<ExtArgs>>): Prisma__TimeBlockClient<$Result.GetResult<Prisma.$TimeBlockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TimeBlocks.
     * @param {TimeBlockDeleteManyArgs} args - Arguments to filter TimeBlocks to delete.
     * @example
     * // Delete a few TimeBlocks
     * const { count } = await prisma.timeBlock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimeBlockDeleteManyArgs>(args?: SelectSubset<T, TimeBlockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeBlockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TimeBlocks
     * const timeBlock = await prisma.timeBlock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimeBlockUpdateManyArgs>(args: SelectSubset<T, TimeBlockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeBlocks and returns the data updated in the database.
     * @param {TimeBlockUpdateManyAndReturnArgs} args - Arguments to update many TimeBlocks.
     * @example
     * // Update many TimeBlocks
     * const timeBlock = await prisma.timeBlock.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TimeBlocks and only return the `id`
     * const timeBlockWithIdOnly = await prisma.timeBlock.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TimeBlockUpdateManyAndReturnArgs>(args: SelectSubset<T, TimeBlockUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeBlockPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TimeBlock.
     * @param {TimeBlockUpsertArgs} args - Arguments to update or create a TimeBlock.
     * @example
     * // Update or create a TimeBlock
     * const timeBlock = await prisma.timeBlock.upsert({
     *   create: {
     *     // ... data to create a TimeBlock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TimeBlock we want to update
     *   }
     * })
     */
    upsert<T extends TimeBlockUpsertArgs>(args: SelectSubset<T, TimeBlockUpsertArgs<ExtArgs>>): Prisma__TimeBlockClient<$Result.GetResult<Prisma.$TimeBlockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TimeBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeBlockCountArgs} args - Arguments to filter TimeBlocks to count.
     * @example
     * // Count the number of TimeBlocks
     * const count = await prisma.timeBlock.count({
     *   where: {
     *     // ... the filter for the TimeBlocks we want to count
     *   }
     * })
    **/
    count<T extends TimeBlockCountArgs>(
      args?: Subset<T, TimeBlockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimeBlockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TimeBlock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeBlockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimeBlockAggregateArgs>(args: Subset<T, TimeBlockAggregateArgs>): Prisma.PrismaPromise<GetTimeBlockAggregateType<T>>

    /**
     * Group by TimeBlock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeBlockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimeBlockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimeBlockGroupByArgs['orderBy'] }
        : { orderBy?: TimeBlockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimeBlockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimeBlockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TimeBlock model
   */
  readonly fields: TimeBlockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TimeBlock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimeBlockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends TimeBlock$clientArgs<ExtArgs> = {}>(args?: Subset<T, TimeBlock$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    dayPlan<T extends DayPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DayPlanDefaultArgs<ExtArgs>>): Prisma__DayPlanClient<$Result.GetResult<Prisma.$DayPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    project<T extends TimeBlock$projectArgs<ExtArgs> = {}>(args?: Subset<T, TimeBlock$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    task<T extends TimeBlock$taskArgs<ExtArgs> = {}>(args?: Subset<T, TimeBlock$taskArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TimeBlock model
   */
  interface TimeBlockFieldRefs {
    readonly id: FieldRef<"TimeBlock", 'String'>
    readonly dayPlanId: FieldRef<"TimeBlock", 'String'>
    readonly startTime: FieldRef<"TimeBlock", 'DateTime'>
    readonly endTime: FieldRef<"TimeBlock", 'DateTime'>
    readonly duration: FieldRef<"TimeBlock", 'Int'>
    readonly type: FieldRef<"TimeBlock", 'String'>
    readonly taskId: FieldRef<"TimeBlock", 'String'>
    readonly projectId: FieldRef<"TimeBlock", 'String'>
    readonly clientId: FieldRef<"TimeBlock", 'String'>
    readonly actualStartTime: FieldRef<"TimeBlock", 'DateTime'>
    readonly actualEndTime: FieldRef<"TimeBlock", 'DateTime'>
    readonly actualDuration: FieldRef<"TimeBlock", 'Int'>
    readonly energyBefore: FieldRef<"TimeBlock", 'Float'>
    readonly energyAfter: FieldRef<"TimeBlock", 'Float'>
    readonly focusQuality: FieldRef<"TimeBlock", 'Float'>
    readonly notes: FieldRef<"TimeBlock", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TimeBlock findUnique
   */
  export type TimeBlockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeBlock
     */
    select?: TimeBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeBlock
     */
    omit?: TimeBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeBlockInclude<ExtArgs> | null
    /**
     * Filter, which TimeBlock to fetch.
     */
    where: TimeBlockWhereUniqueInput
  }

  /**
   * TimeBlock findUniqueOrThrow
   */
  export type TimeBlockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeBlock
     */
    select?: TimeBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeBlock
     */
    omit?: TimeBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeBlockInclude<ExtArgs> | null
    /**
     * Filter, which TimeBlock to fetch.
     */
    where: TimeBlockWhereUniqueInput
  }

  /**
   * TimeBlock findFirst
   */
  export type TimeBlockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeBlock
     */
    select?: TimeBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeBlock
     */
    omit?: TimeBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeBlockInclude<ExtArgs> | null
    /**
     * Filter, which TimeBlock to fetch.
     */
    where?: TimeBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeBlocks to fetch.
     */
    orderBy?: TimeBlockOrderByWithRelationInput | TimeBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeBlocks.
     */
    cursor?: TimeBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeBlocks.
     */
    distinct?: TimeBlockScalarFieldEnum | TimeBlockScalarFieldEnum[]
  }

  /**
   * TimeBlock findFirstOrThrow
   */
  export type TimeBlockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeBlock
     */
    select?: TimeBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeBlock
     */
    omit?: TimeBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeBlockInclude<ExtArgs> | null
    /**
     * Filter, which TimeBlock to fetch.
     */
    where?: TimeBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeBlocks to fetch.
     */
    orderBy?: TimeBlockOrderByWithRelationInput | TimeBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeBlocks.
     */
    cursor?: TimeBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeBlocks.
     */
    distinct?: TimeBlockScalarFieldEnum | TimeBlockScalarFieldEnum[]
  }

  /**
   * TimeBlock findMany
   */
  export type TimeBlockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeBlock
     */
    select?: TimeBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeBlock
     */
    omit?: TimeBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeBlockInclude<ExtArgs> | null
    /**
     * Filter, which TimeBlocks to fetch.
     */
    where?: TimeBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeBlocks to fetch.
     */
    orderBy?: TimeBlockOrderByWithRelationInput | TimeBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TimeBlocks.
     */
    cursor?: TimeBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeBlocks.
     */
    skip?: number
    distinct?: TimeBlockScalarFieldEnum | TimeBlockScalarFieldEnum[]
  }

  /**
   * TimeBlock create
   */
  export type TimeBlockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeBlock
     */
    select?: TimeBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeBlock
     */
    omit?: TimeBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeBlockInclude<ExtArgs> | null
    /**
     * The data needed to create a TimeBlock.
     */
    data: XOR<TimeBlockCreateInput, TimeBlockUncheckedCreateInput>
  }

  /**
   * TimeBlock createMany
   */
  export type TimeBlockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TimeBlocks.
     */
    data: TimeBlockCreateManyInput | TimeBlockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TimeBlock createManyAndReturn
   */
  export type TimeBlockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeBlock
     */
    select?: TimeBlockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimeBlock
     */
    omit?: TimeBlockOmit<ExtArgs> | null
    /**
     * The data used to create many TimeBlocks.
     */
    data: TimeBlockCreateManyInput | TimeBlockCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeBlockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimeBlock update
   */
  export type TimeBlockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeBlock
     */
    select?: TimeBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeBlock
     */
    omit?: TimeBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeBlockInclude<ExtArgs> | null
    /**
     * The data needed to update a TimeBlock.
     */
    data: XOR<TimeBlockUpdateInput, TimeBlockUncheckedUpdateInput>
    /**
     * Choose, which TimeBlock to update.
     */
    where: TimeBlockWhereUniqueInput
  }

  /**
   * TimeBlock updateMany
   */
  export type TimeBlockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TimeBlocks.
     */
    data: XOR<TimeBlockUpdateManyMutationInput, TimeBlockUncheckedUpdateManyInput>
    /**
     * Filter which TimeBlocks to update
     */
    where?: TimeBlockWhereInput
    /**
     * Limit how many TimeBlocks to update.
     */
    limit?: number
  }

  /**
   * TimeBlock updateManyAndReturn
   */
  export type TimeBlockUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeBlock
     */
    select?: TimeBlockSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimeBlock
     */
    omit?: TimeBlockOmit<ExtArgs> | null
    /**
     * The data used to update TimeBlocks.
     */
    data: XOR<TimeBlockUpdateManyMutationInput, TimeBlockUncheckedUpdateManyInput>
    /**
     * Filter which TimeBlocks to update
     */
    where?: TimeBlockWhereInput
    /**
     * Limit how many TimeBlocks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeBlockIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimeBlock upsert
   */
  export type TimeBlockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeBlock
     */
    select?: TimeBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeBlock
     */
    omit?: TimeBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeBlockInclude<ExtArgs> | null
    /**
     * The filter to search for the TimeBlock to update in case it exists.
     */
    where: TimeBlockWhereUniqueInput
    /**
     * In case the TimeBlock found by the `where` argument doesn't exist, create a new TimeBlock with this data.
     */
    create: XOR<TimeBlockCreateInput, TimeBlockUncheckedCreateInput>
    /**
     * In case the TimeBlock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimeBlockUpdateInput, TimeBlockUncheckedUpdateInput>
  }

  /**
   * TimeBlock delete
   */
  export type TimeBlockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeBlock
     */
    select?: TimeBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeBlock
     */
    omit?: TimeBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeBlockInclude<ExtArgs> | null
    /**
     * Filter which TimeBlock to delete.
     */
    where: TimeBlockWhereUniqueInput
  }

  /**
   * TimeBlock deleteMany
   */
  export type TimeBlockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeBlocks to delete
     */
    where?: TimeBlockWhereInput
    /**
     * Limit how many TimeBlocks to delete.
     */
    limit?: number
  }

  /**
   * TimeBlock.client
   */
  export type TimeBlock$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * TimeBlock.project
   */
  export type TimeBlock$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * TimeBlock.task
   */
  export type TimeBlock$taskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
  }

  /**
   * TimeBlock without action
   */
  export type TimeBlockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeBlock
     */
    select?: TimeBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeBlock
     */
    omit?: TimeBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeBlockInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    hourlyRate: number | null
    budgetHours: number | null
    estimatedHours: number | null
    actualHoursSpent: number | null
    completionPercentage: number | null
  }

  export type ProjectSumAggregateOutputType = {
    hourlyRate: number | null
    budgetHours: number | null
    estimatedHours: number | null
    actualHoursSpent: number | null
    completionPercentage: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    type: string | null
    status: string | null
    clientId: string | null
    billable: boolean | null
    hourlyRate: number | null
    budgetHours: number | null
    startDate: Date | null
    deadline: Date | null
    estimatedHours: number | null
    actualHoursSpent: number | null
    completionPercentage: number | null
    goalId: string | null
    parentProjectId: string | null
    priority: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
    archivedAt: Date | null
    icon: string | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    type: string | null
    status: string | null
    clientId: string | null
    billable: boolean | null
    hourlyRate: number | null
    budgetHours: number | null
    startDate: Date | null
    deadline: Date | null
    estimatedHours: number | null
    actualHoursSpent: number | null
    completionPercentage: number | null
    goalId: string | null
    parentProjectId: string | null
    priority: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
    archivedAt: Date | null
    icon: string | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    description: number
    type: number
    status: number
    clientId: number
    billable: number
    hourlyRate: number
    budgetHours: number
    startDate: number
    deadline: number
    estimatedHours: number
    actualHoursSpent: number
    completionPercentage: number
    goalId: number
    parentProjectId: number
    priority: number
    tags: number
    color: number
    createdAt: number
    updatedAt: number
    completedAt: number
    archivedAt: number
    icon: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    hourlyRate?: true
    budgetHours?: true
    estimatedHours?: true
    actualHoursSpent?: true
    completionPercentage?: true
  }

  export type ProjectSumAggregateInputType = {
    hourlyRate?: true
    budgetHours?: true
    estimatedHours?: true
    actualHoursSpent?: true
    completionPercentage?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    type?: true
    status?: true
    clientId?: true
    billable?: true
    hourlyRate?: true
    budgetHours?: true
    startDate?: true
    deadline?: true
    estimatedHours?: true
    actualHoursSpent?: true
    completionPercentage?: true
    goalId?: true
    parentProjectId?: true
    priority?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    archivedAt?: true
    icon?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    type?: true
    status?: true
    clientId?: true
    billable?: true
    hourlyRate?: true
    budgetHours?: true
    startDate?: true
    deadline?: true
    estimatedHours?: true
    actualHoursSpent?: true
    completionPercentage?: true
    goalId?: true
    parentProjectId?: true
    priority?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    archivedAt?: true
    icon?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    type?: true
    status?: true
    clientId?: true
    billable?: true
    hourlyRate?: true
    budgetHours?: true
    startDate?: true
    deadline?: true
    estimatedHours?: true
    actualHoursSpent?: true
    completionPercentage?: true
    goalId?: true
    parentProjectId?: true
    priority?: true
    tags?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    archivedAt?: true
    icon?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    userId: string
    name: string
    description: string | null
    type: string
    status: string
    clientId: string | null
    billable: boolean
    hourlyRate: number | null
    budgetHours: number | null
    startDate: Date | null
    deadline: Date | null
    estimatedHours: number | null
    actualHoursSpent: number
    completionPercentage: number
    goalId: string | null
    parentProjectId: string | null
    priority: string
    tags: string[]
    color: string | null
    createdAt: Date
    updatedAt: Date
    completedAt: Date | null
    archivedAt: Date | null
    icon: string | null
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    clientId?: boolean
    billable?: boolean
    hourlyRate?: boolean
    budgetHours?: boolean
    startDate?: boolean
    deadline?: boolean
    estimatedHours?: boolean
    actualHoursSpent?: boolean
    completionPercentage?: boolean
    goalId?: boolean
    parentProjectId?: boolean
    priority?: boolean
    tags?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    archivedAt?: boolean
    icon?: boolean
    client?: boolean | Project$clientArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    tasks?: boolean | Project$tasksArgs<ExtArgs>
    timeBlocks?: boolean | Project$timeBlocksArgs<ExtArgs>
    timeEntries?: boolean | Project$timeEntriesArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    clientId?: boolean
    billable?: boolean
    hourlyRate?: boolean
    budgetHours?: boolean
    startDate?: boolean
    deadline?: boolean
    estimatedHours?: boolean
    actualHoursSpent?: boolean
    completionPercentage?: boolean
    goalId?: boolean
    parentProjectId?: boolean
    priority?: boolean
    tags?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    archivedAt?: boolean
    icon?: boolean
    client?: boolean | Project$clientArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    clientId?: boolean
    billable?: boolean
    hourlyRate?: boolean
    budgetHours?: boolean
    startDate?: boolean
    deadline?: boolean
    estimatedHours?: boolean
    actualHoursSpent?: boolean
    completionPercentage?: boolean
    goalId?: boolean
    parentProjectId?: boolean
    priority?: boolean
    tags?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    archivedAt?: boolean
    icon?: boolean
    client?: boolean | Project$clientArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    clientId?: boolean
    billable?: boolean
    hourlyRate?: boolean
    budgetHours?: boolean
    startDate?: boolean
    deadline?: boolean
    estimatedHours?: boolean
    actualHoursSpent?: boolean
    completionPercentage?: boolean
    goalId?: boolean
    parentProjectId?: boolean
    priority?: boolean
    tags?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    archivedAt?: boolean
    icon?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "description" | "type" | "status" | "clientId" | "billable" | "hourlyRate" | "budgetHours" | "startDate" | "deadline" | "estimatedHours" | "actualHoursSpent" | "completionPercentage" | "goalId" | "parentProjectId" | "priority" | "tags" | "color" | "createdAt" | "updatedAt" | "completedAt" | "archivedAt" | "icon", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Project$clientArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    tasks?: boolean | Project$tasksArgs<ExtArgs>
    timeBlocks?: boolean | Project$timeBlocksArgs<ExtArgs>
    timeEntries?: boolean | Project$timeEntriesArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Project$clientArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Project$clientArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      timeBlocks: Prisma.$TimeBlockPayload<ExtArgs>[]
      timeEntries: Prisma.$TimeEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      description: string | null
      type: string
      status: string
      clientId: string | null
      billable: boolean
      hourlyRate: number | null
      budgetHours: number | null
      startDate: Date | null
      deadline: Date | null
      estimatedHours: number | null
      actualHoursSpent: number
      completionPercentage: number
      goalId: string | null
      parentProjectId: string | null
      priority: string
      tags: string[]
      color: string | null
      createdAt: Date
      updatedAt: Date
      completedAt: Date | null
      archivedAt: Date | null
      icon: string | null
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends Project$clientArgs<ExtArgs> = {}>(args?: Subset<T, Project$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tasks<T extends Project$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Project$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    timeBlocks<T extends Project$timeBlocksArgs<ExtArgs> = {}>(args?: Subset<T, Project$timeBlocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeBlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    timeEntries<T extends Project$timeEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Project$timeEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly userId: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly type: FieldRef<"Project", 'String'>
    readonly status: FieldRef<"Project", 'String'>
    readonly clientId: FieldRef<"Project", 'String'>
    readonly billable: FieldRef<"Project", 'Boolean'>
    readonly hourlyRate: FieldRef<"Project", 'Float'>
    readonly budgetHours: FieldRef<"Project", 'Float'>
    readonly startDate: FieldRef<"Project", 'DateTime'>
    readonly deadline: FieldRef<"Project", 'DateTime'>
    readonly estimatedHours: FieldRef<"Project", 'Float'>
    readonly actualHoursSpent: FieldRef<"Project", 'Float'>
    readonly completionPercentage: FieldRef<"Project", 'Float'>
    readonly goalId: FieldRef<"Project", 'String'>
    readonly parentProjectId: FieldRef<"Project", 'String'>
    readonly priority: FieldRef<"Project", 'String'>
    readonly tags: FieldRef<"Project", 'String[]'>
    readonly color: FieldRef<"Project", 'String'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
    readonly completedAt: FieldRef<"Project", 'DateTime'>
    readonly archivedAt: FieldRef<"Project", 'DateTime'>
    readonly icon: FieldRef<"Project", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project updateManyAndReturn
   */
  export type ProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project.client
   */
  export type Project$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Project.tasks
   */
  export type Project$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Project.timeBlocks
   */
  export type Project$timeBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeBlock
     */
    select?: TimeBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeBlock
     */
    omit?: TimeBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeBlockInclude<ExtArgs> | null
    where?: TimeBlockWhereInput
    orderBy?: TimeBlockOrderByWithRelationInput | TimeBlockOrderByWithRelationInput[]
    cursor?: TimeBlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeBlockScalarFieldEnum | TimeBlockScalarFieldEnum[]
  }

  /**
   * Project.timeEntries
   */
  export type Project$timeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeEntry
     */
    omit?: TimeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    where?: TimeEntryWhereInput
    orderBy?: TimeEntryOrderByWithRelationInput | TimeEntryOrderByWithRelationInput[]
    cursor?: TimeEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeEntryScalarFieldEnum | TimeEntryScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskAvgAggregateOutputType = {
    estimatedMinutes: number | null
    actualMinutes: number | null
    energyRequired: number | null
  }

  export type TaskSumAggregateOutputType = {
    estimatedMinutes: number | null
    actualMinutes: number | null
    energyRequired: number | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    userId: string | null
    projectId: string | null
    title: string | null
    description: string | null
    status: string | null
    startedAt: Date | null
    completedAt: Date | null
    estimatedMinutes: number | null
    actualMinutes: number | null
    timerRunning: boolean | null
    currentTimerStart: Date | null
    scheduledDate: Date | null
    dueDate: Date | null
    priority: string | null
    type: string | null
    parentTaskId: string | null
    energyRequired: number | null
    isAdHoc: boolean | null
    isRecurring: boolean | null
    recurringPattern: string | null
    createdAt: Date | null
    updatedAt: Date | null
    meetingId: string | null
    goalId: string | null
    keyStepId: string | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    projectId: string | null
    title: string | null
    description: string | null
    status: string | null
    startedAt: Date | null
    completedAt: Date | null
    estimatedMinutes: number | null
    actualMinutes: number | null
    timerRunning: boolean | null
    currentTimerStart: Date | null
    scheduledDate: Date | null
    dueDate: Date | null
    priority: string | null
    type: string | null
    parentTaskId: string | null
    energyRequired: number | null
    isAdHoc: boolean | null
    isRecurring: boolean | null
    recurringPattern: string | null
    createdAt: Date | null
    updatedAt: Date | null
    meetingId: string | null
    goalId: string | null
    keyStepId: string | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    userId: number
    projectId: number
    title: number
    description: number
    status: number
    startedAt: number
    completedAt: number
    estimatedMinutes: number
    actualMinutes: number
    timerRunning: number
    currentTimerStart: number
    scheduledDate: number
    dueDate: number
    priority: number
    type: number
    tags: number
    parentTaskId: number
    dependsOn: number
    blocks: number
    energyRequired: number
    isAdHoc: number
    isRecurring: number
    recurringPattern: number
    createdAt: number
    updatedAt: number
    meetingId: number
    goalId: number
    keyStepId: number
    _all: number
  }


  export type TaskAvgAggregateInputType = {
    estimatedMinutes?: true
    actualMinutes?: true
    energyRequired?: true
  }

  export type TaskSumAggregateInputType = {
    estimatedMinutes?: true
    actualMinutes?: true
    energyRequired?: true
  }

  export type TaskMinAggregateInputType = {
    id?: true
    userId?: true
    projectId?: true
    title?: true
    description?: true
    status?: true
    startedAt?: true
    completedAt?: true
    estimatedMinutes?: true
    actualMinutes?: true
    timerRunning?: true
    currentTimerStart?: true
    scheduledDate?: true
    dueDate?: true
    priority?: true
    type?: true
    parentTaskId?: true
    energyRequired?: true
    isAdHoc?: true
    isRecurring?: true
    recurringPattern?: true
    createdAt?: true
    updatedAt?: true
    meetingId?: true
    goalId?: true
    keyStepId?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    userId?: true
    projectId?: true
    title?: true
    description?: true
    status?: true
    startedAt?: true
    completedAt?: true
    estimatedMinutes?: true
    actualMinutes?: true
    timerRunning?: true
    currentTimerStart?: true
    scheduledDate?: true
    dueDate?: true
    priority?: true
    type?: true
    parentTaskId?: true
    energyRequired?: true
    isAdHoc?: true
    isRecurring?: true
    recurringPattern?: true
    createdAt?: true
    updatedAt?: true
    meetingId?: true
    goalId?: true
    keyStepId?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    userId?: true
    projectId?: true
    title?: true
    description?: true
    status?: true
    startedAt?: true
    completedAt?: true
    estimatedMinutes?: true
    actualMinutes?: true
    timerRunning?: true
    currentTimerStart?: true
    scheduledDate?: true
    dueDate?: true
    priority?: true
    type?: true
    tags?: true
    parentTaskId?: true
    dependsOn?: true
    blocks?: true
    energyRequired?: true
    isAdHoc?: true
    isRecurring?: true
    recurringPattern?: true
    createdAt?: true
    updatedAt?: true
    meetingId?: true
    goalId?: true
    keyStepId?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _avg?: TaskAvgAggregateInputType
    _sum?: TaskSumAggregateInputType
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    userId: string
    projectId: string | null
    title: string
    description: string | null
    status: string
    startedAt: Date | null
    completedAt: Date | null
    estimatedMinutes: number | null
    actualMinutes: number
    timerRunning: boolean
    currentTimerStart: Date | null
    scheduledDate: Date | null
    dueDate: Date | null
    priority: string
    type: string
    tags: string[]
    parentTaskId: string | null
    dependsOn: string[]
    blocks: string[]
    energyRequired: number | null
    isAdHoc: boolean
    isRecurring: boolean
    recurringPattern: string | null
    createdAt: Date
    updatedAt: Date
    meetingId: string | null
    goalId: string | null
    keyStepId: string | null
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    estimatedMinutes?: boolean
    actualMinutes?: boolean
    timerRunning?: boolean
    currentTimerStart?: boolean
    scheduledDate?: boolean
    dueDate?: boolean
    priority?: boolean
    type?: boolean
    tags?: boolean
    parentTaskId?: boolean
    dependsOn?: boolean
    blocks?: boolean
    energyRequired?: boolean
    isAdHoc?: boolean
    isRecurring?: boolean
    recurringPattern?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meetingId?: boolean
    goalId?: boolean
    keyStepId?: boolean
    actionItem?: boolean | Task$actionItemArgs<ExtArgs>
    goal?: boolean | Task$goalArgs<ExtArgs>
    keyStep?: boolean | Task$keyStepArgs<ExtArgs>
    meeting?: boolean | Task$meetingArgs<ExtArgs>
    project?: boolean | Task$projectArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    timeBlocks?: boolean | Task$timeBlocksArgs<ExtArgs>
    timeEntries?: boolean | Task$timeEntriesArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    estimatedMinutes?: boolean
    actualMinutes?: boolean
    timerRunning?: boolean
    currentTimerStart?: boolean
    scheduledDate?: boolean
    dueDate?: boolean
    priority?: boolean
    type?: boolean
    tags?: boolean
    parentTaskId?: boolean
    dependsOn?: boolean
    blocks?: boolean
    energyRequired?: boolean
    isAdHoc?: boolean
    isRecurring?: boolean
    recurringPattern?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meetingId?: boolean
    goalId?: boolean
    keyStepId?: boolean
    goal?: boolean | Task$goalArgs<ExtArgs>
    keyStep?: boolean | Task$keyStepArgs<ExtArgs>
    meeting?: boolean | Task$meetingArgs<ExtArgs>
    project?: boolean | Task$projectArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    estimatedMinutes?: boolean
    actualMinutes?: boolean
    timerRunning?: boolean
    currentTimerStart?: boolean
    scheduledDate?: boolean
    dueDate?: boolean
    priority?: boolean
    type?: boolean
    tags?: boolean
    parentTaskId?: boolean
    dependsOn?: boolean
    blocks?: boolean
    energyRequired?: boolean
    isAdHoc?: boolean
    isRecurring?: boolean
    recurringPattern?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meetingId?: boolean
    goalId?: boolean
    keyStepId?: boolean
    goal?: boolean | Task$goalArgs<ExtArgs>
    keyStep?: boolean | Task$keyStepArgs<ExtArgs>
    meeting?: boolean | Task$meetingArgs<ExtArgs>
    project?: boolean | Task$projectArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    userId?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    estimatedMinutes?: boolean
    actualMinutes?: boolean
    timerRunning?: boolean
    currentTimerStart?: boolean
    scheduledDate?: boolean
    dueDate?: boolean
    priority?: boolean
    type?: boolean
    tags?: boolean
    parentTaskId?: boolean
    dependsOn?: boolean
    blocks?: boolean
    energyRequired?: boolean
    isAdHoc?: boolean
    isRecurring?: boolean
    recurringPattern?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meetingId?: boolean
    goalId?: boolean
    keyStepId?: boolean
  }

  export type TaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "projectId" | "title" | "description" | "status" | "startedAt" | "completedAt" | "estimatedMinutes" | "actualMinutes" | "timerRunning" | "currentTimerStart" | "scheduledDate" | "dueDate" | "priority" | "type" | "tags" | "parentTaskId" | "dependsOn" | "blocks" | "energyRequired" | "isAdHoc" | "isRecurring" | "recurringPattern" | "createdAt" | "updatedAt" | "meetingId" | "goalId" | "keyStepId", ExtArgs["result"]["task"]>
  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actionItem?: boolean | Task$actionItemArgs<ExtArgs>
    goal?: boolean | Task$goalArgs<ExtArgs>
    keyStep?: boolean | Task$keyStepArgs<ExtArgs>
    meeting?: boolean | Task$meetingArgs<ExtArgs>
    project?: boolean | Task$projectArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    timeBlocks?: boolean | Task$timeBlocksArgs<ExtArgs>
    timeEntries?: boolean | Task$timeEntriesArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goal?: boolean | Task$goalArgs<ExtArgs>
    keyStep?: boolean | Task$keyStepArgs<ExtArgs>
    meeting?: boolean | Task$meetingArgs<ExtArgs>
    project?: boolean | Task$projectArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goal?: boolean | Task$goalArgs<ExtArgs>
    keyStep?: boolean | Task$keyStepArgs<ExtArgs>
    meeting?: boolean | Task$meetingArgs<ExtArgs>
    project?: boolean | Task$projectArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      actionItem: Prisma.$ActionItemPayload<ExtArgs> | null
      goal: Prisma.$GoalPayload<ExtArgs> | null
      keyStep: Prisma.$KeyStepPayload<ExtArgs> | null
      meeting: Prisma.$MeetingPayload<ExtArgs> | null
      project: Prisma.$ProjectPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
      timeBlocks: Prisma.$TimeBlockPayload<ExtArgs>[]
      timeEntries: Prisma.$TimeEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      projectId: string | null
      title: string
      description: string | null
      status: string
      startedAt: Date | null
      completedAt: Date | null
      estimatedMinutes: number | null
      actualMinutes: number
      timerRunning: boolean
      currentTimerStart: Date | null
      scheduledDate: Date | null
      dueDate: Date | null
      priority: string
      type: string
      tags: string[]
      parentTaskId: string | null
      dependsOn: string[]
      blocks: string[]
      energyRequired: number | null
      isAdHoc: boolean
      isRecurring: boolean
      recurringPattern: string | null
      createdAt: Date
      updatedAt: Date
      meetingId: string | null
      goalId: string | null
      keyStepId: string | null
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks and returns the data updated in the database.
     * @param {TaskUpdateManyAndReturnArgs} args - Arguments to update many Tasks.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    actionItem<T extends Task$actionItemArgs<ExtArgs> = {}>(args?: Subset<T, Task$actionItemArgs<ExtArgs>>): Prisma__ActionItemClient<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    goal<T extends Task$goalArgs<ExtArgs> = {}>(args?: Subset<T, Task$goalArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    keyStep<T extends Task$keyStepArgs<ExtArgs> = {}>(args?: Subset<T, Task$keyStepArgs<ExtArgs>>): Prisma__KeyStepClient<$Result.GetResult<Prisma.$KeyStepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    meeting<T extends Task$meetingArgs<ExtArgs> = {}>(args?: Subset<T, Task$meetingArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    project<T extends Task$projectArgs<ExtArgs> = {}>(args?: Subset<T, Task$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    timeBlocks<T extends Task$timeBlocksArgs<ExtArgs> = {}>(args?: Subset<T, Task$timeBlocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeBlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    timeEntries<T extends Task$timeEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Task$timeEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly userId: FieldRef<"Task", 'String'>
    readonly projectId: FieldRef<"Task", 'String'>
    readonly title: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly status: FieldRef<"Task", 'String'>
    readonly startedAt: FieldRef<"Task", 'DateTime'>
    readonly completedAt: FieldRef<"Task", 'DateTime'>
    readonly estimatedMinutes: FieldRef<"Task", 'Int'>
    readonly actualMinutes: FieldRef<"Task", 'Int'>
    readonly timerRunning: FieldRef<"Task", 'Boolean'>
    readonly currentTimerStart: FieldRef<"Task", 'DateTime'>
    readonly scheduledDate: FieldRef<"Task", 'DateTime'>
    readonly dueDate: FieldRef<"Task", 'DateTime'>
    readonly priority: FieldRef<"Task", 'String'>
    readonly type: FieldRef<"Task", 'String'>
    readonly tags: FieldRef<"Task", 'String[]'>
    readonly parentTaskId: FieldRef<"Task", 'String'>
    readonly dependsOn: FieldRef<"Task", 'String[]'>
    readonly blocks: FieldRef<"Task", 'String[]'>
    readonly energyRequired: FieldRef<"Task", 'Float'>
    readonly isAdHoc: FieldRef<"Task", 'Boolean'>
    readonly isRecurring: FieldRef<"Task", 'Boolean'>
    readonly recurringPattern: FieldRef<"Task", 'String'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
    readonly meetingId: FieldRef<"Task", 'String'>
    readonly goalId: FieldRef<"Task", 'String'>
    readonly keyStepId: FieldRef<"Task", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Task updateManyAndReturn
   */
  export type TaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number
  }

  /**
   * Task.actionItem
   */
  export type Task$actionItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionItem
     */
    omit?: ActionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
    where?: ActionItemWhereInput
  }

  /**
   * Task.goal
   */
  export type Task$goalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    where?: GoalWhereInput
  }

  /**
   * Task.keyStep
   */
  export type Task$keyStepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyStep
     */
    select?: KeyStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyStep
     */
    omit?: KeyStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyStepInclude<ExtArgs> | null
    where?: KeyStepWhereInput
  }

  /**
   * Task.meeting
   */
  export type Task$meetingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    where?: MeetingWhereInput
  }

  /**
   * Task.project
   */
  export type Task$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Task.timeBlocks
   */
  export type Task$timeBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeBlock
     */
    select?: TimeBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeBlock
     */
    omit?: TimeBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeBlockInclude<ExtArgs> | null
    where?: TimeBlockWhereInput
    orderBy?: TimeBlockOrderByWithRelationInput | TimeBlockOrderByWithRelationInput[]
    cursor?: TimeBlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeBlockScalarFieldEnum | TimeBlockScalarFieldEnum[]
  }

  /**
   * Task.timeEntries
   */
  export type Task$timeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeEntry
     */
    omit?: TimeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    where?: TimeEntryWhereInput
    orderBy?: TimeEntryOrderByWithRelationInput | TimeEntryOrderByWithRelationInput[]
    cursor?: TimeEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeEntryScalarFieldEnum | TimeEntryScalarFieldEnum[]
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model TimeEntry
   */

  export type AggregateTimeEntry = {
    _count: TimeEntryCountAggregateOutputType | null
    _avg: TimeEntryAvgAggregateOutputType | null
    _sum: TimeEntrySumAggregateOutputType | null
    _min: TimeEntryMinAggregateOutputType | null
    _max: TimeEntryMaxAggregateOutputType | null
  }

  export type TimeEntryAvgAggregateOutputType = {
    duration: number | null
    focusQuality: number | null
    energyBefore: number | null
    energyAfter: number | null
    distractions: number | null
    hourlyRate: number | null
    amount: number | null
  }

  export type TimeEntrySumAggregateOutputType = {
    duration: number | null
    focusQuality: number | null
    energyBefore: number | null
    energyAfter: number | null
    distractions: number | null
    hourlyRate: number | null
    amount: number | null
  }

  export type TimeEntryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    taskId: string | null
    projectId: string | null
    clientId: string | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    type: string | null
    description: string | null
    focusQuality: number | null
    energyBefore: number | null
    energyAfter: number | null
    distractions: number | null
    billable: boolean | null
    hourlyRate: number | null
    amount: number | null
    invoiced: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TimeEntryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    taskId: string | null
    projectId: string | null
    clientId: string | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    type: string | null
    description: string | null
    focusQuality: number | null
    energyBefore: number | null
    energyAfter: number | null
    distractions: number | null
    billable: boolean | null
    hourlyRate: number | null
    amount: number | null
    invoiced: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TimeEntryCountAggregateOutputType = {
    id: number
    userId: number
    taskId: number
    projectId: number
    clientId: number
    startTime: number
    endTime: number
    duration: number
    type: number
    description: number
    tags: number
    focusQuality: number
    energyBefore: number
    energyAfter: number
    distractions: number
    billable: number
    hourlyRate: number
    amount: number
    invoiced: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TimeEntryAvgAggregateInputType = {
    duration?: true
    focusQuality?: true
    energyBefore?: true
    energyAfter?: true
    distractions?: true
    hourlyRate?: true
    amount?: true
  }

  export type TimeEntrySumAggregateInputType = {
    duration?: true
    focusQuality?: true
    energyBefore?: true
    energyAfter?: true
    distractions?: true
    hourlyRate?: true
    amount?: true
  }

  export type TimeEntryMinAggregateInputType = {
    id?: true
    userId?: true
    taskId?: true
    projectId?: true
    clientId?: true
    startTime?: true
    endTime?: true
    duration?: true
    type?: true
    description?: true
    focusQuality?: true
    energyBefore?: true
    energyAfter?: true
    distractions?: true
    billable?: true
    hourlyRate?: true
    amount?: true
    invoiced?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TimeEntryMaxAggregateInputType = {
    id?: true
    userId?: true
    taskId?: true
    projectId?: true
    clientId?: true
    startTime?: true
    endTime?: true
    duration?: true
    type?: true
    description?: true
    focusQuality?: true
    energyBefore?: true
    energyAfter?: true
    distractions?: true
    billable?: true
    hourlyRate?: true
    amount?: true
    invoiced?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TimeEntryCountAggregateInputType = {
    id?: true
    userId?: true
    taskId?: true
    projectId?: true
    clientId?: true
    startTime?: true
    endTime?: true
    duration?: true
    type?: true
    description?: true
    tags?: true
    focusQuality?: true
    energyBefore?: true
    energyAfter?: true
    distractions?: true
    billable?: true
    hourlyRate?: true
    amount?: true
    invoiced?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TimeEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeEntry to aggregate.
     */
    where?: TimeEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeEntries to fetch.
     */
    orderBy?: TimeEntryOrderByWithRelationInput | TimeEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimeEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TimeEntries
    **/
    _count?: true | TimeEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TimeEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TimeEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimeEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimeEntryMaxAggregateInputType
  }

  export type GetTimeEntryAggregateType<T extends TimeEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateTimeEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimeEntry[P]>
      : GetScalarType<T[P], AggregateTimeEntry[P]>
  }




  export type TimeEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeEntryWhereInput
    orderBy?: TimeEntryOrderByWithAggregationInput | TimeEntryOrderByWithAggregationInput[]
    by: TimeEntryScalarFieldEnum[] | TimeEntryScalarFieldEnum
    having?: TimeEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimeEntryCountAggregateInputType | true
    _avg?: TimeEntryAvgAggregateInputType
    _sum?: TimeEntrySumAggregateInputType
    _min?: TimeEntryMinAggregateInputType
    _max?: TimeEntryMaxAggregateInputType
  }

  export type TimeEntryGroupByOutputType = {
    id: string
    userId: string
    taskId: string | null
    projectId: string | null
    clientId: string | null
    startTime: Date
    endTime: Date | null
    duration: number
    type: string
    description: string | null
    tags: string[]
    focusQuality: number | null
    energyBefore: number | null
    energyAfter: number | null
    distractions: number
    billable: boolean
    hourlyRate: number | null
    amount: number
    invoiced: boolean
    createdAt: Date
    updatedAt: Date
    _count: TimeEntryCountAggregateOutputType | null
    _avg: TimeEntryAvgAggregateOutputType | null
    _sum: TimeEntrySumAggregateOutputType | null
    _min: TimeEntryMinAggregateOutputType | null
    _max: TimeEntryMaxAggregateOutputType | null
  }

  type GetTimeEntryGroupByPayload<T extends TimeEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimeEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimeEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimeEntryGroupByOutputType[P]>
            : GetScalarType<T[P], TimeEntryGroupByOutputType[P]>
        }
      >
    >


  export type TimeEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    taskId?: boolean
    projectId?: boolean
    clientId?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    type?: boolean
    description?: boolean
    tags?: boolean
    focusQuality?: boolean
    energyBefore?: boolean
    energyAfter?: boolean
    distractions?: boolean
    billable?: boolean
    hourlyRate?: boolean
    amount?: boolean
    invoiced?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | TimeEntry$clientArgs<ExtArgs>
    project?: boolean | TimeEntry$projectArgs<ExtArgs>
    task?: boolean | TimeEntry$taskArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeEntry"]>

  export type TimeEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    taskId?: boolean
    projectId?: boolean
    clientId?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    type?: boolean
    description?: boolean
    tags?: boolean
    focusQuality?: boolean
    energyBefore?: boolean
    energyAfter?: boolean
    distractions?: boolean
    billable?: boolean
    hourlyRate?: boolean
    amount?: boolean
    invoiced?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | TimeEntry$clientArgs<ExtArgs>
    project?: boolean | TimeEntry$projectArgs<ExtArgs>
    task?: boolean | TimeEntry$taskArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeEntry"]>

  export type TimeEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    taskId?: boolean
    projectId?: boolean
    clientId?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    type?: boolean
    description?: boolean
    tags?: boolean
    focusQuality?: boolean
    energyBefore?: boolean
    energyAfter?: boolean
    distractions?: boolean
    billable?: boolean
    hourlyRate?: boolean
    amount?: boolean
    invoiced?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | TimeEntry$clientArgs<ExtArgs>
    project?: boolean | TimeEntry$projectArgs<ExtArgs>
    task?: boolean | TimeEntry$taskArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeEntry"]>

  export type TimeEntrySelectScalar = {
    id?: boolean
    userId?: boolean
    taskId?: boolean
    projectId?: boolean
    clientId?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    type?: boolean
    description?: boolean
    tags?: boolean
    focusQuality?: boolean
    energyBefore?: boolean
    energyAfter?: boolean
    distractions?: boolean
    billable?: boolean
    hourlyRate?: boolean
    amount?: boolean
    invoiced?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TimeEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "taskId" | "projectId" | "clientId" | "startTime" | "endTime" | "duration" | "type" | "description" | "tags" | "focusQuality" | "energyBefore" | "energyAfter" | "distractions" | "billable" | "hourlyRate" | "amount" | "invoiced" | "createdAt" | "updatedAt", ExtArgs["result"]["timeEntry"]>
  export type TimeEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | TimeEntry$clientArgs<ExtArgs>
    project?: boolean | TimeEntry$projectArgs<ExtArgs>
    task?: boolean | TimeEntry$taskArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TimeEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | TimeEntry$clientArgs<ExtArgs>
    project?: boolean | TimeEntry$projectArgs<ExtArgs>
    task?: boolean | TimeEntry$taskArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TimeEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | TimeEntry$clientArgs<ExtArgs>
    project?: boolean | TimeEntry$projectArgs<ExtArgs>
    task?: boolean | TimeEntry$taskArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TimeEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TimeEntry"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs> | null
      project: Prisma.$ProjectPayload<ExtArgs> | null
      task: Prisma.$TaskPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      taskId: string | null
      projectId: string | null
      clientId: string | null
      startTime: Date
      endTime: Date | null
      duration: number
      type: string
      description: string | null
      tags: string[]
      focusQuality: number | null
      energyBefore: number | null
      energyAfter: number | null
      distractions: number
      billable: boolean
      hourlyRate: number | null
      amount: number
      invoiced: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["timeEntry"]>
    composites: {}
  }

  type TimeEntryGetPayload<S extends boolean | null | undefined | TimeEntryDefaultArgs> = $Result.GetResult<Prisma.$TimeEntryPayload, S>

  type TimeEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TimeEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TimeEntryCountAggregateInputType | true
    }

  export interface TimeEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TimeEntry'], meta: { name: 'TimeEntry' } }
    /**
     * Find zero or one TimeEntry that matches the filter.
     * @param {TimeEntryFindUniqueArgs} args - Arguments to find a TimeEntry
     * @example
     * // Get one TimeEntry
     * const timeEntry = await prisma.timeEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimeEntryFindUniqueArgs>(args: SelectSubset<T, TimeEntryFindUniqueArgs<ExtArgs>>): Prisma__TimeEntryClient<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TimeEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TimeEntryFindUniqueOrThrowArgs} args - Arguments to find a TimeEntry
     * @example
     * // Get one TimeEntry
     * const timeEntry = await prisma.timeEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimeEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, TimeEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimeEntryClient<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimeEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeEntryFindFirstArgs} args - Arguments to find a TimeEntry
     * @example
     * // Get one TimeEntry
     * const timeEntry = await prisma.timeEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimeEntryFindFirstArgs>(args?: SelectSubset<T, TimeEntryFindFirstArgs<ExtArgs>>): Prisma__TimeEntryClient<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimeEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeEntryFindFirstOrThrowArgs} args - Arguments to find a TimeEntry
     * @example
     * // Get one TimeEntry
     * const timeEntry = await prisma.timeEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimeEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, TimeEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimeEntryClient<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TimeEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TimeEntries
     * const timeEntries = await prisma.timeEntry.findMany()
     * 
     * // Get first 10 TimeEntries
     * const timeEntries = await prisma.timeEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timeEntryWithIdOnly = await prisma.timeEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimeEntryFindManyArgs>(args?: SelectSubset<T, TimeEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TimeEntry.
     * @param {TimeEntryCreateArgs} args - Arguments to create a TimeEntry.
     * @example
     * // Create one TimeEntry
     * const TimeEntry = await prisma.timeEntry.create({
     *   data: {
     *     // ... data to create a TimeEntry
     *   }
     * })
     * 
     */
    create<T extends TimeEntryCreateArgs>(args: SelectSubset<T, TimeEntryCreateArgs<ExtArgs>>): Prisma__TimeEntryClient<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TimeEntries.
     * @param {TimeEntryCreateManyArgs} args - Arguments to create many TimeEntries.
     * @example
     * // Create many TimeEntries
     * const timeEntry = await prisma.timeEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimeEntryCreateManyArgs>(args?: SelectSubset<T, TimeEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TimeEntries and returns the data saved in the database.
     * @param {TimeEntryCreateManyAndReturnArgs} args - Arguments to create many TimeEntries.
     * @example
     * // Create many TimeEntries
     * const timeEntry = await prisma.timeEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TimeEntries and only return the `id`
     * const timeEntryWithIdOnly = await prisma.timeEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TimeEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, TimeEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TimeEntry.
     * @param {TimeEntryDeleteArgs} args - Arguments to delete one TimeEntry.
     * @example
     * // Delete one TimeEntry
     * const TimeEntry = await prisma.timeEntry.delete({
     *   where: {
     *     // ... filter to delete one TimeEntry
     *   }
     * })
     * 
     */
    delete<T extends TimeEntryDeleteArgs>(args: SelectSubset<T, TimeEntryDeleteArgs<ExtArgs>>): Prisma__TimeEntryClient<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TimeEntry.
     * @param {TimeEntryUpdateArgs} args - Arguments to update one TimeEntry.
     * @example
     * // Update one TimeEntry
     * const timeEntry = await prisma.timeEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimeEntryUpdateArgs>(args: SelectSubset<T, TimeEntryUpdateArgs<ExtArgs>>): Prisma__TimeEntryClient<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TimeEntries.
     * @param {TimeEntryDeleteManyArgs} args - Arguments to filter TimeEntries to delete.
     * @example
     * // Delete a few TimeEntries
     * const { count } = await prisma.timeEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimeEntryDeleteManyArgs>(args?: SelectSubset<T, TimeEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TimeEntries
     * const timeEntry = await prisma.timeEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimeEntryUpdateManyArgs>(args: SelectSubset<T, TimeEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeEntries and returns the data updated in the database.
     * @param {TimeEntryUpdateManyAndReturnArgs} args - Arguments to update many TimeEntries.
     * @example
     * // Update many TimeEntries
     * const timeEntry = await prisma.timeEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TimeEntries and only return the `id`
     * const timeEntryWithIdOnly = await prisma.timeEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TimeEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, TimeEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TimeEntry.
     * @param {TimeEntryUpsertArgs} args - Arguments to update or create a TimeEntry.
     * @example
     * // Update or create a TimeEntry
     * const timeEntry = await prisma.timeEntry.upsert({
     *   create: {
     *     // ... data to create a TimeEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TimeEntry we want to update
     *   }
     * })
     */
    upsert<T extends TimeEntryUpsertArgs>(args: SelectSubset<T, TimeEntryUpsertArgs<ExtArgs>>): Prisma__TimeEntryClient<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TimeEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeEntryCountArgs} args - Arguments to filter TimeEntries to count.
     * @example
     * // Count the number of TimeEntries
     * const count = await prisma.timeEntry.count({
     *   where: {
     *     // ... the filter for the TimeEntries we want to count
     *   }
     * })
    **/
    count<T extends TimeEntryCountArgs>(
      args?: Subset<T, TimeEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimeEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TimeEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimeEntryAggregateArgs>(args: Subset<T, TimeEntryAggregateArgs>): Prisma.PrismaPromise<GetTimeEntryAggregateType<T>>

    /**
     * Group by TimeEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimeEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimeEntryGroupByArgs['orderBy'] }
        : { orderBy?: TimeEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimeEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimeEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TimeEntry model
   */
  readonly fields: TimeEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TimeEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimeEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends TimeEntry$clientArgs<ExtArgs> = {}>(args?: Subset<T, TimeEntry$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    project<T extends TimeEntry$projectArgs<ExtArgs> = {}>(args?: Subset<T, TimeEntry$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    task<T extends TimeEntry$taskArgs<ExtArgs> = {}>(args?: Subset<T, TimeEntry$taskArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TimeEntry model
   */
  interface TimeEntryFieldRefs {
    readonly id: FieldRef<"TimeEntry", 'String'>
    readonly userId: FieldRef<"TimeEntry", 'String'>
    readonly taskId: FieldRef<"TimeEntry", 'String'>
    readonly projectId: FieldRef<"TimeEntry", 'String'>
    readonly clientId: FieldRef<"TimeEntry", 'String'>
    readonly startTime: FieldRef<"TimeEntry", 'DateTime'>
    readonly endTime: FieldRef<"TimeEntry", 'DateTime'>
    readonly duration: FieldRef<"TimeEntry", 'Int'>
    readonly type: FieldRef<"TimeEntry", 'String'>
    readonly description: FieldRef<"TimeEntry", 'String'>
    readonly tags: FieldRef<"TimeEntry", 'String[]'>
    readonly focusQuality: FieldRef<"TimeEntry", 'Float'>
    readonly energyBefore: FieldRef<"TimeEntry", 'Float'>
    readonly energyAfter: FieldRef<"TimeEntry", 'Float'>
    readonly distractions: FieldRef<"TimeEntry", 'Int'>
    readonly billable: FieldRef<"TimeEntry", 'Boolean'>
    readonly hourlyRate: FieldRef<"TimeEntry", 'Float'>
    readonly amount: FieldRef<"TimeEntry", 'Float'>
    readonly invoiced: FieldRef<"TimeEntry", 'Boolean'>
    readonly createdAt: FieldRef<"TimeEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"TimeEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TimeEntry findUnique
   */
  export type TimeEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeEntry
     */
    omit?: TimeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * Filter, which TimeEntry to fetch.
     */
    where: TimeEntryWhereUniqueInput
  }

  /**
   * TimeEntry findUniqueOrThrow
   */
  export type TimeEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeEntry
     */
    omit?: TimeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * Filter, which TimeEntry to fetch.
     */
    where: TimeEntryWhereUniqueInput
  }

  /**
   * TimeEntry findFirst
   */
  export type TimeEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeEntry
     */
    omit?: TimeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * Filter, which TimeEntry to fetch.
     */
    where?: TimeEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeEntries to fetch.
     */
    orderBy?: TimeEntryOrderByWithRelationInput | TimeEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeEntries.
     */
    cursor?: TimeEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeEntries.
     */
    distinct?: TimeEntryScalarFieldEnum | TimeEntryScalarFieldEnum[]
  }

  /**
   * TimeEntry findFirstOrThrow
   */
  export type TimeEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeEntry
     */
    omit?: TimeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * Filter, which TimeEntry to fetch.
     */
    where?: TimeEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeEntries to fetch.
     */
    orderBy?: TimeEntryOrderByWithRelationInput | TimeEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeEntries.
     */
    cursor?: TimeEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeEntries.
     */
    distinct?: TimeEntryScalarFieldEnum | TimeEntryScalarFieldEnum[]
  }

  /**
   * TimeEntry findMany
   */
  export type TimeEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeEntry
     */
    omit?: TimeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * Filter, which TimeEntries to fetch.
     */
    where?: TimeEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeEntries to fetch.
     */
    orderBy?: TimeEntryOrderByWithRelationInput | TimeEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TimeEntries.
     */
    cursor?: TimeEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeEntries.
     */
    skip?: number
    distinct?: TimeEntryScalarFieldEnum | TimeEntryScalarFieldEnum[]
  }

  /**
   * TimeEntry create
   */
  export type TimeEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeEntry
     */
    omit?: TimeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a TimeEntry.
     */
    data: XOR<TimeEntryCreateInput, TimeEntryUncheckedCreateInput>
  }

  /**
   * TimeEntry createMany
   */
  export type TimeEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TimeEntries.
     */
    data: TimeEntryCreateManyInput | TimeEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TimeEntry createManyAndReturn
   */
  export type TimeEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimeEntry
     */
    omit?: TimeEntryOmit<ExtArgs> | null
    /**
     * The data used to create many TimeEntries.
     */
    data: TimeEntryCreateManyInput | TimeEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimeEntry update
   */
  export type TimeEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeEntry
     */
    omit?: TimeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a TimeEntry.
     */
    data: XOR<TimeEntryUpdateInput, TimeEntryUncheckedUpdateInput>
    /**
     * Choose, which TimeEntry to update.
     */
    where: TimeEntryWhereUniqueInput
  }

  /**
   * TimeEntry updateMany
   */
  export type TimeEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TimeEntries.
     */
    data: XOR<TimeEntryUpdateManyMutationInput, TimeEntryUncheckedUpdateManyInput>
    /**
     * Filter which TimeEntries to update
     */
    where?: TimeEntryWhereInput
    /**
     * Limit how many TimeEntries to update.
     */
    limit?: number
  }

  /**
   * TimeEntry updateManyAndReturn
   */
  export type TimeEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimeEntry
     */
    omit?: TimeEntryOmit<ExtArgs> | null
    /**
     * The data used to update TimeEntries.
     */
    data: XOR<TimeEntryUpdateManyMutationInput, TimeEntryUncheckedUpdateManyInput>
    /**
     * Filter which TimeEntries to update
     */
    where?: TimeEntryWhereInput
    /**
     * Limit how many TimeEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimeEntry upsert
   */
  export type TimeEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeEntry
     */
    omit?: TimeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the TimeEntry to update in case it exists.
     */
    where: TimeEntryWhereUniqueInput
    /**
     * In case the TimeEntry found by the `where` argument doesn't exist, create a new TimeEntry with this data.
     */
    create: XOR<TimeEntryCreateInput, TimeEntryUncheckedCreateInput>
    /**
     * In case the TimeEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimeEntryUpdateInput, TimeEntryUncheckedUpdateInput>
  }

  /**
   * TimeEntry delete
   */
  export type TimeEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeEntry
     */
    omit?: TimeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * Filter which TimeEntry to delete.
     */
    where: TimeEntryWhereUniqueInput
  }

  /**
   * TimeEntry deleteMany
   */
  export type TimeEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeEntries to delete
     */
    where?: TimeEntryWhereInput
    /**
     * Limit how many TimeEntries to delete.
     */
    limit?: number
  }

  /**
   * TimeEntry.client
   */
  export type TimeEntry$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * TimeEntry.project
   */
  export type TimeEntry$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * TimeEntry.task
   */
  export type TimeEntry$taskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
  }

  /**
   * TimeEntry without action
   */
  export type TimeEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeEntry
     */
    omit?: TimeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientAvgAggregateOutputType = {
    relationshipHealth: number | null
    defaultHourlyRate: number | null
    outstandingBalance: number | null
  }

  export type ClientSumAggregateOutputType = {
    relationshipHealth: number | null
    defaultHourlyRate: number | null
    outstandingBalance: number | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    companyName: string | null
    email: string | null
    phone: string | null
    industry: string | null
    website: string | null
    timezone: string | null
    relationshipHealth: number | null
    lastContactedAt: Date | null
    preferredCommunication: string | null
    defaultHourlyRate: number | null
    paymentTerms: string | null
    outstandingBalance: number | null
    notes: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastInteractionAt: Date | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    companyName: string | null
    email: string | null
    phone: string | null
    industry: string | null
    website: string | null
    timezone: string | null
    relationshipHealth: number | null
    lastContactedAt: Date | null
    preferredCommunication: string | null
    defaultHourlyRate: number | null
    paymentTerms: string | null
    outstandingBalance: number | null
    notes: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastInteractionAt: Date | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    companyName: number
    email: number
    phone: number
    primaryContact: number
    additionalContacts: number
    industry: number
    website: number
    timezone: number
    relationshipHealth: number
    lastContactedAt: number
    preferredCommunication: number
    defaultHourlyRate: number
    paymentTerms: number
    outstandingBalance: number
    notes: number
    tags: number
    status: number
    createdAt: number
    updatedAt: number
    lastInteractionAt: number
    _all: number
  }


  export type ClientAvgAggregateInputType = {
    relationshipHealth?: true
    defaultHourlyRate?: true
    outstandingBalance?: true
  }

  export type ClientSumAggregateInputType = {
    relationshipHealth?: true
    defaultHourlyRate?: true
    outstandingBalance?: true
  }

  export type ClientMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    companyName?: true
    email?: true
    phone?: true
    industry?: true
    website?: true
    timezone?: true
    relationshipHealth?: true
    lastContactedAt?: true
    preferredCommunication?: true
    defaultHourlyRate?: true
    paymentTerms?: true
    outstandingBalance?: true
    notes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    lastInteractionAt?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    companyName?: true
    email?: true
    phone?: true
    industry?: true
    website?: true
    timezone?: true
    relationshipHealth?: true
    lastContactedAt?: true
    preferredCommunication?: true
    defaultHourlyRate?: true
    paymentTerms?: true
    outstandingBalance?: true
    notes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    lastInteractionAt?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    companyName?: true
    email?: true
    phone?: true
    primaryContact?: true
    additionalContacts?: true
    industry?: true
    website?: true
    timezone?: true
    relationshipHealth?: true
    lastContactedAt?: true
    preferredCommunication?: true
    defaultHourlyRate?: true
    paymentTerms?: true
    outstandingBalance?: true
    notes?: true
    tags?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    lastInteractionAt?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _avg?: ClientAvgAggregateInputType
    _sum?: ClientSumAggregateInputType
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: string
    userId: string
    name: string
    companyName: string | null
    email: string
    phone: string | null
    primaryContact: JsonValue | null
    additionalContacts: JsonValue[]
    industry: string | null
    website: string | null
    timezone: string | null
    relationshipHealth: number | null
    lastContactedAt: Date | null
    preferredCommunication: string | null
    defaultHourlyRate: number | null
    paymentTerms: string | null
    outstandingBalance: number
    notes: string | null
    tags: string[]
    status: string
    createdAt: Date
    updatedAt: Date
    lastInteractionAt: Date | null
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    companyName?: boolean
    email?: boolean
    phone?: boolean
    primaryContact?: boolean
    additionalContacts?: boolean
    industry?: boolean
    website?: boolean
    timezone?: boolean
    relationshipHealth?: boolean
    lastContactedAt?: boolean
    preferredCommunication?: boolean
    defaultHourlyRate?: boolean
    paymentTerms?: boolean
    outstandingBalance?: boolean
    notes?: boolean
    tags?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastInteractionAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    communications?: boolean | Client$communicationsArgs<ExtArgs>
    meetings?: boolean | Client$meetingsArgs<ExtArgs>
    projects?: boolean | Client$projectsArgs<ExtArgs>
    timeBlocks?: boolean | Client$timeBlocksArgs<ExtArgs>
    timeEntries?: boolean | Client$timeEntriesArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    companyName?: boolean
    email?: boolean
    phone?: boolean
    primaryContact?: boolean
    additionalContacts?: boolean
    industry?: boolean
    website?: boolean
    timezone?: boolean
    relationshipHealth?: boolean
    lastContactedAt?: boolean
    preferredCommunication?: boolean
    defaultHourlyRate?: boolean
    paymentTerms?: boolean
    outstandingBalance?: boolean
    notes?: boolean
    tags?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastInteractionAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    companyName?: boolean
    email?: boolean
    phone?: boolean
    primaryContact?: boolean
    additionalContacts?: boolean
    industry?: boolean
    website?: boolean
    timezone?: boolean
    relationshipHealth?: boolean
    lastContactedAt?: boolean
    preferredCommunication?: boolean
    defaultHourlyRate?: boolean
    paymentTerms?: boolean
    outstandingBalance?: boolean
    notes?: boolean
    tags?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastInteractionAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    companyName?: boolean
    email?: boolean
    phone?: boolean
    primaryContact?: boolean
    additionalContacts?: boolean
    industry?: boolean
    website?: boolean
    timezone?: boolean
    relationshipHealth?: boolean
    lastContactedAt?: boolean
    preferredCommunication?: boolean
    defaultHourlyRate?: boolean
    paymentTerms?: boolean
    outstandingBalance?: boolean
    notes?: boolean
    tags?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastInteractionAt?: boolean
  }

  export type ClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "companyName" | "email" | "phone" | "primaryContact" | "additionalContacts" | "industry" | "website" | "timezone" | "relationshipHealth" | "lastContactedAt" | "preferredCommunication" | "defaultHourlyRate" | "paymentTerms" | "outstandingBalance" | "notes" | "tags" | "status" | "createdAt" | "updatedAt" | "lastInteractionAt", ExtArgs["result"]["client"]>
  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    communications?: boolean | Client$communicationsArgs<ExtArgs>
    meetings?: boolean | Client$meetingsArgs<ExtArgs>
    projects?: boolean | Client$projectsArgs<ExtArgs>
    timeBlocks?: boolean | Client$timeBlocksArgs<ExtArgs>
    timeEntries?: boolean | Client$timeEntriesArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      communications: Prisma.$CommunicationPayload<ExtArgs>[]
      meetings: Prisma.$MeetingPayload<ExtArgs>[]
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      timeBlocks: Prisma.$TimeBlockPayload<ExtArgs>[]
      timeEntries: Prisma.$TimeEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      companyName: string | null
      email: string
      phone: string | null
      primaryContact: Prisma.JsonValue | null
      additionalContacts: Prisma.JsonValue[]
      industry: string | null
      website: string | null
      timezone: string | null
      relationshipHealth: number | null
      lastContactedAt: Date | null
      preferredCommunication: string | null
      defaultHourlyRate: number | null
      paymentTerms: string | null
      outstandingBalance: number
      notes: string | null
      tags: string[]
      status: string
      createdAt: Date
      updatedAt: Date
      lastInteractionAt: Date | null
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {ClientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients and returns the data updated in the database.
     * @param {ClientUpdateManyAndReturnArgs} args - Arguments to update many Clients.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    communications<T extends Client$communicationsArgs<ExtArgs> = {}>(args?: Subset<T, Client$communicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    meetings<T extends Client$meetingsArgs<ExtArgs> = {}>(args?: Subset<T, Client$meetingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projects<T extends Client$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Client$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    timeBlocks<T extends Client$timeBlocksArgs<ExtArgs> = {}>(args?: Subset<T, Client$timeBlocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeBlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    timeEntries<T extends Client$timeEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Client$timeEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'String'>
    readonly userId: FieldRef<"Client", 'String'>
    readonly name: FieldRef<"Client", 'String'>
    readonly companyName: FieldRef<"Client", 'String'>
    readonly email: FieldRef<"Client", 'String'>
    readonly phone: FieldRef<"Client", 'String'>
    readonly primaryContact: FieldRef<"Client", 'Json'>
    readonly additionalContacts: FieldRef<"Client", 'Json[]'>
    readonly industry: FieldRef<"Client", 'String'>
    readonly website: FieldRef<"Client", 'String'>
    readonly timezone: FieldRef<"Client", 'String'>
    readonly relationshipHealth: FieldRef<"Client", 'Float'>
    readonly lastContactedAt: FieldRef<"Client", 'DateTime'>
    readonly preferredCommunication: FieldRef<"Client", 'String'>
    readonly defaultHourlyRate: FieldRef<"Client", 'Float'>
    readonly paymentTerms: FieldRef<"Client", 'String'>
    readonly outstandingBalance: FieldRef<"Client", 'Float'>
    readonly notes: FieldRef<"Client", 'String'>
    readonly tags: FieldRef<"Client", 'String[]'>
    readonly status: FieldRef<"Client", 'String'>
    readonly createdAt: FieldRef<"Client", 'DateTime'>
    readonly updatedAt: FieldRef<"Client", 'DateTime'>
    readonly lastInteractionAt: FieldRef<"Client", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client createManyAndReturn
   */
  export type ClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client updateManyAndReturn
   */
  export type ClientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to delete.
     */
    limit?: number
  }

  /**
   * Client.communications
   */
  export type Client$communicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    where?: CommunicationWhereInput
    orderBy?: CommunicationOrderByWithRelationInput | CommunicationOrderByWithRelationInput[]
    cursor?: CommunicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunicationScalarFieldEnum | CommunicationScalarFieldEnum[]
  }

  /**
   * Client.meetings
   */
  export type Client$meetingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    where?: MeetingWhereInput
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    cursor?: MeetingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Client.projects
   */
  export type Client$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Client.timeBlocks
   */
  export type Client$timeBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeBlock
     */
    select?: TimeBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeBlock
     */
    omit?: TimeBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeBlockInclude<ExtArgs> | null
    where?: TimeBlockWhereInput
    orderBy?: TimeBlockOrderByWithRelationInput | TimeBlockOrderByWithRelationInput[]
    cursor?: TimeBlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeBlockScalarFieldEnum | TimeBlockScalarFieldEnum[]
  }

  /**
   * Client.timeEntries
   */
  export type Client$timeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeEntry
     */
    omit?: TimeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    where?: TimeEntryWhereInput
    orderBy?: TimeEntryOrderByWithRelationInput | TimeEntryOrderByWithRelationInput[]
    cursor?: TimeEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeEntryScalarFieldEnum | TimeEntryScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model Communication
   */

  export type AggregateCommunication = {
    _count: CommunicationCountAggregateOutputType | null
    _avg: CommunicationAvgAggregateOutputType | null
    _sum: CommunicationSumAggregateOutputType | null
    _min: CommunicationMinAggregateOutputType | null
    _max: CommunicationMaxAggregateOutputType | null
  }

  export type CommunicationAvgAggregateOutputType = {
    meetingDuration: number | null
    responseTime: number | null
  }

  export type CommunicationSumAggregateOutputType = {
    meetingDuration: number | null
    responseTime: number | null
  }

  export type CommunicationMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    projectId: string | null
    type: string | null
    direction: string | null
    subject: string | null
    content: string | null
    summary: string | null
    from: string | null
    meetingDate: Date | null
    meetingDuration: number | null
    meetingNotes: string | null
    sentiment: string | null
    requiresFollowUp: boolean | null
    followUpDate: Date | null
    createdAt: Date | null
    responseTime: number | null
  }

  export type CommunicationMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    projectId: string | null
    type: string | null
    direction: string | null
    subject: string | null
    content: string | null
    summary: string | null
    from: string | null
    meetingDate: Date | null
    meetingDuration: number | null
    meetingNotes: string | null
    sentiment: string | null
    requiresFollowUp: boolean | null
    followUpDate: Date | null
    createdAt: Date | null
    responseTime: number | null
  }

  export type CommunicationCountAggregateOutputType = {
    id: number
    clientId: number
    projectId: number
    type: number
    direction: number
    subject: number
    content: number
    summary: number
    from: number
    to: number
    cc: number
    attachments: number
    meetingDate: number
    meetingDuration: number
    attendees: number
    meetingNotes: number
    sentiment: number
    requiresFollowUp: number
    followUpDate: number
    createdAt: number
    responseTime: number
    _all: number
  }


  export type CommunicationAvgAggregateInputType = {
    meetingDuration?: true
    responseTime?: true
  }

  export type CommunicationSumAggregateInputType = {
    meetingDuration?: true
    responseTime?: true
  }

  export type CommunicationMinAggregateInputType = {
    id?: true
    clientId?: true
    projectId?: true
    type?: true
    direction?: true
    subject?: true
    content?: true
    summary?: true
    from?: true
    meetingDate?: true
    meetingDuration?: true
    meetingNotes?: true
    sentiment?: true
    requiresFollowUp?: true
    followUpDate?: true
    createdAt?: true
    responseTime?: true
  }

  export type CommunicationMaxAggregateInputType = {
    id?: true
    clientId?: true
    projectId?: true
    type?: true
    direction?: true
    subject?: true
    content?: true
    summary?: true
    from?: true
    meetingDate?: true
    meetingDuration?: true
    meetingNotes?: true
    sentiment?: true
    requiresFollowUp?: true
    followUpDate?: true
    createdAt?: true
    responseTime?: true
  }

  export type CommunicationCountAggregateInputType = {
    id?: true
    clientId?: true
    projectId?: true
    type?: true
    direction?: true
    subject?: true
    content?: true
    summary?: true
    from?: true
    to?: true
    cc?: true
    attachments?: true
    meetingDate?: true
    meetingDuration?: true
    attendees?: true
    meetingNotes?: true
    sentiment?: true
    requiresFollowUp?: true
    followUpDate?: true
    createdAt?: true
    responseTime?: true
    _all?: true
  }

  export type CommunicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Communication to aggregate.
     */
    where?: CommunicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communications to fetch.
     */
    orderBy?: CommunicationOrderByWithRelationInput | CommunicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Communications
    **/
    _count?: true | CommunicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommunicationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommunicationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunicationMaxAggregateInputType
  }

  export type GetCommunicationAggregateType<T extends CommunicationAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunication[P]>
      : GetScalarType<T[P], AggregateCommunication[P]>
  }




  export type CommunicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunicationWhereInput
    orderBy?: CommunicationOrderByWithAggregationInput | CommunicationOrderByWithAggregationInput[]
    by: CommunicationScalarFieldEnum[] | CommunicationScalarFieldEnum
    having?: CommunicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunicationCountAggregateInputType | true
    _avg?: CommunicationAvgAggregateInputType
    _sum?: CommunicationSumAggregateInputType
    _min?: CommunicationMinAggregateInputType
    _max?: CommunicationMaxAggregateInputType
  }

  export type CommunicationGroupByOutputType = {
    id: string
    clientId: string
    projectId: string | null
    type: string
    direction: string
    subject: string
    content: string
    summary: string | null
    from: string | null
    to: string[]
    cc: string[]
    attachments: JsonValue[]
    meetingDate: Date | null
    meetingDuration: number | null
    attendees: string[]
    meetingNotes: string | null
    sentiment: string | null
    requiresFollowUp: boolean
    followUpDate: Date | null
    createdAt: Date
    responseTime: number | null
    _count: CommunicationCountAggregateOutputType | null
    _avg: CommunicationAvgAggregateOutputType | null
    _sum: CommunicationSumAggregateOutputType | null
    _min: CommunicationMinAggregateOutputType | null
    _max: CommunicationMaxAggregateOutputType | null
  }

  type GetCommunicationGroupByPayload<T extends CommunicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunicationGroupByOutputType[P]>
            : GetScalarType<T[P], CommunicationGroupByOutputType[P]>
        }
      >
    >


  export type CommunicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    projectId?: boolean
    type?: boolean
    direction?: boolean
    subject?: boolean
    content?: boolean
    summary?: boolean
    from?: boolean
    to?: boolean
    cc?: boolean
    attachments?: boolean
    meetingDate?: boolean
    meetingDuration?: boolean
    attendees?: boolean
    meetingNotes?: boolean
    sentiment?: boolean
    requiresFollowUp?: boolean
    followUpDate?: boolean
    createdAt?: boolean
    responseTime?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["communication"]>

  export type CommunicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    projectId?: boolean
    type?: boolean
    direction?: boolean
    subject?: boolean
    content?: boolean
    summary?: boolean
    from?: boolean
    to?: boolean
    cc?: boolean
    attachments?: boolean
    meetingDate?: boolean
    meetingDuration?: boolean
    attendees?: boolean
    meetingNotes?: boolean
    sentiment?: boolean
    requiresFollowUp?: boolean
    followUpDate?: boolean
    createdAt?: boolean
    responseTime?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["communication"]>

  export type CommunicationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    projectId?: boolean
    type?: boolean
    direction?: boolean
    subject?: boolean
    content?: boolean
    summary?: boolean
    from?: boolean
    to?: boolean
    cc?: boolean
    attachments?: boolean
    meetingDate?: boolean
    meetingDuration?: boolean
    attendees?: boolean
    meetingNotes?: boolean
    sentiment?: boolean
    requiresFollowUp?: boolean
    followUpDate?: boolean
    createdAt?: boolean
    responseTime?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["communication"]>

  export type CommunicationSelectScalar = {
    id?: boolean
    clientId?: boolean
    projectId?: boolean
    type?: boolean
    direction?: boolean
    subject?: boolean
    content?: boolean
    summary?: boolean
    from?: boolean
    to?: boolean
    cc?: boolean
    attachments?: boolean
    meetingDate?: boolean
    meetingDuration?: boolean
    attendees?: boolean
    meetingNotes?: boolean
    sentiment?: boolean
    requiresFollowUp?: boolean
    followUpDate?: boolean
    createdAt?: boolean
    responseTime?: boolean
  }

  export type CommunicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "projectId" | "type" | "direction" | "subject" | "content" | "summary" | "from" | "to" | "cc" | "attachments" | "meetingDate" | "meetingDuration" | "attendees" | "meetingNotes" | "sentiment" | "requiresFollowUp" | "followUpDate" | "createdAt" | "responseTime", ExtArgs["result"]["communication"]>
  export type CommunicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type CommunicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type CommunicationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $CommunicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Communication"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      projectId: string | null
      type: string
      direction: string
      subject: string
      content: string
      summary: string | null
      from: string | null
      to: string[]
      cc: string[]
      attachments: Prisma.JsonValue[]
      meetingDate: Date | null
      meetingDuration: number | null
      attendees: string[]
      meetingNotes: string | null
      sentiment: string | null
      requiresFollowUp: boolean
      followUpDate: Date | null
      createdAt: Date
      responseTime: number | null
    }, ExtArgs["result"]["communication"]>
    composites: {}
  }

  type CommunicationGetPayload<S extends boolean | null | undefined | CommunicationDefaultArgs> = $Result.GetResult<Prisma.$CommunicationPayload, S>

  type CommunicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommunicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommunicationCountAggregateInputType | true
    }

  export interface CommunicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Communication'], meta: { name: 'Communication' } }
    /**
     * Find zero or one Communication that matches the filter.
     * @param {CommunicationFindUniqueArgs} args - Arguments to find a Communication
     * @example
     * // Get one Communication
     * const communication = await prisma.communication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommunicationFindUniqueArgs>(args: SelectSubset<T, CommunicationFindUniqueArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Communication that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommunicationFindUniqueOrThrowArgs} args - Arguments to find a Communication
     * @example
     * // Get one Communication
     * const communication = await prisma.communication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommunicationFindUniqueOrThrowArgs>(args: SelectSubset<T, CommunicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Communication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationFindFirstArgs} args - Arguments to find a Communication
     * @example
     * // Get one Communication
     * const communication = await prisma.communication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommunicationFindFirstArgs>(args?: SelectSubset<T, CommunicationFindFirstArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Communication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationFindFirstOrThrowArgs} args - Arguments to find a Communication
     * @example
     * // Get one Communication
     * const communication = await prisma.communication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommunicationFindFirstOrThrowArgs>(args?: SelectSubset<T, CommunicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Communications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Communications
     * const communications = await prisma.communication.findMany()
     * 
     * // Get first 10 Communications
     * const communications = await prisma.communication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communicationWithIdOnly = await prisma.communication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommunicationFindManyArgs>(args?: SelectSubset<T, CommunicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Communication.
     * @param {CommunicationCreateArgs} args - Arguments to create a Communication.
     * @example
     * // Create one Communication
     * const Communication = await prisma.communication.create({
     *   data: {
     *     // ... data to create a Communication
     *   }
     * })
     * 
     */
    create<T extends CommunicationCreateArgs>(args: SelectSubset<T, CommunicationCreateArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Communications.
     * @param {CommunicationCreateManyArgs} args - Arguments to create many Communications.
     * @example
     * // Create many Communications
     * const communication = await prisma.communication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommunicationCreateManyArgs>(args?: SelectSubset<T, CommunicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Communications and returns the data saved in the database.
     * @param {CommunicationCreateManyAndReturnArgs} args - Arguments to create many Communications.
     * @example
     * // Create many Communications
     * const communication = await prisma.communication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Communications and only return the `id`
     * const communicationWithIdOnly = await prisma.communication.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommunicationCreateManyAndReturnArgs>(args?: SelectSubset<T, CommunicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Communication.
     * @param {CommunicationDeleteArgs} args - Arguments to delete one Communication.
     * @example
     * // Delete one Communication
     * const Communication = await prisma.communication.delete({
     *   where: {
     *     // ... filter to delete one Communication
     *   }
     * })
     * 
     */
    delete<T extends CommunicationDeleteArgs>(args: SelectSubset<T, CommunicationDeleteArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Communication.
     * @param {CommunicationUpdateArgs} args - Arguments to update one Communication.
     * @example
     * // Update one Communication
     * const communication = await prisma.communication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommunicationUpdateArgs>(args: SelectSubset<T, CommunicationUpdateArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Communications.
     * @param {CommunicationDeleteManyArgs} args - Arguments to filter Communications to delete.
     * @example
     * // Delete a few Communications
     * const { count } = await prisma.communication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommunicationDeleteManyArgs>(args?: SelectSubset<T, CommunicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Communications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Communications
     * const communication = await prisma.communication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommunicationUpdateManyArgs>(args: SelectSubset<T, CommunicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Communications and returns the data updated in the database.
     * @param {CommunicationUpdateManyAndReturnArgs} args - Arguments to update many Communications.
     * @example
     * // Update many Communications
     * const communication = await prisma.communication.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Communications and only return the `id`
     * const communicationWithIdOnly = await prisma.communication.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommunicationUpdateManyAndReturnArgs>(args: SelectSubset<T, CommunicationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Communication.
     * @param {CommunicationUpsertArgs} args - Arguments to update or create a Communication.
     * @example
     * // Update or create a Communication
     * const communication = await prisma.communication.upsert({
     *   create: {
     *     // ... data to create a Communication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Communication we want to update
     *   }
     * })
     */
    upsert<T extends CommunicationUpsertArgs>(args: SelectSubset<T, CommunicationUpsertArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Communications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationCountArgs} args - Arguments to filter Communications to count.
     * @example
     * // Count the number of Communications
     * const count = await prisma.communication.count({
     *   where: {
     *     // ... the filter for the Communications we want to count
     *   }
     * })
    **/
    count<T extends CommunicationCountArgs>(
      args?: Subset<T, CommunicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Communication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunicationAggregateArgs>(args: Subset<T, CommunicationAggregateArgs>): Prisma.PrismaPromise<GetCommunicationAggregateType<T>>

    /**
     * Group by Communication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunicationGroupByArgs['orderBy'] }
        : { orderBy?: CommunicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Communication model
   */
  readonly fields: CommunicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Communication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Communication model
   */
  interface CommunicationFieldRefs {
    readonly id: FieldRef<"Communication", 'String'>
    readonly clientId: FieldRef<"Communication", 'String'>
    readonly projectId: FieldRef<"Communication", 'String'>
    readonly type: FieldRef<"Communication", 'String'>
    readonly direction: FieldRef<"Communication", 'String'>
    readonly subject: FieldRef<"Communication", 'String'>
    readonly content: FieldRef<"Communication", 'String'>
    readonly summary: FieldRef<"Communication", 'String'>
    readonly from: FieldRef<"Communication", 'String'>
    readonly to: FieldRef<"Communication", 'String[]'>
    readonly cc: FieldRef<"Communication", 'String[]'>
    readonly attachments: FieldRef<"Communication", 'Json[]'>
    readonly meetingDate: FieldRef<"Communication", 'DateTime'>
    readonly meetingDuration: FieldRef<"Communication", 'Int'>
    readonly attendees: FieldRef<"Communication", 'String[]'>
    readonly meetingNotes: FieldRef<"Communication", 'String'>
    readonly sentiment: FieldRef<"Communication", 'String'>
    readonly requiresFollowUp: FieldRef<"Communication", 'Boolean'>
    readonly followUpDate: FieldRef<"Communication", 'DateTime'>
    readonly createdAt: FieldRef<"Communication", 'DateTime'>
    readonly responseTime: FieldRef<"Communication", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Communication findUnique
   */
  export type CommunicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * Filter, which Communication to fetch.
     */
    where: CommunicationWhereUniqueInput
  }

  /**
   * Communication findUniqueOrThrow
   */
  export type CommunicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * Filter, which Communication to fetch.
     */
    where: CommunicationWhereUniqueInput
  }

  /**
   * Communication findFirst
   */
  export type CommunicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * Filter, which Communication to fetch.
     */
    where?: CommunicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communications to fetch.
     */
    orderBy?: CommunicationOrderByWithRelationInput | CommunicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Communications.
     */
    cursor?: CommunicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Communications.
     */
    distinct?: CommunicationScalarFieldEnum | CommunicationScalarFieldEnum[]
  }

  /**
   * Communication findFirstOrThrow
   */
  export type CommunicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * Filter, which Communication to fetch.
     */
    where?: CommunicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communications to fetch.
     */
    orderBy?: CommunicationOrderByWithRelationInput | CommunicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Communications.
     */
    cursor?: CommunicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Communications.
     */
    distinct?: CommunicationScalarFieldEnum | CommunicationScalarFieldEnum[]
  }

  /**
   * Communication findMany
   */
  export type CommunicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * Filter, which Communications to fetch.
     */
    where?: CommunicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communications to fetch.
     */
    orderBy?: CommunicationOrderByWithRelationInput | CommunicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Communications.
     */
    cursor?: CommunicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communications.
     */
    skip?: number
    distinct?: CommunicationScalarFieldEnum | CommunicationScalarFieldEnum[]
  }

  /**
   * Communication create
   */
  export type CommunicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * The data needed to create a Communication.
     */
    data: XOR<CommunicationCreateInput, CommunicationUncheckedCreateInput>
  }

  /**
   * Communication createMany
   */
  export type CommunicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Communications.
     */
    data: CommunicationCreateManyInput | CommunicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Communication createManyAndReturn
   */
  export type CommunicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * The data used to create many Communications.
     */
    data: CommunicationCreateManyInput | CommunicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Communication update
   */
  export type CommunicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * The data needed to update a Communication.
     */
    data: XOR<CommunicationUpdateInput, CommunicationUncheckedUpdateInput>
    /**
     * Choose, which Communication to update.
     */
    where: CommunicationWhereUniqueInput
  }

  /**
   * Communication updateMany
   */
  export type CommunicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Communications.
     */
    data: XOR<CommunicationUpdateManyMutationInput, CommunicationUncheckedUpdateManyInput>
    /**
     * Filter which Communications to update
     */
    where?: CommunicationWhereInput
    /**
     * Limit how many Communications to update.
     */
    limit?: number
  }

  /**
   * Communication updateManyAndReturn
   */
  export type CommunicationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * The data used to update Communications.
     */
    data: XOR<CommunicationUpdateManyMutationInput, CommunicationUncheckedUpdateManyInput>
    /**
     * Filter which Communications to update
     */
    where?: CommunicationWhereInput
    /**
     * Limit how many Communications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Communication upsert
   */
  export type CommunicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * The filter to search for the Communication to update in case it exists.
     */
    where: CommunicationWhereUniqueInput
    /**
     * In case the Communication found by the `where` argument doesn't exist, create a new Communication with this data.
     */
    create: XOR<CommunicationCreateInput, CommunicationUncheckedCreateInput>
    /**
     * In case the Communication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunicationUpdateInput, CommunicationUncheckedUpdateInput>
  }

  /**
   * Communication delete
   */
  export type CommunicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * Filter which Communication to delete.
     */
    where: CommunicationWhereUniqueInput
  }

  /**
   * Communication deleteMany
   */
  export type CommunicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Communications to delete
     */
    where?: CommunicationWhereInput
    /**
     * Limit how many Communications to delete.
     */
    limit?: number
  }

  /**
   * Communication without action
   */
  export type CommunicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
  }


  /**
   * Model Meeting
   */

  export type AggregateMeeting = {
    _count: MeetingCountAggregateOutputType | null
    _avg: MeetingAvgAggregateOutputType | null
    _sum: MeetingSumAggregateOutputType | null
    _min: MeetingMinAggregateOutputType | null
    _max: MeetingMaxAggregateOutputType | null
  }

  export type MeetingAvgAggregateOutputType = {
    duration: number | null
  }

  export type MeetingSumAggregateOutputType = {
    duration: number | null
  }

  export type MeetingMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    projectId: string | null
    title: string | null
    description: string | null
    type: string | null
    scheduledAt: Date | null
    duration: number | null
    timezone: string | null
    organizer: string | null
    location: string | null
    meetingLink: string | null
    agenda: string | null
    meetingNotes: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type MeetingMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    projectId: string | null
    title: string | null
    description: string | null
    type: string | null
    scheduledAt: Date | null
    duration: number | null
    timezone: string | null
    organizer: string | null
    location: string | null
    meetingLink: string | null
    agenda: string | null
    meetingNotes: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type MeetingCountAggregateOutputType = {
    id: number
    clientId: number
    projectId: number
    title: number
    description: number
    type: number
    scheduledAt: number
    duration: number
    timezone: number
    organizer: number
    requiredAttendees: number
    optionalAttendees: number
    location: number
    meetingLink: number
    agenda: number
    meetingNotes: number
    actionItems: number
    decisions: number
    status: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type MeetingAvgAggregateInputType = {
    duration?: true
  }

  export type MeetingSumAggregateInputType = {
    duration?: true
  }

  export type MeetingMinAggregateInputType = {
    id?: true
    clientId?: true
    projectId?: true
    title?: true
    description?: true
    type?: true
    scheduledAt?: true
    duration?: true
    timezone?: true
    organizer?: true
    location?: true
    meetingLink?: true
    agenda?: true
    meetingNotes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type MeetingMaxAggregateInputType = {
    id?: true
    clientId?: true
    projectId?: true
    title?: true
    description?: true
    type?: true
    scheduledAt?: true
    duration?: true
    timezone?: true
    organizer?: true
    location?: true
    meetingLink?: true
    agenda?: true
    meetingNotes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type MeetingCountAggregateInputType = {
    id?: true
    clientId?: true
    projectId?: true
    title?: true
    description?: true
    type?: true
    scheduledAt?: true
    duration?: true
    timezone?: true
    organizer?: true
    requiredAttendees?: true
    optionalAttendees?: true
    location?: true
    meetingLink?: true
    agenda?: true
    meetingNotes?: true
    actionItems?: true
    decisions?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type MeetingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Meeting to aggregate.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Meetings
    **/
    _count?: true | MeetingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MeetingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MeetingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MeetingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MeetingMaxAggregateInputType
  }

  export type GetMeetingAggregateType<T extends MeetingAggregateArgs> = {
        [P in keyof T & keyof AggregateMeeting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeeting[P]>
      : GetScalarType<T[P], AggregateMeeting[P]>
  }




  export type MeetingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingWhereInput
    orderBy?: MeetingOrderByWithAggregationInput | MeetingOrderByWithAggregationInput[]
    by: MeetingScalarFieldEnum[] | MeetingScalarFieldEnum
    having?: MeetingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MeetingCountAggregateInputType | true
    _avg?: MeetingAvgAggregateInputType
    _sum?: MeetingSumAggregateInputType
    _min?: MeetingMinAggregateInputType
    _max?: MeetingMaxAggregateInputType
  }

  export type MeetingGroupByOutputType = {
    id: string
    clientId: string | null
    projectId: string | null
    title: string
    description: string | null
    type: string
    scheduledAt: Date
    duration: number
    timezone: string
    organizer: string
    requiredAttendees: string[]
    optionalAttendees: string[]
    location: string | null
    meetingLink: string | null
    agenda: string | null
    meetingNotes: string | null
    actionItems: JsonValue[]
    decisions: string[]
    status: string
    createdAt: Date
    updatedAt: Date
    userId: string
    _count: MeetingCountAggregateOutputType | null
    _avg: MeetingAvgAggregateOutputType | null
    _sum: MeetingSumAggregateOutputType | null
    _min: MeetingMinAggregateOutputType | null
    _max: MeetingMaxAggregateOutputType | null
  }

  type GetMeetingGroupByPayload<T extends MeetingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MeetingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MeetingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeetingGroupByOutputType[P]>
            : GetScalarType<T[P], MeetingGroupByOutputType[P]>
        }
      >
    >


  export type MeetingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    scheduledAt?: boolean
    duration?: boolean
    timezone?: boolean
    organizer?: boolean
    requiredAttendees?: boolean
    optionalAttendees?: boolean
    location?: boolean
    meetingLink?: boolean
    agenda?: boolean
    meetingNotes?: boolean
    actionItems?: boolean
    decisions?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    client?: boolean | Meeting$clientArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    tasks?: boolean | Meeting$tasksArgs<ExtArgs>
    _count?: boolean | MeetingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meeting"]>

  export type MeetingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    scheduledAt?: boolean
    duration?: boolean
    timezone?: boolean
    organizer?: boolean
    requiredAttendees?: boolean
    optionalAttendees?: boolean
    location?: boolean
    meetingLink?: boolean
    agenda?: boolean
    meetingNotes?: boolean
    actionItems?: boolean
    decisions?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    client?: boolean | Meeting$clientArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meeting"]>

  export type MeetingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    scheduledAt?: boolean
    duration?: boolean
    timezone?: boolean
    organizer?: boolean
    requiredAttendees?: boolean
    optionalAttendees?: boolean
    location?: boolean
    meetingLink?: boolean
    agenda?: boolean
    meetingNotes?: boolean
    actionItems?: boolean
    decisions?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    client?: boolean | Meeting$clientArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meeting"]>

  export type MeetingSelectScalar = {
    id?: boolean
    clientId?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    scheduledAt?: boolean
    duration?: boolean
    timezone?: boolean
    organizer?: boolean
    requiredAttendees?: boolean
    optionalAttendees?: boolean
    location?: boolean
    meetingLink?: boolean
    agenda?: boolean
    meetingNotes?: boolean
    actionItems?: boolean
    decisions?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type MeetingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "projectId" | "title" | "description" | "type" | "scheduledAt" | "duration" | "timezone" | "organizer" | "requiredAttendees" | "optionalAttendees" | "location" | "meetingLink" | "agenda" | "meetingNotes" | "actionItems" | "decisions" | "status" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["meeting"]>
  export type MeetingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Meeting$clientArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    tasks?: boolean | Meeting$tasksArgs<ExtArgs>
    _count?: boolean | MeetingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MeetingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Meeting$clientArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MeetingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Meeting$clientArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MeetingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Meeting"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string | null
      projectId: string | null
      title: string
      description: string | null
      type: string
      scheduledAt: Date
      duration: number
      timezone: string
      organizer: string
      requiredAttendees: string[]
      optionalAttendees: string[]
      location: string | null
      meetingLink: string | null
      agenda: string | null
      meetingNotes: string | null
      actionItems: Prisma.JsonValue[]
      decisions: string[]
      status: string
      createdAt: Date
      updatedAt: Date
      userId: string
    }, ExtArgs["result"]["meeting"]>
    composites: {}
  }

  type MeetingGetPayload<S extends boolean | null | undefined | MeetingDefaultArgs> = $Result.GetResult<Prisma.$MeetingPayload, S>

  type MeetingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MeetingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MeetingCountAggregateInputType | true
    }

  export interface MeetingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Meeting'], meta: { name: 'Meeting' } }
    /**
     * Find zero or one Meeting that matches the filter.
     * @param {MeetingFindUniqueArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MeetingFindUniqueArgs>(args: SelectSubset<T, MeetingFindUniqueArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Meeting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MeetingFindUniqueOrThrowArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MeetingFindUniqueOrThrowArgs>(args: SelectSubset<T, MeetingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Meeting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingFindFirstArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MeetingFindFirstArgs>(args?: SelectSubset<T, MeetingFindFirstArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Meeting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingFindFirstOrThrowArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MeetingFindFirstOrThrowArgs>(args?: SelectSubset<T, MeetingFindFirstOrThrowArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Meetings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Meetings
     * const meetings = await prisma.meeting.findMany()
     * 
     * // Get first 10 Meetings
     * const meetings = await prisma.meeting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const meetingWithIdOnly = await prisma.meeting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MeetingFindManyArgs>(args?: SelectSubset<T, MeetingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Meeting.
     * @param {MeetingCreateArgs} args - Arguments to create a Meeting.
     * @example
     * // Create one Meeting
     * const Meeting = await prisma.meeting.create({
     *   data: {
     *     // ... data to create a Meeting
     *   }
     * })
     * 
     */
    create<T extends MeetingCreateArgs>(args: SelectSubset<T, MeetingCreateArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Meetings.
     * @param {MeetingCreateManyArgs} args - Arguments to create many Meetings.
     * @example
     * // Create many Meetings
     * const meeting = await prisma.meeting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MeetingCreateManyArgs>(args?: SelectSubset<T, MeetingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Meetings and returns the data saved in the database.
     * @param {MeetingCreateManyAndReturnArgs} args - Arguments to create many Meetings.
     * @example
     * // Create many Meetings
     * const meeting = await prisma.meeting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Meetings and only return the `id`
     * const meetingWithIdOnly = await prisma.meeting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MeetingCreateManyAndReturnArgs>(args?: SelectSubset<T, MeetingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Meeting.
     * @param {MeetingDeleteArgs} args - Arguments to delete one Meeting.
     * @example
     * // Delete one Meeting
     * const Meeting = await prisma.meeting.delete({
     *   where: {
     *     // ... filter to delete one Meeting
     *   }
     * })
     * 
     */
    delete<T extends MeetingDeleteArgs>(args: SelectSubset<T, MeetingDeleteArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Meeting.
     * @param {MeetingUpdateArgs} args - Arguments to update one Meeting.
     * @example
     * // Update one Meeting
     * const meeting = await prisma.meeting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MeetingUpdateArgs>(args: SelectSubset<T, MeetingUpdateArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Meetings.
     * @param {MeetingDeleteManyArgs} args - Arguments to filter Meetings to delete.
     * @example
     * // Delete a few Meetings
     * const { count } = await prisma.meeting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MeetingDeleteManyArgs>(args?: SelectSubset<T, MeetingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Meetings
     * const meeting = await prisma.meeting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MeetingUpdateManyArgs>(args: SelectSubset<T, MeetingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meetings and returns the data updated in the database.
     * @param {MeetingUpdateManyAndReturnArgs} args - Arguments to update many Meetings.
     * @example
     * // Update many Meetings
     * const meeting = await prisma.meeting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Meetings and only return the `id`
     * const meetingWithIdOnly = await prisma.meeting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MeetingUpdateManyAndReturnArgs>(args: SelectSubset<T, MeetingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Meeting.
     * @param {MeetingUpsertArgs} args - Arguments to update or create a Meeting.
     * @example
     * // Update or create a Meeting
     * const meeting = await prisma.meeting.upsert({
     *   create: {
     *     // ... data to create a Meeting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Meeting we want to update
     *   }
     * })
     */
    upsert<T extends MeetingUpsertArgs>(args: SelectSubset<T, MeetingUpsertArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Meetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingCountArgs} args - Arguments to filter Meetings to count.
     * @example
     * // Count the number of Meetings
     * const count = await prisma.meeting.count({
     *   where: {
     *     // ... the filter for the Meetings we want to count
     *   }
     * })
    **/
    count<T extends MeetingCountArgs>(
      args?: Subset<T, MeetingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeetingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Meeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MeetingAggregateArgs>(args: Subset<T, MeetingAggregateArgs>): Prisma.PrismaPromise<GetMeetingAggregateType<T>>

    /**
     * Group by Meeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MeetingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MeetingGroupByArgs['orderBy'] }
        : { orderBy?: MeetingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MeetingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeetingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Meeting model
   */
  readonly fields: MeetingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Meeting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MeetingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends Meeting$clientArgs<ExtArgs> = {}>(args?: Subset<T, Meeting$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tasks<T extends Meeting$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Meeting$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Meeting model
   */
  interface MeetingFieldRefs {
    readonly id: FieldRef<"Meeting", 'String'>
    readonly clientId: FieldRef<"Meeting", 'String'>
    readonly projectId: FieldRef<"Meeting", 'String'>
    readonly title: FieldRef<"Meeting", 'String'>
    readonly description: FieldRef<"Meeting", 'String'>
    readonly type: FieldRef<"Meeting", 'String'>
    readonly scheduledAt: FieldRef<"Meeting", 'DateTime'>
    readonly duration: FieldRef<"Meeting", 'Int'>
    readonly timezone: FieldRef<"Meeting", 'String'>
    readonly organizer: FieldRef<"Meeting", 'String'>
    readonly requiredAttendees: FieldRef<"Meeting", 'String[]'>
    readonly optionalAttendees: FieldRef<"Meeting", 'String[]'>
    readonly location: FieldRef<"Meeting", 'String'>
    readonly meetingLink: FieldRef<"Meeting", 'String'>
    readonly agenda: FieldRef<"Meeting", 'String'>
    readonly meetingNotes: FieldRef<"Meeting", 'String'>
    readonly actionItems: FieldRef<"Meeting", 'Json[]'>
    readonly decisions: FieldRef<"Meeting", 'String[]'>
    readonly status: FieldRef<"Meeting", 'String'>
    readonly createdAt: FieldRef<"Meeting", 'DateTime'>
    readonly updatedAt: FieldRef<"Meeting", 'DateTime'>
    readonly userId: FieldRef<"Meeting", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Meeting findUnique
   */
  export type MeetingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting findUniqueOrThrow
   */
  export type MeetingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting findFirst
   */
  export type MeetingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Meetings.
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Meetings.
     */
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Meeting findFirstOrThrow
   */
  export type MeetingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Meetings.
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Meetings.
     */
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Meeting findMany
   */
  export type MeetingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meetings to fetch.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Meetings.
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Meeting create
   */
  export type MeetingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * The data needed to create a Meeting.
     */
    data: XOR<MeetingCreateInput, MeetingUncheckedCreateInput>
  }

  /**
   * Meeting createMany
   */
  export type MeetingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Meetings.
     */
    data: MeetingCreateManyInput | MeetingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Meeting createManyAndReturn
   */
  export type MeetingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * The data used to create many Meetings.
     */
    data: MeetingCreateManyInput | MeetingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Meeting update
   */
  export type MeetingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * The data needed to update a Meeting.
     */
    data: XOR<MeetingUpdateInput, MeetingUncheckedUpdateInput>
    /**
     * Choose, which Meeting to update.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting updateMany
   */
  export type MeetingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Meetings.
     */
    data: XOR<MeetingUpdateManyMutationInput, MeetingUncheckedUpdateManyInput>
    /**
     * Filter which Meetings to update
     */
    where?: MeetingWhereInput
    /**
     * Limit how many Meetings to update.
     */
    limit?: number
  }

  /**
   * Meeting updateManyAndReturn
   */
  export type MeetingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * The data used to update Meetings.
     */
    data: XOR<MeetingUpdateManyMutationInput, MeetingUncheckedUpdateManyInput>
    /**
     * Filter which Meetings to update
     */
    where?: MeetingWhereInput
    /**
     * Limit how many Meetings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Meeting upsert
   */
  export type MeetingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * The filter to search for the Meeting to update in case it exists.
     */
    where: MeetingWhereUniqueInput
    /**
     * In case the Meeting found by the `where` argument doesn't exist, create a new Meeting with this data.
     */
    create: XOR<MeetingCreateInput, MeetingUncheckedCreateInput>
    /**
     * In case the Meeting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MeetingUpdateInput, MeetingUncheckedUpdateInput>
  }

  /**
   * Meeting delete
   */
  export type MeetingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter which Meeting to delete.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting deleteMany
   */
  export type MeetingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Meetings to delete
     */
    where?: MeetingWhereInput
    /**
     * Limit how many Meetings to delete.
     */
    limit?: number
  }

  /**
   * Meeting.client
   */
  export type Meeting$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Meeting.tasks
   */
  export type Meeting$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Meeting without action
   */
  export type MeetingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
  }


  /**
   * Model WellBeingEntry
   */

  export type AggregateWellBeingEntry = {
    _count: WellBeingEntryCountAggregateOutputType | null
    _avg: WellBeingEntryAvgAggregateOutputType | null
    _sum: WellBeingEntrySumAggregateOutputType | null
    _min: WellBeingEntryMinAggregateOutputType | null
    _max: WellBeingEntryMaxAggregateOutputType | null
  }

  export type WellBeingEntryAvgAggregateOutputType = {
    morningEnergy: number | null
    afternoonEnergy: number | null
    eveningEnergy: number | null
    averageEnergy: number | null
    exerciseMinutes: number | null
    readingMinutes: number | null
    learningMinutes: number | null
    meditationMinutes: number | null
    sleepHours: number | null
    sleepQuality: number | null
    mood: number | null
    stressLevel: number | null
    focusQuality: number | null
  }

  export type WellBeingEntrySumAggregateOutputType = {
    morningEnergy: number | null
    afternoonEnergy: number | null
    eveningEnergy: number | null
    averageEnergy: number | null
    exerciseMinutes: number | null
    readingMinutes: number | null
    learningMinutes: number | null
    meditationMinutes: number | null
    sleepHours: number | null
    sleepQuality: number | null
    mood: number | null
    stressLevel: number | null
    focusQuality: number | null
  }

  export type WellBeingEntryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    morningEnergy: number | null
    afternoonEnergy: number | null
    eveningEnergy: number | null
    averageEnergy: number | null
    exerciseMinutes: number | null
    exerciseType: string | null
    readingMinutes: number | null
    learningMinutes: number | null
    meditationMinutes: number | null
    sleepHours: number | null
    sleepQuality: number | null
    morningJournal: string | null
    eveningReflection: string | null
    dailyWin: string | null
    mood: number | null
    stressLevel: number | null
    focusQuality: number | null
    notes: string | null
    createdAt: Date | null
  }

  export type WellBeingEntryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    morningEnergy: number | null
    afternoonEnergy: number | null
    eveningEnergy: number | null
    averageEnergy: number | null
    exerciseMinutes: number | null
    exerciseType: string | null
    readingMinutes: number | null
    learningMinutes: number | null
    meditationMinutes: number | null
    sleepHours: number | null
    sleepQuality: number | null
    morningJournal: string | null
    eveningReflection: string | null
    dailyWin: string | null
    mood: number | null
    stressLevel: number | null
    focusQuality: number | null
    notes: string | null
    createdAt: Date | null
  }

  export type WellBeingEntryCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    morningEnergy: number
    afternoonEnergy: number
    eveningEnergy: number
    averageEnergy: number
    exerciseMinutes: number
    exerciseType: number
    readingMinutes: number
    learningMinutes: number
    meditationMinutes: number
    sleepHours: number
    sleepQuality: number
    morningJournal: number
    eveningReflection: number
    gratitude: number
    dailyWin: number
    mood: number
    stressLevel: number
    focusQuality: number
    notes: number
    createdAt: number
    _all: number
  }


  export type WellBeingEntryAvgAggregateInputType = {
    morningEnergy?: true
    afternoonEnergy?: true
    eveningEnergy?: true
    averageEnergy?: true
    exerciseMinutes?: true
    readingMinutes?: true
    learningMinutes?: true
    meditationMinutes?: true
    sleepHours?: true
    sleepQuality?: true
    mood?: true
    stressLevel?: true
    focusQuality?: true
  }

  export type WellBeingEntrySumAggregateInputType = {
    morningEnergy?: true
    afternoonEnergy?: true
    eveningEnergy?: true
    averageEnergy?: true
    exerciseMinutes?: true
    readingMinutes?: true
    learningMinutes?: true
    meditationMinutes?: true
    sleepHours?: true
    sleepQuality?: true
    mood?: true
    stressLevel?: true
    focusQuality?: true
  }

  export type WellBeingEntryMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    morningEnergy?: true
    afternoonEnergy?: true
    eveningEnergy?: true
    averageEnergy?: true
    exerciseMinutes?: true
    exerciseType?: true
    readingMinutes?: true
    learningMinutes?: true
    meditationMinutes?: true
    sleepHours?: true
    sleepQuality?: true
    morningJournal?: true
    eveningReflection?: true
    dailyWin?: true
    mood?: true
    stressLevel?: true
    focusQuality?: true
    notes?: true
    createdAt?: true
  }

  export type WellBeingEntryMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    morningEnergy?: true
    afternoonEnergy?: true
    eveningEnergy?: true
    averageEnergy?: true
    exerciseMinutes?: true
    exerciseType?: true
    readingMinutes?: true
    learningMinutes?: true
    meditationMinutes?: true
    sleepHours?: true
    sleepQuality?: true
    morningJournal?: true
    eveningReflection?: true
    dailyWin?: true
    mood?: true
    stressLevel?: true
    focusQuality?: true
    notes?: true
    createdAt?: true
  }

  export type WellBeingEntryCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    morningEnergy?: true
    afternoonEnergy?: true
    eveningEnergy?: true
    averageEnergy?: true
    exerciseMinutes?: true
    exerciseType?: true
    readingMinutes?: true
    learningMinutes?: true
    meditationMinutes?: true
    sleepHours?: true
    sleepQuality?: true
    morningJournal?: true
    eveningReflection?: true
    gratitude?: true
    dailyWin?: true
    mood?: true
    stressLevel?: true
    focusQuality?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type WellBeingEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WellBeingEntry to aggregate.
     */
    where?: WellBeingEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WellBeingEntries to fetch.
     */
    orderBy?: WellBeingEntryOrderByWithRelationInput | WellBeingEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WellBeingEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WellBeingEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WellBeingEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WellBeingEntries
    **/
    _count?: true | WellBeingEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WellBeingEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WellBeingEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WellBeingEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WellBeingEntryMaxAggregateInputType
  }

  export type GetWellBeingEntryAggregateType<T extends WellBeingEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateWellBeingEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWellBeingEntry[P]>
      : GetScalarType<T[P], AggregateWellBeingEntry[P]>
  }




  export type WellBeingEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WellBeingEntryWhereInput
    orderBy?: WellBeingEntryOrderByWithAggregationInput | WellBeingEntryOrderByWithAggregationInput[]
    by: WellBeingEntryScalarFieldEnum[] | WellBeingEntryScalarFieldEnum
    having?: WellBeingEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WellBeingEntryCountAggregateInputType | true
    _avg?: WellBeingEntryAvgAggregateInputType
    _sum?: WellBeingEntrySumAggregateInputType
    _min?: WellBeingEntryMinAggregateInputType
    _max?: WellBeingEntryMaxAggregateInputType
  }

  export type WellBeingEntryGroupByOutputType = {
    id: string
    userId: string
    date: Date
    morningEnergy: number | null
    afternoonEnergy: number | null
    eveningEnergy: number | null
    averageEnergy: number | null
    exerciseMinutes: number
    exerciseType: string | null
    readingMinutes: number
    learningMinutes: number
    meditationMinutes: number
    sleepHours: number | null
    sleepQuality: number | null
    morningJournal: string | null
    eveningReflection: string | null
    gratitude: string[]
    dailyWin: string | null
    mood: number | null
    stressLevel: number | null
    focusQuality: number | null
    notes: string | null
    createdAt: Date
    _count: WellBeingEntryCountAggregateOutputType | null
    _avg: WellBeingEntryAvgAggregateOutputType | null
    _sum: WellBeingEntrySumAggregateOutputType | null
    _min: WellBeingEntryMinAggregateOutputType | null
    _max: WellBeingEntryMaxAggregateOutputType | null
  }

  type GetWellBeingEntryGroupByPayload<T extends WellBeingEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WellBeingEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WellBeingEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WellBeingEntryGroupByOutputType[P]>
            : GetScalarType<T[P], WellBeingEntryGroupByOutputType[P]>
        }
      >
    >


  export type WellBeingEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    morningEnergy?: boolean
    afternoonEnergy?: boolean
    eveningEnergy?: boolean
    averageEnergy?: boolean
    exerciseMinutes?: boolean
    exerciseType?: boolean
    readingMinutes?: boolean
    learningMinutes?: boolean
    meditationMinutes?: boolean
    sleepHours?: boolean
    sleepQuality?: boolean
    morningJournal?: boolean
    eveningReflection?: boolean
    gratitude?: boolean
    dailyWin?: boolean
    mood?: boolean
    stressLevel?: boolean
    focusQuality?: boolean
    notes?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wellBeingEntry"]>

  export type WellBeingEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    morningEnergy?: boolean
    afternoonEnergy?: boolean
    eveningEnergy?: boolean
    averageEnergy?: boolean
    exerciseMinutes?: boolean
    exerciseType?: boolean
    readingMinutes?: boolean
    learningMinutes?: boolean
    meditationMinutes?: boolean
    sleepHours?: boolean
    sleepQuality?: boolean
    morningJournal?: boolean
    eveningReflection?: boolean
    gratitude?: boolean
    dailyWin?: boolean
    mood?: boolean
    stressLevel?: boolean
    focusQuality?: boolean
    notes?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wellBeingEntry"]>

  export type WellBeingEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    morningEnergy?: boolean
    afternoonEnergy?: boolean
    eveningEnergy?: boolean
    averageEnergy?: boolean
    exerciseMinutes?: boolean
    exerciseType?: boolean
    readingMinutes?: boolean
    learningMinutes?: boolean
    meditationMinutes?: boolean
    sleepHours?: boolean
    sleepQuality?: boolean
    morningJournal?: boolean
    eveningReflection?: boolean
    gratitude?: boolean
    dailyWin?: boolean
    mood?: boolean
    stressLevel?: boolean
    focusQuality?: boolean
    notes?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wellBeingEntry"]>

  export type WellBeingEntrySelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    morningEnergy?: boolean
    afternoonEnergy?: boolean
    eveningEnergy?: boolean
    averageEnergy?: boolean
    exerciseMinutes?: boolean
    exerciseType?: boolean
    readingMinutes?: boolean
    learningMinutes?: boolean
    meditationMinutes?: boolean
    sleepHours?: boolean
    sleepQuality?: boolean
    morningJournal?: boolean
    eveningReflection?: boolean
    gratitude?: boolean
    dailyWin?: boolean
    mood?: boolean
    stressLevel?: boolean
    focusQuality?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type WellBeingEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "date" | "morningEnergy" | "afternoonEnergy" | "eveningEnergy" | "averageEnergy" | "exerciseMinutes" | "exerciseType" | "readingMinutes" | "learningMinutes" | "meditationMinutes" | "sleepHours" | "sleepQuality" | "morningJournal" | "eveningReflection" | "gratitude" | "dailyWin" | "mood" | "stressLevel" | "focusQuality" | "notes" | "createdAt", ExtArgs["result"]["wellBeingEntry"]>
  export type WellBeingEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WellBeingEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WellBeingEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WellBeingEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WellBeingEntry"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      date: Date
      morningEnergy: number | null
      afternoonEnergy: number | null
      eveningEnergy: number | null
      averageEnergy: number | null
      exerciseMinutes: number
      exerciseType: string | null
      readingMinutes: number
      learningMinutes: number
      meditationMinutes: number
      sleepHours: number | null
      sleepQuality: number | null
      morningJournal: string | null
      eveningReflection: string | null
      gratitude: string[]
      dailyWin: string | null
      mood: number | null
      stressLevel: number | null
      focusQuality: number | null
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["wellBeingEntry"]>
    composites: {}
  }

  type WellBeingEntryGetPayload<S extends boolean | null | undefined | WellBeingEntryDefaultArgs> = $Result.GetResult<Prisma.$WellBeingEntryPayload, S>

  type WellBeingEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WellBeingEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WellBeingEntryCountAggregateInputType | true
    }

  export interface WellBeingEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WellBeingEntry'], meta: { name: 'WellBeingEntry' } }
    /**
     * Find zero or one WellBeingEntry that matches the filter.
     * @param {WellBeingEntryFindUniqueArgs} args - Arguments to find a WellBeingEntry
     * @example
     * // Get one WellBeingEntry
     * const wellBeingEntry = await prisma.wellBeingEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WellBeingEntryFindUniqueArgs>(args: SelectSubset<T, WellBeingEntryFindUniqueArgs<ExtArgs>>): Prisma__WellBeingEntryClient<$Result.GetResult<Prisma.$WellBeingEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WellBeingEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WellBeingEntryFindUniqueOrThrowArgs} args - Arguments to find a WellBeingEntry
     * @example
     * // Get one WellBeingEntry
     * const wellBeingEntry = await prisma.wellBeingEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WellBeingEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, WellBeingEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WellBeingEntryClient<$Result.GetResult<Prisma.$WellBeingEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WellBeingEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellBeingEntryFindFirstArgs} args - Arguments to find a WellBeingEntry
     * @example
     * // Get one WellBeingEntry
     * const wellBeingEntry = await prisma.wellBeingEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WellBeingEntryFindFirstArgs>(args?: SelectSubset<T, WellBeingEntryFindFirstArgs<ExtArgs>>): Prisma__WellBeingEntryClient<$Result.GetResult<Prisma.$WellBeingEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WellBeingEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellBeingEntryFindFirstOrThrowArgs} args - Arguments to find a WellBeingEntry
     * @example
     * // Get one WellBeingEntry
     * const wellBeingEntry = await prisma.wellBeingEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WellBeingEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, WellBeingEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__WellBeingEntryClient<$Result.GetResult<Prisma.$WellBeingEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WellBeingEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellBeingEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WellBeingEntries
     * const wellBeingEntries = await prisma.wellBeingEntry.findMany()
     * 
     * // Get first 10 WellBeingEntries
     * const wellBeingEntries = await prisma.wellBeingEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wellBeingEntryWithIdOnly = await prisma.wellBeingEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WellBeingEntryFindManyArgs>(args?: SelectSubset<T, WellBeingEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WellBeingEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WellBeingEntry.
     * @param {WellBeingEntryCreateArgs} args - Arguments to create a WellBeingEntry.
     * @example
     * // Create one WellBeingEntry
     * const WellBeingEntry = await prisma.wellBeingEntry.create({
     *   data: {
     *     // ... data to create a WellBeingEntry
     *   }
     * })
     * 
     */
    create<T extends WellBeingEntryCreateArgs>(args: SelectSubset<T, WellBeingEntryCreateArgs<ExtArgs>>): Prisma__WellBeingEntryClient<$Result.GetResult<Prisma.$WellBeingEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WellBeingEntries.
     * @param {WellBeingEntryCreateManyArgs} args - Arguments to create many WellBeingEntries.
     * @example
     * // Create many WellBeingEntries
     * const wellBeingEntry = await prisma.wellBeingEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WellBeingEntryCreateManyArgs>(args?: SelectSubset<T, WellBeingEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WellBeingEntries and returns the data saved in the database.
     * @param {WellBeingEntryCreateManyAndReturnArgs} args - Arguments to create many WellBeingEntries.
     * @example
     * // Create many WellBeingEntries
     * const wellBeingEntry = await prisma.wellBeingEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WellBeingEntries and only return the `id`
     * const wellBeingEntryWithIdOnly = await prisma.wellBeingEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WellBeingEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, WellBeingEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WellBeingEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WellBeingEntry.
     * @param {WellBeingEntryDeleteArgs} args - Arguments to delete one WellBeingEntry.
     * @example
     * // Delete one WellBeingEntry
     * const WellBeingEntry = await prisma.wellBeingEntry.delete({
     *   where: {
     *     // ... filter to delete one WellBeingEntry
     *   }
     * })
     * 
     */
    delete<T extends WellBeingEntryDeleteArgs>(args: SelectSubset<T, WellBeingEntryDeleteArgs<ExtArgs>>): Prisma__WellBeingEntryClient<$Result.GetResult<Prisma.$WellBeingEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WellBeingEntry.
     * @param {WellBeingEntryUpdateArgs} args - Arguments to update one WellBeingEntry.
     * @example
     * // Update one WellBeingEntry
     * const wellBeingEntry = await prisma.wellBeingEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WellBeingEntryUpdateArgs>(args: SelectSubset<T, WellBeingEntryUpdateArgs<ExtArgs>>): Prisma__WellBeingEntryClient<$Result.GetResult<Prisma.$WellBeingEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WellBeingEntries.
     * @param {WellBeingEntryDeleteManyArgs} args - Arguments to filter WellBeingEntries to delete.
     * @example
     * // Delete a few WellBeingEntries
     * const { count } = await prisma.wellBeingEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WellBeingEntryDeleteManyArgs>(args?: SelectSubset<T, WellBeingEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WellBeingEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellBeingEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WellBeingEntries
     * const wellBeingEntry = await prisma.wellBeingEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WellBeingEntryUpdateManyArgs>(args: SelectSubset<T, WellBeingEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WellBeingEntries and returns the data updated in the database.
     * @param {WellBeingEntryUpdateManyAndReturnArgs} args - Arguments to update many WellBeingEntries.
     * @example
     * // Update many WellBeingEntries
     * const wellBeingEntry = await prisma.wellBeingEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WellBeingEntries and only return the `id`
     * const wellBeingEntryWithIdOnly = await prisma.wellBeingEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WellBeingEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, WellBeingEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WellBeingEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WellBeingEntry.
     * @param {WellBeingEntryUpsertArgs} args - Arguments to update or create a WellBeingEntry.
     * @example
     * // Update or create a WellBeingEntry
     * const wellBeingEntry = await prisma.wellBeingEntry.upsert({
     *   create: {
     *     // ... data to create a WellBeingEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WellBeingEntry we want to update
     *   }
     * })
     */
    upsert<T extends WellBeingEntryUpsertArgs>(args: SelectSubset<T, WellBeingEntryUpsertArgs<ExtArgs>>): Prisma__WellBeingEntryClient<$Result.GetResult<Prisma.$WellBeingEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WellBeingEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellBeingEntryCountArgs} args - Arguments to filter WellBeingEntries to count.
     * @example
     * // Count the number of WellBeingEntries
     * const count = await prisma.wellBeingEntry.count({
     *   where: {
     *     // ... the filter for the WellBeingEntries we want to count
     *   }
     * })
    **/
    count<T extends WellBeingEntryCountArgs>(
      args?: Subset<T, WellBeingEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WellBeingEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WellBeingEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellBeingEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WellBeingEntryAggregateArgs>(args: Subset<T, WellBeingEntryAggregateArgs>): Prisma.PrismaPromise<GetWellBeingEntryAggregateType<T>>

    /**
     * Group by WellBeingEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellBeingEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WellBeingEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WellBeingEntryGroupByArgs['orderBy'] }
        : { orderBy?: WellBeingEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WellBeingEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWellBeingEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WellBeingEntry model
   */
  readonly fields: WellBeingEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WellBeingEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WellBeingEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WellBeingEntry model
   */
  interface WellBeingEntryFieldRefs {
    readonly id: FieldRef<"WellBeingEntry", 'String'>
    readonly userId: FieldRef<"WellBeingEntry", 'String'>
    readonly date: FieldRef<"WellBeingEntry", 'DateTime'>
    readonly morningEnergy: FieldRef<"WellBeingEntry", 'Float'>
    readonly afternoonEnergy: FieldRef<"WellBeingEntry", 'Float'>
    readonly eveningEnergy: FieldRef<"WellBeingEntry", 'Float'>
    readonly averageEnergy: FieldRef<"WellBeingEntry", 'Float'>
    readonly exerciseMinutes: FieldRef<"WellBeingEntry", 'Int'>
    readonly exerciseType: FieldRef<"WellBeingEntry", 'String'>
    readonly readingMinutes: FieldRef<"WellBeingEntry", 'Int'>
    readonly learningMinutes: FieldRef<"WellBeingEntry", 'Int'>
    readonly meditationMinutes: FieldRef<"WellBeingEntry", 'Int'>
    readonly sleepHours: FieldRef<"WellBeingEntry", 'Float'>
    readonly sleepQuality: FieldRef<"WellBeingEntry", 'Float'>
    readonly morningJournal: FieldRef<"WellBeingEntry", 'String'>
    readonly eveningReflection: FieldRef<"WellBeingEntry", 'String'>
    readonly gratitude: FieldRef<"WellBeingEntry", 'String[]'>
    readonly dailyWin: FieldRef<"WellBeingEntry", 'String'>
    readonly mood: FieldRef<"WellBeingEntry", 'Float'>
    readonly stressLevel: FieldRef<"WellBeingEntry", 'Float'>
    readonly focusQuality: FieldRef<"WellBeingEntry", 'Float'>
    readonly notes: FieldRef<"WellBeingEntry", 'String'>
    readonly createdAt: FieldRef<"WellBeingEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WellBeingEntry findUnique
   */
  export type WellBeingEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBeingEntry
     */
    select?: WellBeingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBeingEntry
     */
    omit?: WellBeingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBeingEntryInclude<ExtArgs> | null
    /**
     * Filter, which WellBeingEntry to fetch.
     */
    where: WellBeingEntryWhereUniqueInput
  }

  /**
   * WellBeingEntry findUniqueOrThrow
   */
  export type WellBeingEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBeingEntry
     */
    select?: WellBeingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBeingEntry
     */
    omit?: WellBeingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBeingEntryInclude<ExtArgs> | null
    /**
     * Filter, which WellBeingEntry to fetch.
     */
    where: WellBeingEntryWhereUniqueInput
  }

  /**
   * WellBeingEntry findFirst
   */
  export type WellBeingEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBeingEntry
     */
    select?: WellBeingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBeingEntry
     */
    omit?: WellBeingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBeingEntryInclude<ExtArgs> | null
    /**
     * Filter, which WellBeingEntry to fetch.
     */
    where?: WellBeingEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WellBeingEntries to fetch.
     */
    orderBy?: WellBeingEntryOrderByWithRelationInput | WellBeingEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WellBeingEntries.
     */
    cursor?: WellBeingEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WellBeingEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WellBeingEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WellBeingEntries.
     */
    distinct?: WellBeingEntryScalarFieldEnum | WellBeingEntryScalarFieldEnum[]
  }

  /**
   * WellBeingEntry findFirstOrThrow
   */
  export type WellBeingEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBeingEntry
     */
    select?: WellBeingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBeingEntry
     */
    omit?: WellBeingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBeingEntryInclude<ExtArgs> | null
    /**
     * Filter, which WellBeingEntry to fetch.
     */
    where?: WellBeingEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WellBeingEntries to fetch.
     */
    orderBy?: WellBeingEntryOrderByWithRelationInput | WellBeingEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WellBeingEntries.
     */
    cursor?: WellBeingEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WellBeingEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WellBeingEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WellBeingEntries.
     */
    distinct?: WellBeingEntryScalarFieldEnum | WellBeingEntryScalarFieldEnum[]
  }

  /**
   * WellBeingEntry findMany
   */
  export type WellBeingEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBeingEntry
     */
    select?: WellBeingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBeingEntry
     */
    omit?: WellBeingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBeingEntryInclude<ExtArgs> | null
    /**
     * Filter, which WellBeingEntries to fetch.
     */
    where?: WellBeingEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WellBeingEntries to fetch.
     */
    orderBy?: WellBeingEntryOrderByWithRelationInput | WellBeingEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WellBeingEntries.
     */
    cursor?: WellBeingEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WellBeingEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WellBeingEntries.
     */
    skip?: number
    distinct?: WellBeingEntryScalarFieldEnum | WellBeingEntryScalarFieldEnum[]
  }

  /**
   * WellBeingEntry create
   */
  export type WellBeingEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBeingEntry
     */
    select?: WellBeingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBeingEntry
     */
    omit?: WellBeingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBeingEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a WellBeingEntry.
     */
    data: XOR<WellBeingEntryCreateInput, WellBeingEntryUncheckedCreateInput>
  }

  /**
   * WellBeingEntry createMany
   */
  export type WellBeingEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WellBeingEntries.
     */
    data: WellBeingEntryCreateManyInput | WellBeingEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WellBeingEntry createManyAndReturn
   */
  export type WellBeingEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBeingEntry
     */
    select?: WellBeingEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WellBeingEntry
     */
    omit?: WellBeingEntryOmit<ExtArgs> | null
    /**
     * The data used to create many WellBeingEntries.
     */
    data: WellBeingEntryCreateManyInput | WellBeingEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBeingEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WellBeingEntry update
   */
  export type WellBeingEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBeingEntry
     */
    select?: WellBeingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBeingEntry
     */
    omit?: WellBeingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBeingEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a WellBeingEntry.
     */
    data: XOR<WellBeingEntryUpdateInput, WellBeingEntryUncheckedUpdateInput>
    /**
     * Choose, which WellBeingEntry to update.
     */
    where: WellBeingEntryWhereUniqueInput
  }

  /**
   * WellBeingEntry updateMany
   */
  export type WellBeingEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WellBeingEntries.
     */
    data: XOR<WellBeingEntryUpdateManyMutationInput, WellBeingEntryUncheckedUpdateManyInput>
    /**
     * Filter which WellBeingEntries to update
     */
    where?: WellBeingEntryWhereInput
    /**
     * Limit how many WellBeingEntries to update.
     */
    limit?: number
  }

  /**
   * WellBeingEntry updateManyAndReturn
   */
  export type WellBeingEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBeingEntry
     */
    select?: WellBeingEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WellBeingEntry
     */
    omit?: WellBeingEntryOmit<ExtArgs> | null
    /**
     * The data used to update WellBeingEntries.
     */
    data: XOR<WellBeingEntryUpdateManyMutationInput, WellBeingEntryUncheckedUpdateManyInput>
    /**
     * Filter which WellBeingEntries to update
     */
    where?: WellBeingEntryWhereInput
    /**
     * Limit how many WellBeingEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBeingEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WellBeingEntry upsert
   */
  export type WellBeingEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBeingEntry
     */
    select?: WellBeingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBeingEntry
     */
    omit?: WellBeingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBeingEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the WellBeingEntry to update in case it exists.
     */
    where: WellBeingEntryWhereUniqueInput
    /**
     * In case the WellBeingEntry found by the `where` argument doesn't exist, create a new WellBeingEntry with this data.
     */
    create: XOR<WellBeingEntryCreateInput, WellBeingEntryUncheckedCreateInput>
    /**
     * In case the WellBeingEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WellBeingEntryUpdateInput, WellBeingEntryUncheckedUpdateInput>
  }

  /**
   * WellBeingEntry delete
   */
  export type WellBeingEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBeingEntry
     */
    select?: WellBeingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBeingEntry
     */
    omit?: WellBeingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBeingEntryInclude<ExtArgs> | null
    /**
     * Filter which WellBeingEntry to delete.
     */
    where: WellBeingEntryWhereUniqueInput
  }

  /**
   * WellBeingEntry deleteMany
   */
  export type WellBeingEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WellBeingEntries to delete
     */
    where?: WellBeingEntryWhereInput
    /**
     * Limit how many WellBeingEntries to delete.
     */
    limit?: number
  }

  /**
   * WellBeingEntry without action
   */
  export type WellBeingEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBeingEntry
     */
    select?: WellBeingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBeingEntry
     */
    omit?: WellBeingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBeingEntryInclude<ExtArgs> | null
  }


  /**
   * Model Capture
   */

  export type AggregateCapture = {
    _count: CaptureCountAggregateOutputType | null
    _min: CaptureMinAggregateOutputType | null
    _max: CaptureMaxAggregateOutputType | null
  }

  export type CaptureMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    content: string | null
    transcription: string | null
    status: string | null
    convertedToTaskId: string | null
    convertedToNoteId: string | null
    suggestedProject: string | null
    suggestedDueDate: Date | null
    suggestedPriority: string | null
    createdAt: Date | null
    processedAt: Date | null
  }

  export type CaptureMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    content: string | null
    transcription: string | null
    status: string | null
    convertedToTaskId: string | null
    convertedToNoteId: string | null
    suggestedProject: string | null
    suggestedDueDate: Date | null
    suggestedPriority: string | null
    createdAt: Date | null
    processedAt: Date | null
  }

  export type CaptureCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    content: number
    transcription: number
    status: number
    convertedToTaskId: number
    convertedToNoteId: number
    suggestedProject: number
    suggestedDueDate: number
    suggestedPriority: number
    tags: number
    createdAt: number
    processedAt: number
    _all: number
  }


  export type CaptureMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    content?: true
    transcription?: true
    status?: true
    convertedToTaskId?: true
    convertedToNoteId?: true
    suggestedProject?: true
    suggestedDueDate?: true
    suggestedPriority?: true
    createdAt?: true
    processedAt?: true
  }

  export type CaptureMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    content?: true
    transcription?: true
    status?: true
    convertedToTaskId?: true
    convertedToNoteId?: true
    suggestedProject?: true
    suggestedDueDate?: true
    suggestedPriority?: true
    createdAt?: true
    processedAt?: true
  }

  export type CaptureCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    content?: true
    transcription?: true
    status?: true
    convertedToTaskId?: true
    convertedToNoteId?: true
    suggestedProject?: true
    suggestedDueDate?: true
    suggestedPriority?: true
    tags?: true
    createdAt?: true
    processedAt?: true
    _all?: true
  }

  export type CaptureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Capture to aggregate.
     */
    where?: CaptureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Captures to fetch.
     */
    orderBy?: CaptureOrderByWithRelationInput | CaptureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CaptureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Captures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Captures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Captures
    **/
    _count?: true | CaptureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CaptureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CaptureMaxAggregateInputType
  }

  export type GetCaptureAggregateType<T extends CaptureAggregateArgs> = {
        [P in keyof T & keyof AggregateCapture]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCapture[P]>
      : GetScalarType<T[P], AggregateCapture[P]>
  }




  export type CaptureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaptureWhereInput
    orderBy?: CaptureOrderByWithAggregationInput | CaptureOrderByWithAggregationInput[]
    by: CaptureScalarFieldEnum[] | CaptureScalarFieldEnum
    having?: CaptureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CaptureCountAggregateInputType | true
    _min?: CaptureMinAggregateInputType
    _max?: CaptureMaxAggregateInputType
  }

  export type CaptureGroupByOutputType = {
    id: string
    userId: string
    type: string
    content: string
    transcription: string | null
    status: string
    convertedToTaskId: string | null
    convertedToNoteId: string | null
    suggestedProject: string | null
    suggestedDueDate: Date | null
    suggestedPriority: string | null
    tags: string[]
    createdAt: Date
    processedAt: Date | null
    _count: CaptureCountAggregateOutputType | null
    _min: CaptureMinAggregateOutputType | null
    _max: CaptureMaxAggregateOutputType | null
  }

  type GetCaptureGroupByPayload<T extends CaptureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CaptureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CaptureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CaptureGroupByOutputType[P]>
            : GetScalarType<T[P], CaptureGroupByOutputType[P]>
        }
      >
    >


  export type CaptureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    content?: boolean
    transcription?: boolean
    status?: boolean
    convertedToTaskId?: boolean
    convertedToNoteId?: boolean
    suggestedProject?: boolean
    suggestedDueDate?: boolean
    suggestedPriority?: boolean
    tags?: boolean
    createdAt?: boolean
    processedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["capture"]>

  export type CaptureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    content?: boolean
    transcription?: boolean
    status?: boolean
    convertedToTaskId?: boolean
    convertedToNoteId?: boolean
    suggestedProject?: boolean
    suggestedDueDate?: boolean
    suggestedPriority?: boolean
    tags?: boolean
    createdAt?: boolean
    processedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["capture"]>

  export type CaptureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    content?: boolean
    transcription?: boolean
    status?: boolean
    convertedToTaskId?: boolean
    convertedToNoteId?: boolean
    suggestedProject?: boolean
    suggestedDueDate?: boolean
    suggestedPriority?: boolean
    tags?: boolean
    createdAt?: boolean
    processedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["capture"]>

  export type CaptureSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    content?: boolean
    transcription?: boolean
    status?: boolean
    convertedToTaskId?: boolean
    convertedToNoteId?: boolean
    suggestedProject?: boolean
    suggestedDueDate?: boolean
    suggestedPriority?: boolean
    tags?: boolean
    createdAt?: boolean
    processedAt?: boolean
  }

  export type CaptureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "content" | "transcription" | "status" | "convertedToTaskId" | "convertedToNoteId" | "suggestedProject" | "suggestedDueDate" | "suggestedPriority" | "tags" | "createdAt" | "processedAt", ExtArgs["result"]["capture"]>
  export type CaptureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CaptureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CaptureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CapturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Capture"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      content: string
      transcription: string | null
      status: string
      convertedToTaskId: string | null
      convertedToNoteId: string | null
      suggestedProject: string | null
      suggestedDueDate: Date | null
      suggestedPriority: string | null
      tags: string[]
      createdAt: Date
      processedAt: Date | null
    }, ExtArgs["result"]["capture"]>
    composites: {}
  }

  type CaptureGetPayload<S extends boolean | null | undefined | CaptureDefaultArgs> = $Result.GetResult<Prisma.$CapturePayload, S>

  type CaptureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CaptureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CaptureCountAggregateInputType | true
    }

  export interface CaptureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Capture'], meta: { name: 'Capture' } }
    /**
     * Find zero or one Capture that matches the filter.
     * @param {CaptureFindUniqueArgs} args - Arguments to find a Capture
     * @example
     * // Get one Capture
     * const capture = await prisma.capture.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CaptureFindUniqueArgs>(args: SelectSubset<T, CaptureFindUniqueArgs<ExtArgs>>): Prisma__CaptureClient<$Result.GetResult<Prisma.$CapturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Capture that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CaptureFindUniqueOrThrowArgs} args - Arguments to find a Capture
     * @example
     * // Get one Capture
     * const capture = await prisma.capture.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CaptureFindUniqueOrThrowArgs>(args: SelectSubset<T, CaptureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CaptureClient<$Result.GetResult<Prisma.$CapturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Capture that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaptureFindFirstArgs} args - Arguments to find a Capture
     * @example
     * // Get one Capture
     * const capture = await prisma.capture.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CaptureFindFirstArgs>(args?: SelectSubset<T, CaptureFindFirstArgs<ExtArgs>>): Prisma__CaptureClient<$Result.GetResult<Prisma.$CapturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Capture that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaptureFindFirstOrThrowArgs} args - Arguments to find a Capture
     * @example
     * // Get one Capture
     * const capture = await prisma.capture.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CaptureFindFirstOrThrowArgs>(args?: SelectSubset<T, CaptureFindFirstOrThrowArgs<ExtArgs>>): Prisma__CaptureClient<$Result.GetResult<Prisma.$CapturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Captures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaptureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Captures
     * const captures = await prisma.capture.findMany()
     * 
     * // Get first 10 Captures
     * const captures = await prisma.capture.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const captureWithIdOnly = await prisma.capture.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CaptureFindManyArgs>(args?: SelectSubset<T, CaptureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CapturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Capture.
     * @param {CaptureCreateArgs} args - Arguments to create a Capture.
     * @example
     * // Create one Capture
     * const Capture = await prisma.capture.create({
     *   data: {
     *     // ... data to create a Capture
     *   }
     * })
     * 
     */
    create<T extends CaptureCreateArgs>(args: SelectSubset<T, CaptureCreateArgs<ExtArgs>>): Prisma__CaptureClient<$Result.GetResult<Prisma.$CapturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Captures.
     * @param {CaptureCreateManyArgs} args - Arguments to create many Captures.
     * @example
     * // Create many Captures
     * const capture = await prisma.capture.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CaptureCreateManyArgs>(args?: SelectSubset<T, CaptureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Captures and returns the data saved in the database.
     * @param {CaptureCreateManyAndReturnArgs} args - Arguments to create many Captures.
     * @example
     * // Create many Captures
     * const capture = await prisma.capture.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Captures and only return the `id`
     * const captureWithIdOnly = await prisma.capture.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CaptureCreateManyAndReturnArgs>(args?: SelectSubset<T, CaptureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CapturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Capture.
     * @param {CaptureDeleteArgs} args - Arguments to delete one Capture.
     * @example
     * // Delete one Capture
     * const Capture = await prisma.capture.delete({
     *   where: {
     *     // ... filter to delete one Capture
     *   }
     * })
     * 
     */
    delete<T extends CaptureDeleteArgs>(args: SelectSubset<T, CaptureDeleteArgs<ExtArgs>>): Prisma__CaptureClient<$Result.GetResult<Prisma.$CapturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Capture.
     * @param {CaptureUpdateArgs} args - Arguments to update one Capture.
     * @example
     * // Update one Capture
     * const capture = await prisma.capture.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CaptureUpdateArgs>(args: SelectSubset<T, CaptureUpdateArgs<ExtArgs>>): Prisma__CaptureClient<$Result.GetResult<Prisma.$CapturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Captures.
     * @param {CaptureDeleteManyArgs} args - Arguments to filter Captures to delete.
     * @example
     * // Delete a few Captures
     * const { count } = await prisma.capture.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CaptureDeleteManyArgs>(args?: SelectSubset<T, CaptureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Captures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaptureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Captures
     * const capture = await prisma.capture.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CaptureUpdateManyArgs>(args: SelectSubset<T, CaptureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Captures and returns the data updated in the database.
     * @param {CaptureUpdateManyAndReturnArgs} args - Arguments to update many Captures.
     * @example
     * // Update many Captures
     * const capture = await prisma.capture.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Captures and only return the `id`
     * const captureWithIdOnly = await prisma.capture.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CaptureUpdateManyAndReturnArgs>(args: SelectSubset<T, CaptureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CapturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Capture.
     * @param {CaptureUpsertArgs} args - Arguments to update or create a Capture.
     * @example
     * // Update or create a Capture
     * const capture = await prisma.capture.upsert({
     *   create: {
     *     // ... data to create a Capture
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Capture we want to update
     *   }
     * })
     */
    upsert<T extends CaptureUpsertArgs>(args: SelectSubset<T, CaptureUpsertArgs<ExtArgs>>): Prisma__CaptureClient<$Result.GetResult<Prisma.$CapturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Captures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaptureCountArgs} args - Arguments to filter Captures to count.
     * @example
     * // Count the number of Captures
     * const count = await prisma.capture.count({
     *   where: {
     *     // ... the filter for the Captures we want to count
     *   }
     * })
    **/
    count<T extends CaptureCountArgs>(
      args?: Subset<T, CaptureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CaptureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Capture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaptureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CaptureAggregateArgs>(args: Subset<T, CaptureAggregateArgs>): Prisma.PrismaPromise<GetCaptureAggregateType<T>>

    /**
     * Group by Capture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaptureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CaptureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CaptureGroupByArgs['orderBy'] }
        : { orderBy?: CaptureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CaptureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCaptureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Capture model
   */
  readonly fields: CaptureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Capture.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CaptureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Capture model
   */
  interface CaptureFieldRefs {
    readonly id: FieldRef<"Capture", 'String'>
    readonly userId: FieldRef<"Capture", 'String'>
    readonly type: FieldRef<"Capture", 'String'>
    readonly content: FieldRef<"Capture", 'String'>
    readonly transcription: FieldRef<"Capture", 'String'>
    readonly status: FieldRef<"Capture", 'String'>
    readonly convertedToTaskId: FieldRef<"Capture", 'String'>
    readonly convertedToNoteId: FieldRef<"Capture", 'String'>
    readonly suggestedProject: FieldRef<"Capture", 'String'>
    readonly suggestedDueDate: FieldRef<"Capture", 'DateTime'>
    readonly suggestedPriority: FieldRef<"Capture", 'String'>
    readonly tags: FieldRef<"Capture", 'String[]'>
    readonly createdAt: FieldRef<"Capture", 'DateTime'>
    readonly processedAt: FieldRef<"Capture", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Capture findUnique
   */
  export type CaptureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capture
     */
    select?: CaptureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Capture
     */
    omit?: CaptureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaptureInclude<ExtArgs> | null
    /**
     * Filter, which Capture to fetch.
     */
    where: CaptureWhereUniqueInput
  }

  /**
   * Capture findUniqueOrThrow
   */
  export type CaptureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capture
     */
    select?: CaptureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Capture
     */
    omit?: CaptureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaptureInclude<ExtArgs> | null
    /**
     * Filter, which Capture to fetch.
     */
    where: CaptureWhereUniqueInput
  }

  /**
   * Capture findFirst
   */
  export type CaptureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capture
     */
    select?: CaptureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Capture
     */
    omit?: CaptureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaptureInclude<ExtArgs> | null
    /**
     * Filter, which Capture to fetch.
     */
    where?: CaptureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Captures to fetch.
     */
    orderBy?: CaptureOrderByWithRelationInput | CaptureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Captures.
     */
    cursor?: CaptureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Captures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Captures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Captures.
     */
    distinct?: CaptureScalarFieldEnum | CaptureScalarFieldEnum[]
  }

  /**
   * Capture findFirstOrThrow
   */
  export type CaptureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capture
     */
    select?: CaptureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Capture
     */
    omit?: CaptureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaptureInclude<ExtArgs> | null
    /**
     * Filter, which Capture to fetch.
     */
    where?: CaptureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Captures to fetch.
     */
    orderBy?: CaptureOrderByWithRelationInput | CaptureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Captures.
     */
    cursor?: CaptureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Captures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Captures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Captures.
     */
    distinct?: CaptureScalarFieldEnum | CaptureScalarFieldEnum[]
  }

  /**
   * Capture findMany
   */
  export type CaptureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capture
     */
    select?: CaptureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Capture
     */
    omit?: CaptureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaptureInclude<ExtArgs> | null
    /**
     * Filter, which Captures to fetch.
     */
    where?: CaptureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Captures to fetch.
     */
    orderBy?: CaptureOrderByWithRelationInput | CaptureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Captures.
     */
    cursor?: CaptureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Captures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Captures.
     */
    skip?: number
    distinct?: CaptureScalarFieldEnum | CaptureScalarFieldEnum[]
  }

  /**
   * Capture create
   */
  export type CaptureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capture
     */
    select?: CaptureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Capture
     */
    omit?: CaptureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaptureInclude<ExtArgs> | null
    /**
     * The data needed to create a Capture.
     */
    data: XOR<CaptureCreateInput, CaptureUncheckedCreateInput>
  }

  /**
   * Capture createMany
   */
  export type CaptureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Captures.
     */
    data: CaptureCreateManyInput | CaptureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Capture createManyAndReturn
   */
  export type CaptureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capture
     */
    select?: CaptureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Capture
     */
    omit?: CaptureOmit<ExtArgs> | null
    /**
     * The data used to create many Captures.
     */
    data: CaptureCreateManyInput | CaptureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaptureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Capture update
   */
  export type CaptureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capture
     */
    select?: CaptureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Capture
     */
    omit?: CaptureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaptureInclude<ExtArgs> | null
    /**
     * The data needed to update a Capture.
     */
    data: XOR<CaptureUpdateInput, CaptureUncheckedUpdateInput>
    /**
     * Choose, which Capture to update.
     */
    where: CaptureWhereUniqueInput
  }

  /**
   * Capture updateMany
   */
  export type CaptureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Captures.
     */
    data: XOR<CaptureUpdateManyMutationInput, CaptureUncheckedUpdateManyInput>
    /**
     * Filter which Captures to update
     */
    where?: CaptureWhereInput
    /**
     * Limit how many Captures to update.
     */
    limit?: number
  }

  /**
   * Capture updateManyAndReturn
   */
  export type CaptureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capture
     */
    select?: CaptureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Capture
     */
    omit?: CaptureOmit<ExtArgs> | null
    /**
     * The data used to update Captures.
     */
    data: XOR<CaptureUpdateManyMutationInput, CaptureUncheckedUpdateManyInput>
    /**
     * Filter which Captures to update
     */
    where?: CaptureWhereInput
    /**
     * Limit how many Captures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaptureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Capture upsert
   */
  export type CaptureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capture
     */
    select?: CaptureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Capture
     */
    omit?: CaptureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaptureInclude<ExtArgs> | null
    /**
     * The filter to search for the Capture to update in case it exists.
     */
    where: CaptureWhereUniqueInput
    /**
     * In case the Capture found by the `where` argument doesn't exist, create a new Capture with this data.
     */
    create: XOR<CaptureCreateInput, CaptureUncheckedCreateInput>
    /**
     * In case the Capture was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CaptureUpdateInput, CaptureUncheckedUpdateInput>
  }

  /**
   * Capture delete
   */
  export type CaptureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capture
     */
    select?: CaptureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Capture
     */
    omit?: CaptureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaptureInclude<ExtArgs> | null
    /**
     * Filter which Capture to delete.
     */
    where: CaptureWhereUniqueInput
  }

  /**
   * Capture deleteMany
   */
  export type CaptureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Captures to delete
     */
    where?: CaptureWhereInput
    /**
     * Limit how many Captures to delete.
     */
    limit?: number
  }

  /**
   * Capture without action
   */
  export type CaptureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capture
     */
    select?: CaptureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Capture
     */
    omit?: CaptureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaptureInclude<ExtArgs> | null
  }


  /**
   * Model VoiceSession
   */

  export type AggregateVoiceSession = {
    _count: VoiceSessionCountAggregateOutputType | null
    _avg: VoiceSessionAvgAggregateOutputType | null
    _sum: VoiceSessionSumAggregateOutputType | null
    _min: VoiceSessionMinAggregateOutputType | null
    _max: VoiceSessionMaxAggregateOutputType | null
  }

  export type VoiceSessionAvgAggregateOutputType = {
    duration: number | null
  }

  export type VoiceSessionSumAggregateOutputType = {
    duration: number | null
  }

  export type VoiceSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    duration: number | null
    recordedAt: Date | null
    audioFileUrl: string | null
    transcription: string | null
    summary: string | null
    projectId: string | null
    processed: boolean | null
    archivedAt: Date | null
    createdAt: Date | null
  }

  export type VoiceSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    duration: number | null
    recordedAt: Date | null
    audioFileUrl: string | null
    transcription: string | null
    summary: string | null
    projectId: string | null
    processed: boolean | null
    archivedAt: Date | null
    createdAt: Date | null
  }

  export type VoiceSessionCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    duration: number
    recordedAt: number
    audioFileUrl: number
    waveformData: number
    transcription: number
    speakers: number
    timestamps: number
    summary: number
    keyPoints: number
    actionItems: number
    projectId: number
    tags: number
    processed: number
    archivedAt: number
    createdAt: number
    _all: number
  }


  export type VoiceSessionAvgAggregateInputType = {
    duration?: true
  }

  export type VoiceSessionSumAggregateInputType = {
    duration?: true
  }

  export type VoiceSessionMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    duration?: true
    recordedAt?: true
    audioFileUrl?: true
    transcription?: true
    summary?: true
    projectId?: true
    processed?: true
    archivedAt?: true
    createdAt?: true
  }

  export type VoiceSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    duration?: true
    recordedAt?: true
    audioFileUrl?: true
    transcription?: true
    summary?: true
    projectId?: true
    processed?: true
    archivedAt?: true
    createdAt?: true
  }

  export type VoiceSessionCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    duration?: true
    recordedAt?: true
    audioFileUrl?: true
    waveformData?: true
    transcription?: true
    speakers?: true
    timestamps?: true
    summary?: true
    keyPoints?: true
    actionItems?: true
    projectId?: true
    tags?: true
    processed?: true
    archivedAt?: true
    createdAt?: true
    _all?: true
  }

  export type VoiceSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VoiceSession to aggregate.
     */
    where?: VoiceSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoiceSessions to fetch.
     */
    orderBy?: VoiceSessionOrderByWithRelationInput | VoiceSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoiceSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoiceSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoiceSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VoiceSessions
    **/
    _count?: true | VoiceSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VoiceSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VoiceSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoiceSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoiceSessionMaxAggregateInputType
  }

  export type GetVoiceSessionAggregateType<T extends VoiceSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateVoiceSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVoiceSession[P]>
      : GetScalarType<T[P], AggregateVoiceSession[P]>
  }




  export type VoiceSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoiceSessionWhereInput
    orderBy?: VoiceSessionOrderByWithAggregationInput | VoiceSessionOrderByWithAggregationInput[]
    by: VoiceSessionScalarFieldEnum[] | VoiceSessionScalarFieldEnum
    having?: VoiceSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoiceSessionCountAggregateInputType | true
    _avg?: VoiceSessionAvgAggregateInputType
    _sum?: VoiceSessionSumAggregateInputType
    _min?: VoiceSessionMinAggregateInputType
    _max?: VoiceSessionMaxAggregateInputType
  }

  export type VoiceSessionGroupByOutputType = {
    id: string
    userId: string
    title: string
    duration: number
    recordedAt: Date
    audioFileUrl: string
    waveformData: JsonValue | null
    transcription: string | null
    speakers: JsonValue[]
    timestamps: JsonValue[]
    summary: string | null
    keyPoints: string[]
    actionItems: JsonValue[]
    projectId: string | null
    tags: string[]
    processed: boolean
    archivedAt: Date | null
    createdAt: Date
    _count: VoiceSessionCountAggregateOutputType | null
    _avg: VoiceSessionAvgAggregateOutputType | null
    _sum: VoiceSessionSumAggregateOutputType | null
    _min: VoiceSessionMinAggregateOutputType | null
    _max: VoiceSessionMaxAggregateOutputType | null
  }

  type GetVoiceSessionGroupByPayload<T extends VoiceSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoiceSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoiceSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoiceSessionGroupByOutputType[P]>
            : GetScalarType<T[P], VoiceSessionGroupByOutputType[P]>
        }
      >
    >


  export type VoiceSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    duration?: boolean
    recordedAt?: boolean
    audioFileUrl?: boolean
    waveformData?: boolean
    transcription?: boolean
    speakers?: boolean
    timestamps?: boolean
    summary?: boolean
    keyPoints?: boolean
    actionItems?: boolean
    projectId?: boolean
    tags?: boolean
    processed?: boolean
    archivedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voiceSession"]>

  export type VoiceSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    duration?: boolean
    recordedAt?: boolean
    audioFileUrl?: boolean
    waveformData?: boolean
    transcription?: boolean
    speakers?: boolean
    timestamps?: boolean
    summary?: boolean
    keyPoints?: boolean
    actionItems?: boolean
    projectId?: boolean
    tags?: boolean
    processed?: boolean
    archivedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voiceSession"]>

  export type VoiceSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    duration?: boolean
    recordedAt?: boolean
    audioFileUrl?: boolean
    waveformData?: boolean
    transcription?: boolean
    speakers?: boolean
    timestamps?: boolean
    summary?: boolean
    keyPoints?: boolean
    actionItems?: boolean
    projectId?: boolean
    tags?: boolean
    processed?: boolean
    archivedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voiceSession"]>

  export type VoiceSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    duration?: boolean
    recordedAt?: boolean
    audioFileUrl?: boolean
    waveformData?: boolean
    transcription?: boolean
    speakers?: boolean
    timestamps?: boolean
    summary?: boolean
    keyPoints?: boolean
    actionItems?: boolean
    projectId?: boolean
    tags?: boolean
    processed?: boolean
    archivedAt?: boolean
    createdAt?: boolean
  }

  export type VoiceSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "duration" | "recordedAt" | "audioFileUrl" | "waveformData" | "transcription" | "speakers" | "timestamps" | "summary" | "keyPoints" | "actionItems" | "projectId" | "tags" | "processed" | "archivedAt" | "createdAt", ExtArgs["result"]["voiceSession"]>
  export type VoiceSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VoiceSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VoiceSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VoiceSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VoiceSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      duration: number
      recordedAt: Date
      audioFileUrl: string
      waveformData: Prisma.JsonValue | null
      transcription: string | null
      speakers: Prisma.JsonValue[]
      timestamps: Prisma.JsonValue[]
      summary: string | null
      keyPoints: string[]
      actionItems: Prisma.JsonValue[]
      projectId: string | null
      tags: string[]
      processed: boolean
      archivedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["voiceSession"]>
    composites: {}
  }

  type VoiceSessionGetPayload<S extends boolean | null | undefined | VoiceSessionDefaultArgs> = $Result.GetResult<Prisma.$VoiceSessionPayload, S>

  type VoiceSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VoiceSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VoiceSessionCountAggregateInputType | true
    }

  export interface VoiceSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VoiceSession'], meta: { name: 'VoiceSession' } }
    /**
     * Find zero or one VoiceSession that matches the filter.
     * @param {VoiceSessionFindUniqueArgs} args - Arguments to find a VoiceSession
     * @example
     * // Get one VoiceSession
     * const voiceSession = await prisma.voiceSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VoiceSessionFindUniqueArgs>(args: SelectSubset<T, VoiceSessionFindUniqueArgs<ExtArgs>>): Prisma__VoiceSessionClient<$Result.GetResult<Prisma.$VoiceSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VoiceSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VoiceSessionFindUniqueOrThrowArgs} args - Arguments to find a VoiceSession
     * @example
     * // Get one VoiceSession
     * const voiceSession = await prisma.voiceSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VoiceSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, VoiceSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VoiceSessionClient<$Result.GetResult<Prisma.$VoiceSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VoiceSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceSessionFindFirstArgs} args - Arguments to find a VoiceSession
     * @example
     * // Get one VoiceSession
     * const voiceSession = await prisma.voiceSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VoiceSessionFindFirstArgs>(args?: SelectSubset<T, VoiceSessionFindFirstArgs<ExtArgs>>): Prisma__VoiceSessionClient<$Result.GetResult<Prisma.$VoiceSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VoiceSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceSessionFindFirstOrThrowArgs} args - Arguments to find a VoiceSession
     * @example
     * // Get one VoiceSession
     * const voiceSession = await prisma.voiceSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VoiceSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, VoiceSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__VoiceSessionClient<$Result.GetResult<Prisma.$VoiceSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VoiceSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VoiceSessions
     * const voiceSessions = await prisma.voiceSession.findMany()
     * 
     * // Get first 10 VoiceSessions
     * const voiceSessions = await prisma.voiceSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voiceSessionWithIdOnly = await prisma.voiceSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VoiceSessionFindManyArgs>(args?: SelectSubset<T, VoiceSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoiceSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VoiceSession.
     * @param {VoiceSessionCreateArgs} args - Arguments to create a VoiceSession.
     * @example
     * // Create one VoiceSession
     * const VoiceSession = await prisma.voiceSession.create({
     *   data: {
     *     // ... data to create a VoiceSession
     *   }
     * })
     * 
     */
    create<T extends VoiceSessionCreateArgs>(args: SelectSubset<T, VoiceSessionCreateArgs<ExtArgs>>): Prisma__VoiceSessionClient<$Result.GetResult<Prisma.$VoiceSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VoiceSessions.
     * @param {VoiceSessionCreateManyArgs} args - Arguments to create many VoiceSessions.
     * @example
     * // Create many VoiceSessions
     * const voiceSession = await prisma.voiceSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VoiceSessionCreateManyArgs>(args?: SelectSubset<T, VoiceSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VoiceSessions and returns the data saved in the database.
     * @param {VoiceSessionCreateManyAndReturnArgs} args - Arguments to create many VoiceSessions.
     * @example
     * // Create many VoiceSessions
     * const voiceSession = await prisma.voiceSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VoiceSessions and only return the `id`
     * const voiceSessionWithIdOnly = await prisma.voiceSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VoiceSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, VoiceSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoiceSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VoiceSession.
     * @param {VoiceSessionDeleteArgs} args - Arguments to delete one VoiceSession.
     * @example
     * // Delete one VoiceSession
     * const VoiceSession = await prisma.voiceSession.delete({
     *   where: {
     *     // ... filter to delete one VoiceSession
     *   }
     * })
     * 
     */
    delete<T extends VoiceSessionDeleteArgs>(args: SelectSubset<T, VoiceSessionDeleteArgs<ExtArgs>>): Prisma__VoiceSessionClient<$Result.GetResult<Prisma.$VoiceSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VoiceSession.
     * @param {VoiceSessionUpdateArgs} args - Arguments to update one VoiceSession.
     * @example
     * // Update one VoiceSession
     * const voiceSession = await prisma.voiceSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VoiceSessionUpdateArgs>(args: SelectSubset<T, VoiceSessionUpdateArgs<ExtArgs>>): Prisma__VoiceSessionClient<$Result.GetResult<Prisma.$VoiceSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VoiceSessions.
     * @param {VoiceSessionDeleteManyArgs} args - Arguments to filter VoiceSessions to delete.
     * @example
     * // Delete a few VoiceSessions
     * const { count } = await prisma.voiceSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VoiceSessionDeleteManyArgs>(args?: SelectSubset<T, VoiceSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VoiceSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VoiceSessions
     * const voiceSession = await prisma.voiceSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VoiceSessionUpdateManyArgs>(args: SelectSubset<T, VoiceSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VoiceSessions and returns the data updated in the database.
     * @param {VoiceSessionUpdateManyAndReturnArgs} args - Arguments to update many VoiceSessions.
     * @example
     * // Update many VoiceSessions
     * const voiceSession = await prisma.voiceSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VoiceSessions and only return the `id`
     * const voiceSessionWithIdOnly = await prisma.voiceSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VoiceSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, VoiceSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoiceSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VoiceSession.
     * @param {VoiceSessionUpsertArgs} args - Arguments to update or create a VoiceSession.
     * @example
     * // Update or create a VoiceSession
     * const voiceSession = await prisma.voiceSession.upsert({
     *   create: {
     *     // ... data to create a VoiceSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VoiceSession we want to update
     *   }
     * })
     */
    upsert<T extends VoiceSessionUpsertArgs>(args: SelectSubset<T, VoiceSessionUpsertArgs<ExtArgs>>): Prisma__VoiceSessionClient<$Result.GetResult<Prisma.$VoiceSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VoiceSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceSessionCountArgs} args - Arguments to filter VoiceSessions to count.
     * @example
     * // Count the number of VoiceSessions
     * const count = await prisma.voiceSession.count({
     *   where: {
     *     // ... the filter for the VoiceSessions we want to count
     *   }
     * })
    **/
    count<T extends VoiceSessionCountArgs>(
      args?: Subset<T, VoiceSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoiceSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VoiceSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoiceSessionAggregateArgs>(args: Subset<T, VoiceSessionAggregateArgs>): Prisma.PrismaPromise<GetVoiceSessionAggregateType<T>>

    /**
     * Group by VoiceSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoiceSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoiceSessionGroupByArgs['orderBy'] }
        : { orderBy?: VoiceSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoiceSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoiceSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VoiceSession model
   */
  readonly fields: VoiceSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VoiceSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoiceSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VoiceSession model
   */
  interface VoiceSessionFieldRefs {
    readonly id: FieldRef<"VoiceSession", 'String'>
    readonly userId: FieldRef<"VoiceSession", 'String'>
    readonly title: FieldRef<"VoiceSession", 'String'>
    readonly duration: FieldRef<"VoiceSession", 'Int'>
    readonly recordedAt: FieldRef<"VoiceSession", 'DateTime'>
    readonly audioFileUrl: FieldRef<"VoiceSession", 'String'>
    readonly waveformData: FieldRef<"VoiceSession", 'Json'>
    readonly transcription: FieldRef<"VoiceSession", 'String'>
    readonly speakers: FieldRef<"VoiceSession", 'Json[]'>
    readonly timestamps: FieldRef<"VoiceSession", 'Json[]'>
    readonly summary: FieldRef<"VoiceSession", 'String'>
    readonly keyPoints: FieldRef<"VoiceSession", 'String[]'>
    readonly actionItems: FieldRef<"VoiceSession", 'Json[]'>
    readonly projectId: FieldRef<"VoiceSession", 'String'>
    readonly tags: FieldRef<"VoiceSession", 'String[]'>
    readonly processed: FieldRef<"VoiceSession", 'Boolean'>
    readonly archivedAt: FieldRef<"VoiceSession", 'DateTime'>
    readonly createdAt: FieldRef<"VoiceSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VoiceSession findUnique
   */
  export type VoiceSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceSession
     */
    select?: VoiceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceSession
     */
    omit?: VoiceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceSessionInclude<ExtArgs> | null
    /**
     * Filter, which VoiceSession to fetch.
     */
    where: VoiceSessionWhereUniqueInput
  }

  /**
   * VoiceSession findUniqueOrThrow
   */
  export type VoiceSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceSession
     */
    select?: VoiceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceSession
     */
    omit?: VoiceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceSessionInclude<ExtArgs> | null
    /**
     * Filter, which VoiceSession to fetch.
     */
    where: VoiceSessionWhereUniqueInput
  }

  /**
   * VoiceSession findFirst
   */
  export type VoiceSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceSession
     */
    select?: VoiceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceSession
     */
    omit?: VoiceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceSessionInclude<ExtArgs> | null
    /**
     * Filter, which VoiceSession to fetch.
     */
    where?: VoiceSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoiceSessions to fetch.
     */
    orderBy?: VoiceSessionOrderByWithRelationInput | VoiceSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VoiceSessions.
     */
    cursor?: VoiceSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoiceSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoiceSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VoiceSessions.
     */
    distinct?: VoiceSessionScalarFieldEnum | VoiceSessionScalarFieldEnum[]
  }

  /**
   * VoiceSession findFirstOrThrow
   */
  export type VoiceSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceSession
     */
    select?: VoiceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceSession
     */
    omit?: VoiceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceSessionInclude<ExtArgs> | null
    /**
     * Filter, which VoiceSession to fetch.
     */
    where?: VoiceSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoiceSessions to fetch.
     */
    orderBy?: VoiceSessionOrderByWithRelationInput | VoiceSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VoiceSessions.
     */
    cursor?: VoiceSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoiceSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoiceSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VoiceSessions.
     */
    distinct?: VoiceSessionScalarFieldEnum | VoiceSessionScalarFieldEnum[]
  }

  /**
   * VoiceSession findMany
   */
  export type VoiceSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceSession
     */
    select?: VoiceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceSession
     */
    omit?: VoiceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceSessionInclude<ExtArgs> | null
    /**
     * Filter, which VoiceSessions to fetch.
     */
    where?: VoiceSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoiceSessions to fetch.
     */
    orderBy?: VoiceSessionOrderByWithRelationInput | VoiceSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VoiceSessions.
     */
    cursor?: VoiceSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoiceSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoiceSessions.
     */
    skip?: number
    distinct?: VoiceSessionScalarFieldEnum | VoiceSessionScalarFieldEnum[]
  }

  /**
   * VoiceSession create
   */
  export type VoiceSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceSession
     */
    select?: VoiceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceSession
     */
    omit?: VoiceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a VoiceSession.
     */
    data: XOR<VoiceSessionCreateInput, VoiceSessionUncheckedCreateInput>
  }

  /**
   * VoiceSession createMany
   */
  export type VoiceSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VoiceSessions.
     */
    data: VoiceSessionCreateManyInput | VoiceSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VoiceSession createManyAndReturn
   */
  export type VoiceSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceSession
     */
    select?: VoiceSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceSession
     */
    omit?: VoiceSessionOmit<ExtArgs> | null
    /**
     * The data used to create many VoiceSessions.
     */
    data: VoiceSessionCreateManyInput | VoiceSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VoiceSession update
   */
  export type VoiceSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceSession
     */
    select?: VoiceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceSession
     */
    omit?: VoiceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a VoiceSession.
     */
    data: XOR<VoiceSessionUpdateInput, VoiceSessionUncheckedUpdateInput>
    /**
     * Choose, which VoiceSession to update.
     */
    where: VoiceSessionWhereUniqueInput
  }

  /**
   * VoiceSession updateMany
   */
  export type VoiceSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VoiceSessions.
     */
    data: XOR<VoiceSessionUpdateManyMutationInput, VoiceSessionUncheckedUpdateManyInput>
    /**
     * Filter which VoiceSessions to update
     */
    where?: VoiceSessionWhereInput
    /**
     * Limit how many VoiceSessions to update.
     */
    limit?: number
  }

  /**
   * VoiceSession updateManyAndReturn
   */
  export type VoiceSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceSession
     */
    select?: VoiceSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceSession
     */
    omit?: VoiceSessionOmit<ExtArgs> | null
    /**
     * The data used to update VoiceSessions.
     */
    data: XOR<VoiceSessionUpdateManyMutationInput, VoiceSessionUncheckedUpdateManyInput>
    /**
     * Filter which VoiceSessions to update
     */
    where?: VoiceSessionWhereInput
    /**
     * Limit how many VoiceSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VoiceSession upsert
   */
  export type VoiceSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceSession
     */
    select?: VoiceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceSession
     */
    omit?: VoiceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the VoiceSession to update in case it exists.
     */
    where: VoiceSessionWhereUniqueInput
    /**
     * In case the VoiceSession found by the `where` argument doesn't exist, create a new VoiceSession with this data.
     */
    create: XOR<VoiceSessionCreateInput, VoiceSessionUncheckedCreateInput>
    /**
     * In case the VoiceSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoiceSessionUpdateInput, VoiceSessionUncheckedUpdateInput>
  }

  /**
   * VoiceSession delete
   */
  export type VoiceSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceSession
     */
    select?: VoiceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceSession
     */
    omit?: VoiceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceSessionInclude<ExtArgs> | null
    /**
     * Filter which VoiceSession to delete.
     */
    where: VoiceSessionWhereUniqueInput
  }

  /**
   * VoiceSession deleteMany
   */
  export type VoiceSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VoiceSessions to delete
     */
    where?: VoiceSessionWhereInput
    /**
     * Limit how many VoiceSessions to delete.
     */
    limit?: number
  }

  /**
   * VoiceSession without action
   */
  export type VoiceSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceSession
     */
    select?: VoiceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceSession
     */
    omit?: VoiceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceSessionInclude<ExtArgs> | null
  }


  /**
   * Model CalendarEvent
   */

  export type AggregateCalendarEvent = {
    _count: CalendarEventCountAggregateOutputType | null
    _min: CalendarEventMinAggregateOutputType | null
    _max: CalendarEventMaxAggregateOutputType | null
  }

  export type CalendarEventMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    startTime: Date | null
    endTime: Date | null
    allDay: boolean | null
    timezone: string | null
    isRecurring: boolean | null
    recurrenceRule: string | null
    projectId: string | null
    taskId: string | null
    clientId: string | null
    meetingId: string | null
    type: string | null
    color: string | null
    location: string | null
    externalCalendarId: string | null
    externalEventId: string | null
    syncStatus: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CalendarEventMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    startTime: Date | null
    endTime: Date | null
    allDay: boolean | null
    timezone: string | null
    isRecurring: boolean | null
    recurrenceRule: string | null
    projectId: string | null
    taskId: string | null
    clientId: string | null
    meetingId: string | null
    type: string | null
    color: string | null
    location: string | null
    externalCalendarId: string | null
    externalEventId: string | null
    syncStatus: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CalendarEventCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    description: number
    startTime: number
    endTime: number
    allDay: number
    timezone: number
    isRecurring: number
    recurrenceRule: number
    projectId: number
    taskId: number
    clientId: number
    meetingId: number
    type: number
    reminders: number
    color: number
    location: number
    attendees: number
    externalCalendarId: number
    externalEventId: number
    syncStatus: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CalendarEventMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    startTime?: true
    endTime?: true
    allDay?: true
    timezone?: true
    isRecurring?: true
    recurrenceRule?: true
    projectId?: true
    taskId?: true
    clientId?: true
    meetingId?: true
    type?: true
    color?: true
    location?: true
    externalCalendarId?: true
    externalEventId?: true
    syncStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CalendarEventMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    startTime?: true
    endTime?: true
    allDay?: true
    timezone?: true
    isRecurring?: true
    recurrenceRule?: true
    projectId?: true
    taskId?: true
    clientId?: true
    meetingId?: true
    type?: true
    color?: true
    location?: true
    externalCalendarId?: true
    externalEventId?: true
    syncStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CalendarEventCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    startTime?: true
    endTime?: true
    allDay?: true
    timezone?: true
    isRecurring?: true
    recurrenceRule?: true
    projectId?: true
    taskId?: true
    clientId?: true
    meetingId?: true
    type?: true
    reminders?: true
    color?: true
    location?: true
    attendees?: true
    externalCalendarId?: true
    externalEventId?: true
    syncStatus?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CalendarEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarEvent to aggregate.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CalendarEvents
    **/
    _count?: true | CalendarEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalendarEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalendarEventMaxAggregateInputType
  }

  export type GetCalendarEventAggregateType<T extends CalendarEventAggregateArgs> = {
        [P in keyof T & keyof AggregateCalendarEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalendarEvent[P]>
      : GetScalarType<T[P], AggregateCalendarEvent[P]>
  }




  export type CalendarEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarEventWhereInput
    orderBy?: CalendarEventOrderByWithAggregationInput | CalendarEventOrderByWithAggregationInput[]
    by: CalendarEventScalarFieldEnum[] | CalendarEventScalarFieldEnum
    having?: CalendarEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalendarEventCountAggregateInputType | true
    _min?: CalendarEventMinAggregateInputType
    _max?: CalendarEventMaxAggregateInputType
  }

  export type CalendarEventGroupByOutputType = {
    id: string
    userId: string
    title: string
    description: string | null
    startTime: Date
    endTime: Date
    allDay: boolean
    timezone: string
    isRecurring: boolean
    recurrenceRule: string | null
    projectId: string | null
    taskId: string | null
    clientId: string | null
    meetingId: string | null
    type: string
    reminders: JsonValue[]
    color: string | null
    location: string | null
    attendees: string[]
    externalCalendarId: string | null
    externalEventId: string | null
    syncStatus: string | null
    createdAt: Date
    updatedAt: Date
    _count: CalendarEventCountAggregateOutputType | null
    _min: CalendarEventMinAggregateOutputType | null
    _max: CalendarEventMaxAggregateOutputType | null
  }

  type GetCalendarEventGroupByPayload<T extends CalendarEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalendarEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalendarEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalendarEventGroupByOutputType[P]>
            : GetScalarType<T[P], CalendarEventGroupByOutputType[P]>
        }
      >
    >


  export type CalendarEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    allDay?: boolean
    timezone?: boolean
    isRecurring?: boolean
    recurrenceRule?: boolean
    projectId?: boolean
    taskId?: boolean
    clientId?: boolean
    meetingId?: boolean
    type?: boolean
    reminders?: boolean
    color?: boolean
    location?: boolean
    attendees?: boolean
    externalCalendarId?: boolean
    externalEventId?: boolean
    syncStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendarEvent"]>

  export type CalendarEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    allDay?: boolean
    timezone?: boolean
    isRecurring?: boolean
    recurrenceRule?: boolean
    projectId?: boolean
    taskId?: boolean
    clientId?: boolean
    meetingId?: boolean
    type?: boolean
    reminders?: boolean
    color?: boolean
    location?: boolean
    attendees?: boolean
    externalCalendarId?: boolean
    externalEventId?: boolean
    syncStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendarEvent"]>

  export type CalendarEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    allDay?: boolean
    timezone?: boolean
    isRecurring?: boolean
    recurrenceRule?: boolean
    projectId?: boolean
    taskId?: boolean
    clientId?: boolean
    meetingId?: boolean
    type?: boolean
    reminders?: boolean
    color?: boolean
    location?: boolean
    attendees?: boolean
    externalCalendarId?: boolean
    externalEventId?: boolean
    syncStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendarEvent"]>

  export type CalendarEventSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    allDay?: boolean
    timezone?: boolean
    isRecurring?: boolean
    recurrenceRule?: boolean
    projectId?: boolean
    taskId?: boolean
    clientId?: boolean
    meetingId?: boolean
    type?: boolean
    reminders?: boolean
    color?: boolean
    location?: boolean
    attendees?: boolean
    externalCalendarId?: boolean
    externalEventId?: boolean
    syncStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CalendarEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "description" | "startTime" | "endTime" | "allDay" | "timezone" | "isRecurring" | "recurrenceRule" | "projectId" | "taskId" | "clientId" | "meetingId" | "type" | "reminders" | "color" | "location" | "attendees" | "externalCalendarId" | "externalEventId" | "syncStatus" | "createdAt" | "updatedAt", ExtArgs["result"]["calendarEvent"]>
  export type CalendarEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CalendarEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CalendarEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CalendarEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CalendarEvent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      description: string | null
      startTime: Date
      endTime: Date
      allDay: boolean
      timezone: string
      isRecurring: boolean
      recurrenceRule: string | null
      projectId: string | null
      taskId: string | null
      clientId: string | null
      meetingId: string | null
      type: string
      reminders: Prisma.JsonValue[]
      color: string | null
      location: string | null
      attendees: string[]
      externalCalendarId: string | null
      externalEventId: string | null
      syncStatus: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["calendarEvent"]>
    composites: {}
  }

  type CalendarEventGetPayload<S extends boolean | null | undefined | CalendarEventDefaultArgs> = $Result.GetResult<Prisma.$CalendarEventPayload, S>

  type CalendarEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CalendarEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CalendarEventCountAggregateInputType | true
    }

  export interface CalendarEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CalendarEvent'], meta: { name: 'CalendarEvent' } }
    /**
     * Find zero or one CalendarEvent that matches the filter.
     * @param {CalendarEventFindUniqueArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CalendarEventFindUniqueArgs>(args: SelectSubset<T, CalendarEventFindUniqueArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CalendarEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CalendarEventFindUniqueOrThrowArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CalendarEventFindUniqueOrThrowArgs>(args: SelectSubset<T, CalendarEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CalendarEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventFindFirstArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CalendarEventFindFirstArgs>(args?: SelectSubset<T, CalendarEventFindFirstArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CalendarEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventFindFirstOrThrowArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CalendarEventFindFirstOrThrowArgs>(args?: SelectSubset<T, CalendarEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CalendarEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CalendarEvents
     * const calendarEvents = await prisma.calendarEvent.findMany()
     * 
     * // Get first 10 CalendarEvents
     * const calendarEvents = await prisma.calendarEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calendarEventWithIdOnly = await prisma.calendarEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CalendarEventFindManyArgs>(args?: SelectSubset<T, CalendarEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CalendarEvent.
     * @param {CalendarEventCreateArgs} args - Arguments to create a CalendarEvent.
     * @example
     * // Create one CalendarEvent
     * const CalendarEvent = await prisma.calendarEvent.create({
     *   data: {
     *     // ... data to create a CalendarEvent
     *   }
     * })
     * 
     */
    create<T extends CalendarEventCreateArgs>(args: SelectSubset<T, CalendarEventCreateArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CalendarEvents.
     * @param {CalendarEventCreateManyArgs} args - Arguments to create many CalendarEvents.
     * @example
     * // Create many CalendarEvents
     * const calendarEvent = await prisma.calendarEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CalendarEventCreateManyArgs>(args?: SelectSubset<T, CalendarEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CalendarEvents and returns the data saved in the database.
     * @param {CalendarEventCreateManyAndReturnArgs} args - Arguments to create many CalendarEvents.
     * @example
     * // Create many CalendarEvents
     * const calendarEvent = await prisma.calendarEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CalendarEvents and only return the `id`
     * const calendarEventWithIdOnly = await prisma.calendarEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CalendarEventCreateManyAndReturnArgs>(args?: SelectSubset<T, CalendarEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CalendarEvent.
     * @param {CalendarEventDeleteArgs} args - Arguments to delete one CalendarEvent.
     * @example
     * // Delete one CalendarEvent
     * const CalendarEvent = await prisma.calendarEvent.delete({
     *   where: {
     *     // ... filter to delete one CalendarEvent
     *   }
     * })
     * 
     */
    delete<T extends CalendarEventDeleteArgs>(args: SelectSubset<T, CalendarEventDeleteArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CalendarEvent.
     * @param {CalendarEventUpdateArgs} args - Arguments to update one CalendarEvent.
     * @example
     * // Update one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CalendarEventUpdateArgs>(args: SelectSubset<T, CalendarEventUpdateArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CalendarEvents.
     * @param {CalendarEventDeleteManyArgs} args - Arguments to filter CalendarEvents to delete.
     * @example
     * // Delete a few CalendarEvents
     * const { count } = await prisma.calendarEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CalendarEventDeleteManyArgs>(args?: SelectSubset<T, CalendarEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CalendarEvents
     * const calendarEvent = await prisma.calendarEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CalendarEventUpdateManyArgs>(args: SelectSubset<T, CalendarEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarEvents and returns the data updated in the database.
     * @param {CalendarEventUpdateManyAndReturnArgs} args - Arguments to update many CalendarEvents.
     * @example
     * // Update many CalendarEvents
     * const calendarEvent = await prisma.calendarEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CalendarEvents and only return the `id`
     * const calendarEventWithIdOnly = await prisma.calendarEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CalendarEventUpdateManyAndReturnArgs>(args: SelectSubset<T, CalendarEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CalendarEvent.
     * @param {CalendarEventUpsertArgs} args - Arguments to update or create a CalendarEvent.
     * @example
     * // Update or create a CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.upsert({
     *   create: {
     *     // ... data to create a CalendarEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CalendarEvent we want to update
     *   }
     * })
     */
    upsert<T extends CalendarEventUpsertArgs>(args: SelectSubset<T, CalendarEventUpsertArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CalendarEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventCountArgs} args - Arguments to filter CalendarEvents to count.
     * @example
     * // Count the number of CalendarEvents
     * const count = await prisma.calendarEvent.count({
     *   where: {
     *     // ... the filter for the CalendarEvents we want to count
     *   }
     * })
    **/
    count<T extends CalendarEventCountArgs>(
      args?: Subset<T, CalendarEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalendarEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CalendarEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalendarEventAggregateArgs>(args: Subset<T, CalendarEventAggregateArgs>): Prisma.PrismaPromise<GetCalendarEventAggregateType<T>>

    /**
     * Group by CalendarEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalendarEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalendarEventGroupByArgs['orderBy'] }
        : { orderBy?: CalendarEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalendarEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalendarEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CalendarEvent model
   */
  readonly fields: CalendarEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CalendarEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CalendarEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CalendarEvent model
   */
  interface CalendarEventFieldRefs {
    readonly id: FieldRef<"CalendarEvent", 'String'>
    readonly userId: FieldRef<"CalendarEvent", 'String'>
    readonly title: FieldRef<"CalendarEvent", 'String'>
    readonly description: FieldRef<"CalendarEvent", 'String'>
    readonly startTime: FieldRef<"CalendarEvent", 'DateTime'>
    readonly endTime: FieldRef<"CalendarEvent", 'DateTime'>
    readonly allDay: FieldRef<"CalendarEvent", 'Boolean'>
    readonly timezone: FieldRef<"CalendarEvent", 'String'>
    readonly isRecurring: FieldRef<"CalendarEvent", 'Boolean'>
    readonly recurrenceRule: FieldRef<"CalendarEvent", 'String'>
    readonly projectId: FieldRef<"CalendarEvent", 'String'>
    readonly taskId: FieldRef<"CalendarEvent", 'String'>
    readonly clientId: FieldRef<"CalendarEvent", 'String'>
    readonly meetingId: FieldRef<"CalendarEvent", 'String'>
    readonly type: FieldRef<"CalendarEvent", 'String'>
    readonly reminders: FieldRef<"CalendarEvent", 'Json[]'>
    readonly color: FieldRef<"CalendarEvent", 'String'>
    readonly location: FieldRef<"CalendarEvent", 'String'>
    readonly attendees: FieldRef<"CalendarEvent", 'String[]'>
    readonly externalCalendarId: FieldRef<"CalendarEvent", 'String'>
    readonly externalEventId: FieldRef<"CalendarEvent", 'String'>
    readonly syncStatus: FieldRef<"CalendarEvent", 'String'>
    readonly createdAt: FieldRef<"CalendarEvent", 'DateTime'>
    readonly updatedAt: FieldRef<"CalendarEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CalendarEvent findUnique
   */
  export type CalendarEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where: CalendarEventWhereUniqueInput
  }

  /**
   * CalendarEvent findUniqueOrThrow
   */
  export type CalendarEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where: CalendarEventWhereUniqueInput
  }

  /**
   * CalendarEvent findFirst
   */
  export type CalendarEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarEvents.
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarEvents.
     */
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * CalendarEvent findFirstOrThrow
   */
  export type CalendarEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarEvents.
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarEvents.
     */
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * CalendarEvent findMany
   */
  export type CalendarEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvents to fetch.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CalendarEvents.
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * CalendarEvent create
   */
  export type CalendarEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * The data needed to create a CalendarEvent.
     */
    data: XOR<CalendarEventCreateInput, CalendarEventUncheckedCreateInput>
  }

  /**
   * CalendarEvent createMany
   */
  export type CalendarEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CalendarEvents.
     */
    data: CalendarEventCreateManyInput | CalendarEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CalendarEvent createManyAndReturn
   */
  export type CalendarEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * The data used to create many CalendarEvents.
     */
    data: CalendarEventCreateManyInput | CalendarEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CalendarEvent update
   */
  export type CalendarEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * The data needed to update a CalendarEvent.
     */
    data: XOR<CalendarEventUpdateInput, CalendarEventUncheckedUpdateInput>
    /**
     * Choose, which CalendarEvent to update.
     */
    where: CalendarEventWhereUniqueInput
  }

  /**
   * CalendarEvent updateMany
   */
  export type CalendarEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CalendarEvents.
     */
    data: XOR<CalendarEventUpdateManyMutationInput, CalendarEventUncheckedUpdateManyInput>
    /**
     * Filter which CalendarEvents to update
     */
    where?: CalendarEventWhereInput
    /**
     * Limit how many CalendarEvents to update.
     */
    limit?: number
  }

  /**
   * CalendarEvent updateManyAndReturn
   */
  export type CalendarEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * The data used to update CalendarEvents.
     */
    data: XOR<CalendarEventUpdateManyMutationInput, CalendarEventUncheckedUpdateManyInput>
    /**
     * Filter which CalendarEvents to update
     */
    where?: CalendarEventWhereInput
    /**
     * Limit how many CalendarEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CalendarEvent upsert
   */
  export type CalendarEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * The filter to search for the CalendarEvent to update in case it exists.
     */
    where: CalendarEventWhereUniqueInput
    /**
     * In case the CalendarEvent found by the `where` argument doesn't exist, create a new CalendarEvent with this data.
     */
    create: XOR<CalendarEventCreateInput, CalendarEventUncheckedCreateInput>
    /**
     * In case the CalendarEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalendarEventUpdateInput, CalendarEventUncheckedUpdateInput>
  }

  /**
   * CalendarEvent delete
   */
  export type CalendarEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter which CalendarEvent to delete.
     */
    where: CalendarEventWhereUniqueInput
  }

  /**
   * CalendarEvent deleteMany
   */
  export type CalendarEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarEvents to delete
     */
    where?: CalendarEventWhereInput
    /**
     * Limit how many CalendarEvents to delete.
     */
    limit?: number
  }

  /**
   * CalendarEvent without action
   */
  export type CalendarEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
  }


  /**
   * Model AnalyticsEvent
   */

  export type AggregateAnalyticsEvent = {
    _count: AnalyticsEventCountAggregateOutputType | null
    _min: AnalyticsEventMinAggregateOutputType | null
    _max: AnalyticsEventMaxAggregateOutputType | null
  }

  export type AnalyticsEventMinAggregateOutputType = {
    id: string | null
    userId: string | null
    eventType: string | null
    sessionId: string | null
    createdAt: Date | null
  }

  export type AnalyticsEventMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    eventType: string | null
    sessionId: string | null
    createdAt: Date | null
  }

  export type AnalyticsEventCountAggregateOutputType = {
    id: number
    userId: number
    eventType: number
    eventData: number
    sessionId: number
    createdAt: number
    _all: number
  }


  export type AnalyticsEventMinAggregateInputType = {
    id?: true
    userId?: true
    eventType?: true
    sessionId?: true
    createdAt?: true
  }

  export type AnalyticsEventMaxAggregateInputType = {
    id?: true
    userId?: true
    eventType?: true
    sessionId?: true
    createdAt?: true
  }

  export type AnalyticsEventCountAggregateInputType = {
    id?: true
    userId?: true
    eventType?: true
    eventData?: true
    sessionId?: true
    createdAt?: true
    _all?: true
  }

  export type AnalyticsEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsEvent to aggregate.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnalyticsEvents
    **/
    _count?: true | AnalyticsEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalyticsEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalyticsEventMaxAggregateInputType
  }

  export type GetAnalyticsEventAggregateType<T extends AnalyticsEventAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalyticsEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalyticsEvent[P]>
      : GetScalarType<T[P], AggregateAnalyticsEvent[P]>
  }




  export type AnalyticsEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsEventWhereInput
    orderBy?: AnalyticsEventOrderByWithAggregationInput | AnalyticsEventOrderByWithAggregationInput[]
    by: AnalyticsEventScalarFieldEnum[] | AnalyticsEventScalarFieldEnum
    having?: AnalyticsEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalyticsEventCountAggregateInputType | true
    _min?: AnalyticsEventMinAggregateInputType
    _max?: AnalyticsEventMaxAggregateInputType
  }

  export type AnalyticsEventGroupByOutputType = {
    id: string
    userId: string
    eventType: string
    eventData: JsonValue | null
    sessionId: string | null
    createdAt: Date
    _count: AnalyticsEventCountAggregateOutputType | null
    _min: AnalyticsEventMinAggregateOutputType | null
    _max: AnalyticsEventMaxAggregateOutputType | null
  }

  type GetAnalyticsEventGroupByPayload<T extends AnalyticsEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalyticsEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalyticsEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalyticsEventGroupByOutputType[P]>
            : GetScalarType<T[P], AnalyticsEventGroupByOutputType[P]>
        }
      >
    >


  export type AnalyticsEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventType?: boolean
    eventData?: boolean
    sessionId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analyticsEvent"]>

  export type AnalyticsEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventType?: boolean
    eventData?: boolean
    sessionId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analyticsEvent"]>

  export type AnalyticsEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventType?: boolean
    eventData?: boolean
    sessionId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analyticsEvent"]>

  export type AnalyticsEventSelectScalar = {
    id?: boolean
    userId?: boolean
    eventType?: boolean
    eventData?: boolean
    sessionId?: boolean
    createdAt?: boolean
  }

  export type AnalyticsEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "eventType" | "eventData" | "sessionId" | "createdAt", ExtArgs["result"]["analyticsEvent"]>
  export type AnalyticsEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AnalyticsEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AnalyticsEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AnalyticsEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnalyticsEvent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      eventType: string
      eventData: Prisma.JsonValue | null
      sessionId: string | null
      createdAt: Date
    }, ExtArgs["result"]["analyticsEvent"]>
    composites: {}
  }

  type AnalyticsEventGetPayload<S extends boolean | null | undefined | AnalyticsEventDefaultArgs> = $Result.GetResult<Prisma.$AnalyticsEventPayload, S>

  type AnalyticsEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnalyticsEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnalyticsEventCountAggregateInputType | true
    }

  export interface AnalyticsEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnalyticsEvent'], meta: { name: 'AnalyticsEvent' } }
    /**
     * Find zero or one AnalyticsEvent that matches the filter.
     * @param {AnalyticsEventFindUniqueArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalyticsEventFindUniqueArgs>(args: SelectSubset<T, AnalyticsEventFindUniqueArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnalyticsEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnalyticsEventFindUniqueOrThrowArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalyticsEventFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalyticsEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticsEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventFindFirstArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalyticsEventFindFirstArgs>(args?: SelectSubset<T, AnalyticsEventFindFirstArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticsEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventFindFirstOrThrowArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalyticsEventFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalyticsEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnalyticsEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalyticsEvents
     * const analyticsEvents = await prisma.analyticsEvent.findMany()
     * 
     * // Get first 10 AnalyticsEvents
     * const analyticsEvents = await prisma.analyticsEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analyticsEventWithIdOnly = await prisma.analyticsEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalyticsEventFindManyArgs>(args?: SelectSubset<T, AnalyticsEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnalyticsEvent.
     * @param {AnalyticsEventCreateArgs} args - Arguments to create a AnalyticsEvent.
     * @example
     * // Create one AnalyticsEvent
     * const AnalyticsEvent = await prisma.analyticsEvent.create({
     *   data: {
     *     // ... data to create a AnalyticsEvent
     *   }
     * })
     * 
     */
    create<T extends AnalyticsEventCreateArgs>(args: SelectSubset<T, AnalyticsEventCreateArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnalyticsEvents.
     * @param {AnalyticsEventCreateManyArgs} args - Arguments to create many AnalyticsEvents.
     * @example
     * // Create many AnalyticsEvents
     * const analyticsEvent = await prisma.analyticsEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalyticsEventCreateManyArgs>(args?: SelectSubset<T, AnalyticsEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnalyticsEvents and returns the data saved in the database.
     * @param {AnalyticsEventCreateManyAndReturnArgs} args - Arguments to create many AnalyticsEvents.
     * @example
     * // Create many AnalyticsEvents
     * const analyticsEvent = await prisma.analyticsEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnalyticsEvents and only return the `id`
     * const analyticsEventWithIdOnly = await prisma.analyticsEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalyticsEventCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalyticsEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AnalyticsEvent.
     * @param {AnalyticsEventDeleteArgs} args - Arguments to delete one AnalyticsEvent.
     * @example
     * // Delete one AnalyticsEvent
     * const AnalyticsEvent = await prisma.analyticsEvent.delete({
     *   where: {
     *     // ... filter to delete one AnalyticsEvent
     *   }
     * })
     * 
     */
    delete<T extends AnalyticsEventDeleteArgs>(args: SelectSubset<T, AnalyticsEventDeleteArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnalyticsEvent.
     * @param {AnalyticsEventUpdateArgs} args - Arguments to update one AnalyticsEvent.
     * @example
     * // Update one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalyticsEventUpdateArgs>(args: SelectSubset<T, AnalyticsEventUpdateArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnalyticsEvents.
     * @param {AnalyticsEventDeleteManyArgs} args - Arguments to filter AnalyticsEvents to delete.
     * @example
     * // Delete a few AnalyticsEvents
     * const { count } = await prisma.analyticsEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalyticsEventDeleteManyArgs>(args?: SelectSubset<T, AnalyticsEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalyticsEvents
     * const analyticsEvent = await prisma.analyticsEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalyticsEventUpdateManyArgs>(args: SelectSubset<T, AnalyticsEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsEvents and returns the data updated in the database.
     * @param {AnalyticsEventUpdateManyAndReturnArgs} args - Arguments to update many AnalyticsEvents.
     * @example
     * // Update many AnalyticsEvents
     * const analyticsEvent = await prisma.analyticsEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AnalyticsEvents and only return the `id`
     * const analyticsEventWithIdOnly = await prisma.analyticsEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnalyticsEventUpdateManyAndReturnArgs>(args: SelectSubset<T, AnalyticsEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AnalyticsEvent.
     * @param {AnalyticsEventUpsertArgs} args - Arguments to update or create a AnalyticsEvent.
     * @example
     * // Update or create a AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.upsert({
     *   create: {
     *     // ... data to create a AnalyticsEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalyticsEvent we want to update
     *   }
     * })
     */
    upsert<T extends AnalyticsEventUpsertArgs>(args: SelectSubset<T, AnalyticsEventUpsertArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnalyticsEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventCountArgs} args - Arguments to filter AnalyticsEvents to count.
     * @example
     * // Count the number of AnalyticsEvents
     * const count = await prisma.analyticsEvent.count({
     *   where: {
     *     // ... the filter for the AnalyticsEvents we want to count
     *   }
     * })
    **/
    count<T extends AnalyticsEventCountArgs>(
      args?: Subset<T, AnalyticsEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalyticsEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalyticsEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalyticsEventAggregateArgs>(args: Subset<T, AnalyticsEventAggregateArgs>): Prisma.PrismaPromise<GetAnalyticsEventAggregateType<T>>

    /**
     * Group by AnalyticsEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalyticsEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalyticsEventGroupByArgs['orderBy'] }
        : { orderBy?: AnalyticsEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalyticsEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalyticsEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnalyticsEvent model
   */
  readonly fields: AnalyticsEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalyticsEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalyticsEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnalyticsEvent model
   */
  interface AnalyticsEventFieldRefs {
    readonly id: FieldRef<"AnalyticsEvent", 'String'>
    readonly userId: FieldRef<"AnalyticsEvent", 'String'>
    readonly eventType: FieldRef<"AnalyticsEvent", 'String'>
    readonly eventData: FieldRef<"AnalyticsEvent", 'Json'>
    readonly sessionId: FieldRef<"AnalyticsEvent", 'String'>
    readonly createdAt: FieldRef<"AnalyticsEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnalyticsEvent findUnique
   */
  export type AnalyticsEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where: AnalyticsEventWhereUniqueInput
  }

  /**
   * AnalyticsEvent findUniqueOrThrow
   */
  export type AnalyticsEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where: AnalyticsEventWhereUniqueInput
  }

  /**
   * AnalyticsEvent findFirst
   */
  export type AnalyticsEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsEvents.
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsEvents.
     */
    distinct?: AnalyticsEventScalarFieldEnum | AnalyticsEventScalarFieldEnum[]
  }

  /**
   * AnalyticsEvent findFirstOrThrow
   */
  export type AnalyticsEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsEvents.
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsEvents.
     */
    distinct?: AnalyticsEventScalarFieldEnum | AnalyticsEventScalarFieldEnum[]
  }

  /**
   * AnalyticsEvent findMany
   */
  export type AnalyticsEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvents to fetch.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnalyticsEvents.
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    distinct?: AnalyticsEventScalarFieldEnum | AnalyticsEventScalarFieldEnum[]
  }

  /**
   * AnalyticsEvent create
   */
  export type AnalyticsEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * The data needed to create a AnalyticsEvent.
     */
    data: XOR<AnalyticsEventCreateInput, AnalyticsEventUncheckedCreateInput>
  }

  /**
   * AnalyticsEvent createMany
   */
  export type AnalyticsEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnalyticsEvents.
     */
    data: AnalyticsEventCreateManyInput | AnalyticsEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsEvent createManyAndReturn
   */
  export type AnalyticsEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * The data used to create many AnalyticsEvents.
     */
    data: AnalyticsEventCreateManyInput | AnalyticsEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnalyticsEvent update
   */
  export type AnalyticsEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * The data needed to update a AnalyticsEvent.
     */
    data: XOR<AnalyticsEventUpdateInput, AnalyticsEventUncheckedUpdateInput>
    /**
     * Choose, which AnalyticsEvent to update.
     */
    where: AnalyticsEventWhereUniqueInput
  }

  /**
   * AnalyticsEvent updateMany
   */
  export type AnalyticsEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnalyticsEvents.
     */
    data: XOR<AnalyticsEventUpdateManyMutationInput, AnalyticsEventUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsEvents to update
     */
    where?: AnalyticsEventWhereInput
    /**
     * Limit how many AnalyticsEvents to update.
     */
    limit?: number
  }

  /**
   * AnalyticsEvent updateManyAndReturn
   */
  export type AnalyticsEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * The data used to update AnalyticsEvents.
     */
    data: XOR<AnalyticsEventUpdateManyMutationInput, AnalyticsEventUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsEvents to update
     */
    where?: AnalyticsEventWhereInput
    /**
     * Limit how many AnalyticsEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnalyticsEvent upsert
   */
  export type AnalyticsEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * The filter to search for the AnalyticsEvent to update in case it exists.
     */
    where: AnalyticsEventWhereUniqueInput
    /**
     * In case the AnalyticsEvent found by the `where` argument doesn't exist, create a new AnalyticsEvent with this data.
     */
    create: XOR<AnalyticsEventCreateInput, AnalyticsEventUncheckedCreateInput>
    /**
     * In case the AnalyticsEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalyticsEventUpdateInput, AnalyticsEventUncheckedUpdateInput>
  }

  /**
   * AnalyticsEvent delete
   */
  export type AnalyticsEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * Filter which AnalyticsEvent to delete.
     */
    where: AnalyticsEventWhereUniqueInput
  }

  /**
   * AnalyticsEvent deleteMany
   */
  export type AnalyticsEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsEvents to delete
     */
    where?: AnalyticsEventWhereInput
    /**
     * Limit how many AnalyticsEvents to delete.
     */
    limit?: number
  }

  /**
   * AnalyticsEvent without action
   */
  export type AnalyticsEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
  }


  /**
   * Model Research
   */

  export type AggregateResearch = {
    _count: ResearchCountAggregateOutputType | null
    _avg: ResearchAvgAggregateOutputType | null
    _sum: ResearchSumAggregateOutputType | null
    _min: ResearchMinAggregateOutputType | null
    _max: ResearchMaxAggregateOutputType | null
  }

  export type ResearchAvgAggregateOutputType = {
    progress: number | null
  }

  export type ResearchSumAggregateOutputType = {
    progress: number | null
  }

  export type ResearchMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    scope: $Enums.ResearchScope | null
    searchMethod: $Enums.SearchMethod | null
    status: $Enums.ResearchStatus | null
    originalPrompt: string | null
    refinedPrompt: string | null
    progress: number | null
    errorMessage: string | null
    goalId: string | null
    isFavorited: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type ResearchMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    scope: $Enums.ResearchScope | null
    searchMethod: $Enums.SearchMethod | null
    status: $Enums.ResearchStatus | null
    originalPrompt: string | null
    refinedPrompt: string | null
    progress: number | null
    errorMessage: string | null
    goalId: string | null
    isFavorited: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type ResearchCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    scope: number
    searchMethod: number
    status: number
    originalPrompt: number
    refinedPrompt: number
    rawData: number
    progress: number
    errorMessage: number
    goalId: number
    isFavorited: number
    createdAt: number
    updatedAt: number
    completedAt: number
    _all: number
  }


  export type ResearchAvgAggregateInputType = {
    progress?: true
  }

  export type ResearchSumAggregateInputType = {
    progress?: true
  }

  export type ResearchMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    scope?: true
    searchMethod?: true
    status?: true
    originalPrompt?: true
    refinedPrompt?: true
    progress?: true
    errorMessage?: true
    goalId?: true
    isFavorited?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type ResearchMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    scope?: true
    searchMethod?: true
    status?: true
    originalPrompt?: true
    refinedPrompt?: true
    progress?: true
    errorMessage?: true
    goalId?: true
    isFavorited?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type ResearchCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    scope?: true
    searchMethod?: true
    status?: true
    originalPrompt?: true
    refinedPrompt?: true
    rawData?: true
    progress?: true
    errorMessage?: true
    goalId?: true
    isFavorited?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    _all?: true
  }

  export type ResearchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Research to aggregate.
     */
    where?: ResearchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Research to fetch.
     */
    orderBy?: ResearchOrderByWithRelationInput | ResearchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResearchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Research from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Research.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Research
    **/
    _count?: true | ResearchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResearchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResearchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResearchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResearchMaxAggregateInputType
  }

  export type GetResearchAggregateType<T extends ResearchAggregateArgs> = {
        [P in keyof T & keyof AggregateResearch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResearch[P]>
      : GetScalarType<T[P], AggregateResearch[P]>
  }




  export type ResearchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResearchWhereInput
    orderBy?: ResearchOrderByWithAggregationInput | ResearchOrderByWithAggregationInput[]
    by: ResearchScalarFieldEnum[] | ResearchScalarFieldEnum
    having?: ResearchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResearchCountAggregateInputType | true
    _avg?: ResearchAvgAggregateInputType
    _sum?: ResearchSumAggregateInputType
    _min?: ResearchMinAggregateInputType
    _max?: ResearchMaxAggregateInputType
  }

  export type ResearchGroupByOutputType = {
    id: string
    userId: string
    title: string
    scope: $Enums.ResearchScope
    searchMethod: $Enums.SearchMethod
    status: $Enums.ResearchStatus
    originalPrompt: string
    refinedPrompt: string
    rawData: JsonValue | null
    progress: number
    errorMessage: string | null
    goalId: string | null
    isFavorited: boolean
    createdAt: Date
    updatedAt: Date
    completedAt: Date | null
    _count: ResearchCountAggregateOutputType | null
    _avg: ResearchAvgAggregateOutputType | null
    _sum: ResearchSumAggregateOutputType | null
    _min: ResearchMinAggregateOutputType | null
    _max: ResearchMaxAggregateOutputType | null
  }

  type GetResearchGroupByPayload<T extends ResearchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResearchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResearchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResearchGroupByOutputType[P]>
            : GetScalarType<T[P], ResearchGroupByOutputType[P]>
        }
      >
    >


  export type ResearchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    scope?: boolean
    searchMethod?: boolean
    status?: boolean
    originalPrompt?: boolean
    refinedPrompt?: boolean
    rawData?: boolean
    progress?: boolean
    errorMessage?: boolean
    goalId?: boolean
    isFavorited?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    actionItems?: boolean | Research$actionItemsArgs<ExtArgs>
    leadData?: boolean | Research$leadDataArgs<ExtArgs>
    goal?: boolean | Research$goalArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    insights?: boolean | Research$insightsArgs<ExtArgs>
    sources?: boolean | Research$sourcesArgs<ExtArgs>
    _count?: boolean | ResearchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["research"]>

  export type ResearchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    scope?: boolean
    searchMethod?: boolean
    status?: boolean
    originalPrompt?: boolean
    refinedPrompt?: boolean
    rawData?: boolean
    progress?: boolean
    errorMessage?: boolean
    goalId?: boolean
    isFavorited?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    goal?: boolean | Research$goalArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["research"]>

  export type ResearchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    scope?: boolean
    searchMethod?: boolean
    status?: boolean
    originalPrompt?: boolean
    refinedPrompt?: boolean
    rawData?: boolean
    progress?: boolean
    errorMessage?: boolean
    goalId?: boolean
    isFavorited?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    goal?: boolean | Research$goalArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["research"]>

  export type ResearchSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    scope?: boolean
    searchMethod?: boolean
    status?: boolean
    originalPrompt?: boolean
    refinedPrompt?: boolean
    rawData?: boolean
    progress?: boolean
    errorMessage?: boolean
    goalId?: boolean
    isFavorited?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
  }

  export type ResearchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "scope" | "searchMethod" | "status" | "originalPrompt" | "refinedPrompt" | "rawData" | "progress" | "errorMessage" | "goalId" | "isFavorited" | "createdAt" | "updatedAt" | "completedAt", ExtArgs["result"]["research"]>
  export type ResearchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actionItems?: boolean | Research$actionItemsArgs<ExtArgs>
    leadData?: boolean | Research$leadDataArgs<ExtArgs>
    goal?: boolean | Research$goalArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    insights?: boolean | Research$insightsArgs<ExtArgs>
    sources?: boolean | Research$sourcesArgs<ExtArgs>
    _count?: boolean | ResearchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ResearchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goal?: boolean | Research$goalArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ResearchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goal?: boolean | Research$goalArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ResearchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Research"
    objects: {
      actionItems: Prisma.$ActionItemPayload<ExtArgs>[]
      leadData: Prisma.$LeadDataPayload<ExtArgs> | null
      goal: Prisma.$GoalPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
      insights: Prisma.$ResearchInsightPayload<ExtArgs>[]
      sources: Prisma.$ResearchSourcePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      scope: $Enums.ResearchScope
      searchMethod: $Enums.SearchMethod
      status: $Enums.ResearchStatus
      originalPrompt: string
      refinedPrompt: string
      rawData: Prisma.JsonValue | null
      progress: number
      errorMessage: string | null
      goalId: string | null
      isFavorited: boolean
      createdAt: Date
      updatedAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["research"]>
    composites: {}
  }

  type ResearchGetPayload<S extends boolean | null | undefined | ResearchDefaultArgs> = $Result.GetResult<Prisma.$ResearchPayload, S>

  type ResearchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResearchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResearchCountAggregateInputType | true
    }

  export interface ResearchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Research'], meta: { name: 'Research' } }
    /**
     * Find zero or one Research that matches the filter.
     * @param {ResearchFindUniqueArgs} args - Arguments to find a Research
     * @example
     * // Get one Research
     * const research = await prisma.research.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResearchFindUniqueArgs>(args: SelectSubset<T, ResearchFindUniqueArgs<ExtArgs>>): Prisma__ResearchClient<$Result.GetResult<Prisma.$ResearchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Research that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResearchFindUniqueOrThrowArgs} args - Arguments to find a Research
     * @example
     * // Get one Research
     * const research = await prisma.research.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResearchFindUniqueOrThrowArgs>(args: SelectSubset<T, ResearchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResearchClient<$Result.GetResult<Prisma.$ResearchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Research that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchFindFirstArgs} args - Arguments to find a Research
     * @example
     * // Get one Research
     * const research = await prisma.research.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResearchFindFirstArgs>(args?: SelectSubset<T, ResearchFindFirstArgs<ExtArgs>>): Prisma__ResearchClient<$Result.GetResult<Prisma.$ResearchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Research that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchFindFirstOrThrowArgs} args - Arguments to find a Research
     * @example
     * // Get one Research
     * const research = await prisma.research.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResearchFindFirstOrThrowArgs>(args?: SelectSubset<T, ResearchFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResearchClient<$Result.GetResult<Prisma.$ResearchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Research that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Research
     * const research = await prisma.research.findMany()
     * 
     * // Get first 10 Research
     * const research = await prisma.research.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const researchWithIdOnly = await prisma.research.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResearchFindManyArgs>(args?: SelectSubset<T, ResearchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Research.
     * @param {ResearchCreateArgs} args - Arguments to create a Research.
     * @example
     * // Create one Research
     * const Research = await prisma.research.create({
     *   data: {
     *     // ... data to create a Research
     *   }
     * })
     * 
     */
    create<T extends ResearchCreateArgs>(args: SelectSubset<T, ResearchCreateArgs<ExtArgs>>): Prisma__ResearchClient<$Result.GetResult<Prisma.$ResearchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Research.
     * @param {ResearchCreateManyArgs} args - Arguments to create many Research.
     * @example
     * // Create many Research
     * const research = await prisma.research.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResearchCreateManyArgs>(args?: SelectSubset<T, ResearchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Research and returns the data saved in the database.
     * @param {ResearchCreateManyAndReturnArgs} args - Arguments to create many Research.
     * @example
     * // Create many Research
     * const research = await prisma.research.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Research and only return the `id`
     * const researchWithIdOnly = await prisma.research.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResearchCreateManyAndReturnArgs>(args?: SelectSubset<T, ResearchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Research.
     * @param {ResearchDeleteArgs} args - Arguments to delete one Research.
     * @example
     * // Delete one Research
     * const Research = await prisma.research.delete({
     *   where: {
     *     // ... filter to delete one Research
     *   }
     * })
     * 
     */
    delete<T extends ResearchDeleteArgs>(args: SelectSubset<T, ResearchDeleteArgs<ExtArgs>>): Prisma__ResearchClient<$Result.GetResult<Prisma.$ResearchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Research.
     * @param {ResearchUpdateArgs} args - Arguments to update one Research.
     * @example
     * // Update one Research
     * const research = await prisma.research.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResearchUpdateArgs>(args: SelectSubset<T, ResearchUpdateArgs<ExtArgs>>): Prisma__ResearchClient<$Result.GetResult<Prisma.$ResearchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Research.
     * @param {ResearchDeleteManyArgs} args - Arguments to filter Research to delete.
     * @example
     * // Delete a few Research
     * const { count } = await prisma.research.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResearchDeleteManyArgs>(args?: SelectSubset<T, ResearchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Research.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Research
     * const research = await prisma.research.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResearchUpdateManyArgs>(args: SelectSubset<T, ResearchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Research and returns the data updated in the database.
     * @param {ResearchUpdateManyAndReturnArgs} args - Arguments to update many Research.
     * @example
     * // Update many Research
     * const research = await prisma.research.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Research and only return the `id`
     * const researchWithIdOnly = await prisma.research.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResearchUpdateManyAndReturnArgs>(args: SelectSubset<T, ResearchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Research.
     * @param {ResearchUpsertArgs} args - Arguments to update or create a Research.
     * @example
     * // Update or create a Research
     * const research = await prisma.research.upsert({
     *   create: {
     *     // ... data to create a Research
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Research we want to update
     *   }
     * })
     */
    upsert<T extends ResearchUpsertArgs>(args: SelectSubset<T, ResearchUpsertArgs<ExtArgs>>): Prisma__ResearchClient<$Result.GetResult<Prisma.$ResearchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Research.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchCountArgs} args - Arguments to filter Research to count.
     * @example
     * // Count the number of Research
     * const count = await prisma.research.count({
     *   where: {
     *     // ... the filter for the Research we want to count
     *   }
     * })
    **/
    count<T extends ResearchCountArgs>(
      args?: Subset<T, ResearchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResearchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Research.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResearchAggregateArgs>(args: Subset<T, ResearchAggregateArgs>): Prisma.PrismaPromise<GetResearchAggregateType<T>>

    /**
     * Group by Research.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResearchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResearchGroupByArgs['orderBy'] }
        : { orderBy?: ResearchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResearchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResearchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Research model
   */
  readonly fields: ResearchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Research.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResearchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    actionItems<T extends Research$actionItemsArgs<ExtArgs> = {}>(args?: Subset<T, Research$actionItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leadData<T extends Research$leadDataArgs<ExtArgs> = {}>(args?: Subset<T, Research$leadDataArgs<ExtArgs>>): Prisma__LeadDataClient<$Result.GetResult<Prisma.$LeadDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    goal<T extends Research$goalArgs<ExtArgs> = {}>(args?: Subset<T, Research$goalArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    insights<T extends Research$insightsArgs<ExtArgs> = {}>(args?: Subset<T, Research$insightsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchInsightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sources<T extends Research$sourcesArgs<ExtArgs> = {}>(args?: Subset<T, Research$sourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchSourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Research model
   */
  interface ResearchFieldRefs {
    readonly id: FieldRef<"Research", 'String'>
    readonly userId: FieldRef<"Research", 'String'>
    readonly title: FieldRef<"Research", 'String'>
    readonly scope: FieldRef<"Research", 'ResearchScope'>
    readonly searchMethod: FieldRef<"Research", 'SearchMethod'>
    readonly status: FieldRef<"Research", 'ResearchStatus'>
    readonly originalPrompt: FieldRef<"Research", 'String'>
    readonly refinedPrompt: FieldRef<"Research", 'String'>
    readonly rawData: FieldRef<"Research", 'Json'>
    readonly progress: FieldRef<"Research", 'Int'>
    readonly errorMessage: FieldRef<"Research", 'String'>
    readonly goalId: FieldRef<"Research", 'String'>
    readonly isFavorited: FieldRef<"Research", 'Boolean'>
    readonly createdAt: FieldRef<"Research", 'DateTime'>
    readonly updatedAt: FieldRef<"Research", 'DateTime'>
    readonly completedAt: FieldRef<"Research", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Research findUnique
   */
  export type ResearchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Research
     */
    select?: ResearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Research
     */
    omit?: ResearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchInclude<ExtArgs> | null
    /**
     * Filter, which Research to fetch.
     */
    where: ResearchWhereUniqueInput
  }

  /**
   * Research findUniqueOrThrow
   */
  export type ResearchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Research
     */
    select?: ResearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Research
     */
    omit?: ResearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchInclude<ExtArgs> | null
    /**
     * Filter, which Research to fetch.
     */
    where: ResearchWhereUniqueInput
  }

  /**
   * Research findFirst
   */
  export type ResearchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Research
     */
    select?: ResearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Research
     */
    omit?: ResearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchInclude<ExtArgs> | null
    /**
     * Filter, which Research to fetch.
     */
    where?: ResearchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Research to fetch.
     */
    orderBy?: ResearchOrderByWithRelationInput | ResearchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Research.
     */
    cursor?: ResearchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Research from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Research.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Research.
     */
    distinct?: ResearchScalarFieldEnum | ResearchScalarFieldEnum[]
  }

  /**
   * Research findFirstOrThrow
   */
  export type ResearchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Research
     */
    select?: ResearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Research
     */
    omit?: ResearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchInclude<ExtArgs> | null
    /**
     * Filter, which Research to fetch.
     */
    where?: ResearchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Research to fetch.
     */
    orderBy?: ResearchOrderByWithRelationInput | ResearchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Research.
     */
    cursor?: ResearchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Research from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Research.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Research.
     */
    distinct?: ResearchScalarFieldEnum | ResearchScalarFieldEnum[]
  }

  /**
   * Research findMany
   */
  export type ResearchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Research
     */
    select?: ResearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Research
     */
    omit?: ResearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchInclude<ExtArgs> | null
    /**
     * Filter, which Research to fetch.
     */
    where?: ResearchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Research to fetch.
     */
    orderBy?: ResearchOrderByWithRelationInput | ResearchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Research.
     */
    cursor?: ResearchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Research from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Research.
     */
    skip?: number
    distinct?: ResearchScalarFieldEnum | ResearchScalarFieldEnum[]
  }

  /**
   * Research create
   */
  export type ResearchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Research
     */
    select?: ResearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Research
     */
    omit?: ResearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchInclude<ExtArgs> | null
    /**
     * The data needed to create a Research.
     */
    data: XOR<ResearchCreateInput, ResearchUncheckedCreateInput>
  }

  /**
   * Research createMany
   */
  export type ResearchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Research.
     */
    data: ResearchCreateManyInput | ResearchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Research createManyAndReturn
   */
  export type ResearchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Research
     */
    select?: ResearchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Research
     */
    omit?: ResearchOmit<ExtArgs> | null
    /**
     * The data used to create many Research.
     */
    data: ResearchCreateManyInput | ResearchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Research update
   */
  export type ResearchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Research
     */
    select?: ResearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Research
     */
    omit?: ResearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchInclude<ExtArgs> | null
    /**
     * The data needed to update a Research.
     */
    data: XOR<ResearchUpdateInput, ResearchUncheckedUpdateInput>
    /**
     * Choose, which Research to update.
     */
    where: ResearchWhereUniqueInput
  }

  /**
   * Research updateMany
   */
  export type ResearchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Research.
     */
    data: XOR<ResearchUpdateManyMutationInput, ResearchUncheckedUpdateManyInput>
    /**
     * Filter which Research to update
     */
    where?: ResearchWhereInput
    /**
     * Limit how many Research to update.
     */
    limit?: number
  }

  /**
   * Research updateManyAndReturn
   */
  export type ResearchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Research
     */
    select?: ResearchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Research
     */
    omit?: ResearchOmit<ExtArgs> | null
    /**
     * The data used to update Research.
     */
    data: XOR<ResearchUpdateManyMutationInput, ResearchUncheckedUpdateManyInput>
    /**
     * Filter which Research to update
     */
    where?: ResearchWhereInput
    /**
     * Limit how many Research to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Research upsert
   */
  export type ResearchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Research
     */
    select?: ResearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Research
     */
    omit?: ResearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchInclude<ExtArgs> | null
    /**
     * The filter to search for the Research to update in case it exists.
     */
    where: ResearchWhereUniqueInput
    /**
     * In case the Research found by the `where` argument doesn't exist, create a new Research with this data.
     */
    create: XOR<ResearchCreateInput, ResearchUncheckedCreateInput>
    /**
     * In case the Research was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResearchUpdateInput, ResearchUncheckedUpdateInput>
  }

  /**
   * Research delete
   */
  export type ResearchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Research
     */
    select?: ResearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Research
     */
    omit?: ResearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchInclude<ExtArgs> | null
    /**
     * Filter which Research to delete.
     */
    where: ResearchWhereUniqueInput
  }

  /**
   * Research deleteMany
   */
  export type ResearchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Research to delete
     */
    where?: ResearchWhereInput
    /**
     * Limit how many Research to delete.
     */
    limit?: number
  }

  /**
   * Research.actionItems
   */
  export type Research$actionItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionItem
     */
    omit?: ActionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
    where?: ActionItemWhereInput
    orderBy?: ActionItemOrderByWithRelationInput | ActionItemOrderByWithRelationInput[]
    cursor?: ActionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActionItemScalarFieldEnum | ActionItemScalarFieldEnum[]
  }

  /**
   * Research.leadData
   */
  export type Research$leadDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadData
     */
    select?: LeadDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadData
     */
    omit?: LeadDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadDataInclude<ExtArgs> | null
    where?: LeadDataWhereInput
  }

  /**
   * Research.goal
   */
  export type Research$goalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    where?: GoalWhereInput
  }

  /**
   * Research.insights
   */
  export type Research$insightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchInsight
     */
    select?: ResearchInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchInsight
     */
    omit?: ResearchInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchInsightInclude<ExtArgs> | null
    where?: ResearchInsightWhereInput
    orderBy?: ResearchInsightOrderByWithRelationInput | ResearchInsightOrderByWithRelationInput[]
    cursor?: ResearchInsightWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResearchInsightScalarFieldEnum | ResearchInsightScalarFieldEnum[]
  }

  /**
   * Research.sources
   */
  export type Research$sourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchSource
     */
    select?: ResearchSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchSource
     */
    omit?: ResearchSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchSourceInclude<ExtArgs> | null
    where?: ResearchSourceWhereInput
    orderBy?: ResearchSourceOrderByWithRelationInput | ResearchSourceOrderByWithRelationInput[]
    cursor?: ResearchSourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResearchSourceScalarFieldEnum | ResearchSourceScalarFieldEnum[]
  }

  /**
   * Research without action
   */
  export type ResearchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Research
     */
    select?: ResearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Research
     */
    omit?: ResearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchInclude<ExtArgs> | null
  }


  /**
   * Model ResearchSource
   */

  export type AggregateResearchSource = {
    _count: ResearchSourceCountAggregateOutputType | null
    _avg: ResearchSourceAvgAggregateOutputType | null
    _sum: ResearchSourceSumAggregateOutputType | null
    _min: ResearchSourceMinAggregateOutputType | null
    _max: ResearchSourceMaxAggregateOutputType | null
  }

  export type ResearchSourceAvgAggregateOutputType = {
    credibility: number | null
  }

  export type ResearchSourceSumAggregateOutputType = {
    credibility: number | null
  }

  export type ResearchSourceMinAggregateOutputType = {
    id: string | null
    researchId: string | null
    url: string | null
    title: string | null
    content: string | null
    excerpt: string | null
    credibility: number | null
    scrapedAt: Date | null
  }

  export type ResearchSourceMaxAggregateOutputType = {
    id: string | null
    researchId: string | null
    url: string | null
    title: string | null
    content: string | null
    excerpt: string | null
    credibility: number | null
    scrapedAt: Date | null
  }

  export type ResearchSourceCountAggregateOutputType = {
    id: number
    researchId: number
    url: number
    title: number
    content: number
    excerpt: number
    credibility: number
    citedInSections: number
    scrapedAt: number
    _all: number
  }


  export type ResearchSourceAvgAggregateInputType = {
    credibility?: true
  }

  export type ResearchSourceSumAggregateInputType = {
    credibility?: true
  }

  export type ResearchSourceMinAggregateInputType = {
    id?: true
    researchId?: true
    url?: true
    title?: true
    content?: true
    excerpt?: true
    credibility?: true
    scrapedAt?: true
  }

  export type ResearchSourceMaxAggregateInputType = {
    id?: true
    researchId?: true
    url?: true
    title?: true
    content?: true
    excerpt?: true
    credibility?: true
    scrapedAt?: true
  }

  export type ResearchSourceCountAggregateInputType = {
    id?: true
    researchId?: true
    url?: true
    title?: true
    content?: true
    excerpt?: true
    credibility?: true
    citedInSections?: true
    scrapedAt?: true
    _all?: true
  }

  export type ResearchSourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResearchSource to aggregate.
     */
    where?: ResearchSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchSources to fetch.
     */
    orderBy?: ResearchSourceOrderByWithRelationInput | ResearchSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResearchSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResearchSources
    **/
    _count?: true | ResearchSourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResearchSourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResearchSourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResearchSourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResearchSourceMaxAggregateInputType
  }

  export type GetResearchSourceAggregateType<T extends ResearchSourceAggregateArgs> = {
        [P in keyof T & keyof AggregateResearchSource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResearchSource[P]>
      : GetScalarType<T[P], AggregateResearchSource[P]>
  }




  export type ResearchSourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResearchSourceWhereInput
    orderBy?: ResearchSourceOrderByWithAggregationInput | ResearchSourceOrderByWithAggregationInput[]
    by: ResearchSourceScalarFieldEnum[] | ResearchSourceScalarFieldEnum
    having?: ResearchSourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResearchSourceCountAggregateInputType | true
    _avg?: ResearchSourceAvgAggregateInputType
    _sum?: ResearchSourceSumAggregateInputType
    _min?: ResearchSourceMinAggregateInputType
    _max?: ResearchSourceMaxAggregateInputType
  }

  export type ResearchSourceGroupByOutputType = {
    id: string
    researchId: string
    url: string
    title: string
    content: string
    excerpt: string
    credibility: number
    citedInSections: string[]
    scrapedAt: Date
    _count: ResearchSourceCountAggregateOutputType | null
    _avg: ResearchSourceAvgAggregateOutputType | null
    _sum: ResearchSourceSumAggregateOutputType | null
    _min: ResearchSourceMinAggregateOutputType | null
    _max: ResearchSourceMaxAggregateOutputType | null
  }

  type GetResearchSourceGroupByPayload<T extends ResearchSourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResearchSourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResearchSourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResearchSourceGroupByOutputType[P]>
            : GetScalarType<T[P], ResearchSourceGroupByOutputType[P]>
        }
      >
    >


  export type ResearchSourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    researchId?: boolean
    url?: boolean
    title?: boolean
    content?: boolean
    excerpt?: boolean
    credibility?: boolean
    citedInSections?: boolean
    scrapedAt?: boolean
    research?: boolean | ResearchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["researchSource"]>

  export type ResearchSourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    researchId?: boolean
    url?: boolean
    title?: boolean
    content?: boolean
    excerpt?: boolean
    credibility?: boolean
    citedInSections?: boolean
    scrapedAt?: boolean
    research?: boolean | ResearchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["researchSource"]>

  export type ResearchSourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    researchId?: boolean
    url?: boolean
    title?: boolean
    content?: boolean
    excerpt?: boolean
    credibility?: boolean
    citedInSections?: boolean
    scrapedAt?: boolean
    research?: boolean | ResearchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["researchSource"]>

  export type ResearchSourceSelectScalar = {
    id?: boolean
    researchId?: boolean
    url?: boolean
    title?: boolean
    content?: boolean
    excerpt?: boolean
    credibility?: boolean
    citedInSections?: boolean
    scrapedAt?: boolean
  }

  export type ResearchSourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "researchId" | "url" | "title" | "content" | "excerpt" | "credibility" | "citedInSections" | "scrapedAt", ExtArgs["result"]["researchSource"]>
  export type ResearchSourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    research?: boolean | ResearchDefaultArgs<ExtArgs>
  }
  export type ResearchSourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    research?: boolean | ResearchDefaultArgs<ExtArgs>
  }
  export type ResearchSourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    research?: boolean | ResearchDefaultArgs<ExtArgs>
  }

  export type $ResearchSourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResearchSource"
    objects: {
      research: Prisma.$ResearchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      researchId: string
      url: string
      title: string
      content: string
      excerpt: string
      credibility: number
      citedInSections: string[]
      scrapedAt: Date
    }, ExtArgs["result"]["researchSource"]>
    composites: {}
  }

  type ResearchSourceGetPayload<S extends boolean | null | undefined | ResearchSourceDefaultArgs> = $Result.GetResult<Prisma.$ResearchSourcePayload, S>

  type ResearchSourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResearchSourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResearchSourceCountAggregateInputType | true
    }

  export interface ResearchSourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResearchSource'], meta: { name: 'ResearchSource' } }
    /**
     * Find zero or one ResearchSource that matches the filter.
     * @param {ResearchSourceFindUniqueArgs} args - Arguments to find a ResearchSource
     * @example
     * // Get one ResearchSource
     * const researchSource = await prisma.researchSource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResearchSourceFindUniqueArgs>(args: SelectSubset<T, ResearchSourceFindUniqueArgs<ExtArgs>>): Prisma__ResearchSourceClient<$Result.GetResult<Prisma.$ResearchSourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ResearchSource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResearchSourceFindUniqueOrThrowArgs} args - Arguments to find a ResearchSource
     * @example
     * // Get one ResearchSource
     * const researchSource = await prisma.researchSource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResearchSourceFindUniqueOrThrowArgs>(args: SelectSubset<T, ResearchSourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResearchSourceClient<$Result.GetResult<Prisma.$ResearchSourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResearchSource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchSourceFindFirstArgs} args - Arguments to find a ResearchSource
     * @example
     * // Get one ResearchSource
     * const researchSource = await prisma.researchSource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResearchSourceFindFirstArgs>(args?: SelectSubset<T, ResearchSourceFindFirstArgs<ExtArgs>>): Prisma__ResearchSourceClient<$Result.GetResult<Prisma.$ResearchSourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResearchSource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchSourceFindFirstOrThrowArgs} args - Arguments to find a ResearchSource
     * @example
     * // Get one ResearchSource
     * const researchSource = await prisma.researchSource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResearchSourceFindFirstOrThrowArgs>(args?: SelectSubset<T, ResearchSourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResearchSourceClient<$Result.GetResult<Prisma.$ResearchSourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ResearchSources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchSourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResearchSources
     * const researchSources = await prisma.researchSource.findMany()
     * 
     * // Get first 10 ResearchSources
     * const researchSources = await prisma.researchSource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const researchSourceWithIdOnly = await prisma.researchSource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResearchSourceFindManyArgs>(args?: SelectSubset<T, ResearchSourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchSourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ResearchSource.
     * @param {ResearchSourceCreateArgs} args - Arguments to create a ResearchSource.
     * @example
     * // Create one ResearchSource
     * const ResearchSource = await prisma.researchSource.create({
     *   data: {
     *     // ... data to create a ResearchSource
     *   }
     * })
     * 
     */
    create<T extends ResearchSourceCreateArgs>(args: SelectSubset<T, ResearchSourceCreateArgs<ExtArgs>>): Prisma__ResearchSourceClient<$Result.GetResult<Prisma.$ResearchSourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ResearchSources.
     * @param {ResearchSourceCreateManyArgs} args - Arguments to create many ResearchSources.
     * @example
     * // Create many ResearchSources
     * const researchSource = await prisma.researchSource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResearchSourceCreateManyArgs>(args?: SelectSubset<T, ResearchSourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResearchSources and returns the data saved in the database.
     * @param {ResearchSourceCreateManyAndReturnArgs} args - Arguments to create many ResearchSources.
     * @example
     * // Create many ResearchSources
     * const researchSource = await prisma.researchSource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResearchSources and only return the `id`
     * const researchSourceWithIdOnly = await prisma.researchSource.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResearchSourceCreateManyAndReturnArgs>(args?: SelectSubset<T, ResearchSourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchSourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ResearchSource.
     * @param {ResearchSourceDeleteArgs} args - Arguments to delete one ResearchSource.
     * @example
     * // Delete one ResearchSource
     * const ResearchSource = await prisma.researchSource.delete({
     *   where: {
     *     // ... filter to delete one ResearchSource
     *   }
     * })
     * 
     */
    delete<T extends ResearchSourceDeleteArgs>(args: SelectSubset<T, ResearchSourceDeleteArgs<ExtArgs>>): Prisma__ResearchSourceClient<$Result.GetResult<Prisma.$ResearchSourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ResearchSource.
     * @param {ResearchSourceUpdateArgs} args - Arguments to update one ResearchSource.
     * @example
     * // Update one ResearchSource
     * const researchSource = await prisma.researchSource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResearchSourceUpdateArgs>(args: SelectSubset<T, ResearchSourceUpdateArgs<ExtArgs>>): Prisma__ResearchSourceClient<$Result.GetResult<Prisma.$ResearchSourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ResearchSources.
     * @param {ResearchSourceDeleteManyArgs} args - Arguments to filter ResearchSources to delete.
     * @example
     * // Delete a few ResearchSources
     * const { count } = await prisma.researchSource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResearchSourceDeleteManyArgs>(args?: SelectSubset<T, ResearchSourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResearchSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchSourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResearchSources
     * const researchSource = await prisma.researchSource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResearchSourceUpdateManyArgs>(args: SelectSubset<T, ResearchSourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResearchSources and returns the data updated in the database.
     * @param {ResearchSourceUpdateManyAndReturnArgs} args - Arguments to update many ResearchSources.
     * @example
     * // Update many ResearchSources
     * const researchSource = await prisma.researchSource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ResearchSources and only return the `id`
     * const researchSourceWithIdOnly = await prisma.researchSource.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResearchSourceUpdateManyAndReturnArgs>(args: SelectSubset<T, ResearchSourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchSourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ResearchSource.
     * @param {ResearchSourceUpsertArgs} args - Arguments to update or create a ResearchSource.
     * @example
     * // Update or create a ResearchSource
     * const researchSource = await prisma.researchSource.upsert({
     *   create: {
     *     // ... data to create a ResearchSource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResearchSource we want to update
     *   }
     * })
     */
    upsert<T extends ResearchSourceUpsertArgs>(args: SelectSubset<T, ResearchSourceUpsertArgs<ExtArgs>>): Prisma__ResearchSourceClient<$Result.GetResult<Prisma.$ResearchSourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ResearchSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchSourceCountArgs} args - Arguments to filter ResearchSources to count.
     * @example
     * // Count the number of ResearchSources
     * const count = await prisma.researchSource.count({
     *   where: {
     *     // ... the filter for the ResearchSources we want to count
     *   }
     * })
    **/
    count<T extends ResearchSourceCountArgs>(
      args?: Subset<T, ResearchSourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResearchSourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResearchSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchSourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResearchSourceAggregateArgs>(args: Subset<T, ResearchSourceAggregateArgs>): Prisma.PrismaPromise<GetResearchSourceAggregateType<T>>

    /**
     * Group by ResearchSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchSourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResearchSourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResearchSourceGroupByArgs['orderBy'] }
        : { orderBy?: ResearchSourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResearchSourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResearchSourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResearchSource model
   */
  readonly fields: ResearchSourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResearchSource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResearchSourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    research<T extends ResearchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResearchDefaultArgs<ExtArgs>>): Prisma__ResearchClient<$Result.GetResult<Prisma.$ResearchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResearchSource model
   */
  interface ResearchSourceFieldRefs {
    readonly id: FieldRef<"ResearchSource", 'String'>
    readonly researchId: FieldRef<"ResearchSource", 'String'>
    readonly url: FieldRef<"ResearchSource", 'String'>
    readonly title: FieldRef<"ResearchSource", 'String'>
    readonly content: FieldRef<"ResearchSource", 'String'>
    readonly excerpt: FieldRef<"ResearchSource", 'String'>
    readonly credibility: FieldRef<"ResearchSource", 'Float'>
    readonly citedInSections: FieldRef<"ResearchSource", 'String[]'>
    readonly scrapedAt: FieldRef<"ResearchSource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ResearchSource findUnique
   */
  export type ResearchSourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchSource
     */
    select?: ResearchSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchSource
     */
    omit?: ResearchSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchSourceInclude<ExtArgs> | null
    /**
     * Filter, which ResearchSource to fetch.
     */
    where: ResearchSourceWhereUniqueInput
  }

  /**
   * ResearchSource findUniqueOrThrow
   */
  export type ResearchSourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchSource
     */
    select?: ResearchSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchSource
     */
    omit?: ResearchSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchSourceInclude<ExtArgs> | null
    /**
     * Filter, which ResearchSource to fetch.
     */
    where: ResearchSourceWhereUniqueInput
  }

  /**
   * ResearchSource findFirst
   */
  export type ResearchSourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchSource
     */
    select?: ResearchSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchSource
     */
    omit?: ResearchSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchSourceInclude<ExtArgs> | null
    /**
     * Filter, which ResearchSource to fetch.
     */
    where?: ResearchSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchSources to fetch.
     */
    orderBy?: ResearchSourceOrderByWithRelationInput | ResearchSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResearchSources.
     */
    cursor?: ResearchSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResearchSources.
     */
    distinct?: ResearchSourceScalarFieldEnum | ResearchSourceScalarFieldEnum[]
  }

  /**
   * ResearchSource findFirstOrThrow
   */
  export type ResearchSourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchSource
     */
    select?: ResearchSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchSource
     */
    omit?: ResearchSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchSourceInclude<ExtArgs> | null
    /**
     * Filter, which ResearchSource to fetch.
     */
    where?: ResearchSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchSources to fetch.
     */
    orderBy?: ResearchSourceOrderByWithRelationInput | ResearchSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResearchSources.
     */
    cursor?: ResearchSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResearchSources.
     */
    distinct?: ResearchSourceScalarFieldEnum | ResearchSourceScalarFieldEnum[]
  }

  /**
   * ResearchSource findMany
   */
  export type ResearchSourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchSource
     */
    select?: ResearchSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchSource
     */
    omit?: ResearchSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchSourceInclude<ExtArgs> | null
    /**
     * Filter, which ResearchSources to fetch.
     */
    where?: ResearchSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchSources to fetch.
     */
    orderBy?: ResearchSourceOrderByWithRelationInput | ResearchSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResearchSources.
     */
    cursor?: ResearchSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchSources.
     */
    skip?: number
    distinct?: ResearchSourceScalarFieldEnum | ResearchSourceScalarFieldEnum[]
  }

  /**
   * ResearchSource create
   */
  export type ResearchSourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchSource
     */
    select?: ResearchSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchSource
     */
    omit?: ResearchSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchSourceInclude<ExtArgs> | null
    /**
     * The data needed to create a ResearchSource.
     */
    data: XOR<ResearchSourceCreateInput, ResearchSourceUncheckedCreateInput>
  }

  /**
   * ResearchSource createMany
   */
  export type ResearchSourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResearchSources.
     */
    data: ResearchSourceCreateManyInput | ResearchSourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResearchSource createManyAndReturn
   */
  export type ResearchSourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchSource
     */
    select?: ResearchSourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchSource
     */
    omit?: ResearchSourceOmit<ExtArgs> | null
    /**
     * The data used to create many ResearchSources.
     */
    data: ResearchSourceCreateManyInput | ResearchSourceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchSourceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResearchSource update
   */
  export type ResearchSourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchSource
     */
    select?: ResearchSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchSource
     */
    omit?: ResearchSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchSourceInclude<ExtArgs> | null
    /**
     * The data needed to update a ResearchSource.
     */
    data: XOR<ResearchSourceUpdateInput, ResearchSourceUncheckedUpdateInput>
    /**
     * Choose, which ResearchSource to update.
     */
    where: ResearchSourceWhereUniqueInput
  }

  /**
   * ResearchSource updateMany
   */
  export type ResearchSourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResearchSources.
     */
    data: XOR<ResearchSourceUpdateManyMutationInput, ResearchSourceUncheckedUpdateManyInput>
    /**
     * Filter which ResearchSources to update
     */
    where?: ResearchSourceWhereInput
    /**
     * Limit how many ResearchSources to update.
     */
    limit?: number
  }

  /**
   * ResearchSource updateManyAndReturn
   */
  export type ResearchSourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchSource
     */
    select?: ResearchSourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchSource
     */
    omit?: ResearchSourceOmit<ExtArgs> | null
    /**
     * The data used to update ResearchSources.
     */
    data: XOR<ResearchSourceUpdateManyMutationInput, ResearchSourceUncheckedUpdateManyInput>
    /**
     * Filter which ResearchSources to update
     */
    where?: ResearchSourceWhereInput
    /**
     * Limit how many ResearchSources to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchSourceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResearchSource upsert
   */
  export type ResearchSourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchSource
     */
    select?: ResearchSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchSource
     */
    omit?: ResearchSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchSourceInclude<ExtArgs> | null
    /**
     * The filter to search for the ResearchSource to update in case it exists.
     */
    where: ResearchSourceWhereUniqueInput
    /**
     * In case the ResearchSource found by the `where` argument doesn't exist, create a new ResearchSource with this data.
     */
    create: XOR<ResearchSourceCreateInput, ResearchSourceUncheckedCreateInput>
    /**
     * In case the ResearchSource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResearchSourceUpdateInput, ResearchSourceUncheckedUpdateInput>
  }

  /**
   * ResearchSource delete
   */
  export type ResearchSourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchSource
     */
    select?: ResearchSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchSource
     */
    omit?: ResearchSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchSourceInclude<ExtArgs> | null
    /**
     * Filter which ResearchSource to delete.
     */
    where: ResearchSourceWhereUniqueInput
  }

  /**
   * ResearchSource deleteMany
   */
  export type ResearchSourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResearchSources to delete
     */
    where?: ResearchSourceWhereInput
    /**
     * Limit how many ResearchSources to delete.
     */
    limit?: number
  }

  /**
   * ResearchSource without action
   */
  export type ResearchSourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchSource
     */
    select?: ResearchSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchSource
     */
    omit?: ResearchSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchSourceInclude<ExtArgs> | null
  }


  /**
   * Model ResearchInsight
   */

  export type AggregateResearchInsight = {
    _count: ResearchInsightCountAggregateOutputType | null
    _avg: ResearchInsightAvgAggregateOutputType | null
    _sum: ResearchInsightSumAggregateOutputType | null
    _min: ResearchInsightMinAggregateOutputType | null
    _max: ResearchInsightMaxAggregateOutputType | null
  }

  export type ResearchInsightAvgAggregateOutputType = {
    confidence: number | null
    order: number | null
  }

  export type ResearchInsightSumAggregateOutputType = {
    confidence: number | null
    order: number | null
  }

  export type ResearchInsightMinAggregateOutputType = {
    id: string | null
    researchId: string | null
    title: string | null
    content: string | null
    category: string | null
    confidence: number | null
    order: number | null
    createdAt: Date | null
  }

  export type ResearchInsightMaxAggregateOutputType = {
    id: string | null
    researchId: string | null
    title: string | null
    content: string | null
    category: string | null
    confidence: number | null
    order: number | null
    createdAt: Date | null
  }

  export type ResearchInsightCountAggregateOutputType = {
    id: number
    researchId: number
    title: number
    content: number
    category: number
    visualData: number
    confidence: number
    order: number
    createdAt: number
    _all: number
  }


  export type ResearchInsightAvgAggregateInputType = {
    confidence?: true
    order?: true
  }

  export type ResearchInsightSumAggregateInputType = {
    confidence?: true
    order?: true
  }

  export type ResearchInsightMinAggregateInputType = {
    id?: true
    researchId?: true
    title?: true
    content?: true
    category?: true
    confidence?: true
    order?: true
    createdAt?: true
  }

  export type ResearchInsightMaxAggregateInputType = {
    id?: true
    researchId?: true
    title?: true
    content?: true
    category?: true
    confidence?: true
    order?: true
    createdAt?: true
  }

  export type ResearchInsightCountAggregateInputType = {
    id?: true
    researchId?: true
    title?: true
    content?: true
    category?: true
    visualData?: true
    confidence?: true
    order?: true
    createdAt?: true
    _all?: true
  }

  export type ResearchInsightAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResearchInsight to aggregate.
     */
    where?: ResearchInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchInsights to fetch.
     */
    orderBy?: ResearchInsightOrderByWithRelationInput | ResearchInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResearchInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResearchInsights
    **/
    _count?: true | ResearchInsightCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResearchInsightAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResearchInsightSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResearchInsightMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResearchInsightMaxAggregateInputType
  }

  export type GetResearchInsightAggregateType<T extends ResearchInsightAggregateArgs> = {
        [P in keyof T & keyof AggregateResearchInsight]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResearchInsight[P]>
      : GetScalarType<T[P], AggregateResearchInsight[P]>
  }




  export type ResearchInsightGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResearchInsightWhereInput
    orderBy?: ResearchInsightOrderByWithAggregationInput | ResearchInsightOrderByWithAggregationInput[]
    by: ResearchInsightScalarFieldEnum[] | ResearchInsightScalarFieldEnum
    having?: ResearchInsightScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResearchInsightCountAggregateInputType | true
    _avg?: ResearchInsightAvgAggregateInputType
    _sum?: ResearchInsightSumAggregateInputType
    _min?: ResearchInsightMinAggregateInputType
    _max?: ResearchInsightMaxAggregateInputType
  }

  export type ResearchInsightGroupByOutputType = {
    id: string
    researchId: string
    title: string
    content: string
    category: string
    visualData: JsonValue | null
    confidence: number
    order: number
    createdAt: Date
    _count: ResearchInsightCountAggregateOutputType | null
    _avg: ResearchInsightAvgAggregateOutputType | null
    _sum: ResearchInsightSumAggregateOutputType | null
    _min: ResearchInsightMinAggregateOutputType | null
    _max: ResearchInsightMaxAggregateOutputType | null
  }

  type GetResearchInsightGroupByPayload<T extends ResearchInsightGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResearchInsightGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResearchInsightGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResearchInsightGroupByOutputType[P]>
            : GetScalarType<T[P], ResearchInsightGroupByOutputType[P]>
        }
      >
    >


  export type ResearchInsightSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    researchId?: boolean
    title?: boolean
    content?: boolean
    category?: boolean
    visualData?: boolean
    confidence?: boolean
    order?: boolean
    createdAt?: boolean
    research?: boolean | ResearchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["researchInsight"]>

  export type ResearchInsightSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    researchId?: boolean
    title?: boolean
    content?: boolean
    category?: boolean
    visualData?: boolean
    confidence?: boolean
    order?: boolean
    createdAt?: boolean
    research?: boolean | ResearchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["researchInsight"]>

  export type ResearchInsightSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    researchId?: boolean
    title?: boolean
    content?: boolean
    category?: boolean
    visualData?: boolean
    confidence?: boolean
    order?: boolean
    createdAt?: boolean
    research?: boolean | ResearchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["researchInsight"]>

  export type ResearchInsightSelectScalar = {
    id?: boolean
    researchId?: boolean
    title?: boolean
    content?: boolean
    category?: boolean
    visualData?: boolean
    confidence?: boolean
    order?: boolean
    createdAt?: boolean
  }

  export type ResearchInsightOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "researchId" | "title" | "content" | "category" | "visualData" | "confidence" | "order" | "createdAt", ExtArgs["result"]["researchInsight"]>
  export type ResearchInsightInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    research?: boolean | ResearchDefaultArgs<ExtArgs>
  }
  export type ResearchInsightIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    research?: boolean | ResearchDefaultArgs<ExtArgs>
  }
  export type ResearchInsightIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    research?: boolean | ResearchDefaultArgs<ExtArgs>
  }

  export type $ResearchInsightPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResearchInsight"
    objects: {
      research: Prisma.$ResearchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      researchId: string
      title: string
      content: string
      category: string
      visualData: Prisma.JsonValue | null
      confidence: number
      order: number
      createdAt: Date
    }, ExtArgs["result"]["researchInsight"]>
    composites: {}
  }

  type ResearchInsightGetPayload<S extends boolean | null | undefined | ResearchInsightDefaultArgs> = $Result.GetResult<Prisma.$ResearchInsightPayload, S>

  type ResearchInsightCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResearchInsightFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResearchInsightCountAggregateInputType | true
    }

  export interface ResearchInsightDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResearchInsight'], meta: { name: 'ResearchInsight' } }
    /**
     * Find zero or one ResearchInsight that matches the filter.
     * @param {ResearchInsightFindUniqueArgs} args - Arguments to find a ResearchInsight
     * @example
     * // Get one ResearchInsight
     * const researchInsight = await prisma.researchInsight.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResearchInsightFindUniqueArgs>(args: SelectSubset<T, ResearchInsightFindUniqueArgs<ExtArgs>>): Prisma__ResearchInsightClient<$Result.GetResult<Prisma.$ResearchInsightPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ResearchInsight that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResearchInsightFindUniqueOrThrowArgs} args - Arguments to find a ResearchInsight
     * @example
     * // Get one ResearchInsight
     * const researchInsight = await prisma.researchInsight.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResearchInsightFindUniqueOrThrowArgs>(args: SelectSubset<T, ResearchInsightFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResearchInsightClient<$Result.GetResult<Prisma.$ResearchInsightPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResearchInsight that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchInsightFindFirstArgs} args - Arguments to find a ResearchInsight
     * @example
     * // Get one ResearchInsight
     * const researchInsight = await prisma.researchInsight.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResearchInsightFindFirstArgs>(args?: SelectSubset<T, ResearchInsightFindFirstArgs<ExtArgs>>): Prisma__ResearchInsightClient<$Result.GetResult<Prisma.$ResearchInsightPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResearchInsight that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchInsightFindFirstOrThrowArgs} args - Arguments to find a ResearchInsight
     * @example
     * // Get one ResearchInsight
     * const researchInsight = await prisma.researchInsight.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResearchInsightFindFirstOrThrowArgs>(args?: SelectSubset<T, ResearchInsightFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResearchInsightClient<$Result.GetResult<Prisma.$ResearchInsightPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ResearchInsights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchInsightFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResearchInsights
     * const researchInsights = await prisma.researchInsight.findMany()
     * 
     * // Get first 10 ResearchInsights
     * const researchInsights = await prisma.researchInsight.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const researchInsightWithIdOnly = await prisma.researchInsight.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResearchInsightFindManyArgs>(args?: SelectSubset<T, ResearchInsightFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchInsightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ResearchInsight.
     * @param {ResearchInsightCreateArgs} args - Arguments to create a ResearchInsight.
     * @example
     * // Create one ResearchInsight
     * const ResearchInsight = await prisma.researchInsight.create({
     *   data: {
     *     // ... data to create a ResearchInsight
     *   }
     * })
     * 
     */
    create<T extends ResearchInsightCreateArgs>(args: SelectSubset<T, ResearchInsightCreateArgs<ExtArgs>>): Prisma__ResearchInsightClient<$Result.GetResult<Prisma.$ResearchInsightPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ResearchInsights.
     * @param {ResearchInsightCreateManyArgs} args - Arguments to create many ResearchInsights.
     * @example
     * // Create many ResearchInsights
     * const researchInsight = await prisma.researchInsight.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResearchInsightCreateManyArgs>(args?: SelectSubset<T, ResearchInsightCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResearchInsights and returns the data saved in the database.
     * @param {ResearchInsightCreateManyAndReturnArgs} args - Arguments to create many ResearchInsights.
     * @example
     * // Create many ResearchInsights
     * const researchInsight = await prisma.researchInsight.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResearchInsights and only return the `id`
     * const researchInsightWithIdOnly = await prisma.researchInsight.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResearchInsightCreateManyAndReturnArgs>(args?: SelectSubset<T, ResearchInsightCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchInsightPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ResearchInsight.
     * @param {ResearchInsightDeleteArgs} args - Arguments to delete one ResearchInsight.
     * @example
     * // Delete one ResearchInsight
     * const ResearchInsight = await prisma.researchInsight.delete({
     *   where: {
     *     // ... filter to delete one ResearchInsight
     *   }
     * })
     * 
     */
    delete<T extends ResearchInsightDeleteArgs>(args: SelectSubset<T, ResearchInsightDeleteArgs<ExtArgs>>): Prisma__ResearchInsightClient<$Result.GetResult<Prisma.$ResearchInsightPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ResearchInsight.
     * @param {ResearchInsightUpdateArgs} args - Arguments to update one ResearchInsight.
     * @example
     * // Update one ResearchInsight
     * const researchInsight = await prisma.researchInsight.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResearchInsightUpdateArgs>(args: SelectSubset<T, ResearchInsightUpdateArgs<ExtArgs>>): Prisma__ResearchInsightClient<$Result.GetResult<Prisma.$ResearchInsightPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ResearchInsights.
     * @param {ResearchInsightDeleteManyArgs} args - Arguments to filter ResearchInsights to delete.
     * @example
     * // Delete a few ResearchInsights
     * const { count } = await prisma.researchInsight.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResearchInsightDeleteManyArgs>(args?: SelectSubset<T, ResearchInsightDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResearchInsights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchInsightUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResearchInsights
     * const researchInsight = await prisma.researchInsight.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResearchInsightUpdateManyArgs>(args: SelectSubset<T, ResearchInsightUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResearchInsights and returns the data updated in the database.
     * @param {ResearchInsightUpdateManyAndReturnArgs} args - Arguments to update many ResearchInsights.
     * @example
     * // Update many ResearchInsights
     * const researchInsight = await prisma.researchInsight.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ResearchInsights and only return the `id`
     * const researchInsightWithIdOnly = await prisma.researchInsight.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResearchInsightUpdateManyAndReturnArgs>(args: SelectSubset<T, ResearchInsightUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchInsightPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ResearchInsight.
     * @param {ResearchInsightUpsertArgs} args - Arguments to update or create a ResearchInsight.
     * @example
     * // Update or create a ResearchInsight
     * const researchInsight = await prisma.researchInsight.upsert({
     *   create: {
     *     // ... data to create a ResearchInsight
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResearchInsight we want to update
     *   }
     * })
     */
    upsert<T extends ResearchInsightUpsertArgs>(args: SelectSubset<T, ResearchInsightUpsertArgs<ExtArgs>>): Prisma__ResearchInsightClient<$Result.GetResult<Prisma.$ResearchInsightPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ResearchInsights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchInsightCountArgs} args - Arguments to filter ResearchInsights to count.
     * @example
     * // Count the number of ResearchInsights
     * const count = await prisma.researchInsight.count({
     *   where: {
     *     // ... the filter for the ResearchInsights we want to count
     *   }
     * })
    **/
    count<T extends ResearchInsightCountArgs>(
      args?: Subset<T, ResearchInsightCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResearchInsightCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResearchInsight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchInsightAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResearchInsightAggregateArgs>(args: Subset<T, ResearchInsightAggregateArgs>): Prisma.PrismaPromise<GetResearchInsightAggregateType<T>>

    /**
     * Group by ResearchInsight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchInsightGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResearchInsightGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResearchInsightGroupByArgs['orderBy'] }
        : { orderBy?: ResearchInsightGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResearchInsightGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResearchInsightGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResearchInsight model
   */
  readonly fields: ResearchInsightFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResearchInsight.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResearchInsightClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    research<T extends ResearchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResearchDefaultArgs<ExtArgs>>): Prisma__ResearchClient<$Result.GetResult<Prisma.$ResearchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResearchInsight model
   */
  interface ResearchInsightFieldRefs {
    readonly id: FieldRef<"ResearchInsight", 'String'>
    readonly researchId: FieldRef<"ResearchInsight", 'String'>
    readonly title: FieldRef<"ResearchInsight", 'String'>
    readonly content: FieldRef<"ResearchInsight", 'String'>
    readonly category: FieldRef<"ResearchInsight", 'String'>
    readonly visualData: FieldRef<"ResearchInsight", 'Json'>
    readonly confidence: FieldRef<"ResearchInsight", 'Float'>
    readonly order: FieldRef<"ResearchInsight", 'Int'>
    readonly createdAt: FieldRef<"ResearchInsight", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ResearchInsight findUnique
   */
  export type ResearchInsightFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchInsight
     */
    select?: ResearchInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchInsight
     */
    omit?: ResearchInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchInsightInclude<ExtArgs> | null
    /**
     * Filter, which ResearchInsight to fetch.
     */
    where: ResearchInsightWhereUniqueInput
  }

  /**
   * ResearchInsight findUniqueOrThrow
   */
  export type ResearchInsightFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchInsight
     */
    select?: ResearchInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchInsight
     */
    omit?: ResearchInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchInsightInclude<ExtArgs> | null
    /**
     * Filter, which ResearchInsight to fetch.
     */
    where: ResearchInsightWhereUniqueInput
  }

  /**
   * ResearchInsight findFirst
   */
  export type ResearchInsightFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchInsight
     */
    select?: ResearchInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchInsight
     */
    omit?: ResearchInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchInsightInclude<ExtArgs> | null
    /**
     * Filter, which ResearchInsight to fetch.
     */
    where?: ResearchInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchInsights to fetch.
     */
    orderBy?: ResearchInsightOrderByWithRelationInput | ResearchInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResearchInsights.
     */
    cursor?: ResearchInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResearchInsights.
     */
    distinct?: ResearchInsightScalarFieldEnum | ResearchInsightScalarFieldEnum[]
  }

  /**
   * ResearchInsight findFirstOrThrow
   */
  export type ResearchInsightFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchInsight
     */
    select?: ResearchInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchInsight
     */
    omit?: ResearchInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchInsightInclude<ExtArgs> | null
    /**
     * Filter, which ResearchInsight to fetch.
     */
    where?: ResearchInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchInsights to fetch.
     */
    orderBy?: ResearchInsightOrderByWithRelationInput | ResearchInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResearchInsights.
     */
    cursor?: ResearchInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResearchInsights.
     */
    distinct?: ResearchInsightScalarFieldEnum | ResearchInsightScalarFieldEnum[]
  }

  /**
   * ResearchInsight findMany
   */
  export type ResearchInsightFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchInsight
     */
    select?: ResearchInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchInsight
     */
    omit?: ResearchInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchInsightInclude<ExtArgs> | null
    /**
     * Filter, which ResearchInsights to fetch.
     */
    where?: ResearchInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchInsights to fetch.
     */
    orderBy?: ResearchInsightOrderByWithRelationInput | ResearchInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResearchInsights.
     */
    cursor?: ResearchInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchInsights.
     */
    skip?: number
    distinct?: ResearchInsightScalarFieldEnum | ResearchInsightScalarFieldEnum[]
  }

  /**
   * ResearchInsight create
   */
  export type ResearchInsightCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchInsight
     */
    select?: ResearchInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchInsight
     */
    omit?: ResearchInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchInsightInclude<ExtArgs> | null
    /**
     * The data needed to create a ResearchInsight.
     */
    data: XOR<ResearchInsightCreateInput, ResearchInsightUncheckedCreateInput>
  }

  /**
   * ResearchInsight createMany
   */
  export type ResearchInsightCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResearchInsights.
     */
    data: ResearchInsightCreateManyInput | ResearchInsightCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResearchInsight createManyAndReturn
   */
  export type ResearchInsightCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchInsight
     */
    select?: ResearchInsightSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchInsight
     */
    omit?: ResearchInsightOmit<ExtArgs> | null
    /**
     * The data used to create many ResearchInsights.
     */
    data: ResearchInsightCreateManyInput | ResearchInsightCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchInsightIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResearchInsight update
   */
  export type ResearchInsightUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchInsight
     */
    select?: ResearchInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchInsight
     */
    omit?: ResearchInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchInsightInclude<ExtArgs> | null
    /**
     * The data needed to update a ResearchInsight.
     */
    data: XOR<ResearchInsightUpdateInput, ResearchInsightUncheckedUpdateInput>
    /**
     * Choose, which ResearchInsight to update.
     */
    where: ResearchInsightWhereUniqueInput
  }

  /**
   * ResearchInsight updateMany
   */
  export type ResearchInsightUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResearchInsights.
     */
    data: XOR<ResearchInsightUpdateManyMutationInput, ResearchInsightUncheckedUpdateManyInput>
    /**
     * Filter which ResearchInsights to update
     */
    where?: ResearchInsightWhereInput
    /**
     * Limit how many ResearchInsights to update.
     */
    limit?: number
  }

  /**
   * ResearchInsight updateManyAndReturn
   */
  export type ResearchInsightUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchInsight
     */
    select?: ResearchInsightSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchInsight
     */
    omit?: ResearchInsightOmit<ExtArgs> | null
    /**
     * The data used to update ResearchInsights.
     */
    data: XOR<ResearchInsightUpdateManyMutationInput, ResearchInsightUncheckedUpdateManyInput>
    /**
     * Filter which ResearchInsights to update
     */
    where?: ResearchInsightWhereInput
    /**
     * Limit how many ResearchInsights to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchInsightIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResearchInsight upsert
   */
  export type ResearchInsightUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchInsight
     */
    select?: ResearchInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchInsight
     */
    omit?: ResearchInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchInsightInclude<ExtArgs> | null
    /**
     * The filter to search for the ResearchInsight to update in case it exists.
     */
    where: ResearchInsightWhereUniqueInput
    /**
     * In case the ResearchInsight found by the `where` argument doesn't exist, create a new ResearchInsight with this data.
     */
    create: XOR<ResearchInsightCreateInput, ResearchInsightUncheckedCreateInput>
    /**
     * In case the ResearchInsight was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResearchInsightUpdateInput, ResearchInsightUncheckedUpdateInput>
  }

  /**
   * ResearchInsight delete
   */
  export type ResearchInsightDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchInsight
     */
    select?: ResearchInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchInsight
     */
    omit?: ResearchInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchInsightInclude<ExtArgs> | null
    /**
     * Filter which ResearchInsight to delete.
     */
    where: ResearchInsightWhereUniqueInput
  }

  /**
   * ResearchInsight deleteMany
   */
  export type ResearchInsightDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResearchInsights to delete
     */
    where?: ResearchInsightWhereInput
    /**
     * Limit how many ResearchInsights to delete.
     */
    limit?: number
  }

  /**
   * ResearchInsight without action
   */
  export type ResearchInsightDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchInsight
     */
    select?: ResearchInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchInsight
     */
    omit?: ResearchInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchInsightInclude<ExtArgs> | null
  }


  /**
   * Model ActionItem
   */

  export type AggregateActionItem = {
    _count: ActionItemCountAggregateOutputType | null
    _avg: ActionItemAvgAggregateOutputType | null
    _sum: ActionItemSumAggregateOutputType | null
    _min: ActionItemMinAggregateOutputType | null
    _max: ActionItemMaxAggregateOutputType | null
  }

  export type ActionItemAvgAggregateOutputType = {
    effort: number | null
  }

  export type ActionItemSumAggregateOutputType = {
    effort: number | null
  }

  export type ActionItemMinAggregateOutputType = {
    id: string | null
    researchId: string | null
    description: string | null
    priority: $Enums.ActionPriority | null
    effort: number | null
    convertedToTaskId: string | null
    convertedAt: Date | null
    createdAt: Date | null
  }

  export type ActionItemMaxAggregateOutputType = {
    id: string | null
    researchId: string | null
    description: string | null
    priority: $Enums.ActionPriority | null
    effort: number | null
    convertedToTaskId: string | null
    convertedAt: Date | null
    createdAt: Date | null
  }

  export type ActionItemCountAggregateOutputType = {
    id: number
    researchId: number
    description: number
    priority: number
    effort: number
    convertedToTaskId: number
    convertedAt: number
    createdAt: number
    _all: number
  }


  export type ActionItemAvgAggregateInputType = {
    effort?: true
  }

  export type ActionItemSumAggregateInputType = {
    effort?: true
  }

  export type ActionItemMinAggregateInputType = {
    id?: true
    researchId?: true
    description?: true
    priority?: true
    effort?: true
    convertedToTaskId?: true
    convertedAt?: true
    createdAt?: true
  }

  export type ActionItemMaxAggregateInputType = {
    id?: true
    researchId?: true
    description?: true
    priority?: true
    effort?: true
    convertedToTaskId?: true
    convertedAt?: true
    createdAt?: true
  }

  export type ActionItemCountAggregateInputType = {
    id?: true
    researchId?: true
    description?: true
    priority?: true
    effort?: true
    convertedToTaskId?: true
    convertedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ActionItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActionItem to aggregate.
     */
    where?: ActionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionItems to fetch.
     */
    orderBy?: ActionItemOrderByWithRelationInput | ActionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActionItems
    **/
    _count?: true | ActionItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActionItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActionItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActionItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActionItemMaxAggregateInputType
  }

  export type GetActionItemAggregateType<T extends ActionItemAggregateArgs> = {
        [P in keyof T & keyof AggregateActionItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActionItem[P]>
      : GetScalarType<T[P], AggregateActionItem[P]>
  }




  export type ActionItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionItemWhereInput
    orderBy?: ActionItemOrderByWithAggregationInput | ActionItemOrderByWithAggregationInput[]
    by: ActionItemScalarFieldEnum[] | ActionItemScalarFieldEnum
    having?: ActionItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActionItemCountAggregateInputType | true
    _avg?: ActionItemAvgAggregateInputType
    _sum?: ActionItemSumAggregateInputType
    _min?: ActionItemMinAggregateInputType
    _max?: ActionItemMaxAggregateInputType
  }

  export type ActionItemGroupByOutputType = {
    id: string
    researchId: string
    description: string
    priority: $Enums.ActionPriority
    effort: number
    convertedToTaskId: string | null
    convertedAt: Date | null
    createdAt: Date
    _count: ActionItemCountAggregateOutputType | null
    _avg: ActionItemAvgAggregateOutputType | null
    _sum: ActionItemSumAggregateOutputType | null
    _min: ActionItemMinAggregateOutputType | null
    _max: ActionItemMaxAggregateOutputType | null
  }

  type GetActionItemGroupByPayload<T extends ActionItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActionItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActionItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActionItemGroupByOutputType[P]>
            : GetScalarType<T[P], ActionItemGroupByOutputType[P]>
        }
      >
    >


  export type ActionItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    researchId?: boolean
    description?: boolean
    priority?: boolean
    effort?: boolean
    convertedToTaskId?: boolean
    convertedAt?: boolean
    createdAt?: boolean
    convertedToTask?: boolean | ActionItem$convertedToTaskArgs<ExtArgs>
    research?: boolean | ResearchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actionItem"]>

  export type ActionItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    researchId?: boolean
    description?: boolean
    priority?: boolean
    effort?: boolean
    convertedToTaskId?: boolean
    convertedAt?: boolean
    createdAt?: boolean
    convertedToTask?: boolean | ActionItem$convertedToTaskArgs<ExtArgs>
    research?: boolean | ResearchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actionItem"]>

  export type ActionItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    researchId?: boolean
    description?: boolean
    priority?: boolean
    effort?: boolean
    convertedToTaskId?: boolean
    convertedAt?: boolean
    createdAt?: boolean
    convertedToTask?: boolean | ActionItem$convertedToTaskArgs<ExtArgs>
    research?: boolean | ResearchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actionItem"]>

  export type ActionItemSelectScalar = {
    id?: boolean
    researchId?: boolean
    description?: boolean
    priority?: boolean
    effort?: boolean
    convertedToTaskId?: boolean
    convertedAt?: boolean
    createdAt?: boolean
  }

  export type ActionItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "researchId" | "description" | "priority" | "effort" | "convertedToTaskId" | "convertedAt" | "createdAt", ExtArgs["result"]["actionItem"]>
  export type ActionItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    convertedToTask?: boolean | ActionItem$convertedToTaskArgs<ExtArgs>
    research?: boolean | ResearchDefaultArgs<ExtArgs>
  }
  export type ActionItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    convertedToTask?: boolean | ActionItem$convertedToTaskArgs<ExtArgs>
    research?: boolean | ResearchDefaultArgs<ExtArgs>
  }
  export type ActionItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    convertedToTask?: boolean | ActionItem$convertedToTaskArgs<ExtArgs>
    research?: boolean | ResearchDefaultArgs<ExtArgs>
  }

  export type $ActionItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActionItem"
    objects: {
      convertedToTask: Prisma.$TaskPayload<ExtArgs> | null
      research: Prisma.$ResearchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      researchId: string
      description: string
      priority: $Enums.ActionPriority
      effort: number
      convertedToTaskId: string | null
      convertedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["actionItem"]>
    composites: {}
  }

  type ActionItemGetPayload<S extends boolean | null | undefined | ActionItemDefaultArgs> = $Result.GetResult<Prisma.$ActionItemPayload, S>

  type ActionItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActionItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActionItemCountAggregateInputType | true
    }

  export interface ActionItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActionItem'], meta: { name: 'ActionItem' } }
    /**
     * Find zero or one ActionItem that matches the filter.
     * @param {ActionItemFindUniqueArgs} args - Arguments to find a ActionItem
     * @example
     * // Get one ActionItem
     * const actionItem = await prisma.actionItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActionItemFindUniqueArgs>(args: SelectSubset<T, ActionItemFindUniqueArgs<ExtArgs>>): Prisma__ActionItemClient<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActionItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActionItemFindUniqueOrThrowArgs} args - Arguments to find a ActionItem
     * @example
     * // Get one ActionItem
     * const actionItem = await prisma.actionItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActionItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ActionItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActionItemClient<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActionItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionItemFindFirstArgs} args - Arguments to find a ActionItem
     * @example
     * // Get one ActionItem
     * const actionItem = await prisma.actionItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActionItemFindFirstArgs>(args?: SelectSubset<T, ActionItemFindFirstArgs<ExtArgs>>): Prisma__ActionItemClient<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActionItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionItemFindFirstOrThrowArgs} args - Arguments to find a ActionItem
     * @example
     * // Get one ActionItem
     * const actionItem = await prisma.actionItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActionItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ActionItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActionItemClient<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActionItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActionItems
     * const actionItems = await prisma.actionItem.findMany()
     * 
     * // Get first 10 ActionItems
     * const actionItems = await prisma.actionItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actionItemWithIdOnly = await prisma.actionItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActionItemFindManyArgs>(args?: SelectSubset<T, ActionItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActionItem.
     * @param {ActionItemCreateArgs} args - Arguments to create a ActionItem.
     * @example
     * // Create one ActionItem
     * const ActionItem = await prisma.actionItem.create({
     *   data: {
     *     // ... data to create a ActionItem
     *   }
     * })
     * 
     */
    create<T extends ActionItemCreateArgs>(args: SelectSubset<T, ActionItemCreateArgs<ExtArgs>>): Prisma__ActionItemClient<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActionItems.
     * @param {ActionItemCreateManyArgs} args - Arguments to create many ActionItems.
     * @example
     * // Create many ActionItems
     * const actionItem = await prisma.actionItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActionItemCreateManyArgs>(args?: SelectSubset<T, ActionItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActionItems and returns the data saved in the database.
     * @param {ActionItemCreateManyAndReturnArgs} args - Arguments to create many ActionItems.
     * @example
     * // Create many ActionItems
     * const actionItem = await prisma.actionItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActionItems and only return the `id`
     * const actionItemWithIdOnly = await prisma.actionItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActionItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ActionItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ActionItem.
     * @param {ActionItemDeleteArgs} args - Arguments to delete one ActionItem.
     * @example
     * // Delete one ActionItem
     * const ActionItem = await prisma.actionItem.delete({
     *   where: {
     *     // ... filter to delete one ActionItem
     *   }
     * })
     * 
     */
    delete<T extends ActionItemDeleteArgs>(args: SelectSubset<T, ActionItemDeleteArgs<ExtArgs>>): Prisma__ActionItemClient<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActionItem.
     * @param {ActionItemUpdateArgs} args - Arguments to update one ActionItem.
     * @example
     * // Update one ActionItem
     * const actionItem = await prisma.actionItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActionItemUpdateArgs>(args: SelectSubset<T, ActionItemUpdateArgs<ExtArgs>>): Prisma__ActionItemClient<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActionItems.
     * @param {ActionItemDeleteManyArgs} args - Arguments to filter ActionItems to delete.
     * @example
     * // Delete a few ActionItems
     * const { count } = await prisma.actionItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActionItemDeleteManyArgs>(args?: SelectSubset<T, ActionItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActionItems
     * const actionItem = await prisma.actionItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActionItemUpdateManyArgs>(args: SelectSubset<T, ActionItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActionItems and returns the data updated in the database.
     * @param {ActionItemUpdateManyAndReturnArgs} args - Arguments to update many ActionItems.
     * @example
     * // Update many ActionItems
     * const actionItem = await prisma.actionItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActionItems and only return the `id`
     * const actionItemWithIdOnly = await prisma.actionItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActionItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ActionItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ActionItem.
     * @param {ActionItemUpsertArgs} args - Arguments to update or create a ActionItem.
     * @example
     * // Update or create a ActionItem
     * const actionItem = await prisma.actionItem.upsert({
     *   create: {
     *     // ... data to create a ActionItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActionItem we want to update
     *   }
     * })
     */
    upsert<T extends ActionItemUpsertArgs>(args: SelectSubset<T, ActionItemUpsertArgs<ExtArgs>>): Prisma__ActionItemClient<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionItemCountArgs} args - Arguments to filter ActionItems to count.
     * @example
     * // Count the number of ActionItems
     * const count = await prisma.actionItem.count({
     *   where: {
     *     // ... the filter for the ActionItems we want to count
     *   }
     * })
    **/
    count<T extends ActionItemCountArgs>(
      args?: Subset<T, ActionItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActionItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActionItemAggregateArgs>(args: Subset<T, ActionItemAggregateArgs>): Prisma.PrismaPromise<GetActionItemAggregateType<T>>

    /**
     * Group by ActionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActionItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActionItemGroupByArgs['orderBy'] }
        : { orderBy?: ActionItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActionItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActionItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActionItem model
   */
  readonly fields: ActionItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActionItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActionItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    convertedToTask<T extends ActionItem$convertedToTaskArgs<ExtArgs> = {}>(args?: Subset<T, ActionItem$convertedToTaskArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    research<T extends ResearchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResearchDefaultArgs<ExtArgs>>): Prisma__ResearchClient<$Result.GetResult<Prisma.$ResearchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActionItem model
   */
  interface ActionItemFieldRefs {
    readonly id: FieldRef<"ActionItem", 'String'>
    readonly researchId: FieldRef<"ActionItem", 'String'>
    readonly description: FieldRef<"ActionItem", 'String'>
    readonly priority: FieldRef<"ActionItem", 'ActionPriority'>
    readonly effort: FieldRef<"ActionItem", 'Int'>
    readonly convertedToTaskId: FieldRef<"ActionItem", 'String'>
    readonly convertedAt: FieldRef<"ActionItem", 'DateTime'>
    readonly createdAt: FieldRef<"ActionItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActionItem findUnique
   */
  export type ActionItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionItem
     */
    omit?: ActionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
    /**
     * Filter, which ActionItem to fetch.
     */
    where: ActionItemWhereUniqueInput
  }

  /**
   * ActionItem findUniqueOrThrow
   */
  export type ActionItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionItem
     */
    omit?: ActionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
    /**
     * Filter, which ActionItem to fetch.
     */
    where: ActionItemWhereUniqueInput
  }

  /**
   * ActionItem findFirst
   */
  export type ActionItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionItem
     */
    omit?: ActionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
    /**
     * Filter, which ActionItem to fetch.
     */
    where?: ActionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionItems to fetch.
     */
    orderBy?: ActionItemOrderByWithRelationInput | ActionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActionItems.
     */
    cursor?: ActionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActionItems.
     */
    distinct?: ActionItemScalarFieldEnum | ActionItemScalarFieldEnum[]
  }

  /**
   * ActionItem findFirstOrThrow
   */
  export type ActionItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionItem
     */
    omit?: ActionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
    /**
     * Filter, which ActionItem to fetch.
     */
    where?: ActionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionItems to fetch.
     */
    orderBy?: ActionItemOrderByWithRelationInput | ActionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActionItems.
     */
    cursor?: ActionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActionItems.
     */
    distinct?: ActionItemScalarFieldEnum | ActionItemScalarFieldEnum[]
  }

  /**
   * ActionItem findMany
   */
  export type ActionItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionItem
     */
    omit?: ActionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
    /**
     * Filter, which ActionItems to fetch.
     */
    where?: ActionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionItems to fetch.
     */
    orderBy?: ActionItemOrderByWithRelationInput | ActionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActionItems.
     */
    cursor?: ActionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionItems.
     */
    skip?: number
    distinct?: ActionItemScalarFieldEnum | ActionItemScalarFieldEnum[]
  }

  /**
   * ActionItem create
   */
  export type ActionItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionItem
     */
    omit?: ActionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ActionItem.
     */
    data: XOR<ActionItemCreateInput, ActionItemUncheckedCreateInput>
  }

  /**
   * ActionItem createMany
   */
  export type ActionItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActionItems.
     */
    data: ActionItemCreateManyInput | ActionItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActionItem createManyAndReturn
   */
  export type ActionItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActionItem
     */
    omit?: ActionItemOmit<ExtArgs> | null
    /**
     * The data used to create many ActionItems.
     */
    data: ActionItemCreateManyInput | ActionItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActionItem update
   */
  export type ActionItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionItem
     */
    omit?: ActionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ActionItem.
     */
    data: XOR<ActionItemUpdateInput, ActionItemUncheckedUpdateInput>
    /**
     * Choose, which ActionItem to update.
     */
    where: ActionItemWhereUniqueInput
  }

  /**
   * ActionItem updateMany
   */
  export type ActionItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActionItems.
     */
    data: XOR<ActionItemUpdateManyMutationInput, ActionItemUncheckedUpdateManyInput>
    /**
     * Filter which ActionItems to update
     */
    where?: ActionItemWhereInput
    /**
     * Limit how many ActionItems to update.
     */
    limit?: number
  }

  /**
   * ActionItem updateManyAndReturn
   */
  export type ActionItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActionItem
     */
    omit?: ActionItemOmit<ExtArgs> | null
    /**
     * The data used to update ActionItems.
     */
    data: XOR<ActionItemUpdateManyMutationInput, ActionItemUncheckedUpdateManyInput>
    /**
     * Filter which ActionItems to update
     */
    where?: ActionItemWhereInput
    /**
     * Limit how many ActionItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActionItem upsert
   */
  export type ActionItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionItem
     */
    omit?: ActionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ActionItem to update in case it exists.
     */
    where: ActionItemWhereUniqueInput
    /**
     * In case the ActionItem found by the `where` argument doesn't exist, create a new ActionItem with this data.
     */
    create: XOR<ActionItemCreateInput, ActionItemUncheckedCreateInput>
    /**
     * In case the ActionItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActionItemUpdateInput, ActionItemUncheckedUpdateInput>
  }

  /**
   * ActionItem delete
   */
  export type ActionItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionItem
     */
    omit?: ActionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
    /**
     * Filter which ActionItem to delete.
     */
    where: ActionItemWhereUniqueInput
  }

  /**
   * ActionItem deleteMany
   */
  export type ActionItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActionItems to delete
     */
    where?: ActionItemWhereInput
    /**
     * Limit how many ActionItems to delete.
     */
    limit?: number
  }

  /**
   * ActionItem.convertedToTask
   */
  export type ActionItem$convertedToTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
  }

  /**
   * ActionItem without action
   */
  export type ActionItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionItem
     */
    omit?: ActionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
  }


  /**
   * Model LeadData
   */

  export type AggregateLeadData = {
    _count: LeadDataCountAggregateOutputType | null
    _avg: LeadDataAvgAggregateOutputType | null
    _sum: LeadDataSumAggregateOutputType | null
    _min: LeadDataMinAggregateOutputType | null
    _max: LeadDataMaxAggregateOutputType | null
  }

  export type LeadDataAvgAggregateOutputType = {
    totalFound: number | null
  }

  export type LeadDataSumAggregateOutputType = {
    totalFound: number | null
  }

  export type LeadDataMinAggregateOutputType = {
    id: string | null
    researchId: string | null
    totalFound: number | null
    exportedAt: Date | null
  }

  export type LeadDataMaxAggregateOutputType = {
    id: string | null
    researchId: string | null
    totalFound: number | null
    exportedAt: Date | null
  }

  export type LeadDataCountAggregateOutputType = {
    id: number
    researchId: number
    totalFound: number
    exportedAt: number
    _all: number
  }


  export type LeadDataAvgAggregateInputType = {
    totalFound?: true
  }

  export type LeadDataSumAggregateInputType = {
    totalFound?: true
  }

  export type LeadDataMinAggregateInputType = {
    id?: true
    researchId?: true
    totalFound?: true
    exportedAt?: true
  }

  export type LeadDataMaxAggregateInputType = {
    id?: true
    researchId?: true
    totalFound?: true
    exportedAt?: true
  }

  export type LeadDataCountAggregateInputType = {
    id?: true
    researchId?: true
    totalFound?: true
    exportedAt?: true
    _all?: true
  }

  export type LeadDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadData to aggregate.
     */
    where?: LeadDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadData to fetch.
     */
    orderBy?: LeadDataOrderByWithRelationInput | LeadDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeadData
    **/
    _count?: true | LeadDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeadDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeadDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadDataMaxAggregateInputType
  }

  export type GetLeadDataAggregateType<T extends LeadDataAggregateArgs> = {
        [P in keyof T & keyof AggregateLeadData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeadData[P]>
      : GetScalarType<T[P], AggregateLeadData[P]>
  }




  export type LeadDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadDataWhereInput
    orderBy?: LeadDataOrderByWithAggregationInput | LeadDataOrderByWithAggregationInput[]
    by: LeadDataScalarFieldEnum[] | LeadDataScalarFieldEnum
    having?: LeadDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadDataCountAggregateInputType | true
    _avg?: LeadDataAvgAggregateInputType
    _sum?: LeadDataSumAggregateInputType
    _min?: LeadDataMinAggregateInputType
    _max?: LeadDataMaxAggregateInputType
  }

  export type LeadDataGroupByOutputType = {
    id: string
    researchId: string
    totalFound: number
    exportedAt: Date | null
    _count: LeadDataCountAggregateOutputType | null
    _avg: LeadDataAvgAggregateOutputType | null
    _sum: LeadDataSumAggregateOutputType | null
    _min: LeadDataMinAggregateOutputType | null
    _max: LeadDataMaxAggregateOutputType | null
  }

  type GetLeadDataGroupByPayload<T extends LeadDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadDataGroupByOutputType[P]>
            : GetScalarType<T[P], LeadDataGroupByOutputType[P]>
        }
      >
    >


  export type LeadDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    researchId?: boolean
    totalFound?: boolean
    exportedAt?: boolean
    leads?: boolean | LeadData$leadsArgs<ExtArgs>
    research?: boolean | ResearchDefaultArgs<ExtArgs>
    _count?: boolean | LeadDataCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leadData"]>

  export type LeadDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    researchId?: boolean
    totalFound?: boolean
    exportedAt?: boolean
    research?: boolean | ResearchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leadData"]>

  export type LeadDataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    researchId?: boolean
    totalFound?: boolean
    exportedAt?: boolean
    research?: boolean | ResearchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leadData"]>

  export type LeadDataSelectScalar = {
    id?: boolean
    researchId?: boolean
    totalFound?: boolean
    exportedAt?: boolean
  }

  export type LeadDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "researchId" | "totalFound" | "exportedAt", ExtArgs["result"]["leadData"]>
  export type LeadDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leads?: boolean | LeadData$leadsArgs<ExtArgs>
    research?: boolean | ResearchDefaultArgs<ExtArgs>
    _count?: boolean | LeadDataCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LeadDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    research?: boolean | ResearchDefaultArgs<ExtArgs>
  }
  export type LeadDataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    research?: boolean | ResearchDefaultArgs<ExtArgs>
  }

  export type $LeadDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeadData"
    objects: {
      leads: Prisma.$LeadPayload<ExtArgs>[]
      research: Prisma.$ResearchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      researchId: string
      totalFound: number
      exportedAt: Date | null
    }, ExtArgs["result"]["leadData"]>
    composites: {}
  }

  type LeadDataGetPayload<S extends boolean | null | undefined | LeadDataDefaultArgs> = $Result.GetResult<Prisma.$LeadDataPayload, S>

  type LeadDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeadDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeadDataCountAggregateInputType | true
    }

  export interface LeadDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeadData'], meta: { name: 'LeadData' } }
    /**
     * Find zero or one LeadData that matches the filter.
     * @param {LeadDataFindUniqueArgs} args - Arguments to find a LeadData
     * @example
     * // Get one LeadData
     * const leadData = await prisma.leadData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadDataFindUniqueArgs>(args: SelectSubset<T, LeadDataFindUniqueArgs<ExtArgs>>): Prisma__LeadDataClient<$Result.GetResult<Prisma.$LeadDataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeadData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeadDataFindUniqueOrThrowArgs} args - Arguments to find a LeadData
     * @example
     * // Get one LeadData
     * const leadData = await prisma.leadData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadDataFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadDataClient<$Result.GetResult<Prisma.$LeadDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeadData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadDataFindFirstArgs} args - Arguments to find a LeadData
     * @example
     * // Get one LeadData
     * const leadData = await prisma.leadData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadDataFindFirstArgs>(args?: SelectSubset<T, LeadDataFindFirstArgs<ExtArgs>>): Prisma__LeadDataClient<$Result.GetResult<Prisma.$LeadDataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeadData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadDataFindFirstOrThrowArgs} args - Arguments to find a LeadData
     * @example
     * // Get one LeadData
     * const leadData = await prisma.leadData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadDataFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadDataClient<$Result.GetResult<Prisma.$LeadDataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeadData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeadData
     * const leadData = await prisma.leadData.findMany()
     * 
     * // Get first 10 LeadData
     * const leadData = await prisma.leadData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadDataWithIdOnly = await prisma.leadData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeadDataFindManyArgs>(args?: SelectSubset<T, LeadDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeadData.
     * @param {LeadDataCreateArgs} args - Arguments to create a LeadData.
     * @example
     * // Create one LeadData
     * const LeadData = await prisma.leadData.create({
     *   data: {
     *     // ... data to create a LeadData
     *   }
     * })
     * 
     */
    create<T extends LeadDataCreateArgs>(args: SelectSubset<T, LeadDataCreateArgs<ExtArgs>>): Prisma__LeadDataClient<$Result.GetResult<Prisma.$LeadDataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeadData.
     * @param {LeadDataCreateManyArgs} args - Arguments to create many LeadData.
     * @example
     * // Create many LeadData
     * const leadData = await prisma.leadData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadDataCreateManyArgs>(args?: SelectSubset<T, LeadDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeadData and returns the data saved in the database.
     * @param {LeadDataCreateManyAndReturnArgs} args - Arguments to create many LeadData.
     * @example
     * // Create many LeadData
     * const leadData = await prisma.leadData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeadData and only return the `id`
     * const leadDataWithIdOnly = await prisma.leadData.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeadDataCreateManyAndReturnArgs>(args?: SelectSubset<T, LeadDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadDataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LeadData.
     * @param {LeadDataDeleteArgs} args - Arguments to delete one LeadData.
     * @example
     * // Delete one LeadData
     * const LeadData = await prisma.leadData.delete({
     *   where: {
     *     // ... filter to delete one LeadData
     *   }
     * })
     * 
     */
    delete<T extends LeadDataDeleteArgs>(args: SelectSubset<T, LeadDataDeleteArgs<ExtArgs>>): Prisma__LeadDataClient<$Result.GetResult<Prisma.$LeadDataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeadData.
     * @param {LeadDataUpdateArgs} args - Arguments to update one LeadData.
     * @example
     * // Update one LeadData
     * const leadData = await prisma.leadData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadDataUpdateArgs>(args: SelectSubset<T, LeadDataUpdateArgs<ExtArgs>>): Prisma__LeadDataClient<$Result.GetResult<Prisma.$LeadDataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeadData.
     * @param {LeadDataDeleteManyArgs} args - Arguments to filter LeadData to delete.
     * @example
     * // Delete a few LeadData
     * const { count } = await prisma.leadData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadDataDeleteManyArgs>(args?: SelectSubset<T, LeadDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeadData
     * const leadData = await prisma.leadData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadDataUpdateManyArgs>(args: SelectSubset<T, LeadDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadData and returns the data updated in the database.
     * @param {LeadDataUpdateManyAndReturnArgs} args - Arguments to update many LeadData.
     * @example
     * // Update many LeadData
     * const leadData = await prisma.leadData.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeadData and only return the `id`
     * const leadDataWithIdOnly = await prisma.leadData.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeadDataUpdateManyAndReturnArgs>(args: SelectSubset<T, LeadDataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadDataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LeadData.
     * @param {LeadDataUpsertArgs} args - Arguments to update or create a LeadData.
     * @example
     * // Update or create a LeadData
     * const leadData = await prisma.leadData.upsert({
     *   create: {
     *     // ... data to create a LeadData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeadData we want to update
     *   }
     * })
     */
    upsert<T extends LeadDataUpsertArgs>(args: SelectSubset<T, LeadDataUpsertArgs<ExtArgs>>): Prisma__LeadDataClient<$Result.GetResult<Prisma.$LeadDataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeadData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadDataCountArgs} args - Arguments to filter LeadData to count.
     * @example
     * // Count the number of LeadData
     * const count = await prisma.leadData.count({
     *   where: {
     *     // ... the filter for the LeadData we want to count
     *   }
     * })
    **/
    count<T extends LeadDataCountArgs>(
      args?: Subset<T, LeadDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeadData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadDataAggregateArgs>(args: Subset<T, LeadDataAggregateArgs>): Prisma.PrismaPromise<GetLeadDataAggregateType<T>>

    /**
     * Group by LeadData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadDataGroupByArgs['orderBy'] }
        : { orderBy?: LeadDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeadData model
   */
  readonly fields: LeadDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeadData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    leads<T extends LeadData$leadsArgs<ExtArgs> = {}>(args?: Subset<T, LeadData$leadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    research<T extends ResearchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResearchDefaultArgs<ExtArgs>>): Prisma__ResearchClient<$Result.GetResult<Prisma.$ResearchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeadData model
   */
  interface LeadDataFieldRefs {
    readonly id: FieldRef<"LeadData", 'String'>
    readonly researchId: FieldRef<"LeadData", 'String'>
    readonly totalFound: FieldRef<"LeadData", 'Int'>
    readonly exportedAt: FieldRef<"LeadData", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeadData findUnique
   */
  export type LeadDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadData
     */
    select?: LeadDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadData
     */
    omit?: LeadDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadDataInclude<ExtArgs> | null
    /**
     * Filter, which LeadData to fetch.
     */
    where: LeadDataWhereUniqueInput
  }

  /**
   * LeadData findUniqueOrThrow
   */
  export type LeadDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadData
     */
    select?: LeadDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadData
     */
    omit?: LeadDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadDataInclude<ExtArgs> | null
    /**
     * Filter, which LeadData to fetch.
     */
    where: LeadDataWhereUniqueInput
  }

  /**
   * LeadData findFirst
   */
  export type LeadDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadData
     */
    select?: LeadDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadData
     */
    omit?: LeadDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadDataInclude<ExtArgs> | null
    /**
     * Filter, which LeadData to fetch.
     */
    where?: LeadDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadData to fetch.
     */
    orderBy?: LeadDataOrderByWithRelationInput | LeadDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadData.
     */
    cursor?: LeadDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadData.
     */
    distinct?: LeadDataScalarFieldEnum | LeadDataScalarFieldEnum[]
  }

  /**
   * LeadData findFirstOrThrow
   */
  export type LeadDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadData
     */
    select?: LeadDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadData
     */
    omit?: LeadDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadDataInclude<ExtArgs> | null
    /**
     * Filter, which LeadData to fetch.
     */
    where?: LeadDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadData to fetch.
     */
    orderBy?: LeadDataOrderByWithRelationInput | LeadDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadData.
     */
    cursor?: LeadDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadData.
     */
    distinct?: LeadDataScalarFieldEnum | LeadDataScalarFieldEnum[]
  }

  /**
   * LeadData findMany
   */
  export type LeadDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadData
     */
    select?: LeadDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadData
     */
    omit?: LeadDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadDataInclude<ExtArgs> | null
    /**
     * Filter, which LeadData to fetch.
     */
    where?: LeadDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadData to fetch.
     */
    orderBy?: LeadDataOrderByWithRelationInput | LeadDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeadData.
     */
    cursor?: LeadDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadData.
     */
    skip?: number
    distinct?: LeadDataScalarFieldEnum | LeadDataScalarFieldEnum[]
  }

  /**
   * LeadData create
   */
  export type LeadDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadData
     */
    select?: LeadDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadData
     */
    omit?: LeadDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadDataInclude<ExtArgs> | null
    /**
     * The data needed to create a LeadData.
     */
    data: XOR<LeadDataCreateInput, LeadDataUncheckedCreateInput>
  }

  /**
   * LeadData createMany
   */
  export type LeadDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeadData.
     */
    data: LeadDataCreateManyInput | LeadDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeadData createManyAndReturn
   */
  export type LeadDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadData
     */
    select?: LeadDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeadData
     */
    omit?: LeadDataOmit<ExtArgs> | null
    /**
     * The data used to create many LeadData.
     */
    data: LeadDataCreateManyInput | LeadDataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadDataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeadData update
   */
  export type LeadDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadData
     */
    select?: LeadDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadData
     */
    omit?: LeadDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadDataInclude<ExtArgs> | null
    /**
     * The data needed to update a LeadData.
     */
    data: XOR<LeadDataUpdateInput, LeadDataUncheckedUpdateInput>
    /**
     * Choose, which LeadData to update.
     */
    where: LeadDataWhereUniqueInput
  }

  /**
   * LeadData updateMany
   */
  export type LeadDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeadData.
     */
    data: XOR<LeadDataUpdateManyMutationInput, LeadDataUncheckedUpdateManyInput>
    /**
     * Filter which LeadData to update
     */
    where?: LeadDataWhereInput
    /**
     * Limit how many LeadData to update.
     */
    limit?: number
  }

  /**
   * LeadData updateManyAndReturn
   */
  export type LeadDataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadData
     */
    select?: LeadDataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeadData
     */
    omit?: LeadDataOmit<ExtArgs> | null
    /**
     * The data used to update LeadData.
     */
    data: XOR<LeadDataUpdateManyMutationInput, LeadDataUncheckedUpdateManyInput>
    /**
     * Filter which LeadData to update
     */
    where?: LeadDataWhereInput
    /**
     * Limit how many LeadData to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadDataIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeadData upsert
   */
  export type LeadDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadData
     */
    select?: LeadDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadData
     */
    omit?: LeadDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadDataInclude<ExtArgs> | null
    /**
     * The filter to search for the LeadData to update in case it exists.
     */
    where: LeadDataWhereUniqueInput
    /**
     * In case the LeadData found by the `where` argument doesn't exist, create a new LeadData with this data.
     */
    create: XOR<LeadDataCreateInput, LeadDataUncheckedCreateInput>
    /**
     * In case the LeadData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadDataUpdateInput, LeadDataUncheckedUpdateInput>
  }

  /**
   * LeadData delete
   */
  export type LeadDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadData
     */
    select?: LeadDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadData
     */
    omit?: LeadDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadDataInclude<ExtArgs> | null
    /**
     * Filter which LeadData to delete.
     */
    where: LeadDataWhereUniqueInput
  }

  /**
   * LeadData deleteMany
   */
  export type LeadDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadData to delete
     */
    where?: LeadDataWhereInput
    /**
     * Limit how many LeadData to delete.
     */
    limit?: number
  }

  /**
   * LeadData.leads
   */
  export type LeadData$leadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    cursor?: LeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * LeadData without action
   */
  export type LeadDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadData
     */
    select?: LeadDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadData
     */
    omit?: LeadDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadDataInclude<ExtArgs> | null
  }


  /**
   * Model Lead
   */

  export type AggregateLead = {
    _count: LeadCountAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  export type LeadMinAggregateOutputType = {
    id: string | null
    leadDataId: string | null
    name: string | null
    company: string | null
    email: string | null
    phone: string | null
    website: string | null
    industry: string | null
    location: string | null
    suggestedDM: string | null
    suggestedEmail: string | null
    contacted: boolean | null
    contactedAt: Date | null
    createdAt: Date | null
  }

  export type LeadMaxAggregateOutputType = {
    id: string | null
    leadDataId: string | null
    name: string | null
    company: string | null
    email: string | null
    phone: string | null
    website: string | null
    industry: string | null
    location: string | null
    suggestedDM: string | null
    suggestedEmail: string | null
    contacted: boolean | null
    contactedAt: Date | null
    createdAt: Date | null
  }

  export type LeadCountAggregateOutputType = {
    id: number
    leadDataId: number
    name: number
    company: number
    email: number
    phone: number
    website: number
    industry: number
    location: number
    painPoints: number
    suggestedDM: number
    suggestedEmail: number
    personalization: number
    contacted: number
    contactedAt: number
    createdAt: number
    _all: number
  }


  export type LeadMinAggregateInputType = {
    id?: true
    leadDataId?: true
    name?: true
    company?: true
    email?: true
    phone?: true
    website?: true
    industry?: true
    location?: true
    suggestedDM?: true
    suggestedEmail?: true
    contacted?: true
    contactedAt?: true
    createdAt?: true
  }

  export type LeadMaxAggregateInputType = {
    id?: true
    leadDataId?: true
    name?: true
    company?: true
    email?: true
    phone?: true
    website?: true
    industry?: true
    location?: true
    suggestedDM?: true
    suggestedEmail?: true
    contacted?: true
    contactedAt?: true
    createdAt?: true
  }

  export type LeadCountAggregateInputType = {
    id?: true
    leadDataId?: true
    name?: true
    company?: true
    email?: true
    phone?: true
    website?: true
    industry?: true
    location?: true
    painPoints?: true
    suggestedDM?: true
    suggestedEmail?: true
    personalization?: true
    contacted?: true
    contactedAt?: true
    createdAt?: true
    _all?: true
  }

  export type LeadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lead to aggregate.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leads
    **/
    _count?: true | LeadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadMaxAggregateInputType
  }

  export type GetLeadAggregateType<T extends LeadAggregateArgs> = {
        [P in keyof T & keyof AggregateLead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLead[P]>
      : GetScalarType<T[P], AggregateLead[P]>
  }




  export type LeadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithAggregationInput | LeadOrderByWithAggregationInput[]
    by: LeadScalarFieldEnum[] | LeadScalarFieldEnum
    having?: LeadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadCountAggregateInputType | true
    _min?: LeadMinAggregateInputType
    _max?: LeadMaxAggregateInputType
  }

  export type LeadGroupByOutputType = {
    id: string
    leadDataId: string
    name: string
    company: string | null
    email: string | null
    phone: string | null
    website: string | null
    industry: string | null
    location: string | null
    painPoints: string[]
    suggestedDM: string
    suggestedEmail: string
    personalization: JsonValue | null
    contacted: boolean
    contactedAt: Date | null
    createdAt: Date
    _count: LeadCountAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  type GetLeadGroupByPayload<T extends LeadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadGroupByOutputType[P]>
            : GetScalarType<T[P], LeadGroupByOutputType[P]>
        }
      >
    >


  export type LeadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leadDataId?: boolean
    name?: boolean
    company?: boolean
    email?: boolean
    phone?: boolean
    website?: boolean
    industry?: boolean
    location?: boolean
    painPoints?: boolean
    suggestedDM?: boolean
    suggestedEmail?: boolean
    personalization?: boolean
    contacted?: boolean
    contactedAt?: boolean
    createdAt?: boolean
    leadData?: boolean | LeadDataDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leadDataId?: boolean
    name?: boolean
    company?: boolean
    email?: boolean
    phone?: boolean
    website?: boolean
    industry?: boolean
    location?: boolean
    painPoints?: boolean
    suggestedDM?: boolean
    suggestedEmail?: boolean
    personalization?: boolean
    contacted?: boolean
    contactedAt?: boolean
    createdAt?: boolean
    leadData?: boolean | LeadDataDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leadDataId?: boolean
    name?: boolean
    company?: boolean
    email?: boolean
    phone?: boolean
    website?: boolean
    industry?: boolean
    location?: boolean
    painPoints?: boolean
    suggestedDM?: boolean
    suggestedEmail?: boolean
    personalization?: boolean
    contacted?: boolean
    contactedAt?: boolean
    createdAt?: boolean
    leadData?: boolean | LeadDataDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectScalar = {
    id?: boolean
    leadDataId?: boolean
    name?: boolean
    company?: boolean
    email?: boolean
    phone?: boolean
    website?: boolean
    industry?: boolean
    location?: boolean
    painPoints?: boolean
    suggestedDM?: boolean
    suggestedEmail?: boolean
    personalization?: boolean
    contacted?: boolean
    contactedAt?: boolean
    createdAt?: boolean
  }

  export type LeadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "leadDataId" | "name" | "company" | "email" | "phone" | "website" | "industry" | "location" | "painPoints" | "suggestedDM" | "suggestedEmail" | "personalization" | "contacted" | "contactedAt" | "createdAt", ExtArgs["result"]["lead"]>
  export type LeadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leadData?: boolean | LeadDataDefaultArgs<ExtArgs>
  }
  export type LeadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leadData?: boolean | LeadDataDefaultArgs<ExtArgs>
  }
  export type LeadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leadData?: boolean | LeadDataDefaultArgs<ExtArgs>
  }

  export type $LeadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lead"
    objects: {
      leadData: Prisma.$LeadDataPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      leadDataId: string
      name: string
      company: string | null
      email: string | null
      phone: string | null
      website: string | null
      industry: string | null
      location: string | null
      painPoints: string[]
      suggestedDM: string
      suggestedEmail: string
      personalization: Prisma.JsonValue | null
      contacted: boolean
      contactedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["lead"]>
    composites: {}
  }

  type LeadGetPayload<S extends boolean | null | undefined | LeadDefaultArgs> = $Result.GetResult<Prisma.$LeadPayload, S>

  type LeadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeadCountAggregateInputType | true
    }

  export interface LeadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lead'], meta: { name: 'Lead' } }
    /**
     * Find zero or one Lead that matches the filter.
     * @param {LeadFindUniqueArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadFindUniqueArgs>(args: SelectSubset<T, LeadFindUniqueArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lead that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeadFindUniqueOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadFindFirstArgs>(args?: SelectSubset<T, LeadFindFirstArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leads
     * const leads = await prisma.lead.findMany()
     * 
     * // Get first 10 Leads
     * const leads = await prisma.lead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadWithIdOnly = await prisma.lead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeadFindManyArgs>(args?: SelectSubset<T, LeadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lead.
     * @param {LeadCreateArgs} args - Arguments to create a Lead.
     * @example
     * // Create one Lead
     * const Lead = await prisma.lead.create({
     *   data: {
     *     // ... data to create a Lead
     *   }
     * })
     * 
     */
    create<T extends LeadCreateArgs>(args: SelectSubset<T, LeadCreateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leads.
     * @param {LeadCreateManyArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadCreateManyArgs>(args?: SelectSubset<T, LeadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leads and returns the data saved in the database.
     * @param {LeadCreateManyAndReturnArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leads and only return the `id`
     * const leadWithIdOnly = await prisma.lead.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeadCreateManyAndReturnArgs>(args?: SelectSubset<T, LeadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lead.
     * @param {LeadDeleteArgs} args - Arguments to delete one Lead.
     * @example
     * // Delete one Lead
     * const Lead = await prisma.lead.delete({
     *   where: {
     *     // ... filter to delete one Lead
     *   }
     * })
     * 
     */
    delete<T extends LeadDeleteArgs>(args: SelectSubset<T, LeadDeleteArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lead.
     * @param {LeadUpdateArgs} args - Arguments to update one Lead.
     * @example
     * // Update one Lead
     * const lead = await prisma.lead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadUpdateArgs>(args: SelectSubset<T, LeadUpdateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leads.
     * @param {LeadDeleteManyArgs} args - Arguments to filter Leads to delete.
     * @example
     * // Delete a few Leads
     * const { count } = await prisma.lead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadDeleteManyArgs>(args?: SelectSubset<T, LeadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leads
     * const lead = await prisma.lead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadUpdateManyArgs>(args: SelectSubset<T, LeadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leads and returns the data updated in the database.
     * @param {LeadUpdateManyAndReturnArgs} args - Arguments to update many Leads.
     * @example
     * // Update many Leads
     * const lead = await prisma.lead.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Leads and only return the `id`
     * const leadWithIdOnly = await prisma.lead.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeadUpdateManyAndReturnArgs>(args: SelectSubset<T, LeadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lead.
     * @param {LeadUpsertArgs} args - Arguments to update or create a Lead.
     * @example
     * // Update or create a Lead
     * const lead = await prisma.lead.upsert({
     *   create: {
     *     // ... data to create a Lead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lead we want to update
     *   }
     * })
     */
    upsert<T extends LeadUpsertArgs>(args: SelectSubset<T, LeadUpsertArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCountArgs} args - Arguments to filter Leads to count.
     * @example
     * // Count the number of Leads
     * const count = await prisma.lead.count({
     *   where: {
     *     // ... the filter for the Leads we want to count
     *   }
     * })
    **/
    count<T extends LeadCountArgs>(
      args?: Subset<T, LeadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadAggregateArgs>(args: Subset<T, LeadAggregateArgs>): Prisma.PrismaPromise<GetLeadAggregateType<T>>

    /**
     * Group by Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadGroupByArgs['orderBy'] }
        : { orderBy?: LeadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lead model
   */
  readonly fields: LeadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    leadData<T extends LeadDataDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeadDataDefaultArgs<ExtArgs>>): Prisma__LeadDataClient<$Result.GetResult<Prisma.$LeadDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lead model
   */
  interface LeadFieldRefs {
    readonly id: FieldRef<"Lead", 'String'>
    readonly leadDataId: FieldRef<"Lead", 'String'>
    readonly name: FieldRef<"Lead", 'String'>
    readonly company: FieldRef<"Lead", 'String'>
    readonly email: FieldRef<"Lead", 'String'>
    readonly phone: FieldRef<"Lead", 'String'>
    readonly website: FieldRef<"Lead", 'String'>
    readonly industry: FieldRef<"Lead", 'String'>
    readonly location: FieldRef<"Lead", 'String'>
    readonly painPoints: FieldRef<"Lead", 'String[]'>
    readonly suggestedDM: FieldRef<"Lead", 'String'>
    readonly suggestedEmail: FieldRef<"Lead", 'String'>
    readonly personalization: FieldRef<"Lead", 'Json'>
    readonly contacted: FieldRef<"Lead", 'Boolean'>
    readonly contactedAt: FieldRef<"Lead", 'DateTime'>
    readonly createdAt: FieldRef<"Lead", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lead findUnique
   */
  export type LeadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findUniqueOrThrow
   */
  export type LeadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findFirst
   */
  export type LeadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findFirstOrThrow
   */
  export type LeadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findMany
   */
  export type LeadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Leads to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead create
   */
  export type LeadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to create a Lead.
     */
    data: XOR<LeadCreateInput, LeadUncheckedCreateInput>
  }

  /**
   * Lead createMany
   */
  export type LeadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lead createManyAndReturn
   */
  export type LeadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lead update
   */
  export type LeadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to update a Lead.
     */
    data: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
    /**
     * Choose, which Lead to update.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead updateMany
   */
  export type LeadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leads.
     */
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyInput>
    /**
     * Filter which Leads to update
     */
    where?: LeadWhereInput
    /**
     * Limit how many Leads to update.
     */
    limit?: number
  }

  /**
   * Lead updateManyAndReturn
   */
  export type LeadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * The data used to update Leads.
     */
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyInput>
    /**
     * Filter which Leads to update
     */
    where?: LeadWhereInput
    /**
     * Limit how many Leads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lead upsert
   */
  export type LeadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The filter to search for the Lead to update in case it exists.
     */
    where: LeadWhereUniqueInput
    /**
     * In case the Lead found by the `where` argument doesn't exist, create a new Lead with this data.
     */
    create: XOR<LeadCreateInput, LeadUncheckedCreateInput>
    /**
     * In case the Lead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
  }

  /**
   * Lead delete
   */
  export type LeadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter which Lead to delete.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead deleteMany
   */
  export type LeadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leads to delete
     */
    where?: LeadWhereInput
    /**
     * Limit how many Leads to delete.
     */
    limit?: number
  }

  /**
   * Lead without action
   */
  export type LeadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    avatar: 'avatar',
    timezone: 'timezone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    geminiApiKey: 'geminiApiKey',
    geminiModel: 'geminiModel',
    groqApiKey: 'groqApiKey',
    llmProvider: 'llmProvider',
    serperApiKey: 'serperApiKey',
    researchLimit: 'researchLimit'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const YearPlanScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    year: 'year',
    theme: 'theme',
    vision: 'vision',
    focusAreas: 'focusAreas',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type YearPlanScalarFieldEnum = (typeof YearPlanScalarFieldEnum)[keyof typeof YearPlanScalarFieldEnum]


  export const GoalScalarFieldEnum: {
    id: 'id',
    yearPlanId: 'yearPlanId',
    title: 'title',
    description: 'description',
    category: 'category',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    kpis: 'kpis',
    priority: 'priority',
    progress: 'progress',
    risks: 'risks',
    strategies: 'strategies',
    targetDate: 'targetDate'
  };

  export type GoalScalarFieldEnum = (typeof GoalScalarFieldEnum)[keyof typeof GoalScalarFieldEnum]


  export const MilestoneScalarFieldEnum: {
    id: 'id',
    goalId: 'goalId',
    title: 'title',
    targetDate: 'targetDate',
    completed: 'completed',
    completedAt: 'completedAt',
    createdAt: 'createdAt'
  };

  export type MilestoneScalarFieldEnum = (typeof MilestoneScalarFieldEnum)[keyof typeof MilestoneScalarFieldEnum]


  export const KeyStepScalarFieldEnum: {
    id: 'id',
    goalId: 'goalId',
    title: 'title',
    description: 'description',
    order: 'order',
    completed: 'completed',
    completedAt: 'completedAt',
    progress: 'progress',
    targetDate: 'targetDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KeyStepScalarFieldEnum = (typeof KeyStepScalarFieldEnum)[keyof typeof KeyStepScalarFieldEnum]


  export const NoteScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    content: 'content',
    goalId: 'goalId',
    keyStepId: 'keyStepId',
    dayPlanId: 'dayPlanId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NoteScalarFieldEnum = (typeof NoteScalarFieldEnum)[keyof typeof NoteScalarFieldEnum]


  export const QuarterPlanScalarFieldEnum: {
    id: 'id',
    yearPlanId: 'yearPlanId',
    quarter: 'quarter',
    theme: 'theme',
    startDate: 'startDate',
    endDate: 'endDate'
  };

  export type QuarterPlanScalarFieldEnum = (typeof QuarterPlanScalarFieldEnum)[keyof typeof QuarterPlanScalarFieldEnum]


  export const QuarterObjectiveScalarFieldEnum: {
    id: 'id',
    quarterPlanId: 'quarterPlanId',
    title: 'title',
    description: 'description',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuarterObjectiveScalarFieldEnum = (typeof QuarterObjectiveScalarFieldEnum)[keyof typeof QuarterObjectiveScalarFieldEnum]


  export const QuarterFocusScalarFieldEnum: {
    id: 'id',
    quarterPlanId: 'quarterPlanId',
    goalId: 'goalId',
    priority: 'priority',
    progress: 'progress',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuarterFocusScalarFieldEnum = (typeof QuarterFocusScalarFieldEnum)[keyof typeof QuarterFocusScalarFieldEnum]


  export const MonthPlanScalarFieldEnum: {
    id: 'id',
    quarterPlanId: 'quarterPlanId',
    month: 'month',
    year: 'year',
    objectives: 'objectives',
    completionRate: 'completionRate',
    energyRating: 'energyRating',
    rating: 'rating',
    reviewNotes: 'reviewNotes',
    theme: 'theme'
  };

  export type MonthPlanScalarFieldEnum = (typeof MonthPlanScalarFieldEnum)[keyof typeof MonthPlanScalarFieldEnum]


  export const MonthFocusScalarFieldEnum: {
    id: 'id',
    monthPlanId: 'monthPlanId',
    quarterFocusId: 'quarterFocusId',
    priority: 'priority',
    progress: 'progress',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MonthFocusScalarFieldEnum = (typeof MonthFocusScalarFieldEnum)[keyof typeof MonthFocusScalarFieldEnum]


  export const WeekPlanScalarFieldEnum: {
    id: 'id',
    monthPlanId: 'monthPlanId',
    weekNumber: 'weekNumber',
    year: 'year',
    startDate: 'startDate',
    endDate: 'endDate',
    topOutcomes: 'topOutcomes',
    plannedClientHours: 'plannedClientHours',
    plannedPersonalHours: 'plannedPersonalHours',
    userId: 'userId',
    challenges: 'challenges',
    keyWins: 'keyWins',
    lessonsLearned: 'lessonsLearned',
    rating: 'rating',
    reviewNotes: 'reviewNotes'
  };

  export type WeekPlanScalarFieldEnum = (typeof WeekPlanScalarFieldEnum)[keyof typeof WeekPlanScalarFieldEnum]


  export const WeekFocusScalarFieldEnum: {
    id: 'id',
    weekPlanId: 'weekPlanId',
    monthFocusId: 'monthFocusId',
    priority: 'priority',
    progress: 'progress',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WeekFocusScalarFieldEnum = (typeof WeekFocusScalarFieldEnum)[keyof typeof WeekFocusScalarFieldEnum]


  export const DayPlanScalarFieldEnum: {
    id: 'id',
    weekPlanId: 'weekPlanId',
    date: 'date',
    topPriorities: 'topPriorities',
    morningEnergy: 'morningEnergy',
    afternoonEnergy: 'afternoonEnergy',
    eveningEnergy: 'eveningEnergy',
    dailyWin: 'dailyWin',
    gratitude: 'gratitude',
    tomorrowPrep: 'tomorrowPrep',
    completionRate: 'completionRate',
    userId: 'userId'
  };

  export type DayPlanScalarFieldEnum = (typeof DayPlanScalarFieldEnum)[keyof typeof DayPlanScalarFieldEnum]


  export const DayFocusScalarFieldEnum: {
    id: 'id',
    dayPlanId: 'dayPlanId',
    weekFocusId: 'weekFocusId',
    priority: 'priority',
    completed: 'completed',
    completedAt: 'completedAt',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DayFocusScalarFieldEnum = (typeof DayFocusScalarFieldEnum)[keyof typeof DayFocusScalarFieldEnum]


  export const TimeBlockScalarFieldEnum: {
    id: 'id',
    dayPlanId: 'dayPlanId',
    startTime: 'startTime',
    endTime: 'endTime',
    duration: 'duration',
    type: 'type',
    taskId: 'taskId',
    projectId: 'projectId',
    clientId: 'clientId',
    actualStartTime: 'actualStartTime',
    actualEndTime: 'actualEndTime',
    actualDuration: 'actualDuration',
    energyBefore: 'energyBefore',
    energyAfter: 'energyAfter',
    focusQuality: 'focusQuality',
    notes: 'notes'
  };

  export type TimeBlockScalarFieldEnum = (typeof TimeBlockScalarFieldEnum)[keyof typeof TimeBlockScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    description: 'description',
    type: 'type',
    status: 'status',
    clientId: 'clientId',
    billable: 'billable',
    hourlyRate: 'hourlyRate',
    budgetHours: 'budgetHours',
    startDate: 'startDate',
    deadline: 'deadline',
    estimatedHours: 'estimatedHours',
    actualHoursSpent: 'actualHoursSpent',
    completionPercentage: 'completionPercentage',
    goalId: 'goalId',
    parentProjectId: 'parentProjectId',
    priority: 'priority',
    tags: 'tags',
    color: 'color',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    completedAt: 'completedAt',
    archivedAt: 'archivedAt',
    icon: 'icon'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    projectId: 'projectId',
    title: 'title',
    description: 'description',
    status: 'status',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    estimatedMinutes: 'estimatedMinutes',
    actualMinutes: 'actualMinutes',
    timerRunning: 'timerRunning',
    currentTimerStart: 'currentTimerStart',
    scheduledDate: 'scheduledDate',
    dueDate: 'dueDate',
    priority: 'priority',
    type: 'type',
    tags: 'tags',
    parentTaskId: 'parentTaskId',
    dependsOn: 'dependsOn',
    blocks: 'blocks',
    energyRequired: 'energyRequired',
    isAdHoc: 'isAdHoc',
    isRecurring: 'isRecurring',
    recurringPattern: 'recurringPattern',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    meetingId: 'meetingId',
    goalId: 'goalId',
    keyStepId: 'keyStepId'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const TimeEntryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    taskId: 'taskId',
    projectId: 'projectId',
    clientId: 'clientId',
    startTime: 'startTime',
    endTime: 'endTime',
    duration: 'duration',
    type: 'type',
    description: 'description',
    tags: 'tags',
    focusQuality: 'focusQuality',
    energyBefore: 'energyBefore',
    energyAfter: 'energyAfter',
    distractions: 'distractions',
    billable: 'billable',
    hourlyRate: 'hourlyRate',
    amount: 'amount',
    invoiced: 'invoiced',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TimeEntryScalarFieldEnum = (typeof TimeEntryScalarFieldEnum)[keyof typeof TimeEntryScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    companyName: 'companyName',
    email: 'email',
    phone: 'phone',
    primaryContact: 'primaryContact',
    additionalContacts: 'additionalContacts',
    industry: 'industry',
    website: 'website',
    timezone: 'timezone',
    relationshipHealth: 'relationshipHealth',
    lastContactedAt: 'lastContactedAt',
    preferredCommunication: 'preferredCommunication',
    defaultHourlyRate: 'defaultHourlyRate',
    paymentTerms: 'paymentTerms',
    outstandingBalance: 'outstandingBalance',
    notes: 'notes',
    tags: 'tags',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastInteractionAt: 'lastInteractionAt'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const CommunicationScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    projectId: 'projectId',
    type: 'type',
    direction: 'direction',
    subject: 'subject',
    content: 'content',
    summary: 'summary',
    from: 'from',
    to: 'to',
    cc: 'cc',
    attachments: 'attachments',
    meetingDate: 'meetingDate',
    meetingDuration: 'meetingDuration',
    attendees: 'attendees',
    meetingNotes: 'meetingNotes',
    sentiment: 'sentiment',
    requiresFollowUp: 'requiresFollowUp',
    followUpDate: 'followUpDate',
    createdAt: 'createdAt',
    responseTime: 'responseTime'
  };

  export type CommunicationScalarFieldEnum = (typeof CommunicationScalarFieldEnum)[keyof typeof CommunicationScalarFieldEnum]


  export const MeetingScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    projectId: 'projectId',
    title: 'title',
    description: 'description',
    type: 'type',
    scheduledAt: 'scheduledAt',
    duration: 'duration',
    timezone: 'timezone',
    organizer: 'organizer',
    requiredAttendees: 'requiredAttendees',
    optionalAttendees: 'optionalAttendees',
    location: 'location',
    meetingLink: 'meetingLink',
    agenda: 'agenda',
    meetingNotes: 'meetingNotes',
    actionItems: 'actionItems',
    decisions: 'decisions',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type MeetingScalarFieldEnum = (typeof MeetingScalarFieldEnum)[keyof typeof MeetingScalarFieldEnum]


  export const WellBeingEntryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    morningEnergy: 'morningEnergy',
    afternoonEnergy: 'afternoonEnergy',
    eveningEnergy: 'eveningEnergy',
    averageEnergy: 'averageEnergy',
    exerciseMinutes: 'exerciseMinutes',
    exerciseType: 'exerciseType',
    readingMinutes: 'readingMinutes',
    learningMinutes: 'learningMinutes',
    meditationMinutes: 'meditationMinutes',
    sleepHours: 'sleepHours',
    sleepQuality: 'sleepQuality',
    morningJournal: 'morningJournal',
    eveningReflection: 'eveningReflection',
    gratitude: 'gratitude',
    dailyWin: 'dailyWin',
    mood: 'mood',
    stressLevel: 'stressLevel',
    focusQuality: 'focusQuality',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type WellBeingEntryScalarFieldEnum = (typeof WellBeingEntryScalarFieldEnum)[keyof typeof WellBeingEntryScalarFieldEnum]


  export const CaptureScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    content: 'content',
    transcription: 'transcription',
    status: 'status',
    convertedToTaskId: 'convertedToTaskId',
    convertedToNoteId: 'convertedToNoteId',
    suggestedProject: 'suggestedProject',
    suggestedDueDate: 'suggestedDueDate',
    suggestedPriority: 'suggestedPriority',
    tags: 'tags',
    createdAt: 'createdAt',
    processedAt: 'processedAt'
  };

  export type CaptureScalarFieldEnum = (typeof CaptureScalarFieldEnum)[keyof typeof CaptureScalarFieldEnum]


  export const VoiceSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    duration: 'duration',
    recordedAt: 'recordedAt',
    audioFileUrl: 'audioFileUrl',
    waveformData: 'waveformData',
    transcription: 'transcription',
    speakers: 'speakers',
    timestamps: 'timestamps',
    summary: 'summary',
    keyPoints: 'keyPoints',
    actionItems: 'actionItems',
    projectId: 'projectId',
    tags: 'tags',
    processed: 'processed',
    archivedAt: 'archivedAt',
    createdAt: 'createdAt'
  };

  export type VoiceSessionScalarFieldEnum = (typeof VoiceSessionScalarFieldEnum)[keyof typeof VoiceSessionScalarFieldEnum]


  export const CalendarEventScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    description: 'description',
    startTime: 'startTime',
    endTime: 'endTime',
    allDay: 'allDay',
    timezone: 'timezone',
    isRecurring: 'isRecurring',
    recurrenceRule: 'recurrenceRule',
    projectId: 'projectId',
    taskId: 'taskId',
    clientId: 'clientId',
    meetingId: 'meetingId',
    type: 'type',
    reminders: 'reminders',
    color: 'color',
    location: 'location',
    attendees: 'attendees',
    externalCalendarId: 'externalCalendarId',
    externalEventId: 'externalEventId',
    syncStatus: 'syncStatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CalendarEventScalarFieldEnum = (typeof CalendarEventScalarFieldEnum)[keyof typeof CalendarEventScalarFieldEnum]


  export const AnalyticsEventScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    eventType: 'eventType',
    eventData: 'eventData',
    sessionId: 'sessionId',
    createdAt: 'createdAt'
  };

  export type AnalyticsEventScalarFieldEnum = (typeof AnalyticsEventScalarFieldEnum)[keyof typeof AnalyticsEventScalarFieldEnum]


  export const ResearchScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    scope: 'scope',
    searchMethod: 'searchMethod',
    status: 'status',
    originalPrompt: 'originalPrompt',
    refinedPrompt: 'refinedPrompt',
    rawData: 'rawData',
    progress: 'progress',
    errorMessage: 'errorMessage',
    goalId: 'goalId',
    isFavorited: 'isFavorited',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    completedAt: 'completedAt'
  };

  export type ResearchScalarFieldEnum = (typeof ResearchScalarFieldEnum)[keyof typeof ResearchScalarFieldEnum]


  export const ResearchSourceScalarFieldEnum: {
    id: 'id',
    researchId: 'researchId',
    url: 'url',
    title: 'title',
    content: 'content',
    excerpt: 'excerpt',
    credibility: 'credibility',
    citedInSections: 'citedInSections',
    scrapedAt: 'scrapedAt'
  };

  export type ResearchSourceScalarFieldEnum = (typeof ResearchSourceScalarFieldEnum)[keyof typeof ResearchSourceScalarFieldEnum]


  export const ResearchInsightScalarFieldEnum: {
    id: 'id',
    researchId: 'researchId',
    title: 'title',
    content: 'content',
    category: 'category',
    visualData: 'visualData',
    confidence: 'confidence',
    order: 'order',
    createdAt: 'createdAt'
  };

  export type ResearchInsightScalarFieldEnum = (typeof ResearchInsightScalarFieldEnum)[keyof typeof ResearchInsightScalarFieldEnum]


  export const ActionItemScalarFieldEnum: {
    id: 'id',
    researchId: 'researchId',
    description: 'description',
    priority: 'priority',
    effort: 'effort',
    convertedToTaskId: 'convertedToTaskId',
    convertedAt: 'convertedAt',
    createdAt: 'createdAt'
  };

  export type ActionItemScalarFieldEnum = (typeof ActionItemScalarFieldEnum)[keyof typeof ActionItemScalarFieldEnum]


  export const LeadDataScalarFieldEnum: {
    id: 'id',
    researchId: 'researchId',
    totalFound: 'totalFound',
    exportedAt: 'exportedAt'
  };

  export type LeadDataScalarFieldEnum = (typeof LeadDataScalarFieldEnum)[keyof typeof LeadDataScalarFieldEnum]


  export const LeadScalarFieldEnum: {
    id: 'id',
    leadDataId: 'leadDataId',
    name: 'name',
    company: 'company',
    email: 'email',
    phone: 'phone',
    website: 'website',
    industry: 'industry',
    location: 'location',
    painPoints: 'painPoints',
    suggestedDM: 'suggestedDM',
    suggestedEmail: 'suggestedEmail',
    personalization: 'personalization',
    contacted: 'contacted',
    contactedAt: 'contactedAt',
    createdAt: 'createdAt'
  };

  export type LeadScalarFieldEnum = (typeof LeadScalarFieldEnum)[keyof typeof LeadScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Json[]'
   */
  export type ListJsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json[]'>
    


  /**
   * Reference to a field of type 'ResearchScope'
   */
  export type EnumResearchScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResearchScope'>
    


  /**
   * Reference to a field of type 'ResearchScope[]'
   */
  export type ListEnumResearchScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResearchScope[]'>
    


  /**
   * Reference to a field of type 'SearchMethod'
   */
  export type EnumSearchMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SearchMethod'>
    


  /**
   * Reference to a field of type 'SearchMethod[]'
   */
  export type ListEnumSearchMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SearchMethod[]'>
    


  /**
   * Reference to a field of type 'ResearchStatus'
   */
  export type EnumResearchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResearchStatus'>
    


  /**
   * Reference to a field of type 'ResearchStatus[]'
   */
  export type ListEnumResearchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResearchStatus[]'>
    


  /**
   * Reference to a field of type 'ActionPriority'
   */
  export type EnumActionPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActionPriority'>
    


  /**
   * Reference to a field of type 'ActionPriority[]'
   */
  export type ListEnumActionPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActionPriority[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    timezone?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    geminiApiKey?: StringNullableFilter<"User"> | string | null
    geminiModel?: StringFilter<"User"> | string
    groqApiKey?: StringNullableFilter<"User"> | string | null
    llmProvider?: StringFilter<"User"> | string
    serperApiKey?: StringNullableFilter<"User"> | string | null
    researchLimit?: IntFilter<"User"> | number
    analyticsEvents?: AnalyticsEventListRelationFilter
    calendarEvents?: CalendarEventListRelationFilter
    captures?: CaptureListRelationFilter
    clients?: ClientListRelationFilter
    dayPlans?: DayPlanListRelationFilter
    meetings?: MeetingListRelationFilter
    notes?: NoteListRelationFilter
    projects?: ProjectListRelationFilter
    researches?: ResearchListRelationFilter
    tasks?: TaskListRelationFilter
    timeEntries?: TimeEntryListRelationFilter
    voiceSessions?: VoiceSessionListRelationFilter
    weekPlans?: WeekPlanListRelationFilter
    wellBeingEntries?: WellBeingEntryListRelationFilter
    yearPlans?: YearPlanListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    geminiApiKey?: SortOrderInput | SortOrder
    geminiModel?: SortOrder
    groqApiKey?: SortOrderInput | SortOrder
    llmProvider?: SortOrder
    serperApiKey?: SortOrderInput | SortOrder
    researchLimit?: SortOrder
    analyticsEvents?: AnalyticsEventOrderByRelationAggregateInput
    calendarEvents?: CalendarEventOrderByRelationAggregateInput
    captures?: CaptureOrderByRelationAggregateInput
    clients?: ClientOrderByRelationAggregateInput
    dayPlans?: DayPlanOrderByRelationAggregateInput
    meetings?: MeetingOrderByRelationAggregateInput
    notes?: NoteOrderByRelationAggregateInput
    projects?: ProjectOrderByRelationAggregateInput
    researches?: ResearchOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
    timeEntries?: TimeEntryOrderByRelationAggregateInput
    voiceSessions?: VoiceSessionOrderByRelationAggregateInput
    weekPlans?: WeekPlanOrderByRelationAggregateInput
    wellBeingEntries?: WellBeingEntryOrderByRelationAggregateInput
    yearPlans?: YearPlanOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    timezone?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    geminiApiKey?: StringNullableFilter<"User"> | string | null
    geminiModel?: StringFilter<"User"> | string
    groqApiKey?: StringNullableFilter<"User"> | string | null
    llmProvider?: StringFilter<"User"> | string
    serperApiKey?: StringNullableFilter<"User"> | string | null
    researchLimit?: IntFilter<"User"> | number
    analyticsEvents?: AnalyticsEventListRelationFilter
    calendarEvents?: CalendarEventListRelationFilter
    captures?: CaptureListRelationFilter
    clients?: ClientListRelationFilter
    dayPlans?: DayPlanListRelationFilter
    meetings?: MeetingListRelationFilter
    notes?: NoteListRelationFilter
    projects?: ProjectListRelationFilter
    researches?: ResearchListRelationFilter
    tasks?: TaskListRelationFilter
    timeEntries?: TimeEntryListRelationFilter
    voiceSessions?: VoiceSessionListRelationFilter
    weekPlans?: WeekPlanListRelationFilter
    wellBeingEntries?: WellBeingEntryListRelationFilter
    yearPlans?: YearPlanListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    geminiApiKey?: SortOrderInput | SortOrder
    geminiModel?: SortOrder
    groqApiKey?: SortOrderInput | SortOrder
    llmProvider?: SortOrder
    serperApiKey?: SortOrderInput | SortOrder
    researchLimit?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    timezone?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    geminiApiKey?: StringNullableWithAggregatesFilter<"User"> | string | null
    geminiModel?: StringWithAggregatesFilter<"User"> | string
    groqApiKey?: StringNullableWithAggregatesFilter<"User"> | string | null
    llmProvider?: StringWithAggregatesFilter<"User"> | string
    serperApiKey?: StringNullableWithAggregatesFilter<"User"> | string | null
    researchLimit?: IntWithAggregatesFilter<"User"> | number
  }

  export type YearPlanWhereInput = {
    AND?: YearPlanWhereInput | YearPlanWhereInput[]
    OR?: YearPlanWhereInput[]
    NOT?: YearPlanWhereInput | YearPlanWhereInput[]
    id?: StringFilter<"YearPlan"> | string
    userId?: StringFilter<"YearPlan"> | string
    year?: IntFilter<"YearPlan"> | number
    theme?: StringFilter<"YearPlan"> | string
    vision?: StringFilter<"YearPlan"> | string
    focusAreas?: StringNullableListFilter<"YearPlan">
    createdAt?: DateTimeFilter<"YearPlan"> | Date | string
    updatedAt?: DateTimeFilter<"YearPlan"> | Date | string
    status?: StringFilter<"YearPlan"> | string
    goals?: GoalListRelationFilter
    quarterPlans?: QuarterPlanListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type YearPlanOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    theme?: SortOrder
    vision?: SortOrder
    focusAreas?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    goals?: GoalOrderByRelationAggregateInput
    quarterPlans?: QuarterPlanOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type YearPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_year?: YearPlanUserIdYearCompoundUniqueInput
    AND?: YearPlanWhereInput | YearPlanWhereInput[]
    OR?: YearPlanWhereInput[]
    NOT?: YearPlanWhereInput | YearPlanWhereInput[]
    userId?: StringFilter<"YearPlan"> | string
    year?: IntFilter<"YearPlan"> | number
    theme?: StringFilter<"YearPlan"> | string
    vision?: StringFilter<"YearPlan"> | string
    focusAreas?: StringNullableListFilter<"YearPlan">
    createdAt?: DateTimeFilter<"YearPlan"> | Date | string
    updatedAt?: DateTimeFilter<"YearPlan"> | Date | string
    status?: StringFilter<"YearPlan"> | string
    goals?: GoalListRelationFilter
    quarterPlans?: QuarterPlanListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_year">

  export type YearPlanOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    theme?: SortOrder
    vision?: SortOrder
    focusAreas?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    _count?: YearPlanCountOrderByAggregateInput
    _avg?: YearPlanAvgOrderByAggregateInput
    _max?: YearPlanMaxOrderByAggregateInput
    _min?: YearPlanMinOrderByAggregateInput
    _sum?: YearPlanSumOrderByAggregateInput
  }

  export type YearPlanScalarWhereWithAggregatesInput = {
    AND?: YearPlanScalarWhereWithAggregatesInput | YearPlanScalarWhereWithAggregatesInput[]
    OR?: YearPlanScalarWhereWithAggregatesInput[]
    NOT?: YearPlanScalarWhereWithAggregatesInput | YearPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"YearPlan"> | string
    userId?: StringWithAggregatesFilter<"YearPlan"> | string
    year?: IntWithAggregatesFilter<"YearPlan"> | number
    theme?: StringWithAggregatesFilter<"YearPlan"> | string
    vision?: StringWithAggregatesFilter<"YearPlan"> | string
    focusAreas?: StringNullableListFilter<"YearPlan">
    createdAt?: DateTimeWithAggregatesFilter<"YearPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"YearPlan"> | Date | string
    status?: StringWithAggregatesFilter<"YearPlan"> | string
  }

  export type GoalWhereInput = {
    AND?: GoalWhereInput | GoalWhereInput[]
    OR?: GoalWhereInput[]
    NOT?: GoalWhereInput | GoalWhereInput[]
    id?: StringFilter<"Goal"> | string
    yearPlanId?: StringFilter<"Goal"> | string
    title?: StringFilter<"Goal"> | string
    description?: StringNullableFilter<"Goal"> | string | null
    category?: StringFilter<"Goal"> | string
    status?: StringFilter<"Goal"> | string
    createdAt?: DateTimeFilter<"Goal"> | Date | string
    updatedAt?: DateTimeFilter<"Goal"> | Date | string
    kpis?: StringNullableListFilter<"Goal">
    priority?: StringFilter<"Goal"> | string
    progress?: FloatFilter<"Goal"> | number
    risks?: StringNullableListFilter<"Goal">
    strategies?: StringNullableListFilter<"Goal">
    targetDate?: DateTimeNullableFilter<"Goal"> | Date | string | null
    yearPlan?: XOR<YearPlanScalarRelationFilter, YearPlanWhereInput>
    keySteps?: KeyStepListRelationFilter
    milestones?: MilestoneListRelationFilter
    notes?: NoteListRelationFilter
    quarterFocuses?: QuarterFocusListRelationFilter
    researches?: ResearchListRelationFilter
    tasks?: TaskListRelationFilter
  }

  export type GoalOrderByWithRelationInput = {
    id?: SortOrder
    yearPlanId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kpis?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
    risks?: SortOrder
    strategies?: SortOrder
    targetDate?: SortOrderInput | SortOrder
    yearPlan?: YearPlanOrderByWithRelationInput
    keySteps?: KeyStepOrderByRelationAggregateInput
    milestones?: MilestoneOrderByRelationAggregateInput
    notes?: NoteOrderByRelationAggregateInput
    quarterFocuses?: QuarterFocusOrderByRelationAggregateInput
    researches?: ResearchOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type GoalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GoalWhereInput | GoalWhereInput[]
    OR?: GoalWhereInput[]
    NOT?: GoalWhereInput | GoalWhereInput[]
    yearPlanId?: StringFilter<"Goal"> | string
    title?: StringFilter<"Goal"> | string
    description?: StringNullableFilter<"Goal"> | string | null
    category?: StringFilter<"Goal"> | string
    status?: StringFilter<"Goal"> | string
    createdAt?: DateTimeFilter<"Goal"> | Date | string
    updatedAt?: DateTimeFilter<"Goal"> | Date | string
    kpis?: StringNullableListFilter<"Goal">
    priority?: StringFilter<"Goal"> | string
    progress?: FloatFilter<"Goal"> | number
    risks?: StringNullableListFilter<"Goal">
    strategies?: StringNullableListFilter<"Goal">
    targetDate?: DateTimeNullableFilter<"Goal"> | Date | string | null
    yearPlan?: XOR<YearPlanScalarRelationFilter, YearPlanWhereInput>
    keySteps?: KeyStepListRelationFilter
    milestones?: MilestoneListRelationFilter
    notes?: NoteListRelationFilter
    quarterFocuses?: QuarterFocusListRelationFilter
    researches?: ResearchListRelationFilter
    tasks?: TaskListRelationFilter
  }, "id">

  export type GoalOrderByWithAggregationInput = {
    id?: SortOrder
    yearPlanId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kpis?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
    risks?: SortOrder
    strategies?: SortOrder
    targetDate?: SortOrderInput | SortOrder
    _count?: GoalCountOrderByAggregateInput
    _avg?: GoalAvgOrderByAggregateInput
    _max?: GoalMaxOrderByAggregateInput
    _min?: GoalMinOrderByAggregateInput
    _sum?: GoalSumOrderByAggregateInput
  }

  export type GoalScalarWhereWithAggregatesInput = {
    AND?: GoalScalarWhereWithAggregatesInput | GoalScalarWhereWithAggregatesInput[]
    OR?: GoalScalarWhereWithAggregatesInput[]
    NOT?: GoalScalarWhereWithAggregatesInput | GoalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Goal"> | string
    yearPlanId?: StringWithAggregatesFilter<"Goal"> | string
    title?: StringWithAggregatesFilter<"Goal"> | string
    description?: StringNullableWithAggregatesFilter<"Goal"> | string | null
    category?: StringWithAggregatesFilter<"Goal"> | string
    status?: StringWithAggregatesFilter<"Goal"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Goal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Goal"> | Date | string
    kpis?: StringNullableListFilter<"Goal">
    priority?: StringWithAggregatesFilter<"Goal"> | string
    progress?: FloatWithAggregatesFilter<"Goal"> | number
    risks?: StringNullableListFilter<"Goal">
    strategies?: StringNullableListFilter<"Goal">
    targetDate?: DateTimeNullableWithAggregatesFilter<"Goal"> | Date | string | null
  }

  export type MilestoneWhereInput = {
    AND?: MilestoneWhereInput | MilestoneWhereInput[]
    OR?: MilestoneWhereInput[]
    NOT?: MilestoneWhereInput | MilestoneWhereInput[]
    id?: StringFilter<"Milestone"> | string
    goalId?: StringFilter<"Milestone"> | string
    title?: StringFilter<"Milestone"> | string
    targetDate?: DateTimeNullableFilter<"Milestone"> | Date | string | null
    completed?: BoolFilter<"Milestone"> | boolean
    completedAt?: DateTimeNullableFilter<"Milestone"> | Date | string | null
    createdAt?: DateTimeFilter<"Milestone"> | Date | string
    goal?: XOR<GoalScalarRelationFilter, GoalWhereInput>
  }

  export type MilestoneOrderByWithRelationInput = {
    id?: SortOrder
    goalId?: SortOrder
    title?: SortOrder
    targetDate?: SortOrderInput | SortOrder
    completed?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    goal?: GoalOrderByWithRelationInput
  }

  export type MilestoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MilestoneWhereInput | MilestoneWhereInput[]
    OR?: MilestoneWhereInput[]
    NOT?: MilestoneWhereInput | MilestoneWhereInput[]
    goalId?: StringFilter<"Milestone"> | string
    title?: StringFilter<"Milestone"> | string
    targetDate?: DateTimeNullableFilter<"Milestone"> | Date | string | null
    completed?: BoolFilter<"Milestone"> | boolean
    completedAt?: DateTimeNullableFilter<"Milestone"> | Date | string | null
    createdAt?: DateTimeFilter<"Milestone"> | Date | string
    goal?: XOR<GoalScalarRelationFilter, GoalWhereInput>
  }, "id">

  export type MilestoneOrderByWithAggregationInput = {
    id?: SortOrder
    goalId?: SortOrder
    title?: SortOrder
    targetDate?: SortOrderInput | SortOrder
    completed?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MilestoneCountOrderByAggregateInput
    _max?: MilestoneMaxOrderByAggregateInput
    _min?: MilestoneMinOrderByAggregateInput
  }

  export type MilestoneScalarWhereWithAggregatesInput = {
    AND?: MilestoneScalarWhereWithAggregatesInput | MilestoneScalarWhereWithAggregatesInput[]
    OR?: MilestoneScalarWhereWithAggregatesInput[]
    NOT?: MilestoneScalarWhereWithAggregatesInput | MilestoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Milestone"> | string
    goalId?: StringWithAggregatesFilter<"Milestone"> | string
    title?: StringWithAggregatesFilter<"Milestone"> | string
    targetDate?: DateTimeNullableWithAggregatesFilter<"Milestone"> | Date | string | null
    completed?: BoolWithAggregatesFilter<"Milestone"> | boolean
    completedAt?: DateTimeNullableWithAggregatesFilter<"Milestone"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Milestone"> | Date | string
  }

  export type KeyStepWhereInput = {
    AND?: KeyStepWhereInput | KeyStepWhereInput[]
    OR?: KeyStepWhereInput[]
    NOT?: KeyStepWhereInput | KeyStepWhereInput[]
    id?: StringFilter<"KeyStep"> | string
    goalId?: StringFilter<"KeyStep"> | string
    title?: StringFilter<"KeyStep"> | string
    description?: StringNullableFilter<"KeyStep"> | string | null
    order?: IntFilter<"KeyStep"> | number
    completed?: BoolFilter<"KeyStep"> | boolean
    completedAt?: DateTimeNullableFilter<"KeyStep"> | Date | string | null
    progress?: FloatFilter<"KeyStep"> | number
    targetDate?: DateTimeNullableFilter<"KeyStep"> | Date | string | null
    createdAt?: DateTimeFilter<"KeyStep"> | Date | string
    updatedAt?: DateTimeFilter<"KeyStep"> | Date | string
    goal?: XOR<GoalScalarRelationFilter, GoalWhereInput>
    notes?: NoteListRelationFilter
    tasks?: TaskListRelationFilter
  }

  export type KeyStepOrderByWithRelationInput = {
    id?: SortOrder
    goalId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    progress?: SortOrder
    targetDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    goal?: GoalOrderByWithRelationInput
    notes?: NoteOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type KeyStepWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KeyStepWhereInput | KeyStepWhereInput[]
    OR?: KeyStepWhereInput[]
    NOT?: KeyStepWhereInput | KeyStepWhereInput[]
    goalId?: StringFilter<"KeyStep"> | string
    title?: StringFilter<"KeyStep"> | string
    description?: StringNullableFilter<"KeyStep"> | string | null
    order?: IntFilter<"KeyStep"> | number
    completed?: BoolFilter<"KeyStep"> | boolean
    completedAt?: DateTimeNullableFilter<"KeyStep"> | Date | string | null
    progress?: FloatFilter<"KeyStep"> | number
    targetDate?: DateTimeNullableFilter<"KeyStep"> | Date | string | null
    createdAt?: DateTimeFilter<"KeyStep"> | Date | string
    updatedAt?: DateTimeFilter<"KeyStep"> | Date | string
    goal?: XOR<GoalScalarRelationFilter, GoalWhereInput>
    notes?: NoteListRelationFilter
    tasks?: TaskListRelationFilter
  }, "id">

  export type KeyStepOrderByWithAggregationInput = {
    id?: SortOrder
    goalId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    progress?: SortOrder
    targetDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KeyStepCountOrderByAggregateInput
    _avg?: KeyStepAvgOrderByAggregateInput
    _max?: KeyStepMaxOrderByAggregateInput
    _min?: KeyStepMinOrderByAggregateInput
    _sum?: KeyStepSumOrderByAggregateInput
  }

  export type KeyStepScalarWhereWithAggregatesInput = {
    AND?: KeyStepScalarWhereWithAggregatesInput | KeyStepScalarWhereWithAggregatesInput[]
    OR?: KeyStepScalarWhereWithAggregatesInput[]
    NOT?: KeyStepScalarWhereWithAggregatesInput | KeyStepScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KeyStep"> | string
    goalId?: StringWithAggregatesFilter<"KeyStep"> | string
    title?: StringWithAggregatesFilter<"KeyStep"> | string
    description?: StringNullableWithAggregatesFilter<"KeyStep"> | string | null
    order?: IntWithAggregatesFilter<"KeyStep"> | number
    completed?: BoolWithAggregatesFilter<"KeyStep"> | boolean
    completedAt?: DateTimeNullableWithAggregatesFilter<"KeyStep"> | Date | string | null
    progress?: FloatWithAggregatesFilter<"KeyStep"> | number
    targetDate?: DateTimeNullableWithAggregatesFilter<"KeyStep"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"KeyStep"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KeyStep"> | Date | string
  }

  export type NoteWhereInput = {
    AND?: NoteWhereInput | NoteWhereInput[]
    OR?: NoteWhereInput[]
    NOT?: NoteWhereInput | NoteWhereInput[]
    id?: StringFilter<"Note"> | string
    userId?: StringFilter<"Note"> | string
    content?: StringFilter<"Note"> | string
    goalId?: StringNullableFilter<"Note"> | string | null
    keyStepId?: StringNullableFilter<"Note"> | string | null
    dayPlanId?: StringNullableFilter<"Note"> | string | null
    createdAt?: DateTimeFilter<"Note"> | Date | string
    updatedAt?: DateTimeFilter<"Note"> | Date | string
    dayPlan?: XOR<DayPlanNullableScalarRelationFilter, DayPlanWhereInput> | null
    goal?: XOR<GoalNullableScalarRelationFilter, GoalWhereInput> | null
    keyStep?: XOR<KeyStepNullableScalarRelationFilter, KeyStepWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NoteOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    goalId?: SortOrderInput | SortOrder
    keyStepId?: SortOrderInput | SortOrder
    dayPlanId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dayPlan?: DayPlanOrderByWithRelationInput
    goal?: GoalOrderByWithRelationInput
    keyStep?: KeyStepOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type NoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NoteWhereInput | NoteWhereInput[]
    OR?: NoteWhereInput[]
    NOT?: NoteWhereInput | NoteWhereInput[]
    userId?: StringFilter<"Note"> | string
    content?: StringFilter<"Note"> | string
    goalId?: StringNullableFilter<"Note"> | string | null
    keyStepId?: StringNullableFilter<"Note"> | string | null
    dayPlanId?: StringNullableFilter<"Note"> | string | null
    createdAt?: DateTimeFilter<"Note"> | Date | string
    updatedAt?: DateTimeFilter<"Note"> | Date | string
    dayPlan?: XOR<DayPlanNullableScalarRelationFilter, DayPlanWhereInput> | null
    goal?: XOR<GoalNullableScalarRelationFilter, GoalWhereInput> | null
    keyStep?: XOR<KeyStepNullableScalarRelationFilter, KeyStepWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NoteOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    goalId?: SortOrderInput | SortOrder
    keyStepId?: SortOrderInput | SortOrder
    dayPlanId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NoteCountOrderByAggregateInput
    _max?: NoteMaxOrderByAggregateInput
    _min?: NoteMinOrderByAggregateInput
  }

  export type NoteScalarWhereWithAggregatesInput = {
    AND?: NoteScalarWhereWithAggregatesInput | NoteScalarWhereWithAggregatesInput[]
    OR?: NoteScalarWhereWithAggregatesInput[]
    NOT?: NoteScalarWhereWithAggregatesInput | NoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Note"> | string
    userId?: StringWithAggregatesFilter<"Note"> | string
    content?: StringWithAggregatesFilter<"Note"> | string
    goalId?: StringNullableWithAggregatesFilter<"Note"> | string | null
    keyStepId?: StringNullableWithAggregatesFilter<"Note"> | string | null
    dayPlanId?: StringNullableWithAggregatesFilter<"Note"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Note"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Note"> | Date | string
  }

  export type QuarterPlanWhereInput = {
    AND?: QuarterPlanWhereInput | QuarterPlanWhereInput[]
    OR?: QuarterPlanWhereInput[]
    NOT?: QuarterPlanWhereInput | QuarterPlanWhereInput[]
    id?: StringFilter<"QuarterPlan"> | string
    yearPlanId?: StringFilter<"QuarterPlan"> | string
    quarter?: IntFilter<"QuarterPlan"> | number
    theme?: StringFilter<"QuarterPlan"> | string
    startDate?: DateTimeFilter<"QuarterPlan"> | Date | string
    endDate?: DateTimeFilter<"QuarterPlan"> | Date | string
    monthPlans?: MonthPlanListRelationFilter
    quarterFocuses?: QuarterFocusListRelationFilter
    objectives?: QuarterObjectiveListRelationFilter
    yearPlan?: XOR<YearPlanScalarRelationFilter, YearPlanWhereInput>
  }

  export type QuarterPlanOrderByWithRelationInput = {
    id?: SortOrder
    yearPlanId?: SortOrder
    quarter?: SortOrder
    theme?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    monthPlans?: MonthPlanOrderByRelationAggregateInput
    quarterFocuses?: QuarterFocusOrderByRelationAggregateInput
    objectives?: QuarterObjectiveOrderByRelationAggregateInput
    yearPlan?: YearPlanOrderByWithRelationInput
  }

  export type QuarterPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    yearPlanId_quarter?: QuarterPlanYearPlanIdQuarterCompoundUniqueInput
    AND?: QuarterPlanWhereInput | QuarterPlanWhereInput[]
    OR?: QuarterPlanWhereInput[]
    NOT?: QuarterPlanWhereInput | QuarterPlanWhereInput[]
    yearPlanId?: StringFilter<"QuarterPlan"> | string
    quarter?: IntFilter<"QuarterPlan"> | number
    theme?: StringFilter<"QuarterPlan"> | string
    startDate?: DateTimeFilter<"QuarterPlan"> | Date | string
    endDate?: DateTimeFilter<"QuarterPlan"> | Date | string
    monthPlans?: MonthPlanListRelationFilter
    quarterFocuses?: QuarterFocusListRelationFilter
    objectives?: QuarterObjectiveListRelationFilter
    yearPlan?: XOR<YearPlanScalarRelationFilter, YearPlanWhereInput>
  }, "id" | "yearPlanId_quarter">

  export type QuarterPlanOrderByWithAggregationInput = {
    id?: SortOrder
    yearPlanId?: SortOrder
    quarter?: SortOrder
    theme?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    _count?: QuarterPlanCountOrderByAggregateInput
    _avg?: QuarterPlanAvgOrderByAggregateInput
    _max?: QuarterPlanMaxOrderByAggregateInput
    _min?: QuarterPlanMinOrderByAggregateInput
    _sum?: QuarterPlanSumOrderByAggregateInput
  }

  export type QuarterPlanScalarWhereWithAggregatesInput = {
    AND?: QuarterPlanScalarWhereWithAggregatesInput | QuarterPlanScalarWhereWithAggregatesInput[]
    OR?: QuarterPlanScalarWhereWithAggregatesInput[]
    NOT?: QuarterPlanScalarWhereWithAggregatesInput | QuarterPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuarterPlan"> | string
    yearPlanId?: StringWithAggregatesFilter<"QuarterPlan"> | string
    quarter?: IntWithAggregatesFilter<"QuarterPlan"> | number
    theme?: StringWithAggregatesFilter<"QuarterPlan"> | string
    startDate?: DateTimeWithAggregatesFilter<"QuarterPlan"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"QuarterPlan"> | Date | string
  }

  export type QuarterObjectiveWhereInput = {
    AND?: QuarterObjectiveWhereInput | QuarterObjectiveWhereInput[]
    OR?: QuarterObjectiveWhereInput[]
    NOT?: QuarterObjectiveWhereInput | QuarterObjectiveWhereInput[]
    id?: StringFilter<"QuarterObjective"> | string
    quarterPlanId?: StringFilter<"QuarterObjective"> | string
    title?: StringFilter<"QuarterObjective"> | string
    description?: StringNullableFilter<"QuarterObjective"> | string | null
    status?: StringFilter<"QuarterObjective"> | string
    createdAt?: DateTimeFilter<"QuarterObjective"> | Date | string
    updatedAt?: DateTimeFilter<"QuarterObjective"> | Date | string
    quarterPlan?: XOR<QuarterPlanScalarRelationFilter, QuarterPlanWhereInput>
  }

  export type QuarterObjectiveOrderByWithRelationInput = {
    id?: SortOrder
    quarterPlanId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quarterPlan?: QuarterPlanOrderByWithRelationInput
  }

  export type QuarterObjectiveWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuarterObjectiveWhereInput | QuarterObjectiveWhereInput[]
    OR?: QuarterObjectiveWhereInput[]
    NOT?: QuarterObjectiveWhereInput | QuarterObjectiveWhereInput[]
    quarterPlanId?: StringFilter<"QuarterObjective"> | string
    title?: StringFilter<"QuarterObjective"> | string
    description?: StringNullableFilter<"QuarterObjective"> | string | null
    status?: StringFilter<"QuarterObjective"> | string
    createdAt?: DateTimeFilter<"QuarterObjective"> | Date | string
    updatedAt?: DateTimeFilter<"QuarterObjective"> | Date | string
    quarterPlan?: XOR<QuarterPlanScalarRelationFilter, QuarterPlanWhereInput>
  }, "id">

  export type QuarterObjectiveOrderByWithAggregationInput = {
    id?: SortOrder
    quarterPlanId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuarterObjectiveCountOrderByAggregateInput
    _max?: QuarterObjectiveMaxOrderByAggregateInput
    _min?: QuarterObjectiveMinOrderByAggregateInput
  }

  export type QuarterObjectiveScalarWhereWithAggregatesInput = {
    AND?: QuarterObjectiveScalarWhereWithAggregatesInput | QuarterObjectiveScalarWhereWithAggregatesInput[]
    OR?: QuarterObjectiveScalarWhereWithAggregatesInput[]
    NOT?: QuarterObjectiveScalarWhereWithAggregatesInput | QuarterObjectiveScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuarterObjective"> | string
    quarterPlanId?: StringWithAggregatesFilter<"QuarterObjective"> | string
    title?: StringWithAggregatesFilter<"QuarterObjective"> | string
    description?: StringNullableWithAggregatesFilter<"QuarterObjective"> | string | null
    status?: StringWithAggregatesFilter<"QuarterObjective"> | string
    createdAt?: DateTimeWithAggregatesFilter<"QuarterObjective"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QuarterObjective"> | Date | string
  }

  export type QuarterFocusWhereInput = {
    AND?: QuarterFocusWhereInput | QuarterFocusWhereInput[]
    OR?: QuarterFocusWhereInput[]
    NOT?: QuarterFocusWhereInput | QuarterFocusWhereInput[]
    id?: StringFilter<"QuarterFocus"> | string
    quarterPlanId?: StringFilter<"QuarterFocus"> | string
    goalId?: StringFilter<"QuarterFocus"> | string
    priority?: IntFilter<"QuarterFocus"> | number
    progress?: FloatFilter<"QuarterFocus"> | number
    notes?: StringNullableFilter<"QuarterFocus"> | string | null
    createdAt?: DateTimeFilter<"QuarterFocus"> | Date | string
    updatedAt?: DateTimeFilter<"QuarterFocus"> | Date | string
    monthFocuses?: MonthFocusListRelationFilter
    goal?: XOR<GoalScalarRelationFilter, GoalWhereInput>
    quarterPlan?: XOR<QuarterPlanScalarRelationFilter, QuarterPlanWhereInput>
  }

  export type QuarterFocusOrderByWithRelationInput = {
    id?: SortOrder
    quarterPlanId?: SortOrder
    goalId?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    monthFocuses?: MonthFocusOrderByRelationAggregateInput
    goal?: GoalOrderByWithRelationInput
    quarterPlan?: QuarterPlanOrderByWithRelationInput
  }

  export type QuarterFocusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    quarterPlanId_goalId?: QuarterFocusQuarterPlanIdGoalIdCompoundUniqueInput
    AND?: QuarterFocusWhereInput | QuarterFocusWhereInput[]
    OR?: QuarterFocusWhereInput[]
    NOT?: QuarterFocusWhereInput | QuarterFocusWhereInput[]
    quarterPlanId?: StringFilter<"QuarterFocus"> | string
    goalId?: StringFilter<"QuarterFocus"> | string
    priority?: IntFilter<"QuarterFocus"> | number
    progress?: FloatFilter<"QuarterFocus"> | number
    notes?: StringNullableFilter<"QuarterFocus"> | string | null
    createdAt?: DateTimeFilter<"QuarterFocus"> | Date | string
    updatedAt?: DateTimeFilter<"QuarterFocus"> | Date | string
    monthFocuses?: MonthFocusListRelationFilter
    goal?: XOR<GoalScalarRelationFilter, GoalWhereInput>
    quarterPlan?: XOR<QuarterPlanScalarRelationFilter, QuarterPlanWhereInput>
  }, "id" | "quarterPlanId_goalId">

  export type QuarterFocusOrderByWithAggregationInput = {
    id?: SortOrder
    quarterPlanId?: SortOrder
    goalId?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuarterFocusCountOrderByAggregateInput
    _avg?: QuarterFocusAvgOrderByAggregateInput
    _max?: QuarterFocusMaxOrderByAggregateInput
    _min?: QuarterFocusMinOrderByAggregateInput
    _sum?: QuarterFocusSumOrderByAggregateInput
  }

  export type QuarterFocusScalarWhereWithAggregatesInput = {
    AND?: QuarterFocusScalarWhereWithAggregatesInput | QuarterFocusScalarWhereWithAggregatesInput[]
    OR?: QuarterFocusScalarWhereWithAggregatesInput[]
    NOT?: QuarterFocusScalarWhereWithAggregatesInput | QuarterFocusScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuarterFocus"> | string
    quarterPlanId?: StringWithAggregatesFilter<"QuarterFocus"> | string
    goalId?: StringWithAggregatesFilter<"QuarterFocus"> | string
    priority?: IntWithAggregatesFilter<"QuarterFocus"> | number
    progress?: FloatWithAggregatesFilter<"QuarterFocus"> | number
    notes?: StringNullableWithAggregatesFilter<"QuarterFocus"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"QuarterFocus"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QuarterFocus"> | Date | string
  }

  export type MonthPlanWhereInput = {
    AND?: MonthPlanWhereInput | MonthPlanWhereInput[]
    OR?: MonthPlanWhereInput[]
    NOT?: MonthPlanWhereInput | MonthPlanWhereInput[]
    id?: StringFilter<"MonthPlan"> | string
    quarterPlanId?: StringFilter<"MonthPlan"> | string
    month?: IntFilter<"MonthPlan"> | number
    year?: IntFilter<"MonthPlan"> | number
    objectives?: StringNullableListFilter<"MonthPlan">
    completionRate?: FloatFilter<"MonthPlan"> | number
    energyRating?: FloatNullableFilter<"MonthPlan"> | number | null
    rating?: IntNullableFilter<"MonthPlan"> | number | null
    reviewNotes?: StringNullableFilter<"MonthPlan"> | string | null
    theme?: StringNullableFilter<"MonthPlan"> | string | null
    monthFocuses?: MonthFocusListRelationFilter
    quarterPlan?: XOR<QuarterPlanScalarRelationFilter, QuarterPlanWhereInput>
    weekPlans?: WeekPlanListRelationFilter
  }

  export type MonthPlanOrderByWithRelationInput = {
    id?: SortOrder
    quarterPlanId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    objectives?: SortOrder
    completionRate?: SortOrder
    energyRating?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    reviewNotes?: SortOrderInput | SortOrder
    theme?: SortOrderInput | SortOrder
    monthFocuses?: MonthFocusOrderByRelationAggregateInput
    quarterPlan?: QuarterPlanOrderByWithRelationInput
    weekPlans?: WeekPlanOrderByRelationAggregateInput
  }

  export type MonthPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    quarterPlanId_month?: MonthPlanQuarterPlanIdMonthCompoundUniqueInput
    AND?: MonthPlanWhereInput | MonthPlanWhereInput[]
    OR?: MonthPlanWhereInput[]
    NOT?: MonthPlanWhereInput | MonthPlanWhereInput[]
    quarterPlanId?: StringFilter<"MonthPlan"> | string
    month?: IntFilter<"MonthPlan"> | number
    year?: IntFilter<"MonthPlan"> | number
    objectives?: StringNullableListFilter<"MonthPlan">
    completionRate?: FloatFilter<"MonthPlan"> | number
    energyRating?: FloatNullableFilter<"MonthPlan"> | number | null
    rating?: IntNullableFilter<"MonthPlan"> | number | null
    reviewNotes?: StringNullableFilter<"MonthPlan"> | string | null
    theme?: StringNullableFilter<"MonthPlan"> | string | null
    monthFocuses?: MonthFocusListRelationFilter
    quarterPlan?: XOR<QuarterPlanScalarRelationFilter, QuarterPlanWhereInput>
    weekPlans?: WeekPlanListRelationFilter
  }, "id" | "quarterPlanId_month">

  export type MonthPlanOrderByWithAggregationInput = {
    id?: SortOrder
    quarterPlanId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    objectives?: SortOrder
    completionRate?: SortOrder
    energyRating?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    reviewNotes?: SortOrderInput | SortOrder
    theme?: SortOrderInput | SortOrder
    _count?: MonthPlanCountOrderByAggregateInput
    _avg?: MonthPlanAvgOrderByAggregateInput
    _max?: MonthPlanMaxOrderByAggregateInput
    _min?: MonthPlanMinOrderByAggregateInput
    _sum?: MonthPlanSumOrderByAggregateInput
  }

  export type MonthPlanScalarWhereWithAggregatesInput = {
    AND?: MonthPlanScalarWhereWithAggregatesInput | MonthPlanScalarWhereWithAggregatesInput[]
    OR?: MonthPlanScalarWhereWithAggregatesInput[]
    NOT?: MonthPlanScalarWhereWithAggregatesInput | MonthPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MonthPlan"> | string
    quarterPlanId?: StringWithAggregatesFilter<"MonthPlan"> | string
    month?: IntWithAggregatesFilter<"MonthPlan"> | number
    year?: IntWithAggregatesFilter<"MonthPlan"> | number
    objectives?: StringNullableListFilter<"MonthPlan">
    completionRate?: FloatWithAggregatesFilter<"MonthPlan"> | number
    energyRating?: FloatNullableWithAggregatesFilter<"MonthPlan"> | number | null
    rating?: IntNullableWithAggregatesFilter<"MonthPlan"> | number | null
    reviewNotes?: StringNullableWithAggregatesFilter<"MonthPlan"> | string | null
    theme?: StringNullableWithAggregatesFilter<"MonthPlan"> | string | null
  }

  export type MonthFocusWhereInput = {
    AND?: MonthFocusWhereInput | MonthFocusWhereInput[]
    OR?: MonthFocusWhereInput[]
    NOT?: MonthFocusWhereInput | MonthFocusWhereInput[]
    id?: StringFilter<"MonthFocus"> | string
    monthPlanId?: StringFilter<"MonthFocus"> | string
    quarterFocusId?: StringFilter<"MonthFocus"> | string
    priority?: IntFilter<"MonthFocus"> | number
    progress?: FloatFilter<"MonthFocus"> | number
    notes?: StringNullableFilter<"MonthFocus"> | string | null
    createdAt?: DateTimeFilter<"MonthFocus"> | Date | string
    updatedAt?: DateTimeFilter<"MonthFocus"> | Date | string
    monthPlan?: XOR<MonthPlanScalarRelationFilter, MonthPlanWhereInput>
    quarterFocus?: XOR<QuarterFocusScalarRelationFilter, QuarterFocusWhereInput>
    weekFocuses?: WeekFocusListRelationFilter
  }

  export type MonthFocusOrderByWithRelationInput = {
    id?: SortOrder
    monthPlanId?: SortOrder
    quarterFocusId?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    monthPlan?: MonthPlanOrderByWithRelationInput
    quarterFocus?: QuarterFocusOrderByWithRelationInput
    weekFocuses?: WeekFocusOrderByRelationAggregateInput
  }

  export type MonthFocusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    monthPlanId_quarterFocusId?: MonthFocusMonthPlanIdQuarterFocusIdCompoundUniqueInput
    AND?: MonthFocusWhereInput | MonthFocusWhereInput[]
    OR?: MonthFocusWhereInput[]
    NOT?: MonthFocusWhereInput | MonthFocusWhereInput[]
    monthPlanId?: StringFilter<"MonthFocus"> | string
    quarterFocusId?: StringFilter<"MonthFocus"> | string
    priority?: IntFilter<"MonthFocus"> | number
    progress?: FloatFilter<"MonthFocus"> | number
    notes?: StringNullableFilter<"MonthFocus"> | string | null
    createdAt?: DateTimeFilter<"MonthFocus"> | Date | string
    updatedAt?: DateTimeFilter<"MonthFocus"> | Date | string
    monthPlan?: XOR<MonthPlanScalarRelationFilter, MonthPlanWhereInput>
    quarterFocus?: XOR<QuarterFocusScalarRelationFilter, QuarterFocusWhereInput>
    weekFocuses?: WeekFocusListRelationFilter
  }, "id" | "monthPlanId_quarterFocusId">

  export type MonthFocusOrderByWithAggregationInput = {
    id?: SortOrder
    monthPlanId?: SortOrder
    quarterFocusId?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MonthFocusCountOrderByAggregateInput
    _avg?: MonthFocusAvgOrderByAggregateInput
    _max?: MonthFocusMaxOrderByAggregateInput
    _min?: MonthFocusMinOrderByAggregateInput
    _sum?: MonthFocusSumOrderByAggregateInput
  }

  export type MonthFocusScalarWhereWithAggregatesInput = {
    AND?: MonthFocusScalarWhereWithAggregatesInput | MonthFocusScalarWhereWithAggregatesInput[]
    OR?: MonthFocusScalarWhereWithAggregatesInput[]
    NOT?: MonthFocusScalarWhereWithAggregatesInput | MonthFocusScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MonthFocus"> | string
    monthPlanId?: StringWithAggregatesFilter<"MonthFocus"> | string
    quarterFocusId?: StringWithAggregatesFilter<"MonthFocus"> | string
    priority?: IntWithAggregatesFilter<"MonthFocus"> | number
    progress?: FloatWithAggregatesFilter<"MonthFocus"> | number
    notes?: StringNullableWithAggregatesFilter<"MonthFocus"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MonthFocus"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MonthFocus"> | Date | string
  }

  export type WeekPlanWhereInput = {
    AND?: WeekPlanWhereInput | WeekPlanWhereInput[]
    OR?: WeekPlanWhereInput[]
    NOT?: WeekPlanWhereInput | WeekPlanWhereInput[]
    id?: StringFilter<"WeekPlan"> | string
    monthPlanId?: StringFilter<"WeekPlan"> | string
    weekNumber?: IntFilter<"WeekPlan"> | number
    year?: IntFilter<"WeekPlan"> | number
    startDate?: DateTimeFilter<"WeekPlan"> | Date | string
    endDate?: DateTimeFilter<"WeekPlan"> | Date | string
    topOutcomes?: StringNullableListFilter<"WeekPlan">
    plannedClientHours?: FloatNullableFilter<"WeekPlan"> | number | null
    plannedPersonalHours?: FloatNullableFilter<"WeekPlan"> | number | null
    userId?: StringFilter<"WeekPlan"> | string
    challenges?: StringNullableListFilter<"WeekPlan">
    keyWins?: StringNullableListFilter<"WeekPlan">
    lessonsLearned?: StringNullableListFilter<"WeekPlan">
    rating?: IntNullableFilter<"WeekPlan"> | number | null
    reviewNotes?: StringNullableFilter<"WeekPlan"> | string | null
    dayPlans?: DayPlanListRelationFilter
    weekFocuses?: WeekFocusListRelationFilter
    monthPlan?: XOR<MonthPlanScalarRelationFilter, MonthPlanWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type WeekPlanOrderByWithRelationInput = {
    id?: SortOrder
    monthPlanId?: SortOrder
    weekNumber?: SortOrder
    year?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    topOutcomes?: SortOrder
    plannedClientHours?: SortOrderInput | SortOrder
    plannedPersonalHours?: SortOrderInput | SortOrder
    userId?: SortOrder
    challenges?: SortOrder
    keyWins?: SortOrder
    lessonsLearned?: SortOrder
    rating?: SortOrderInput | SortOrder
    reviewNotes?: SortOrderInput | SortOrder
    dayPlans?: DayPlanOrderByRelationAggregateInput
    weekFocuses?: WeekFocusOrderByRelationAggregateInput
    monthPlan?: MonthPlanOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type WeekPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WeekPlanWhereInput | WeekPlanWhereInput[]
    OR?: WeekPlanWhereInput[]
    NOT?: WeekPlanWhereInput | WeekPlanWhereInput[]
    monthPlanId?: StringFilter<"WeekPlan"> | string
    weekNumber?: IntFilter<"WeekPlan"> | number
    year?: IntFilter<"WeekPlan"> | number
    startDate?: DateTimeFilter<"WeekPlan"> | Date | string
    endDate?: DateTimeFilter<"WeekPlan"> | Date | string
    topOutcomes?: StringNullableListFilter<"WeekPlan">
    plannedClientHours?: FloatNullableFilter<"WeekPlan"> | number | null
    plannedPersonalHours?: FloatNullableFilter<"WeekPlan"> | number | null
    userId?: StringFilter<"WeekPlan"> | string
    challenges?: StringNullableListFilter<"WeekPlan">
    keyWins?: StringNullableListFilter<"WeekPlan">
    lessonsLearned?: StringNullableListFilter<"WeekPlan">
    rating?: IntNullableFilter<"WeekPlan"> | number | null
    reviewNotes?: StringNullableFilter<"WeekPlan"> | string | null
    dayPlans?: DayPlanListRelationFilter
    weekFocuses?: WeekFocusListRelationFilter
    monthPlan?: XOR<MonthPlanScalarRelationFilter, MonthPlanWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type WeekPlanOrderByWithAggregationInput = {
    id?: SortOrder
    monthPlanId?: SortOrder
    weekNumber?: SortOrder
    year?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    topOutcomes?: SortOrder
    plannedClientHours?: SortOrderInput | SortOrder
    plannedPersonalHours?: SortOrderInput | SortOrder
    userId?: SortOrder
    challenges?: SortOrder
    keyWins?: SortOrder
    lessonsLearned?: SortOrder
    rating?: SortOrderInput | SortOrder
    reviewNotes?: SortOrderInput | SortOrder
    _count?: WeekPlanCountOrderByAggregateInput
    _avg?: WeekPlanAvgOrderByAggregateInput
    _max?: WeekPlanMaxOrderByAggregateInput
    _min?: WeekPlanMinOrderByAggregateInput
    _sum?: WeekPlanSumOrderByAggregateInput
  }

  export type WeekPlanScalarWhereWithAggregatesInput = {
    AND?: WeekPlanScalarWhereWithAggregatesInput | WeekPlanScalarWhereWithAggregatesInput[]
    OR?: WeekPlanScalarWhereWithAggregatesInput[]
    NOT?: WeekPlanScalarWhereWithAggregatesInput | WeekPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WeekPlan"> | string
    monthPlanId?: StringWithAggregatesFilter<"WeekPlan"> | string
    weekNumber?: IntWithAggregatesFilter<"WeekPlan"> | number
    year?: IntWithAggregatesFilter<"WeekPlan"> | number
    startDate?: DateTimeWithAggregatesFilter<"WeekPlan"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"WeekPlan"> | Date | string
    topOutcomes?: StringNullableListFilter<"WeekPlan">
    plannedClientHours?: FloatNullableWithAggregatesFilter<"WeekPlan"> | number | null
    plannedPersonalHours?: FloatNullableWithAggregatesFilter<"WeekPlan"> | number | null
    userId?: StringWithAggregatesFilter<"WeekPlan"> | string
    challenges?: StringNullableListFilter<"WeekPlan">
    keyWins?: StringNullableListFilter<"WeekPlan">
    lessonsLearned?: StringNullableListFilter<"WeekPlan">
    rating?: IntNullableWithAggregatesFilter<"WeekPlan"> | number | null
    reviewNotes?: StringNullableWithAggregatesFilter<"WeekPlan"> | string | null
  }

  export type WeekFocusWhereInput = {
    AND?: WeekFocusWhereInput | WeekFocusWhereInput[]
    OR?: WeekFocusWhereInput[]
    NOT?: WeekFocusWhereInput | WeekFocusWhereInput[]
    id?: StringFilter<"WeekFocus"> | string
    weekPlanId?: StringFilter<"WeekFocus"> | string
    monthFocusId?: StringFilter<"WeekFocus"> | string
    priority?: IntFilter<"WeekFocus"> | number
    progress?: FloatFilter<"WeekFocus"> | number
    notes?: StringNullableFilter<"WeekFocus"> | string | null
    createdAt?: DateTimeFilter<"WeekFocus"> | Date | string
    updatedAt?: DateTimeFilter<"WeekFocus"> | Date | string
    dayFocuses?: DayFocusListRelationFilter
    monthFocus?: XOR<MonthFocusScalarRelationFilter, MonthFocusWhereInput>
    weekPlan?: XOR<WeekPlanScalarRelationFilter, WeekPlanWhereInput>
  }

  export type WeekFocusOrderByWithRelationInput = {
    id?: SortOrder
    weekPlanId?: SortOrder
    monthFocusId?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dayFocuses?: DayFocusOrderByRelationAggregateInput
    monthFocus?: MonthFocusOrderByWithRelationInput
    weekPlan?: WeekPlanOrderByWithRelationInput
  }

  export type WeekFocusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    weekPlanId_monthFocusId?: WeekFocusWeekPlanIdMonthFocusIdCompoundUniqueInput
    AND?: WeekFocusWhereInput | WeekFocusWhereInput[]
    OR?: WeekFocusWhereInput[]
    NOT?: WeekFocusWhereInput | WeekFocusWhereInput[]
    weekPlanId?: StringFilter<"WeekFocus"> | string
    monthFocusId?: StringFilter<"WeekFocus"> | string
    priority?: IntFilter<"WeekFocus"> | number
    progress?: FloatFilter<"WeekFocus"> | number
    notes?: StringNullableFilter<"WeekFocus"> | string | null
    createdAt?: DateTimeFilter<"WeekFocus"> | Date | string
    updatedAt?: DateTimeFilter<"WeekFocus"> | Date | string
    dayFocuses?: DayFocusListRelationFilter
    monthFocus?: XOR<MonthFocusScalarRelationFilter, MonthFocusWhereInput>
    weekPlan?: XOR<WeekPlanScalarRelationFilter, WeekPlanWhereInput>
  }, "id" | "weekPlanId_monthFocusId">

  export type WeekFocusOrderByWithAggregationInput = {
    id?: SortOrder
    weekPlanId?: SortOrder
    monthFocusId?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WeekFocusCountOrderByAggregateInput
    _avg?: WeekFocusAvgOrderByAggregateInput
    _max?: WeekFocusMaxOrderByAggregateInput
    _min?: WeekFocusMinOrderByAggregateInput
    _sum?: WeekFocusSumOrderByAggregateInput
  }

  export type WeekFocusScalarWhereWithAggregatesInput = {
    AND?: WeekFocusScalarWhereWithAggregatesInput | WeekFocusScalarWhereWithAggregatesInput[]
    OR?: WeekFocusScalarWhereWithAggregatesInput[]
    NOT?: WeekFocusScalarWhereWithAggregatesInput | WeekFocusScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WeekFocus"> | string
    weekPlanId?: StringWithAggregatesFilter<"WeekFocus"> | string
    monthFocusId?: StringWithAggregatesFilter<"WeekFocus"> | string
    priority?: IntWithAggregatesFilter<"WeekFocus"> | number
    progress?: FloatWithAggregatesFilter<"WeekFocus"> | number
    notes?: StringNullableWithAggregatesFilter<"WeekFocus"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WeekFocus"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WeekFocus"> | Date | string
  }

  export type DayPlanWhereInput = {
    AND?: DayPlanWhereInput | DayPlanWhereInput[]
    OR?: DayPlanWhereInput[]
    NOT?: DayPlanWhereInput | DayPlanWhereInput[]
    id?: StringFilter<"DayPlan"> | string
    weekPlanId?: StringFilter<"DayPlan"> | string
    date?: DateTimeFilter<"DayPlan"> | Date | string
    topPriorities?: StringNullableListFilter<"DayPlan">
    morningEnergy?: FloatNullableFilter<"DayPlan"> | number | null
    afternoonEnergy?: FloatNullableFilter<"DayPlan"> | number | null
    eveningEnergy?: FloatNullableFilter<"DayPlan"> | number | null
    dailyWin?: StringNullableFilter<"DayPlan"> | string | null
    gratitude?: StringNullableListFilter<"DayPlan">
    tomorrowPrep?: StringNullableListFilter<"DayPlan">
    completionRate?: FloatFilter<"DayPlan"> | number
    userId?: StringFilter<"DayPlan"> | string
    dayFocuses?: DayFocusListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    weekPlan?: XOR<WeekPlanScalarRelationFilter, WeekPlanWhereInput>
    notes?: NoteListRelationFilter
    timeBlocks?: TimeBlockListRelationFilter
  }

  export type DayPlanOrderByWithRelationInput = {
    id?: SortOrder
    weekPlanId?: SortOrder
    date?: SortOrder
    topPriorities?: SortOrder
    morningEnergy?: SortOrderInput | SortOrder
    afternoonEnergy?: SortOrderInput | SortOrder
    eveningEnergy?: SortOrderInput | SortOrder
    dailyWin?: SortOrderInput | SortOrder
    gratitude?: SortOrder
    tomorrowPrep?: SortOrder
    completionRate?: SortOrder
    userId?: SortOrder
    dayFocuses?: DayFocusOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    weekPlan?: WeekPlanOrderByWithRelationInput
    notes?: NoteOrderByRelationAggregateInput
    timeBlocks?: TimeBlockOrderByRelationAggregateInput
  }

  export type DayPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_date?: DayPlanUserIdDateCompoundUniqueInput
    AND?: DayPlanWhereInput | DayPlanWhereInput[]
    OR?: DayPlanWhereInput[]
    NOT?: DayPlanWhereInput | DayPlanWhereInput[]
    weekPlanId?: StringFilter<"DayPlan"> | string
    date?: DateTimeFilter<"DayPlan"> | Date | string
    topPriorities?: StringNullableListFilter<"DayPlan">
    morningEnergy?: FloatNullableFilter<"DayPlan"> | number | null
    afternoonEnergy?: FloatNullableFilter<"DayPlan"> | number | null
    eveningEnergy?: FloatNullableFilter<"DayPlan"> | number | null
    dailyWin?: StringNullableFilter<"DayPlan"> | string | null
    gratitude?: StringNullableListFilter<"DayPlan">
    tomorrowPrep?: StringNullableListFilter<"DayPlan">
    completionRate?: FloatFilter<"DayPlan"> | number
    userId?: StringFilter<"DayPlan"> | string
    dayFocuses?: DayFocusListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    weekPlan?: XOR<WeekPlanScalarRelationFilter, WeekPlanWhereInput>
    notes?: NoteListRelationFilter
    timeBlocks?: TimeBlockListRelationFilter
  }, "id" | "userId_date">

  export type DayPlanOrderByWithAggregationInput = {
    id?: SortOrder
    weekPlanId?: SortOrder
    date?: SortOrder
    topPriorities?: SortOrder
    morningEnergy?: SortOrderInput | SortOrder
    afternoonEnergy?: SortOrderInput | SortOrder
    eveningEnergy?: SortOrderInput | SortOrder
    dailyWin?: SortOrderInput | SortOrder
    gratitude?: SortOrder
    tomorrowPrep?: SortOrder
    completionRate?: SortOrder
    userId?: SortOrder
    _count?: DayPlanCountOrderByAggregateInput
    _avg?: DayPlanAvgOrderByAggregateInput
    _max?: DayPlanMaxOrderByAggregateInput
    _min?: DayPlanMinOrderByAggregateInput
    _sum?: DayPlanSumOrderByAggregateInput
  }

  export type DayPlanScalarWhereWithAggregatesInput = {
    AND?: DayPlanScalarWhereWithAggregatesInput | DayPlanScalarWhereWithAggregatesInput[]
    OR?: DayPlanScalarWhereWithAggregatesInput[]
    NOT?: DayPlanScalarWhereWithAggregatesInput | DayPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DayPlan"> | string
    weekPlanId?: StringWithAggregatesFilter<"DayPlan"> | string
    date?: DateTimeWithAggregatesFilter<"DayPlan"> | Date | string
    topPriorities?: StringNullableListFilter<"DayPlan">
    morningEnergy?: FloatNullableWithAggregatesFilter<"DayPlan"> | number | null
    afternoonEnergy?: FloatNullableWithAggregatesFilter<"DayPlan"> | number | null
    eveningEnergy?: FloatNullableWithAggregatesFilter<"DayPlan"> | number | null
    dailyWin?: StringNullableWithAggregatesFilter<"DayPlan"> | string | null
    gratitude?: StringNullableListFilter<"DayPlan">
    tomorrowPrep?: StringNullableListFilter<"DayPlan">
    completionRate?: FloatWithAggregatesFilter<"DayPlan"> | number
    userId?: StringWithAggregatesFilter<"DayPlan"> | string
  }

  export type DayFocusWhereInput = {
    AND?: DayFocusWhereInput | DayFocusWhereInput[]
    OR?: DayFocusWhereInput[]
    NOT?: DayFocusWhereInput | DayFocusWhereInput[]
    id?: StringFilter<"DayFocus"> | string
    dayPlanId?: StringFilter<"DayFocus"> | string
    weekFocusId?: StringFilter<"DayFocus"> | string
    priority?: IntFilter<"DayFocus"> | number
    completed?: BoolFilter<"DayFocus"> | boolean
    completedAt?: DateTimeNullableFilter<"DayFocus"> | Date | string | null
    notes?: StringNullableFilter<"DayFocus"> | string | null
    createdAt?: DateTimeFilter<"DayFocus"> | Date | string
    updatedAt?: DateTimeFilter<"DayFocus"> | Date | string
    dayPlan?: XOR<DayPlanScalarRelationFilter, DayPlanWhereInput>
    weekFocus?: XOR<WeekFocusScalarRelationFilter, WeekFocusWhereInput>
  }

  export type DayFocusOrderByWithRelationInput = {
    id?: SortOrder
    dayPlanId?: SortOrder
    weekFocusId?: SortOrder
    priority?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dayPlan?: DayPlanOrderByWithRelationInput
    weekFocus?: WeekFocusOrderByWithRelationInput
  }

  export type DayFocusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    dayPlanId_weekFocusId?: DayFocusDayPlanIdWeekFocusIdCompoundUniqueInput
    AND?: DayFocusWhereInput | DayFocusWhereInput[]
    OR?: DayFocusWhereInput[]
    NOT?: DayFocusWhereInput | DayFocusWhereInput[]
    dayPlanId?: StringFilter<"DayFocus"> | string
    weekFocusId?: StringFilter<"DayFocus"> | string
    priority?: IntFilter<"DayFocus"> | number
    completed?: BoolFilter<"DayFocus"> | boolean
    completedAt?: DateTimeNullableFilter<"DayFocus"> | Date | string | null
    notes?: StringNullableFilter<"DayFocus"> | string | null
    createdAt?: DateTimeFilter<"DayFocus"> | Date | string
    updatedAt?: DateTimeFilter<"DayFocus"> | Date | string
    dayPlan?: XOR<DayPlanScalarRelationFilter, DayPlanWhereInput>
    weekFocus?: XOR<WeekFocusScalarRelationFilter, WeekFocusWhereInput>
  }, "id" | "dayPlanId_weekFocusId">

  export type DayFocusOrderByWithAggregationInput = {
    id?: SortOrder
    dayPlanId?: SortOrder
    weekFocusId?: SortOrder
    priority?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DayFocusCountOrderByAggregateInput
    _avg?: DayFocusAvgOrderByAggregateInput
    _max?: DayFocusMaxOrderByAggregateInput
    _min?: DayFocusMinOrderByAggregateInput
    _sum?: DayFocusSumOrderByAggregateInput
  }

  export type DayFocusScalarWhereWithAggregatesInput = {
    AND?: DayFocusScalarWhereWithAggregatesInput | DayFocusScalarWhereWithAggregatesInput[]
    OR?: DayFocusScalarWhereWithAggregatesInput[]
    NOT?: DayFocusScalarWhereWithAggregatesInput | DayFocusScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DayFocus"> | string
    dayPlanId?: StringWithAggregatesFilter<"DayFocus"> | string
    weekFocusId?: StringWithAggregatesFilter<"DayFocus"> | string
    priority?: IntWithAggregatesFilter<"DayFocus"> | number
    completed?: BoolWithAggregatesFilter<"DayFocus"> | boolean
    completedAt?: DateTimeNullableWithAggregatesFilter<"DayFocus"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"DayFocus"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DayFocus"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DayFocus"> | Date | string
  }

  export type TimeBlockWhereInput = {
    AND?: TimeBlockWhereInput | TimeBlockWhereInput[]
    OR?: TimeBlockWhereInput[]
    NOT?: TimeBlockWhereInput | TimeBlockWhereInput[]
    id?: StringFilter<"TimeBlock"> | string
    dayPlanId?: StringFilter<"TimeBlock"> | string
    startTime?: DateTimeFilter<"TimeBlock"> | Date | string
    endTime?: DateTimeFilter<"TimeBlock"> | Date | string
    duration?: IntFilter<"TimeBlock"> | number
    type?: StringFilter<"TimeBlock"> | string
    taskId?: StringNullableFilter<"TimeBlock"> | string | null
    projectId?: StringNullableFilter<"TimeBlock"> | string | null
    clientId?: StringNullableFilter<"TimeBlock"> | string | null
    actualStartTime?: DateTimeNullableFilter<"TimeBlock"> | Date | string | null
    actualEndTime?: DateTimeNullableFilter<"TimeBlock"> | Date | string | null
    actualDuration?: IntNullableFilter<"TimeBlock"> | number | null
    energyBefore?: FloatNullableFilter<"TimeBlock"> | number | null
    energyAfter?: FloatNullableFilter<"TimeBlock"> | number | null
    focusQuality?: FloatNullableFilter<"TimeBlock"> | number | null
    notes?: StringNullableFilter<"TimeBlock"> | string | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    dayPlan?: XOR<DayPlanScalarRelationFilter, DayPlanWhereInput>
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    task?: XOR<TaskNullableScalarRelationFilter, TaskWhereInput> | null
  }

  export type TimeBlockOrderByWithRelationInput = {
    id?: SortOrder
    dayPlanId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    type?: SortOrder
    taskId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    actualStartTime?: SortOrderInput | SortOrder
    actualEndTime?: SortOrderInput | SortOrder
    actualDuration?: SortOrderInput | SortOrder
    energyBefore?: SortOrderInput | SortOrder
    energyAfter?: SortOrderInput | SortOrder
    focusQuality?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    client?: ClientOrderByWithRelationInput
    dayPlan?: DayPlanOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    task?: TaskOrderByWithRelationInput
  }

  export type TimeBlockWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TimeBlockWhereInput | TimeBlockWhereInput[]
    OR?: TimeBlockWhereInput[]
    NOT?: TimeBlockWhereInput | TimeBlockWhereInput[]
    dayPlanId?: StringFilter<"TimeBlock"> | string
    startTime?: DateTimeFilter<"TimeBlock"> | Date | string
    endTime?: DateTimeFilter<"TimeBlock"> | Date | string
    duration?: IntFilter<"TimeBlock"> | number
    type?: StringFilter<"TimeBlock"> | string
    taskId?: StringNullableFilter<"TimeBlock"> | string | null
    projectId?: StringNullableFilter<"TimeBlock"> | string | null
    clientId?: StringNullableFilter<"TimeBlock"> | string | null
    actualStartTime?: DateTimeNullableFilter<"TimeBlock"> | Date | string | null
    actualEndTime?: DateTimeNullableFilter<"TimeBlock"> | Date | string | null
    actualDuration?: IntNullableFilter<"TimeBlock"> | number | null
    energyBefore?: FloatNullableFilter<"TimeBlock"> | number | null
    energyAfter?: FloatNullableFilter<"TimeBlock"> | number | null
    focusQuality?: FloatNullableFilter<"TimeBlock"> | number | null
    notes?: StringNullableFilter<"TimeBlock"> | string | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    dayPlan?: XOR<DayPlanScalarRelationFilter, DayPlanWhereInput>
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    task?: XOR<TaskNullableScalarRelationFilter, TaskWhereInput> | null
  }, "id">

  export type TimeBlockOrderByWithAggregationInput = {
    id?: SortOrder
    dayPlanId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    type?: SortOrder
    taskId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    actualStartTime?: SortOrderInput | SortOrder
    actualEndTime?: SortOrderInput | SortOrder
    actualDuration?: SortOrderInput | SortOrder
    energyBefore?: SortOrderInput | SortOrder
    energyAfter?: SortOrderInput | SortOrder
    focusQuality?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: TimeBlockCountOrderByAggregateInput
    _avg?: TimeBlockAvgOrderByAggregateInput
    _max?: TimeBlockMaxOrderByAggregateInput
    _min?: TimeBlockMinOrderByAggregateInput
    _sum?: TimeBlockSumOrderByAggregateInput
  }

  export type TimeBlockScalarWhereWithAggregatesInput = {
    AND?: TimeBlockScalarWhereWithAggregatesInput | TimeBlockScalarWhereWithAggregatesInput[]
    OR?: TimeBlockScalarWhereWithAggregatesInput[]
    NOT?: TimeBlockScalarWhereWithAggregatesInput | TimeBlockScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TimeBlock"> | string
    dayPlanId?: StringWithAggregatesFilter<"TimeBlock"> | string
    startTime?: DateTimeWithAggregatesFilter<"TimeBlock"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"TimeBlock"> | Date | string
    duration?: IntWithAggregatesFilter<"TimeBlock"> | number
    type?: StringWithAggregatesFilter<"TimeBlock"> | string
    taskId?: StringNullableWithAggregatesFilter<"TimeBlock"> | string | null
    projectId?: StringNullableWithAggregatesFilter<"TimeBlock"> | string | null
    clientId?: StringNullableWithAggregatesFilter<"TimeBlock"> | string | null
    actualStartTime?: DateTimeNullableWithAggregatesFilter<"TimeBlock"> | Date | string | null
    actualEndTime?: DateTimeNullableWithAggregatesFilter<"TimeBlock"> | Date | string | null
    actualDuration?: IntNullableWithAggregatesFilter<"TimeBlock"> | number | null
    energyBefore?: FloatNullableWithAggregatesFilter<"TimeBlock"> | number | null
    energyAfter?: FloatNullableWithAggregatesFilter<"TimeBlock"> | number | null
    focusQuality?: FloatNullableWithAggregatesFilter<"TimeBlock"> | number | null
    notes?: StringNullableWithAggregatesFilter<"TimeBlock"> | string | null
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    userId?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    type?: StringFilter<"Project"> | string
    status?: StringFilter<"Project"> | string
    clientId?: StringNullableFilter<"Project"> | string | null
    billable?: BoolFilter<"Project"> | boolean
    hourlyRate?: FloatNullableFilter<"Project"> | number | null
    budgetHours?: FloatNullableFilter<"Project"> | number | null
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    deadline?: DateTimeNullableFilter<"Project"> | Date | string | null
    estimatedHours?: FloatNullableFilter<"Project"> | number | null
    actualHoursSpent?: FloatFilter<"Project"> | number
    completionPercentage?: FloatFilter<"Project"> | number
    goalId?: StringNullableFilter<"Project"> | string | null
    parentProjectId?: StringNullableFilter<"Project"> | string | null
    priority?: StringFilter<"Project"> | string
    tags?: StringNullableListFilter<"Project">
    color?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    completedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    archivedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    icon?: StringNullableFilter<"Project"> | string | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tasks?: TaskListRelationFilter
    timeBlocks?: TimeBlockListRelationFilter
    timeEntries?: TimeEntryListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    clientId?: SortOrderInput | SortOrder
    billable?: SortOrder
    hourlyRate?: SortOrderInput | SortOrder
    budgetHours?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    deadline?: SortOrderInput | SortOrder
    estimatedHours?: SortOrderInput | SortOrder
    actualHoursSpent?: SortOrder
    completionPercentage?: SortOrder
    goalId?: SortOrderInput | SortOrder
    parentProjectId?: SortOrderInput | SortOrder
    priority?: SortOrder
    tags?: SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    archivedAt?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    client?: ClientOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    tasks?: TaskOrderByRelationAggregateInput
    timeBlocks?: TimeBlockOrderByRelationAggregateInput
    timeEntries?: TimeEntryOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    userId?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    type?: StringFilter<"Project"> | string
    status?: StringFilter<"Project"> | string
    clientId?: StringNullableFilter<"Project"> | string | null
    billable?: BoolFilter<"Project"> | boolean
    hourlyRate?: FloatNullableFilter<"Project"> | number | null
    budgetHours?: FloatNullableFilter<"Project"> | number | null
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    deadline?: DateTimeNullableFilter<"Project"> | Date | string | null
    estimatedHours?: FloatNullableFilter<"Project"> | number | null
    actualHoursSpent?: FloatFilter<"Project"> | number
    completionPercentage?: FloatFilter<"Project"> | number
    goalId?: StringNullableFilter<"Project"> | string | null
    parentProjectId?: StringNullableFilter<"Project"> | string | null
    priority?: StringFilter<"Project"> | string
    tags?: StringNullableListFilter<"Project">
    color?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    completedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    archivedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    icon?: StringNullableFilter<"Project"> | string | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tasks?: TaskListRelationFilter
    timeBlocks?: TimeBlockListRelationFilter
    timeEntries?: TimeEntryListRelationFilter
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    clientId?: SortOrderInput | SortOrder
    billable?: SortOrder
    hourlyRate?: SortOrderInput | SortOrder
    budgetHours?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    deadline?: SortOrderInput | SortOrder
    estimatedHours?: SortOrderInput | SortOrder
    actualHoursSpent?: SortOrder
    completionPercentage?: SortOrder
    goalId?: SortOrderInput | SortOrder
    parentProjectId?: SortOrderInput | SortOrder
    priority?: SortOrder
    tags?: SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    archivedAt?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    userId?: StringWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    description?: StringNullableWithAggregatesFilter<"Project"> | string | null
    type?: StringWithAggregatesFilter<"Project"> | string
    status?: StringWithAggregatesFilter<"Project"> | string
    clientId?: StringNullableWithAggregatesFilter<"Project"> | string | null
    billable?: BoolWithAggregatesFilter<"Project"> | boolean
    hourlyRate?: FloatNullableWithAggregatesFilter<"Project"> | number | null
    budgetHours?: FloatNullableWithAggregatesFilter<"Project"> | number | null
    startDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    deadline?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    estimatedHours?: FloatNullableWithAggregatesFilter<"Project"> | number | null
    actualHoursSpent?: FloatWithAggregatesFilter<"Project"> | number
    completionPercentage?: FloatWithAggregatesFilter<"Project"> | number
    goalId?: StringNullableWithAggregatesFilter<"Project"> | string | null
    parentProjectId?: StringNullableWithAggregatesFilter<"Project"> | string | null
    priority?: StringWithAggregatesFilter<"Project"> | string
    tags?: StringNullableListFilter<"Project">
    color?: StringNullableWithAggregatesFilter<"Project"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    archivedAt?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    icon?: StringNullableWithAggregatesFilter<"Project"> | string | null
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    userId?: StringFilter<"Task"> | string
    projectId?: StringNullableFilter<"Task"> | string | null
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: StringFilter<"Task"> | string
    startedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    estimatedMinutes?: IntNullableFilter<"Task"> | number | null
    actualMinutes?: IntFilter<"Task"> | number
    timerRunning?: BoolFilter<"Task"> | boolean
    currentTimerStart?: DateTimeNullableFilter<"Task"> | Date | string | null
    scheduledDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    priority?: StringFilter<"Task"> | string
    type?: StringFilter<"Task"> | string
    tags?: StringNullableListFilter<"Task">
    parentTaskId?: StringNullableFilter<"Task"> | string | null
    dependsOn?: StringNullableListFilter<"Task">
    blocks?: StringNullableListFilter<"Task">
    energyRequired?: FloatNullableFilter<"Task"> | number | null
    isAdHoc?: BoolFilter<"Task"> | boolean
    isRecurring?: BoolFilter<"Task"> | boolean
    recurringPattern?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    meetingId?: StringNullableFilter<"Task"> | string | null
    goalId?: StringNullableFilter<"Task"> | string | null
    keyStepId?: StringNullableFilter<"Task"> | string | null
    actionItem?: XOR<ActionItemNullableScalarRelationFilter, ActionItemWhereInput> | null
    goal?: XOR<GoalNullableScalarRelationFilter, GoalWhereInput> | null
    keyStep?: XOR<KeyStepNullableScalarRelationFilter, KeyStepWhereInput> | null
    meeting?: XOR<MeetingNullableScalarRelationFilter, MeetingWhereInput> | null
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    timeBlocks?: TimeBlockListRelationFilter
    timeEntries?: TimeEntryListRelationFilter
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    estimatedMinutes?: SortOrderInput | SortOrder
    actualMinutes?: SortOrder
    timerRunning?: SortOrder
    currentTimerStart?: SortOrderInput | SortOrder
    scheduledDate?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    priority?: SortOrder
    type?: SortOrder
    tags?: SortOrder
    parentTaskId?: SortOrderInput | SortOrder
    dependsOn?: SortOrder
    blocks?: SortOrder
    energyRequired?: SortOrderInput | SortOrder
    isAdHoc?: SortOrder
    isRecurring?: SortOrder
    recurringPattern?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    meetingId?: SortOrderInput | SortOrder
    goalId?: SortOrderInput | SortOrder
    keyStepId?: SortOrderInput | SortOrder
    actionItem?: ActionItemOrderByWithRelationInput
    goal?: GoalOrderByWithRelationInput
    keyStep?: KeyStepOrderByWithRelationInput
    meeting?: MeetingOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    timeBlocks?: TimeBlockOrderByRelationAggregateInput
    timeEntries?: TimeEntryOrderByRelationAggregateInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    userId?: StringFilter<"Task"> | string
    projectId?: StringNullableFilter<"Task"> | string | null
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: StringFilter<"Task"> | string
    startedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    estimatedMinutes?: IntNullableFilter<"Task"> | number | null
    actualMinutes?: IntFilter<"Task"> | number
    timerRunning?: BoolFilter<"Task"> | boolean
    currentTimerStart?: DateTimeNullableFilter<"Task"> | Date | string | null
    scheduledDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    priority?: StringFilter<"Task"> | string
    type?: StringFilter<"Task"> | string
    tags?: StringNullableListFilter<"Task">
    parentTaskId?: StringNullableFilter<"Task"> | string | null
    dependsOn?: StringNullableListFilter<"Task">
    blocks?: StringNullableListFilter<"Task">
    energyRequired?: FloatNullableFilter<"Task"> | number | null
    isAdHoc?: BoolFilter<"Task"> | boolean
    isRecurring?: BoolFilter<"Task"> | boolean
    recurringPattern?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    meetingId?: StringNullableFilter<"Task"> | string | null
    goalId?: StringNullableFilter<"Task"> | string | null
    keyStepId?: StringNullableFilter<"Task"> | string | null
    actionItem?: XOR<ActionItemNullableScalarRelationFilter, ActionItemWhereInput> | null
    goal?: XOR<GoalNullableScalarRelationFilter, GoalWhereInput> | null
    keyStep?: XOR<KeyStepNullableScalarRelationFilter, KeyStepWhereInput> | null
    meeting?: XOR<MeetingNullableScalarRelationFilter, MeetingWhereInput> | null
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    timeBlocks?: TimeBlockListRelationFilter
    timeEntries?: TimeEntryListRelationFilter
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    estimatedMinutes?: SortOrderInput | SortOrder
    actualMinutes?: SortOrder
    timerRunning?: SortOrder
    currentTimerStart?: SortOrderInput | SortOrder
    scheduledDate?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    priority?: SortOrder
    type?: SortOrder
    tags?: SortOrder
    parentTaskId?: SortOrderInput | SortOrder
    dependsOn?: SortOrder
    blocks?: SortOrder
    energyRequired?: SortOrderInput | SortOrder
    isAdHoc?: SortOrder
    isRecurring?: SortOrder
    recurringPattern?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    meetingId?: SortOrderInput | SortOrder
    goalId?: SortOrderInput | SortOrder
    keyStepId?: SortOrderInput | SortOrder
    _count?: TaskCountOrderByAggregateInput
    _avg?: TaskAvgOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
    _sum?: TaskSumOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    userId?: StringWithAggregatesFilter<"Task"> | string
    projectId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    title?: StringWithAggregatesFilter<"Task"> | string
    description?: StringNullableWithAggregatesFilter<"Task"> | string | null
    status?: StringWithAggregatesFilter<"Task"> | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    estimatedMinutes?: IntNullableWithAggregatesFilter<"Task"> | number | null
    actualMinutes?: IntWithAggregatesFilter<"Task"> | number
    timerRunning?: BoolWithAggregatesFilter<"Task"> | boolean
    currentTimerStart?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    scheduledDate?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    priority?: StringWithAggregatesFilter<"Task"> | string
    type?: StringWithAggregatesFilter<"Task"> | string
    tags?: StringNullableListFilter<"Task">
    parentTaskId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    dependsOn?: StringNullableListFilter<"Task">
    blocks?: StringNullableListFilter<"Task">
    energyRequired?: FloatNullableWithAggregatesFilter<"Task"> | number | null
    isAdHoc?: BoolWithAggregatesFilter<"Task"> | boolean
    isRecurring?: BoolWithAggregatesFilter<"Task"> | boolean
    recurringPattern?: StringNullableWithAggregatesFilter<"Task"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    meetingId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    goalId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    keyStepId?: StringNullableWithAggregatesFilter<"Task"> | string | null
  }

  export type TimeEntryWhereInput = {
    AND?: TimeEntryWhereInput | TimeEntryWhereInput[]
    OR?: TimeEntryWhereInput[]
    NOT?: TimeEntryWhereInput | TimeEntryWhereInput[]
    id?: StringFilter<"TimeEntry"> | string
    userId?: StringFilter<"TimeEntry"> | string
    taskId?: StringNullableFilter<"TimeEntry"> | string | null
    projectId?: StringNullableFilter<"TimeEntry"> | string | null
    clientId?: StringNullableFilter<"TimeEntry"> | string | null
    startTime?: DateTimeFilter<"TimeEntry"> | Date | string
    endTime?: DateTimeNullableFilter<"TimeEntry"> | Date | string | null
    duration?: IntFilter<"TimeEntry"> | number
    type?: StringFilter<"TimeEntry"> | string
    description?: StringNullableFilter<"TimeEntry"> | string | null
    tags?: StringNullableListFilter<"TimeEntry">
    focusQuality?: FloatNullableFilter<"TimeEntry"> | number | null
    energyBefore?: FloatNullableFilter<"TimeEntry"> | number | null
    energyAfter?: FloatNullableFilter<"TimeEntry"> | number | null
    distractions?: IntFilter<"TimeEntry"> | number
    billable?: BoolFilter<"TimeEntry"> | boolean
    hourlyRate?: FloatNullableFilter<"TimeEntry"> | number | null
    amount?: FloatFilter<"TimeEntry"> | number
    invoiced?: BoolFilter<"TimeEntry"> | boolean
    createdAt?: DateTimeFilter<"TimeEntry"> | Date | string
    updatedAt?: DateTimeFilter<"TimeEntry"> | Date | string
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    task?: XOR<TaskNullableScalarRelationFilter, TaskWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TimeEntryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    taskId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    duration?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    tags?: SortOrder
    focusQuality?: SortOrderInput | SortOrder
    energyBefore?: SortOrderInput | SortOrder
    energyAfter?: SortOrderInput | SortOrder
    distractions?: SortOrder
    billable?: SortOrder
    hourlyRate?: SortOrderInput | SortOrder
    amount?: SortOrder
    invoiced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    task?: TaskOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TimeEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TimeEntryWhereInput | TimeEntryWhereInput[]
    OR?: TimeEntryWhereInput[]
    NOT?: TimeEntryWhereInput | TimeEntryWhereInput[]
    userId?: StringFilter<"TimeEntry"> | string
    taskId?: StringNullableFilter<"TimeEntry"> | string | null
    projectId?: StringNullableFilter<"TimeEntry"> | string | null
    clientId?: StringNullableFilter<"TimeEntry"> | string | null
    startTime?: DateTimeFilter<"TimeEntry"> | Date | string
    endTime?: DateTimeNullableFilter<"TimeEntry"> | Date | string | null
    duration?: IntFilter<"TimeEntry"> | number
    type?: StringFilter<"TimeEntry"> | string
    description?: StringNullableFilter<"TimeEntry"> | string | null
    tags?: StringNullableListFilter<"TimeEntry">
    focusQuality?: FloatNullableFilter<"TimeEntry"> | number | null
    energyBefore?: FloatNullableFilter<"TimeEntry"> | number | null
    energyAfter?: FloatNullableFilter<"TimeEntry"> | number | null
    distractions?: IntFilter<"TimeEntry"> | number
    billable?: BoolFilter<"TimeEntry"> | boolean
    hourlyRate?: FloatNullableFilter<"TimeEntry"> | number | null
    amount?: FloatFilter<"TimeEntry"> | number
    invoiced?: BoolFilter<"TimeEntry"> | boolean
    createdAt?: DateTimeFilter<"TimeEntry"> | Date | string
    updatedAt?: DateTimeFilter<"TimeEntry"> | Date | string
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    task?: XOR<TaskNullableScalarRelationFilter, TaskWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TimeEntryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    taskId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    duration?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    tags?: SortOrder
    focusQuality?: SortOrderInput | SortOrder
    energyBefore?: SortOrderInput | SortOrder
    energyAfter?: SortOrderInput | SortOrder
    distractions?: SortOrder
    billable?: SortOrder
    hourlyRate?: SortOrderInput | SortOrder
    amount?: SortOrder
    invoiced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TimeEntryCountOrderByAggregateInput
    _avg?: TimeEntryAvgOrderByAggregateInput
    _max?: TimeEntryMaxOrderByAggregateInput
    _min?: TimeEntryMinOrderByAggregateInput
    _sum?: TimeEntrySumOrderByAggregateInput
  }

  export type TimeEntryScalarWhereWithAggregatesInput = {
    AND?: TimeEntryScalarWhereWithAggregatesInput | TimeEntryScalarWhereWithAggregatesInput[]
    OR?: TimeEntryScalarWhereWithAggregatesInput[]
    NOT?: TimeEntryScalarWhereWithAggregatesInput | TimeEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TimeEntry"> | string
    userId?: StringWithAggregatesFilter<"TimeEntry"> | string
    taskId?: StringNullableWithAggregatesFilter<"TimeEntry"> | string | null
    projectId?: StringNullableWithAggregatesFilter<"TimeEntry"> | string | null
    clientId?: StringNullableWithAggregatesFilter<"TimeEntry"> | string | null
    startTime?: DateTimeWithAggregatesFilter<"TimeEntry"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"TimeEntry"> | Date | string | null
    duration?: IntWithAggregatesFilter<"TimeEntry"> | number
    type?: StringWithAggregatesFilter<"TimeEntry"> | string
    description?: StringNullableWithAggregatesFilter<"TimeEntry"> | string | null
    tags?: StringNullableListFilter<"TimeEntry">
    focusQuality?: FloatNullableWithAggregatesFilter<"TimeEntry"> | number | null
    energyBefore?: FloatNullableWithAggregatesFilter<"TimeEntry"> | number | null
    energyAfter?: FloatNullableWithAggregatesFilter<"TimeEntry"> | number | null
    distractions?: IntWithAggregatesFilter<"TimeEntry"> | number
    billable?: BoolWithAggregatesFilter<"TimeEntry"> | boolean
    hourlyRate?: FloatNullableWithAggregatesFilter<"TimeEntry"> | number | null
    amount?: FloatWithAggregatesFilter<"TimeEntry"> | number
    invoiced?: BoolWithAggregatesFilter<"TimeEntry"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TimeEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TimeEntry"> | Date | string
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: StringFilter<"Client"> | string
    userId?: StringFilter<"Client"> | string
    name?: StringFilter<"Client"> | string
    companyName?: StringNullableFilter<"Client"> | string | null
    email?: StringFilter<"Client"> | string
    phone?: StringNullableFilter<"Client"> | string | null
    primaryContact?: JsonNullableFilter<"Client">
    additionalContacts?: JsonNullableListFilter<"Client">
    industry?: StringNullableFilter<"Client"> | string | null
    website?: StringNullableFilter<"Client"> | string | null
    timezone?: StringNullableFilter<"Client"> | string | null
    relationshipHealth?: FloatNullableFilter<"Client"> | number | null
    lastContactedAt?: DateTimeNullableFilter<"Client"> | Date | string | null
    preferredCommunication?: StringNullableFilter<"Client"> | string | null
    defaultHourlyRate?: FloatNullableFilter<"Client"> | number | null
    paymentTerms?: StringNullableFilter<"Client"> | string | null
    outstandingBalance?: FloatFilter<"Client"> | number
    notes?: StringNullableFilter<"Client"> | string | null
    tags?: StringNullableListFilter<"Client">
    status?: StringFilter<"Client"> | string
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    lastInteractionAt?: DateTimeNullableFilter<"Client"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    communications?: CommunicationListRelationFilter
    meetings?: MeetingListRelationFilter
    projects?: ProjectListRelationFilter
    timeBlocks?: TimeBlockListRelationFilter
    timeEntries?: TimeEntryListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    companyName?: SortOrderInput | SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    primaryContact?: SortOrderInput | SortOrder
    additionalContacts?: SortOrder
    industry?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    relationshipHealth?: SortOrderInput | SortOrder
    lastContactedAt?: SortOrderInput | SortOrder
    preferredCommunication?: SortOrderInput | SortOrder
    defaultHourlyRate?: SortOrderInput | SortOrder
    paymentTerms?: SortOrderInput | SortOrder
    outstandingBalance?: SortOrder
    notes?: SortOrderInput | SortOrder
    tags?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastInteractionAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    communications?: CommunicationOrderByRelationAggregateInput
    meetings?: MeetingOrderByRelationAggregateInput
    projects?: ProjectOrderByRelationAggregateInput
    timeBlocks?: TimeBlockOrderByRelationAggregateInput
    timeEntries?: TimeEntryOrderByRelationAggregateInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    userId?: StringFilter<"Client"> | string
    name?: StringFilter<"Client"> | string
    companyName?: StringNullableFilter<"Client"> | string | null
    email?: StringFilter<"Client"> | string
    phone?: StringNullableFilter<"Client"> | string | null
    primaryContact?: JsonNullableFilter<"Client">
    additionalContacts?: JsonNullableListFilter<"Client">
    industry?: StringNullableFilter<"Client"> | string | null
    website?: StringNullableFilter<"Client"> | string | null
    timezone?: StringNullableFilter<"Client"> | string | null
    relationshipHealth?: FloatNullableFilter<"Client"> | number | null
    lastContactedAt?: DateTimeNullableFilter<"Client"> | Date | string | null
    preferredCommunication?: StringNullableFilter<"Client"> | string | null
    defaultHourlyRate?: FloatNullableFilter<"Client"> | number | null
    paymentTerms?: StringNullableFilter<"Client"> | string | null
    outstandingBalance?: FloatFilter<"Client"> | number
    notes?: StringNullableFilter<"Client"> | string | null
    tags?: StringNullableListFilter<"Client">
    status?: StringFilter<"Client"> | string
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    lastInteractionAt?: DateTimeNullableFilter<"Client"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    communications?: CommunicationListRelationFilter
    meetings?: MeetingListRelationFilter
    projects?: ProjectListRelationFilter
    timeBlocks?: TimeBlockListRelationFilter
    timeEntries?: TimeEntryListRelationFilter
  }, "id">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    companyName?: SortOrderInput | SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    primaryContact?: SortOrderInput | SortOrder
    additionalContacts?: SortOrder
    industry?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    relationshipHealth?: SortOrderInput | SortOrder
    lastContactedAt?: SortOrderInput | SortOrder
    preferredCommunication?: SortOrderInput | SortOrder
    defaultHourlyRate?: SortOrderInput | SortOrder
    paymentTerms?: SortOrderInput | SortOrder
    outstandingBalance?: SortOrder
    notes?: SortOrderInput | SortOrder
    tags?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastInteractionAt?: SortOrderInput | SortOrder
    _count?: ClientCountOrderByAggregateInput
    _avg?: ClientAvgOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
    _sum?: ClientSumOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Client"> | string
    userId?: StringWithAggregatesFilter<"Client"> | string
    name?: StringWithAggregatesFilter<"Client"> | string
    companyName?: StringNullableWithAggregatesFilter<"Client"> | string | null
    email?: StringWithAggregatesFilter<"Client"> | string
    phone?: StringNullableWithAggregatesFilter<"Client"> | string | null
    primaryContact?: JsonNullableWithAggregatesFilter<"Client">
    additionalContacts?: JsonNullableListFilter<"Client">
    industry?: StringNullableWithAggregatesFilter<"Client"> | string | null
    website?: StringNullableWithAggregatesFilter<"Client"> | string | null
    timezone?: StringNullableWithAggregatesFilter<"Client"> | string | null
    relationshipHealth?: FloatNullableWithAggregatesFilter<"Client"> | number | null
    lastContactedAt?: DateTimeNullableWithAggregatesFilter<"Client"> | Date | string | null
    preferredCommunication?: StringNullableWithAggregatesFilter<"Client"> | string | null
    defaultHourlyRate?: FloatNullableWithAggregatesFilter<"Client"> | number | null
    paymentTerms?: StringNullableWithAggregatesFilter<"Client"> | string | null
    outstandingBalance?: FloatWithAggregatesFilter<"Client"> | number
    notes?: StringNullableWithAggregatesFilter<"Client"> | string | null
    tags?: StringNullableListFilter<"Client">
    status?: StringWithAggregatesFilter<"Client"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    lastInteractionAt?: DateTimeNullableWithAggregatesFilter<"Client"> | Date | string | null
  }

  export type CommunicationWhereInput = {
    AND?: CommunicationWhereInput | CommunicationWhereInput[]
    OR?: CommunicationWhereInput[]
    NOT?: CommunicationWhereInput | CommunicationWhereInput[]
    id?: StringFilter<"Communication"> | string
    clientId?: StringFilter<"Communication"> | string
    projectId?: StringNullableFilter<"Communication"> | string | null
    type?: StringFilter<"Communication"> | string
    direction?: StringFilter<"Communication"> | string
    subject?: StringFilter<"Communication"> | string
    content?: StringFilter<"Communication"> | string
    summary?: StringNullableFilter<"Communication"> | string | null
    from?: StringNullableFilter<"Communication"> | string | null
    to?: StringNullableListFilter<"Communication">
    cc?: StringNullableListFilter<"Communication">
    attachments?: JsonNullableListFilter<"Communication">
    meetingDate?: DateTimeNullableFilter<"Communication"> | Date | string | null
    meetingDuration?: IntNullableFilter<"Communication"> | number | null
    attendees?: StringNullableListFilter<"Communication">
    meetingNotes?: StringNullableFilter<"Communication"> | string | null
    sentiment?: StringNullableFilter<"Communication"> | string | null
    requiresFollowUp?: BoolFilter<"Communication"> | boolean
    followUpDate?: DateTimeNullableFilter<"Communication"> | Date | string | null
    createdAt?: DateTimeFilter<"Communication"> | Date | string
    responseTime?: IntNullableFilter<"Communication"> | number | null
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }

  export type CommunicationOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    projectId?: SortOrderInput | SortOrder
    type?: SortOrder
    direction?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    summary?: SortOrderInput | SortOrder
    from?: SortOrderInput | SortOrder
    to?: SortOrder
    cc?: SortOrder
    attachments?: SortOrder
    meetingDate?: SortOrderInput | SortOrder
    meetingDuration?: SortOrderInput | SortOrder
    attendees?: SortOrder
    meetingNotes?: SortOrderInput | SortOrder
    sentiment?: SortOrderInput | SortOrder
    requiresFollowUp?: SortOrder
    followUpDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    responseTime?: SortOrderInput | SortOrder
    client?: ClientOrderByWithRelationInput
  }

  export type CommunicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommunicationWhereInput | CommunicationWhereInput[]
    OR?: CommunicationWhereInput[]
    NOT?: CommunicationWhereInput | CommunicationWhereInput[]
    clientId?: StringFilter<"Communication"> | string
    projectId?: StringNullableFilter<"Communication"> | string | null
    type?: StringFilter<"Communication"> | string
    direction?: StringFilter<"Communication"> | string
    subject?: StringFilter<"Communication"> | string
    content?: StringFilter<"Communication"> | string
    summary?: StringNullableFilter<"Communication"> | string | null
    from?: StringNullableFilter<"Communication"> | string | null
    to?: StringNullableListFilter<"Communication">
    cc?: StringNullableListFilter<"Communication">
    attachments?: JsonNullableListFilter<"Communication">
    meetingDate?: DateTimeNullableFilter<"Communication"> | Date | string | null
    meetingDuration?: IntNullableFilter<"Communication"> | number | null
    attendees?: StringNullableListFilter<"Communication">
    meetingNotes?: StringNullableFilter<"Communication"> | string | null
    sentiment?: StringNullableFilter<"Communication"> | string | null
    requiresFollowUp?: BoolFilter<"Communication"> | boolean
    followUpDate?: DateTimeNullableFilter<"Communication"> | Date | string | null
    createdAt?: DateTimeFilter<"Communication"> | Date | string
    responseTime?: IntNullableFilter<"Communication"> | number | null
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }, "id">

  export type CommunicationOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    projectId?: SortOrderInput | SortOrder
    type?: SortOrder
    direction?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    summary?: SortOrderInput | SortOrder
    from?: SortOrderInput | SortOrder
    to?: SortOrder
    cc?: SortOrder
    attachments?: SortOrder
    meetingDate?: SortOrderInput | SortOrder
    meetingDuration?: SortOrderInput | SortOrder
    attendees?: SortOrder
    meetingNotes?: SortOrderInput | SortOrder
    sentiment?: SortOrderInput | SortOrder
    requiresFollowUp?: SortOrder
    followUpDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    responseTime?: SortOrderInput | SortOrder
    _count?: CommunicationCountOrderByAggregateInput
    _avg?: CommunicationAvgOrderByAggregateInput
    _max?: CommunicationMaxOrderByAggregateInput
    _min?: CommunicationMinOrderByAggregateInput
    _sum?: CommunicationSumOrderByAggregateInput
  }

  export type CommunicationScalarWhereWithAggregatesInput = {
    AND?: CommunicationScalarWhereWithAggregatesInput | CommunicationScalarWhereWithAggregatesInput[]
    OR?: CommunicationScalarWhereWithAggregatesInput[]
    NOT?: CommunicationScalarWhereWithAggregatesInput | CommunicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Communication"> | string
    clientId?: StringWithAggregatesFilter<"Communication"> | string
    projectId?: StringNullableWithAggregatesFilter<"Communication"> | string | null
    type?: StringWithAggregatesFilter<"Communication"> | string
    direction?: StringWithAggregatesFilter<"Communication"> | string
    subject?: StringWithAggregatesFilter<"Communication"> | string
    content?: StringWithAggregatesFilter<"Communication"> | string
    summary?: StringNullableWithAggregatesFilter<"Communication"> | string | null
    from?: StringNullableWithAggregatesFilter<"Communication"> | string | null
    to?: StringNullableListFilter<"Communication">
    cc?: StringNullableListFilter<"Communication">
    attachments?: JsonNullableListFilter<"Communication">
    meetingDate?: DateTimeNullableWithAggregatesFilter<"Communication"> | Date | string | null
    meetingDuration?: IntNullableWithAggregatesFilter<"Communication"> | number | null
    attendees?: StringNullableListFilter<"Communication">
    meetingNotes?: StringNullableWithAggregatesFilter<"Communication"> | string | null
    sentiment?: StringNullableWithAggregatesFilter<"Communication"> | string | null
    requiresFollowUp?: BoolWithAggregatesFilter<"Communication"> | boolean
    followUpDate?: DateTimeNullableWithAggregatesFilter<"Communication"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Communication"> | Date | string
    responseTime?: IntNullableWithAggregatesFilter<"Communication"> | number | null
  }

  export type MeetingWhereInput = {
    AND?: MeetingWhereInput | MeetingWhereInput[]
    OR?: MeetingWhereInput[]
    NOT?: MeetingWhereInput | MeetingWhereInput[]
    id?: StringFilter<"Meeting"> | string
    clientId?: StringNullableFilter<"Meeting"> | string | null
    projectId?: StringNullableFilter<"Meeting"> | string | null
    title?: StringFilter<"Meeting"> | string
    description?: StringNullableFilter<"Meeting"> | string | null
    type?: StringFilter<"Meeting"> | string
    scheduledAt?: DateTimeFilter<"Meeting"> | Date | string
    duration?: IntFilter<"Meeting"> | number
    timezone?: StringFilter<"Meeting"> | string
    organizer?: StringFilter<"Meeting"> | string
    requiredAttendees?: StringNullableListFilter<"Meeting">
    optionalAttendees?: StringNullableListFilter<"Meeting">
    location?: StringNullableFilter<"Meeting"> | string | null
    meetingLink?: StringNullableFilter<"Meeting"> | string | null
    agenda?: StringNullableFilter<"Meeting"> | string | null
    meetingNotes?: StringNullableFilter<"Meeting"> | string | null
    actionItems?: JsonNullableListFilter<"Meeting">
    decisions?: StringNullableListFilter<"Meeting">
    status?: StringFilter<"Meeting"> | string
    createdAt?: DateTimeFilter<"Meeting"> | Date | string
    updatedAt?: DateTimeFilter<"Meeting"> | Date | string
    userId?: StringFilter<"Meeting"> | string
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tasks?: TaskListRelationFilter
  }

  export type MeetingOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    timezone?: SortOrder
    organizer?: SortOrder
    requiredAttendees?: SortOrder
    optionalAttendees?: SortOrder
    location?: SortOrderInput | SortOrder
    meetingLink?: SortOrderInput | SortOrder
    agenda?: SortOrderInput | SortOrder
    meetingNotes?: SortOrderInput | SortOrder
    actionItems?: SortOrder
    decisions?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    client?: ClientOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type MeetingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MeetingWhereInput | MeetingWhereInput[]
    OR?: MeetingWhereInput[]
    NOT?: MeetingWhereInput | MeetingWhereInput[]
    clientId?: StringNullableFilter<"Meeting"> | string | null
    projectId?: StringNullableFilter<"Meeting"> | string | null
    title?: StringFilter<"Meeting"> | string
    description?: StringNullableFilter<"Meeting"> | string | null
    type?: StringFilter<"Meeting"> | string
    scheduledAt?: DateTimeFilter<"Meeting"> | Date | string
    duration?: IntFilter<"Meeting"> | number
    timezone?: StringFilter<"Meeting"> | string
    organizer?: StringFilter<"Meeting"> | string
    requiredAttendees?: StringNullableListFilter<"Meeting">
    optionalAttendees?: StringNullableListFilter<"Meeting">
    location?: StringNullableFilter<"Meeting"> | string | null
    meetingLink?: StringNullableFilter<"Meeting"> | string | null
    agenda?: StringNullableFilter<"Meeting"> | string | null
    meetingNotes?: StringNullableFilter<"Meeting"> | string | null
    actionItems?: JsonNullableListFilter<"Meeting">
    decisions?: StringNullableListFilter<"Meeting">
    status?: StringFilter<"Meeting"> | string
    createdAt?: DateTimeFilter<"Meeting"> | Date | string
    updatedAt?: DateTimeFilter<"Meeting"> | Date | string
    userId?: StringFilter<"Meeting"> | string
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tasks?: TaskListRelationFilter
  }, "id">

  export type MeetingOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    timezone?: SortOrder
    organizer?: SortOrder
    requiredAttendees?: SortOrder
    optionalAttendees?: SortOrder
    location?: SortOrderInput | SortOrder
    meetingLink?: SortOrderInput | SortOrder
    agenda?: SortOrderInput | SortOrder
    meetingNotes?: SortOrderInput | SortOrder
    actionItems?: SortOrder
    decisions?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: MeetingCountOrderByAggregateInput
    _avg?: MeetingAvgOrderByAggregateInput
    _max?: MeetingMaxOrderByAggregateInput
    _min?: MeetingMinOrderByAggregateInput
    _sum?: MeetingSumOrderByAggregateInput
  }

  export type MeetingScalarWhereWithAggregatesInput = {
    AND?: MeetingScalarWhereWithAggregatesInput | MeetingScalarWhereWithAggregatesInput[]
    OR?: MeetingScalarWhereWithAggregatesInput[]
    NOT?: MeetingScalarWhereWithAggregatesInput | MeetingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Meeting"> | string
    clientId?: StringNullableWithAggregatesFilter<"Meeting"> | string | null
    projectId?: StringNullableWithAggregatesFilter<"Meeting"> | string | null
    title?: StringWithAggregatesFilter<"Meeting"> | string
    description?: StringNullableWithAggregatesFilter<"Meeting"> | string | null
    type?: StringWithAggregatesFilter<"Meeting"> | string
    scheduledAt?: DateTimeWithAggregatesFilter<"Meeting"> | Date | string
    duration?: IntWithAggregatesFilter<"Meeting"> | number
    timezone?: StringWithAggregatesFilter<"Meeting"> | string
    organizer?: StringWithAggregatesFilter<"Meeting"> | string
    requiredAttendees?: StringNullableListFilter<"Meeting">
    optionalAttendees?: StringNullableListFilter<"Meeting">
    location?: StringNullableWithAggregatesFilter<"Meeting"> | string | null
    meetingLink?: StringNullableWithAggregatesFilter<"Meeting"> | string | null
    agenda?: StringNullableWithAggregatesFilter<"Meeting"> | string | null
    meetingNotes?: StringNullableWithAggregatesFilter<"Meeting"> | string | null
    actionItems?: JsonNullableListFilter<"Meeting">
    decisions?: StringNullableListFilter<"Meeting">
    status?: StringWithAggregatesFilter<"Meeting"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Meeting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Meeting"> | Date | string
    userId?: StringWithAggregatesFilter<"Meeting"> | string
  }

  export type WellBeingEntryWhereInput = {
    AND?: WellBeingEntryWhereInput | WellBeingEntryWhereInput[]
    OR?: WellBeingEntryWhereInput[]
    NOT?: WellBeingEntryWhereInput | WellBeingEntryWhereInput[]
    id?: StringFilter<"WellBeingEntry"> | string
    userId?: StringFilter<"WellBeingEntry"> | string
    date?: DateTimeFilter<"WellBeingEntry"> | Date | string
    morningEnergy?: FloatNullableFilter<"WellBeingEntry"> | number | null
    afternoonEnergy?: FloatNullableFilter<"WellBeingEntry"> | number | null
    eveningEnergy?: FloatNullableFilter<"WellBeingEntry"> | number | null
    averageEnergy?: FloatNullableFilter<"WellBeingEntry"> | number | null
    exerciseMinutes?: IntFilter<"WellBeingEntry"> | number
    exerciseType?: StringNullableFilter<"WellBeingEntry"> | string | null
    readingMinutes?: IntFilter<"WellBeingEntry"> | number
    learningMinutes?: IntFilter<"WellBeingEntry"> | number
    meditationMinutes?: IntFilter<"WellBeingEntry"> | number
    sleepHours?: FloatNullableFilter<"WellBeingEntry"> | number | null
    sleepQuality?: FloatNullableFilter<"WellBeingEntry"> | number | null
    morningJournal?: StringNullableFilter<"WellBeingEntry"> | string | null
    eveningReflection?: StringNullableFilter<"WellBeingEntry"> | string | null
    gratitude?: StringNullableListFilter<"WellBeingEntry">
    dailyWin?: StringNullableFilter<"WellBeingEntry"> | string | null
    mood?: FloatNullableFilter<"WellBeingEntry"> | number | null
    stressLevel?: FloatNullableFilter<"WellBeingEntry"> | number | null
    focusQuality?: FloatNullableFilter<"WellBeingEntry"> | number | null
    notes?: StringNullableFilter<"WellBeingEntry"> | string | null
    createdAt?: DateTimeFilter<"WellBeingEntry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type WellBeingEntryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    morningEnergy?: SortOrderInput | SortOrder
    afternoonEnergy?: SortOrderInput | SortOrder
    eveningEnergy?: SortOrderInput | SortOrder
    averageEnergy?: SortOrderInput | SortOrder
    exerciseMinutes?: SortOrder
    exerciseType?: SortOrderInput | SortOrder
    readingMinutes?: SortOrder
    learningMinutes?: SortOrder
    meditationMinutes?: SortOrder
    sleepHours?: SortOrderInput | SortOrder
    sleepQuality?: SortOrderInput | SortOrder
    morningJournal?: SortOrderInput | SortOrder
    eveningReflection?: SortOrderInput | SortOrder
    gratitude?: SortOrder
    dailyWin?: SortOrderInput | SortOrder
    mood?: SortOrderInput | SortOrder
    stressLevel?: SortOrderInput | SortOrder
    focusQuality?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type WellBeingEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_date?: WellBeingEntryUserIdDateCompoundUniqueInput
    AND?: WellBeingEntryWhereInput | WellBeingEntryWhereInput[]
    OR?: WellBeingEntryWhereInput[]
    NOT?: WellBeingEntryWhereInput | WellBeingEntryWhereInput[]
    userId?: StringFilter<"WellBeingEntry"> | string
    date?: DateTimeFilter<"WellBeingEntry"> | Date | string
    morningEnergy?: FloatNullableFilter<"WellBeingEntry"> | number | null
    afternoonEnergy?: FloatNullableFilter<"WellBeingEntry"> | number | null
    eveningEnergy?: FloatNullableFilter<"WellBeingEntry"> | number | null
    averageEnergy?: FloatNullableFilter<"WellBeingEntry"> | number | null
    exerciseMinutes?: IntFilter<"WellBeingEntry"> | number
    exerciseType?: StringNullableFilter<"WellBeingEntry"> | string | null
    readingMinutes?: IntFilter<"WellBeingEntry"> | number
    learningMinutes?: IntFilter<"WellBeingEntry"> | number
    meditationMinutes?: IntFilter<"WellBeingEntry"> | number
    sleepHours?: FloatNullableFilter<"WellBeingEntry"> | number | null
    sleepQuality?: FloatNullableFilter<"WellBeingEntry"> | number | null
    morningJournal?: StringNullableFilter<"WellBeingEntry"> | string | null
    eveningReflection?: StringNullableFilter<"WellBeingEntry"> | string | null
    gratitude?: StringNullableListFilter<"WellBeingEntry">
    dailyWin?: StringNullableFilter<"WellBeingEntry"> | string | null
    mood?: FloatNullableFilter<"WellBeingEntry"> | number | null
    stressLevel?: FloatNullableFilter<"WellBeingEntry"> | number | null
    focusQuality?: FloatNullableFilter<"WellBeingEntry"> | number | null
    notes?: StringNullableFilter<"WellBeingEntry"> | string | null
    createdAt?: DateTimeFilter<"WellBeingEntry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_date">

  export type WellBeingEntryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    morningEnergy?: SortOrderInput | SortOrder
    afternoonEnergy?: SortOrderInput | SortOrder
    eveningEnergy?: SortOrderInput | SortOrder
    averageEnergy?: SortOrderInput | SortOrder
    exerciseMinutes?: SortOrder
    exerciseType?: SortOrderInput | SortOrder
    readingMinutes?: SortOrder
    learningMinutes?: SortOrder
    meditationMinutes?: SortOrder
    sleepHours?: SortOrderInput | SortOrder
    sleepQuality?: SortOrderInput | SortOrder
    morningJournal?: SortOrderInput | SortOrder
    eveningReflection?: SortOrderInput | SortOrder
    gratitude?: SortOrder
    dailyWin?: SortOrderInput | SortOrder
    mood?: SortOrderInput | SortOrder
    stressLevel?: SortOrderInput | SortOrder
    focusQuality?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: WellBeingEntryCountOrderByAggregateInput
    _avg?: WellBeingEntryAvgOrderByAggregateInput
    _max?: WellBeingEntryMaxOrderByAggregateInput
    _min?: WellBeingEntryMinOrderByAggregateInput
    _sum?: WellBeingEntrySumOrderByAggregateInput
  }

  export type WellBeingEntryScalarWhereWithAggregatesInput = {
    AND?: WellBeingEntryScalarWhereWithAggregatesInput | WellBeingEntryScalarWhereWithAggregatesInput[]
    OR?: WellBeingEntryScalarWhereWithAggregatesInput[]
    NOT?: WellBeingEntryScalarWhereWithAggregatesInput | WellBeingEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WellBeingEntry"> | string
    userId?: StringWithAggregatesFilter<"WellBeingEntry"> | string
    date?: DateTimeWithAggregatesFilter<"WellBeingEntry"> | Date | string
    morningEnergy?: FloatNullableWithAggregatesFilter<"WellBeingEntry"> | number | null
    afternoonEnergy?: FloatNullableWithAggregatesFilter<"WellBeingEntry"> | number | null
    eveningEnergy?: FloatNullableWithAggregatesFilter<"WellBeingEntry"> | number | null
    averageEnergy?: FloatNullableWithAggregatesFilter<"WellBeingEntry"> | number | null
    exerciseMinutes?: IntWithAggregatesFilter<"WellBeingEntry"> | number
    exerciseType?: StringNullableWithAggregatesFilter<"WellBeingEntry"> | string | null
    readingMinutes?: IntWithAggregatesFilter<"WellBeingEntry"> | number
    learningMinutes?: IntWithAggregatesFilter<"WellBeingEntry"> | number
    meditationMinutes?: IntWithAggregatesFilter<"WellBeingEntry"> | number
    sleepHours?: FloatNullableWithAggregatesFilter<"WellBeingEntry"> | number | null
    sleepQuality?: FloatNullableWithAggregatesFilter<"WellBeingEntry"> | number | null
    morningJournal?: StringNullableWithAggregatesFilter<"WellBeingEntry"> | string | null
    eveningReflection?: StringNullableWithAggregatesFilter<"WellBeingEntry"> | string | null
    gratitude?: StringNullableListFilter<"WellBeingEntry">
    dailyWin?: StringNullableWithAggregatesFilter<"WellBeingEntry"> | string | null
    mood?: FloatNullableWithAggregatesFilter<"WellBeingEntry"> | number | null
    stressLevel?: FloatNullableWithAggregatesFilter<"WellBeingEntry"> | number | null
    focusQuality?: FloatNullableWithAggregatesFilter<"WellBeingEntry"> | number | null
    notes?: StringNullableWithAggregatesFilter<"WellBeingEntry"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WellBeingEntry"> | Date | string
  }

  export type CaptureWhereInput = {
    AND?: CaptureWhereInput | CaptureWhereInput[]
    OR?: CaptureWhereInput[]
    NOT?: CaptureWhereInput | CaptureWhereInput[]
    id?: StringFilter<"Capture"> | string
    userId?: StringFilter<"Capture"> | string
    type?: StringFilter<"Capture"> | string
    content?: StringFilter<"Capture"> | string
    transcription?: StringNullableFilter<"Capture"> | string | null
    status?: StringFilter<"Capture"> | string
    convertedToTaskId?: StringNullableFilter<"Capture"> | string | null
    convertedToNoteId?: StringNullableFilter<"Capture"> | string | null
    suggestedProject?: StringNullableFilter<"Capture"> | string | null
    suggestedDueDate?: DateTimeNullableFilter<"Capture"> | Date | string | null
    suggestedPriority?: StringNullableFilter<"Capture"> | string | null
    tags?: StringNullableListFilter<"Capture">
    createdAt?: DateTimeFilter<"Capture"> | Date | string
    processedAt?: DateTimeNullableFilter<"Capture"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CaptureOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    transcription?: SortOrderInput | SortOrder
    status?: SortOrder
    convertedToTaskId?: SortOrderInput | SortOrder
    convertedToNoteId?: SortOrderInput | SortOrder
    suggestedProject?: SortOrderInput | SortOrder
    suggestedDueDate?: SortOrderInput | SortOrder
    suggestedPriority?: SortOrderInput | SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type CaptureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CaptureWhereInput | CaptureWhereInput[]
    OR?: CaptureWhereInput[]
    NOT?: CaptureWhereInput | CaptureWhereInput[]
    userId?: StringFilter<"Capture"> | string
    type?: StringFilter<"Capture"> | string
    content?: StringFilter<"Capture"> | string
    transcription?: StringNullableFilter<"Capture"> | string | null
    status?: StringFilter<"Capture"> | string
    convertedToTaskId?: StringNullableFilter<"Capture"> | string | null
    convertedToNoteId?: StringNullableFilter<"Capture"> | string | null
    suggestedProject?: StringNullableFilter<"Capture"> | string | null
    suggestedDueDate?: DateTimeNullableFilter<"Capture"> | Date | string | null
    suggestedPriority?: StringNullableFilter<"Capture"> | string | null
    tags?: StringNullableListFilter<"Capture">
    createdAt?: DateTimeFilter<"Capture"> | Date | string
    processedAt?: DateTimeNullableFilter<"Capture"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CaptureOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    transcription?: SortOrderInput | SortOrder
    status?: SortOrder
    convertedToTaskId?: SortOrderInput | SortOrder
    convertedToNoteId?: SortOrderInput | SortOrder
    suggestedProject?: SortOrderInput | SortOrder
    suggestedDueDate?: SortOrderInput | SortOrder
    suggestedPriority?: SortOrderInput | SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    _count?: CaptureCountOrderByAggregateInput
    _max?: CaptureMaxOrderByAggregateInput
    _min?: CaptureMinOrderByAggregateInput
  }

  export type CaptureScalarWhereWithAggregatesInput = {
    AND?: CaptureScalarWhereWithAggregatesInput | CaptureScalarWhereWithAggregatesInput[]
    OR?: CaptureScalarWhereWithAggregatesInput[]
    NOT?: CaptureScalarWhereWithAggregatesInput | CaptureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Capture"> | string
    userId?: StringWithAggregatesFilter<"Capture"> | string
    type?: StringWithAggregatesFilter<"Capture"> | string
    content?: StringWithAggregatesFilter<"Capture"> | string
    transcription?: StringNullableWithAggregatesFilter<"Capture"> | string | null
    status?: StringWithAggregatesFilter<"Capture"> | string
    convertedToTaskId?: StringNullableWithAggregatesFilter<"Capture"> | string | null
    convertedToNoteId?: StringNullableWithAggregatesFilter<"Capture"> | string | null
    suggestedProject?: StringNullableWithAggregatesFilter<"Capture"> | string | null
    suggestedDueDate?: DateTimeNullableWithAggregatesFilter<"Capture"> | Date | string | null
    suggestedPriority?: StringNullableWithAggregatesFilter<"Capture"> | string | null
    tags?: StringNullableListFilter<"Capture">
    createdAt?: DateTimeWithAggregatesFilter<"Capture"> | Date | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"Capture"> | Date | string | null
  }

  export type VoiceSessionWhereInput = {
    AND?: VoiceSessionWhereInput | VoiceSessionWhereInput[]
    OR?: VoiceSessionWhereInput[]
    NOT?: VoiceSessionWhereInput | VoiceSessionWhereInput[]
    id?: StringFilter<"VoiceSession"> | string
    userId?: StringFilter<"VoiceSession"> | string
    title?: StringFilter<"VoiceSession"> | string
    duration?: IntFilter<"VoiceSession"> | number
    recordedAt?: DateTimeFilter<"VoiceSession"> | Date | string
    audioFileUrl?: StringFilter<"VoiceSession"> | string
    waveformData?: JsonNullableFilter<"VoiceSession">
    transcription?: StringNullableFilter<"VoiceSession"> | string | null
    speakers?: JsonNullableListFilter<"VoiceSession">
    timestamps?: JsonNullableListFilter<"VoiceSession">
    summary?: StringNullableFilter<"VoiceSession"> | string | null
    keyPoints?: StringNullableListFilter<"VoiceSession">
    actionItems?: JsonNullableListFilter<"VoiceSession">
    projectId?: StringNullableFilter<"VoiceSession"> | string | null
    tags?: StringNullableListFilter<"VoiceSession">
    processed?: BoolFilter<"VoiceSession"> | boolean
    archivedAt?: DateTimeNullableFilter<"VoiceSession"> | Date | string | null
    createdAt?: DateTimeFilter<"VoiceSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type VoiceSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    duration?: SortOrder
    recordedAt?: SortOrder
    audioFileUrl?: SortOrder
    waveformData?: SortOrderInput | SortOrder
    transcription?: SortOrderInput | SortOrder
    speakers?: SortOrder
    timestamps?: SortOrder
    summary?: SortOrderInput | SortOrder
    keyPoints?: SortOrder
    actionItems?: SortOrder
    projectId?: SortOrderInput | SortOrder
    tags?: SortOrder
    processed?: SortOrder
    archivedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type VoiceSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VoiceSessionWhereInput | VoiceSessionWhereInput[]
    OR?: VoiceSessionWhereInput[]
    NOT?: VoiceSessionWhereInput | VoiceSessionWhereInput[]
    userId?: StringFilter<"VoiceSession"> | string
    title?: StringFilter<"VoiceSession"> | string
    duration?: IntFilter<"VoiceSession"> | number
    recordedAt?: DateTimeFilter<"VoiceSession"> | Date | string
    audioFileUrl?: StringFilter<"VoiceSession"> | string
    waveformData?: JsonNullableFilter<"VoiceSession">
    transcription?: StringNullableFilter<"VoiceSession"> | string | null
    speakers?: JsonNullableListFilter<"VoiceSession">
    timestamps?: JsonNullableListFilter<"VoiceSession">
    summary?: StringNullableFilter<"VoiceSession"> | string | null
    keyPoints?: StringNullableListFilter<"VoiceSession">
    actionItems?: JsonNullableListFilter<"VoiceSession">
    projectId?: StringNullableFilter<"VoiceSession"> | string | null
    tags?: StringNullableListFilter<"VoiceSession">
    processed?: BoolFilter<"VoiceSession"> | boolean
    archivedAt?: DateTimeNullableFilter<"VoiceSession"> | Date | string | null
    createdAt?: DateTimeFilter<"VoiceSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type VoiceSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    duration?: SortOrder
    recordedAt?: SortOrder
    audioFileUrl?: SortOrder
    waveformData?: SortOrderInput | SortOrder
    transcription?: SortOrderInput | SortOrder
    speakers?: SortOrder
    timestamps?: SortOrder
    summary?: SortOrderInput | SortOrder
    keyPoints?: SortOrder
    actionItems?: SortOrder
    projectId?: SortOrderInput | SortOrder
    tags?: SortOrder
    processed?: SortOrder
    archivedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: VoiceSessionCountOrderByAggregateInput
    _avg?: VoiceSessionAvgOrderByAggregateInput
    _max?: VoiceSessionMaxOrderByAggregateInput
    _min?: VoiceSessionMinOrderByAggregateInput
    _sum?: VoiceSessionSumOrderByAggregateInput
  }

  export type VoiceSessionScalarWhereWithAggregatesInput = {
    AND?: VoiceSessionScalarWhereWithAggregatesInput | VoiceSessionScalarWhereWithAggregatesInput[]
    OR?: VoiceSessionScalarWhereWithAggregatesInput[]
    NOT?: VoiceSessionScalarWhereWithAggregatesInput | VoiceSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VoiceSession"> | string
    userId?: StringWithAggregatesFilter<"VoiceSession"> | string
    title?: StringWithAggregatesFilter<"VoiceSession"> | string
    duration?: IntWithAggregatesFilter<"VoiceSession"> | number
    recordedAt?: DateTimeWithAggregatesFilter<"VoiceSession"> | Date | string
    audioFileUrl?: StringWithAggregatesFilter<"VoiceSession"> | string
    waveformData?: JsonNullableWithAggregatesFilter<"VoiceSession">
    transcription?: StringNullableWithAggregatesFilter<"VoiceSession"> | string | null
    speakers?: JsonNullableListFilter<"VoiceSession">
    timestamps?: JsonNullableListFilter<"VoiceSession">
    summary?: StringNullableWithAggregatesFilter<"VoiceSession"> | string | null
    keyPoints?: StringNullableListFilter<"VoiceSession">
    actionItems?: JsonNullableListFilter<"VoiceSession">
    projectId?: StringNullableWithAggregatesFilter<"VoiceSession"> | string | null
    tags?: StringNullableListFilter<"VoiceSession">
    processed?: BoolWithAggregatesFilter<"VoiceSession"> | boolean
    archivedAt?: DateTimeNullableWithAggregatesFilter<"VoiceSession"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VoiceSession"> | Date | string
  }

  export type CalendarEventWhereInput = {
    AND?: CalendarEventWhereInput | CalendarEventWhereInput[]
    OR?: CalendarEventWhereInput[]
    NOT?: CalendarEventWhereInput | CalendarEventWhereInput[]
    id?: StringFilter<"CalendarEvent"> | string
    userId?: StringFilter<"CalendarEvent"> | string
    title?: StringFilter<"CalendarEvent"> | string
    description?: StringNullableFilter<"CalendarEvent"> | string | null
    startTime?: DateTimeFilter<"CalendarEvent"> | Date | string
    endTime?: DateTimeFilter<"CalendarEvent"> | Date | string
    allDay?: BoolFilter<"CalendarEvent"> | boolean
    timezone?: StringFilter<"CalendarEvent"> | string
    isRecurring?: BoolFilter<"CalendarEvent"> | boolean
    recurrenceRule?: StringNullableFilter<"CalendarEvent"> | string | null
    projectId?: StringNullableFilter<"CalendarEvent"> | string | null
    taskId?: StringNullableFilter<"CalendarEvent"> | string | null
    clientId?: StringNullableFilter<"CalendarEvent"> | string | null
    meetingId?: StringNullableFilter<"CalendarEvent"> | string | null
    type?: StringFilter<"CalendarEvent"> | string
    reminders?: JsonNullableListFilter<"CalendarEvent">
    color?: StringNullableFilter<"CalendarEvent"> | string | null
    location?: StringNullableFilter<"CalendarEvent"> | string | null
    attendees?: StringNullableListFilter<"CalendarEvent">
    externalCalendarId?: StringNullableFilter<"CalendarEvent"> | string | null
    externalEventId?: StringNullableFilter<"CalendarEvent"> | string | null
    syncStatus?: StringNullableFilter<"CalendarEvent"> | string | null
    createdAt?: DateTimeFilter<"CalendarEvent"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarEvent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CalendarEventOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    allDay?: SortOrder
    timezone?: SortOrder
    isRecurring?: SortOrder
    recurrenceRule?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    taskId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    meetingId?: SortOrderInput | SortOrder
    type?: SortOrder
    reminders?: SortOrder
    color?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    attendees?: SortOrder
    externalCalendarId?: SortOrderInput | SortOrder
    externalEventId?: SortOrderInput | SortOrder
    syncStatus?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type CalendarEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CalendarEventWhereInput | CalendarEventWhereInput[]
    OR?: CalendarEventWhereInput[]
    NOT?: CalendarEventWhereInput | CalendarEventWhereInput[]
    userId?: StringFilter<"CalendarEvent"> | string
    title?: StringFilter<"CalendarEvent"> | string
    description?: StringNullableFilter<"CalendarEvent"> | string | null
    startTime?: DateTimeFilter<"CalendarEvent"> | Date | string
    endTime?: DateTimeFilter<"CalendarEvent"> | Date | string
    allDay?: BoolFilter<"CalendarEvent"> | boolean
    timezone?: StringFilter<"CalendarEvent"> | string
    isRecurring?: BoolFilter<"CalendarEvent"> | boolean
    recurrenceRule?: StringNullableFilter<"CalendarEvent"> | string | null
    projectId?: StringNullableFilter<"CalendarEvent"> | string | null
    taskId?: StringNullableFilter<"CalendarEvent"> | string | null
    clientId?: StringNullableFilter<"CalendarEvent"> | string | null
    meetingId?: StringNullableFilter<"CalendarEvent"> | string | null
    type?: StringFilter<"CalendarEvent"> | string
    reminders?: JsonNullableListFilter<"CalendarEvent">
    color?: StringNullableFilter<"CalendarEvent"> | string | null
    location?: StringNullableFilter<"CalendarEvent"> | string | null
    attendees?: StringNullableListFilter<"CalendarEvent">
    externalCalendarId?: StringNullableFilter<"CalendarEvent"> | string | null
    externalEventId?: StringNullableFilter<"CalendarEvent"> | string | null
    syncStatus?: StringNullableFilter<"CalendarEvent"> | string | null
    createdAt?: DateTimeFilter<"CalendarEvent"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarEvent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CalendarEventOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    allDay?: SortOrder
    timezone?: SortOrder
    isRecurring?: SortOrder
    recurrenceRule?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    taskId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    meetingId?: SortOrderInput | SortOrder
    type?: SortOrder
    reminders?: SortOrder
    color?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    attendees?: SortOrder
    externalCalendarId?: SortOrderInput | SortOrder
    externalEventId?: SortOrderInput | SortOrder
    syncStatus?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CalendarEventCountOrderByAggregateInput
    _max?: CalendarEventMaxOrderByAggregateInput
    _min?: CalendarEventMinOrderByAggregateInput
  }

  export type CalendarEventScalarWhereWithAggregatesInput = {
    AND?: CalendarEventScalarWhereWithAggregatesInput | CalendarEventScalarWhereWithAggregatesInput[]
    OR?: CalendarEventScalarWhereWithAggregatesInput[]
    NOT?: CalendarEventScalarWhereWithAggregatesInput | CalendarEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CalendarEvent"> | string
    userId?: StringWithAggregatesFilter<"CalendarEvent"> | string
    title?: StringWithAggregatesFilter<"CalendarEvent"> | string
    description?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
    startTime?: DateTimeWithAggregatesFilter<"CalendarEvent"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"CalendarEvent"> | Date | string
    allDay?: BoolWithAggregatesFilter<"CalendarEvent"> | boolean
    timezone?: StringWithAggregatesFilter<"CalendarEvent"> | string
    isRecurring?: BoolWithAggregatesFilter<"CalendarEvent"> | boolean
    recurrenceRule?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
    projectId?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
    taskId?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
    clientId?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
    meetingId?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
    type?: StringWithAggregatesFilter<"CalendarEvent"> | string
    reminders?: JsonNullableListFilter<"CalendarEvent">
    color?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
    location?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
    attendees?: StringNullableListFilter<"CalendarEvent">
    externalCalendarId?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
    externalEventId?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
    syncStatus?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CalendarEvent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CalendarEvent"> | Date | string
  }

  export type AnalyticsEventWhereInput = {
    AND?: AnalyticsEventWhereInput | AnalyticsEventWhereInput[]
    OR?: AnalyticsEventWhereInput[]
    NOT?: AnalyticsEventWhereInput | AnalyticsEventWhereInput[]
    id?: StringFilter<"AnalyticsEvent"> | string
    userId?: StringFilter<"AnalyticsEvent"> | string
    eventType?: StringFilter<"AnalyticsEvent"> | string
    eventData?: JsonNullableFilter<"AnalyticsEvent">
    sessionId?: StringNullableFilter<"AnalyticsEvent"> | string | null
    createdAt?: DateTimeFilter<"AnalyticsEvent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AnalyticsEventOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    eventData?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AnalyticsEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnalyticsEventWhereInput | AnalyticsEventWhereInput[]
    OR?: AnalyticsEventWhereInput[]
    NOT?: AnalyticsEventWhereInput | AnalyticsEventWhereInput[]
    userId?: StringFilter<"AnalyticsEvent"> | string
    eventType?: StringFilter<"AnalyticsEvent"> | string
    eventData?: JsonNullableFilter<"AnalyticsEvent">
    sessionId?: StringNullableFilter<"AnalyticsEvent"> | string | null
    createdAt?: DateTimeFilter<"AnalyticsEvent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AnalyticsEventOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    eventData?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AnalyticsEventCountOrderByAggregateInput
    _max?: AnalyticsEventMaxOrderByAggregateInput
    _min?: AnalyticsEventMinOrderByAggregateInput
  }

  export type AnalyticsEventScalarWhereWithAggregatesInput = {
    AND?: AnalyticsEventScalarWhereWithAggregatesInput | AnalyticsEventScalarWhereWithAggregatesInput[]
    OR?: AnalyticsEventScalarWhereWithAggregatesInput[]
    NOT?: AnalyticsEventScalarWhereWithAggregatesInput | AnalyticsEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnalyticsEvent"> | string
    userId?: StringWithAggregatesFilter<"AnalyticsEvent"> | string
    eventType?: StringWithAggregatesFilter<"AnalyticsEvent"> | string
    eventData?: JsonNullableWithAggregatesFilter<"AnalyticsEvent">
    sessionId?: StringNullableWithAggregatesFilter<"AnalyticsEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AnalyticsEvent"> | Date | string
  }

  export type ResearchWhereInput = {
    AND?: ResearchWhereInput | ResearchWhereInput[]
    OR?: ResearchWhereInput[]
    NOT?: ResearchWhereInput | ResearchWhereInput[]
    id?: StringFilter<"Research"> | string
    userId?: StringFilter<"Research"> | string
    title?: StringFilter<"Research"> | string
    scope?: EnumResearchScopeFilter<"Research"> | $Enums.ResearchScope
    searchMethod?: EnumSearchMethodFilter<"Research"> | $Enums.SearchMethod
    status?: EnumResearchStatusFilter<"Research"> | $Enums.ResearchStatus
    originalPrompt?: StringFilter<"Research"> | string
    refinedPrompt?: StringFilter<"Research"> | string
    rawData?: JsonNullableFilter<"Research">
    progress?: IntFilter<"Research"> | number
    errorMessage?: StringNullableFilter<"Research"> | string | null
    goalId?: StringNullableFilter<"Research"> | string | null
    isFavorited?: BoolFilter<"Research"> | boolean
    createdAt?: DateTimeFilter<"Research"> | Date | string
    updatedAt?: DateTimeFilter<"Research"> | Date | string
    completedAt?: DateTimeNullableFilter<"Research"> | Date | string | null
    actionItems?: ActionItemListRelationFilter
    leadData?: XOR<LeadDataNullableScalarRelationFilter, LeadDataWhereInput> | null
    goal?: XOR<GoalNullableScalarRelationFilter, GoalWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    insights?: ResearchInsightListRelationFilter
    sources?: ResearchSourceListRelationFilter
  }

  export type ResearchOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    scope?: SortOrder
    searchMethod?: SortOrder
    status?: SortOrder
    originalPrompt?: SortOrder
    refinedPrompt?: SortOrder
    rawData?: SortOrderInput | SortOrder
    progress?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    goalId?: SortOrderInput | SortOrder
    isFavorited?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    actionItems?: ActionItemOrderByRelationAggregateInput
    leadData?: LeadDataOrderByWithRelationInput
    goal?: GoalOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    insights?: ResearchInsightOrderByRelationAggregateInput
    sources?: ResearchSourceOrderByRelationAggregateInput
  }

  export type ResearchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ResearchWhereInput | ResearchWhereInput[]
    OR?: ResearchWhereInput[]
    NOT?: ResearchWhereInput | ResearchWhereInput[]
    userId?: StringFilter<"Research"> | string
    title?: StringFilter<"Research"> | string
    scope?: EnumResearchScopeFilter<"Research"> | $Enums.ResearchScope
    searchMethod?: EnumSearchMethodFilter<"Research"> | $Enums.SearchMethod
    status?: EnumResearchStatusFilter<"Research"> | $Enums.ResearchStatus
    originalPrompt?: StringFilter<"Research"> | string
    refinedPrompt?: StringFilter<"Research"> | string
    rawData?: JsonNullableFilter<"Research">
    progress?: IntFilter<"Research"> | number
    errorMessage?: StringNullableFilter<"Research"> | string | null
    goalId?: StringNullableFilter<"Research"> | string | null
    isFavorited?: BoolFilter<"Research"> | boolean
    createdAt?: DateTimeFilter<"Research"> | Date | string
    updatedAt?: DateTimeFilter<"Research"> | Date | string
    completedAt?: DateTimeNullableFilter<"Research"> | Date | string | null
    actionItems?: ActionItemListRelationFilter
    leadData?: XOR<LeadDataNullableScalarRelationFilter, LeadDataWhereInput> | null
    goal?: XOR<GoalNullableScalarRelationFilter, GoalWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    insights?: ResearchInsightListRelationFilter
    sources?: ResearchSourceListRelationFilter
  }, "id">

  export type ResearchOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    scope?: SortOrder
    searchMethod?: SortOrder
    status?: SortOrder
    originalPrompt?: SortOrder
    refinedPrompt?: SortOrder
    rawData?: SortOrderInput | SortOrder
    progress?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    goalId?: SortOrderInput | SortOrder
    isFavorited?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: ResearchCountOrderByAggregateInput
    _avg?: ResearchAvgOrderByAggregateInput
    _max?: ResearchMaxOrderByAggregateInput
    _min?: ResearchMinOrderByAggregateInput
    _sum?: ResearchSumOrderByAggregateInput
  }

  export type ResearchScalarWhereWithAggregatesInput = {
    AND?: ResearchScalarWhereWithAggregatesInput | ResearchScalarWhereWithAggregatesInput[]
    OR?: ResearchScalarWhereWithAggregatesInput[]
    NOT?: ResearchScalarWhereWithAggregatesInput | ResearchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Research"> | string
    userId?: StringWithAggregatesFilter<"Research"> | string
    title?: StringWithAggregatesFilter<"Research"> | string
    scope?: EnumResearchScopeWithAggregatesFilter<"Research"> | $Enums.ResearchScope
    searchMethod?: EnumSearchMethodWithAggregatesFilter<"Research"> | $Enums.SearchMethod
    status?: EnumResearchStatusWithAggregatesFilter<"Research"> | $Enums.ResearchStatus
    originalPrompt?: StringWithAggregatesFilter<"Research"> | string
    refinedPrompt?: StringWithAggregatesFilter<"Research"> | string
    rawData?: JsonNullableWithAggregatesFilter<"Research">
    progress?: IntWithAggregatesFilter<"Research"> | number
    errorMessage?: StringNullableWithAggregatesFilter<"Research"> | string | null
    goalId?: StringNullableWithAggregatesFilter<"Research"> | string | null
    isFavorited?: BoolWithAggregatesFilter<"Research"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Research"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Research"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"Research"> | Date | string | null
  }

  export type ResearchSourceWhereInput = {
    AND?: ResearchSourceWhereInput | ResearchSourceWhereInput[]
    OR?: ResearchSourceWhereInput[]
    NOT?: ResearchSourceWhereInput | ResearchSourceWhereInput[]
    id?: StringFilter<"ResearchSource"> | string
    researchId?: StringFilter<"ResearchSource"> | string
    url?: StringFilter<"ResearchSource"> | string
    title?: StringFilter<"ResearchSource"> | string
    content?: StringFilter<"ResearchSource"> | string
    excerpt?: StringFilter<"ResearchSource"> | string
    credibility?: FloatFilter<"ResearchSource"> | number
    citedInSections?: StringNullableListFilter<"ResearchSource">
    scrapedAt?: DateTimeFilter<"ResearchSource"> | Date | string
    research?: XOR<ResearchScalarRelationFilter, ResearchWhereInput>
  }

  export type ResearchSourceOrderByWithRelationInput = {
    id?: SortOrder
    researchId?: SortOrder
    url?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    credibility?: SortOrder
    citedInSections?: SortOrder
    scrapedAt?: SortOrder
    research?: ResearchOrderByWithRelationInput
  }

  export type ResearchSourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ResearchSourceWhereInput | ResearchSourceWhereInput[]
    OR?: ResearchSourceWhereInput[]
    NOT?: ResearchSourceWhereInput | ResearchSourceWhereInput[]
    researchId?: StringFilter<"ResearchSource"> | string
    url?: StringFilter<"ResearchSource"> | string
    title?: StringFilter<"ResearchSource"> | string
    content?: StringFilter<"ResearchSource"> | string
    excerpt?: StringFilter<"ResearchSource"> | string
    credibility?: FloatFilter<"ResearchSource"> | number
    citedInSections?: StringNullableListFilter<"ResearchSource">
    scrapedAt?: DateTimeFilter<"ResearchSource"> | Date | string
    research?: XOR<ResearchScalarRelationFilter, ResearchWhereInput>
  }, "id">

  export type ResearchSourceOrderByWithAggregationInput = {
    id?: SortOrder
    researchId?: SortOrder
    url?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    credibility?: SortOrder
    citedInSections?: SortOrder
    scrapedAt?: SortOrder
    _count?: ResearchSourceCountOrderByAggregateInput
    _avg?: ResearchSourceAvgOrderByAggregateInput
    _max?: ResearchSourceMaxOrderByAggregateInput
    _min?: ResearchSourceMinOrderByAggregateInput
    _sum?: ResearchSourceSumOrderByAggregateInput
  }

  export type ResearchSourceScalarWhereWithAggregatesInput = {
    AND?: ResearchSourceScalarWhereWithAggregatesInput | ResearchSourceScalarWhereWithAggregatesInput[]
    OR?: ResearchSourceScalarWhereWithAggregatesInput[]
    NOT?: ResearchSourceScalarWhereWithAggregatesInput | ResearchSourceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ResearchSource"> | string
    researchId?: StringWithAggregatesFilter<"ResearchSource"> | string
    url?: StringWithAggregatesFilter<"ResearchSource"> | string
    title?: StringWithAggregatesFilter<"ResearchSource"> | string
    content?: StringWithAggregatesFilter<"ResearchSource"> | string
    excerpt?: StringWithAggregatesFilter<"ResearchSource"> | string
    credibility?: FloatWithAggregatesFilter<"ResearchSource"> | number
    citedInSections?: StringNullableListFilter<"ResearchSource">
    scrapedAt?: DateTimeWithAggregatesFilter<"ResearchSource"> | Date | string
  }

  export type ResearchInsightWhereInput = {
    AND?: ResearchInsightWhereInput | ResearchInsightWhereInput[]
    OR?: ResearchInsightWhereInput[]
    NOT?: ResearchInsightWhereInput | ResearchInsightWhereInput[]
    id?: StringFilter<"ResearchInsight"> | string
    researchId?: StringFilter<"ResearchInsight"> | string
    title?: StringFilter<"ResearchInsight"> | string
    content?: StringFilter<"ResearchInsight"> | string
    category?: StringFilter<"ResearchInsight"> | string
    visualData?: JsonNullableFilter<"ResearchInsight">
    confidence?: FloatFilter<"ResearchInsight"> | number
    order?: IntFilter<"ResearchInsight"> | number
    createdAt?: DateTimeFilter<"ResearchInsight"> | Date | string
    research?: XOR<ResearchScalarRelationFilter, ResearchWhereInput>
  }

  export type ResearchInsightOrderByWithRelationInput = {
    id?: SortOrder
    researchId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    visualData?: SortOrderInput | SortOrder
    confidence?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    research?: ResearchOrderByWithRelationInput
  }

  export type ResearchInsightWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ResearchInsightWhereInput | ResearchInsightWhereInput[]
    OR?: ResearchInsightWhereInput[]
    NOT?: ResearchInsightWhereInput | ResearchInsightWhereInput[]
    researchId?: StringFilter<"ResearchInsight"> | string
    title?: StringFilter<"ResearchInsight"> | string
    content?: StringFilter<"ResearchInsight"> | string
    category?: StringFilter<"ResearchInsight"> | string
    visualData?: JsonNullableFilter<"ResearchInsight">
    confidence?: FloatFilter<"ResearchInsight"> | number
    order?: IntFilter<"ResearchInsight"> | number
    createdAt?: DateTimeFilter<"ResearchInsight"> | Date | string
    research?: XOR<ResearchScalarRelationFilter, ResearchWhereInput>
  }, "id">

  export type ResearchInsightOrderByWithAggregationInput = {
    id?: SortOrder
    researchId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    visualData?: SortOrderInput | SortOrder
    confidence?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    _count?: ResearchInsightCountOrderByAggregateInput
    _avg?: ResearchInsightAvgOrderByAggregateInput
    _max?: ResearchInsightMaxOrderByAggregateInput
    _min?: ResearchInsightMinOrderByAggregateInput
    _sum?: ResearchInsightSumOrderByAggregateInput
  }

  export type ResearchInsightScalarWhereWithAggregatesInput = {
    AND?: ResearchInsightScalarWhereWithAggregatesInput | ResearchInsightScalarWhereWithAggregatesInput[]
    OR?: ResearchInsightScalarWhereWithAggregatesInput[]
    NOT?: ResearchInsightScalarWhereWithAggregatesInput | ResearchInsightScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ResearchInsight"> | string
    researchId?: StringWithAggregatesFilter<"ResearchInsight"> | string
    title?: StringWithAggregatesFilter<"ResearchInsight"> | string
    content?: StringWithAggregatesFilter<"ResearchInsight"> | string
    category?: StringWithAggregatesFilter<"ResearchInsight"> | string
    visualData?: JsonNullableWithAggregatesFilter<"ResearchInsight">
    confidence?: FloatWithAggregatesFilter<"ResearchInsight"> | number
    order?: IntWithAggregatesFilter<"ResearchInsight"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ResearchInsight"> | Date | string
  }

  export type ActionItemWhereInput = {
    AND?: ActionItemWhereInput | ActionItemWhereInput[]
    OR?: ActionItemWhereInput[]
    NOT?: ActionItemWhereInput | ActionItemWhereInput[]
    id?: StringFilter<"ActionItem"> | string
    researchId?: StringFilter<"ActionItem"> | string
    description?: StringFilter<"ActionItem"> | string
    priority?: EnumActionPriorityFilter<"ActionItem"> | $Enums.ActionPriority
    effort?: IntFilter<"ActionItem"> | number
    convertedToTaskId?: StringNullableFilter<"ActionItem"> | string | null
    convertedAt?: DateTimeNullableFilter<"ActionItem"> | Date | string | null
    createdAt?: DateTimeFilter<"ActionItem"> | Date | string
    convertedToTask?: XOR<TaskNullableScalarRelationFilter, TaskWhereInput> | null
    research?: XOR<ResearchScalarRelationFilter, ResearchWhereInput>
  }

  export type ActionItemOrderByWithRelationInput = {
    id?: SortOrder
    researchId?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    effort?: SortOrder
    convertedToTaskId?: SortOrderInput | SortOrder
    convertedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    convertedToTask?: TaskOrderByWithRelationInput
    research?: ResearchOrderByWithRelationInput
  }

  export type ActionItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    convertedToTaskId?: string
    AND?: ActionItemWhereInput | ActionItemWhereInput[]
    OR?: ActionItemWhereInput[]
    NOT?: ActionItemWhereInput | ActionItemWhereInput[]
    researchId?: StringFilter<"ActionItem"> | string
    description?: StringFilter<"ActionItem"> | string
    priority?: EnumActionPriorityFilter<"ActionItem"> | $Enums.ActionPriority
    effort?: IntFilter<"ActionItem"> | number
    convertedAt?: DateTimeNullableFilter<"ActionItem"> | Date | string | null
    createdAt?: DateTimeFilter<"ActionItem"> | Date | string
    convertedToTask?: XOR<TaskNullableScalarRelationFilter, TaskWhereInput> | null
    research?: XOR<ResearchScalarRelationFilter, ResearchWhereInput>
  }, "id" | "convertedToTaskId">

  export type ActionItemOrderByWithAggregationInput = {
    id?: SortOrder
    researchId?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    effort?: SortOrder
    convertedToTaskId?: SortOrderInput | SortOrder
    convertedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ActionItemCountOrderByAggregateInput
    _avg?: ActionItemAvgOrderByAggregateInput
    _max?: ActionItemMaxOrderByAggregateInput
    _min?: ActionItemMinOrderByAggregateInput
    _sum?: ActionItemSumOrderByAggregateInput
  }

  export type ActionItemScalarWhereWithAggregatesInput = {
    AND?: ActionItemScalarWhereWithAggregatesInput | ActionItemScalarWhereWithAggregatesInput[]
    OR?: ActionItemScalarWhereWithAggregatesInput[]
    NOT?: ActionItemScalarWhereWithAggregatesInput | ActionItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActionItem"> | string
    researchId?: StringWithAggregatesFilter<"ActionItem"> | string
    description?: StringWithAggregatesFilter<"ActionItem"> | string
    priority?: EnumActionPriorityWithAggregatesFilter<"ActionItem"> | $Enums.ActionPriority
    effort?: IntWithAggregatesFilter<"ActionItem"> | number
    convertedToTaskId?: StringNullableWithAggregatesFilter<"ActionItem"> | string | null
    convertedAt?: DateTimeNullableWithAggregatesFilter<"ActionItem"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ActionItem"> | Date | string
  }

  export type LeadDataWhereInput = {
    AND?: LeadDataWhereInput | LeadDataWhereInput[]
    OR?: LeadDataWhereInput[]
    NOT?: LeadDataWhereInput | LeadDataWhereInput[]
    id?: StringFilter<"LeadData"> | string
    researchId?: StringFilter<"LeadData"> | string
    totalFound?: IntFilter<"LeadData"> | number
    exportedAt?: DateTimeNullableFilter<"LeadData"> | Date | string | null
    leads?: LeadListRelationFilter
    research?: XOR<ResearchScalarRelationFilter, ResearchWhereInput>
  }

  export type LeadDataOrderByWithRelationInput = {
    id?: SortOrder
    researchId?: SortOrder
    totalFound?: SortOrder
    exportedAt?: SortOrderInput | SortOrder
    leads?: LeadOrderByRelationAggregateInput
    research?: ResearchOrderByWithRelationInput
  }

  export type LeadDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    researchId?: string
    AND?: LeadDataWhereInput | LeadDataWhereInput[]
    OR?: LeadDataWhereInput[]
    NOT?: LeadDataWhereInput | LeadDataWhereInput[]
    totalFound?: IntFilter<"LeadData"> | number
    exportedAt?: DateTimeNullableFilter<"LeadData"> | Date | string | null
    leads?: LeadListRelationFilter
    research?: XOR<ResearchScalarRelationFilter, ResearchWhereInput>
  }, "id" | "researchId">

  export type LeadDataOrderByWithAggregationInput = {
    id?: SortOrder
    researchId?: SortOrder
    totalFound?: SortOrder
    exportedAt?: SortOrderInput | SortOrder
    _count?: LeadDataCountOrderByAggregateInput
    _avg?: LeadDataAvgOrderByAggregateInput
    _max?: LeadDataMaxOrderByAggregateInput
    _min?: LeadDataMinOrderByAggregateInput
    _sum?: LeadDataSumOrderByAggregateInput
  }

  export type LeadDataScalarWhereWithAggregatesInput = {
    AND?: LeadDataScalarWhereWithAggregatesInput | LeadDataScalarWhereWithAggregatesInput[]
    OR?: LeadDataScalarWhereWithAggregatesInput[]
    NOT?: LeadDataScalarWhereWithAggregatesInput | LeadDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeadData"> | string
    researchId?: StringWithAggregatesFilter<"LeadData"> | string
    totalFound?: IntWithAggregatesFilter<"LeadData"> | number
    exportedAt?: DateTimeNullableWithAggregatesFilter<"LeadData"> | Date | string | null
  }

  export type LeadWhereInput = {
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    id?: StringFilter<"Lead"> | string
    leadDataId?: StringFilter<"Lead"> | string
    name?: StringFilter<"Lead"> | string
    company?: StringNullableFilter<"Lead"> | string | null
    email?: StringNullableFilter<"Lead"> | string | null
    phone?: StringNullableFilter<"Lead"> | string | null
    website?: StringNullableFilter<"Lead"> | string | null
    industry?: StringNullableFilter<"Lead"> | string | null
    location?: StringNullableFilter<"Lead"> | string | null
    painPoints?: StringNullableListFilter<"Lead">
    suggestedDM?: StringFilter<"Lead"> | string
    suggestedEmail?: StringFilter<"Lead"> | string
    personalization?: JsonNullableFilter<"Lead">
    contacted?: BoolFilter<"Lead"> | boolean
    contactedAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    leadData?: XOR<LeadDataScalarRelationFilter, LeadDataWhereInput>
  }

  export type LeadOrderByWithRelationInput = {
    id?: SortOrder
    leadDataId?: SortOrder
    name?: SortOrder
    company?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    painPoints?: SortOrder
    suggestedDM?: SortOrder
    suggestedEmail?: SortOrder
    personalization?: SortOrderInput | SortOrder
    contacted?: SortOrder
    contactedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    leadData?: LeadDataOrderByWithRelationInput
  }

  export type LeadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    leadDataId?: StringFilter<"Lead"> | string
    name?: StringFilter<"Lead"> | string
    company?: StringNullableFilter<"Lead"> | string | null
    email?: StringNullableFilter<"Lead"> | string | null
    phone?: StringNullableFilter<"Lead"> | string | null
    website?: StringNullableFilter<"Lead"> | string | null
    industry?: StringNullableFilter<"Lead"> | string | null
    location?: StringNullableFilter<"Lead"> | string | null
    painPoints?: StringNullableListFilter<"Lead">
    suggestedDM?: StringFilter<"Lead"> | string
    suggestedEmail?: StringFilter<"Lead"> | string
    personalization?: JsonNullableFilter<"Lead">
    contacted?: BoolFilter<"Lead"> | boolean
    contactedAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    leadData?: XOR<LeadDataScalarRelationFilter, LeadDataWhereInput>
  }, "id">

  export type LeadOrderByWithAggregationInput = {
    id?: SortOrder
    leadDataId?: SortOrder
    name?: SortOrder
    company?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    painPoints?: SortOrder
    suggestedDM?: SortOrder
    suggestedEmail?: SortOrder
    personalization?: SortOrderInput | SortOrder
    contacted?: SortOrder
    contactedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LeadCountOrderByAggregateInput
    _max?: LeadMaxOrderByAggregateInput
    _min?: LeadMinOrderByAggregateInput
  }

  export type LeadScalarWhereWithAggregatesInput = {
    AND?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    OR?: LeadScalarWhereWithAggregatesInput[]
    NOT?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lead"> | string
    leadDataId?: StringWithAggregatesFilter<"Lead"> | string
    name?: StringWithAggregatesFilter<"Lead"> | string
    company?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    email?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    website?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    industry?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    location?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    painPoints?: StringNullableListFilter<"Lead">
    suggestedDM?: StringWithAggregatesFilter<"Lead"> | string
    suggestedEmail?: StringWithAggregatesFilter<"Lead"> | string
    personalization?: JsonNullableWithAggregatesFilter<"Lead">
    contacted?: BoolWithAggregatesFilter<"Lead"> | boolean
    contactedAt?: DateTimeNullableWithAggregatesFilter<"Lead"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    geminiApiKey?: string | null
    geminiModel?: string
    groqApiKey?: string | null
    llmProvider?: string
    serperApiKey?: string | null
    researchLimit?: number
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    captures?: CaptureCreateNestedManyWithoutUserInput
    clients?: ClientCreateNestedManyWithoutUserInput
    dayPlans?: DayPlanCreateNestedManyWithoutUserInput
    meetings?: MeetingCreateNestedManyWithoutUserInput
    notes?: NoteCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    researches?: ResearchCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    voiceSessions?: VoiceSessionCreateNestedManyWithoutUserInput
    weekPlans?: WeekPlanCreateNestedManyWithoutUserInput
    wellBeingEntries?: WellBeingEntryCreateNestedManyWithoutUserInput
    yearPlans?: YearPlanCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    geminiApiKey?: string | null
    geminiModel?: string
    groqApiKey?: string | null
    llmProvider?: string
    serperApiKey?: string | null
    researchLimit?: number
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    captures?: CaptureUncheckedCreateNestedManyWithoutUserInput
    clients?: ClientUncheckedCreateNestedManyWithoutUserInput
    dayPlans?: DayPlanUncheckedCreateNestedManyWithoutUserInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutUserInput
    notes?: NoteUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    researches?: ResearchUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    voiceSessions?: VoiceSessionUncheckedCreateNestedManyWithoutUserInput
    weekPlans?: WeekPlanUncheckedCreateNestedManyWithoutUserInput
    wellBeingEntries?: WellBeingEntryUncheckedCreateNestedManyWithoutUserInput
    yearPlans?: YearPlanUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    geminiModel?: StringFieldUpdateOperationsInput | string
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    llmProvider?: StringFieldUpdateOperationsInput | string
    serperApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    researchLimit?: IntFieldUpdateOperationsInput | number
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    captures?: CaptureUpdateManyWithoutUserNestedInput
    clients?: ClientUpdateManyWithoutUserNestedInput
    dayPlans?: DayPlanUpdateManyWithoutUserNestedInput
    meetings?: MeetingUpdateManyWithoutUserNestedInput
    notes?: NoteUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    researches?: ResearchUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    voiceSessions?: VoiceSessionUpdateManyWithoutUserNestedInput
    weekPlans?: WeekPlanUpdateManyWithoutUserNestedInput
    wellBeingEntries?: WellBeingEntryUpdateManyWithoutUserNestedInput
    yearPlans?: YearPlanUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    geminiModel?: StringFieldUpdateOperationsInput | string
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    llmProvider?: StringFieldUpdateOperationsInput | string
    serperApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    researchLimit?: IntFieldUpdateOperationsInput | number
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    captures?: CaptureUncheckedUpdateManyWithoutUserNestedInput
    clients?: ClientUncheckedUpdateManyWithoutUserNestedInput
    dayPlans?: DayPlanUncheckedUpdateManyWithoutUserNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutUserNestedInput
    notes?: NoteUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    researches?: ResearchUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    voiceSessions?: VoiceSessionUncheckedUpdateManyWithoutUserNestedInput
    weekPlans?: WeekPlanUncheckedUpdateManyWithoutUserNestedInput
    wellBeingEntries?: WellBeingEntryUncheckedUpdateManyWithoutUserNestedInput
    yearPlans?: YearPlanUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    geminiApiKey?: string | null
    geminiModel?: string
    groqApiKey?: string | null
    llmProvider?: string
    serperApiKey?: string | null
    researchLimit?: number
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    geminiModel?: StringFieldUpdateOperationsInput | string
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    llmProvider?: StringFieldUpdateOperationsInput | string
    serperApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    researchLimit?: IntFieldUpdateOperationsInput | number
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    geminiModel?: StringFieldUpdateOperationsInput | string
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    llmProvider?: StringFieldUpdateOperationsInput | string
    serperApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    researchLimit?: IntFieldUpdateOperationsInput | number
  }

  export type YearPlanCreateInput = {
    id?: string
    year: number
    theme: string
    vision: string
    focusAreas?: YearPlanCreatefocusAreasInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    goals?: GoalCreateNestedManyWithoutYearPlanInput
    quarterPlans?: QuarterPlanCreateNestedManyWithoutYearPlanInput
    user: UserCreateNestedOneWithoutYearPlansInput
  }

  export type YearPlanUncheckedCreateInput = {
    id?: string
    userId: string
    year: number
    theme: string
    vision: string
    focusAreas?: YearPlanCreatefocusAreasInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    goals?: GoalUncheckedCreateNestedManyWithoutYearPlanInput
    quarterPlans?: QuarterPlanUncheckedCreateNestedManyWithoutYearPlanInput
  }

  export type YearPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    theme?: StringFieldUpdateOperationsInput | string
    vision?: StringFieldUpdateOperationsInput | string
    focusAreas?: YearPlanUpdatefocusAreasInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    goals?: GoalUpdateManyWithoutYearPlanNestedInput
    quarterPlans?: QuarterPlanUpdateManyWithoutYearPlanNestedInput
    user?: UserUpdateOneRequiredWithoutYearPlansNestedInput
  }

  export type YearPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    theme?: StringFieldUpdateOperationsInput | string
    vision?: StringFieldUpdateOperationsInput | string
    focusAreas?: YearPlanUpdatefocusAreasInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    goals?: GoalUncheckedUpdateManyWithoutYearPlanNestedInput
    quarterPlans?: QuarterPlanUncheckedUpdateManyWithoutYearPlanNestedInput
  }

  export type YearPlanCreateManyInput = {
    id?: string
    userId: string
    year: number
    theme: string
    vision: string
    focusAreas?: YearPlanCreatefocusAreasInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
  }

  export type YearPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    theme?: StringFieldUpdateOperationsInput | string
    vision?: StringFieldUpdateOperationsInput | string
    focusAreas?: YearPlanUpdatefocusAreasInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type YearPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    theme?: StringFieldUpdateOperationsInput | string
    vision?: StringFieldUpdateOperationsInput | string
    focusAreas?: YearPlanUpdatefocusAreasInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type GoalCreateInput = {
    id?: string
    title: string
    description?: string | null
    category: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    kpis?: GoalCreatekpisInput | string[]
    priority?: string
    progress?: number
    risks?: GoalCreaterisksInput | string[]
    strategies?: GoalCreatestrategiesInput | string[]
    targetDate?: Date | string | null
    yearPlan: YearPlanCreateNestedOneWithoutGoalsInput
    keySteps?: KeyStepCreateNestedManyWithoutGoalInput
    milestones?: MilestoneCreateNestedManyWithoutGoalInput
    notes?: NoteCreateNestedManyWithoutGoalInput
    quarterFocuses?: QuarterFocusCreateNestedManyWithoutGoalInput
    researches?: ResearchCreateNestedManyWithoutGoalInput
    tasks?: TaskCreateNestedManyWithoutGoalInput
  }

  export type GoalUncheckedCreateInput = {
    id?: string
    yearPlanId: string
    title: string
    description?: string | null
    category: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    kpis?: GoalCreatekpisInput | string[]
    priority?: string
    progress?: number
    risks?: GoalCreaterisksInput | string[]
    strategies?: GoalCreatestrategiesInput | string[]
    targetDate?: Date | string | null
    keySteps?: KeyStepUncheckedCreateNestedManyWithoutGoalInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutGoalInput
    notes?: NoteUncheckedCreateNestedManyWithoutGoalInput
    quarterFocuses?: QuarterFocusUncheckedCreateNestedManyWithoutGoalInput
    researches?: ResearchUncheckedCreateNestedManyWithoutGoalInput
    tasks?: TaskUncheckedCreateNestedManyWithoutGoalInput
  }

  export type GoalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kpis?: GoalUpdatekpisInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    risks?: GoalUpdaterisksInput | string[]
    strategies?: GoalUpdatestrategiesInput | string[]
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    yearPlan?: YearPlanUpdateOneRequiredWithoutGoalsNestedInput
    keySteps?: KeyStepUpdateManyWithoutGoalNestedInput
    milestones?: MilestoneUpdateManyWithoutGoalNestedInput
    notes?: NoteUpdateManyWithoutGoalNestedInput
    quarterFocuses?: QuarterFocusUpdateManyWithoutGoalNestedInput
    researches?: ResearchUpdateManyWithoutGoalNestedInput
    tasks?: TaskUpdateManyWithoutGoalNestedInput
  }

  export type GoalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    yearPlanId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kpis?: GoalUpdatekpisInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    risks?: GoalUpdaterisksInput | string[]
    strategies?: GoalUpdatestrategiesInput | string[]
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    keySteps?: KeyStepUncheckedUpdateManyWithoutGoalNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutGoalNestedInput
    notes?: NoteUncheckedUpdateManyWithoutGoalNestedInput
    quarterFocuses?: QuarterFocusUncheckedUpdateManyWithoutGoalNestedInput
    researches?: ResearchUncheckedUpdateManyWithoutGoalNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutGoalNestedInput
  }

  export type GoalCreateManyInput = {
    id?: string
    yearPlanId: string
    title: string
    description?: string | null
    category: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    kpis?: GoalCreatekpisInput | string[]
    priority?: string
    progress?: number
    risks?: GoalCreaterisksInput | string[]
    strategies?: GoalCreatestrategiesInput | string[]
    targetDate?: Date | string | null
  }

  export type GoalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kpis?: GoalUpdatekpisInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    risks?: GoalUpdaterisksInput | string[]
    strategies?: GoalUpdatestrategiesInput | string[]
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GoalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    yearPlanId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kpis?: GoalUpdatekpisInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    risks?: GoalUpdaterisksInput | string[]
    strategies?: GoalUpdatestrategiesInput | string[]
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MilestoneCreateInput = {
    id?: string
    title: string
    targetDate?: Date | string | null
    completed?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    goal: GoalCreateNestedOneWithoutMilestonesInput
  }

  export type MilestoneUncheckedCreateInput = {
    id?: string
    goalId: string
    title: string
    targetDate?: Date | string | null
    completed?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MilestoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goal?: GoalUpdateOneRequiredWithoutMilestonesNestedInput
  }

  export type MilestoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneCreateManyInput = {
    id?: string
    goalId: string
    title: string
    targetDate?: Date | string | null
    completed?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MilestoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeyStepCreateInput = {
    id?: string
    title: string
    description?: string | null
    order?: number
    completed?: boolean
    completedAt?: Date | string | null
    progress?: number
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goal: GoalCreateNestedOneWithoutKeyStepsInput
    notes?: NoteCreateNestedManyWithoutKeyStepInput
    tasks?: TaskCreateNestedManyWithoutKeyStepInput
  }

  export type KeyStepUncheckedCreateInput = {
    id?: string
    goalId: string
    title: string
    description?: string | null
    order?: number
    completed?: boolean
    completedAt?: Date | string | null
    progress?: number
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: NoteUncheckedCreateNestedManyWithoutKeyStepInput
    tasks?: TaskUncheckedCreateNestedManyWithoutKeyStepInput
  }

  export type KeyStepUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goal?: GoalUpdateOneRequiredWithoutKeyStepsNestedInput
    notes?: NoteUpdateManyWithoutKeyStepNestedInput
    tasks?: TaskUpdateManyWithoutKeyStepNestedInput
  }

  export type KeyStepUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NoteUncheckedUpdateManyWithoutKeyStepNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutKeyStepNestedInput
  }

  export type KeyStepCreateManyInput = {
    id?: string
    goalId: string
    title: string
    description?: string | null
    order?: number
    completed?: boolean
    completedAt?: Date | string | null
    progress?: number
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeyStepUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeyStepUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dayPlan?: DayPlanCreateNestedOneWithoutNotesInput
    goal?: GoalCreateNestedOneWithoutNotesInput
    keyStep?: KeyStepCreateNestedOneWithoutNotesInput
    user: UserCreateNestedOneWithoutNotesInput
  }

  export type NoteUncheckedCreateInput = {
    id?: string
    userId: string
    content: string
    goalId?: string | null
    keyStepId?: string | null
    dayPlanId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayPlan?: DayPlanUpdateOneWithoutNotesNestedInput
    goal?: GoalUpdateOneWithoutNotesNestedInput
    keyStep?: KeyStepUpdateOneWithoutNotesNestedInput
    user?: UserUpdateOneRequiredWithoutNotesNestedInput
  }

  export type NoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    keyStepId?: NullableStringFieldUpdateOperationsInput | string | null
    dayPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteCreateManyInput = {
    id?: string
    userId: string
    content: string
    goalId?: string | null
    keyStepId?: string | null
    dayPlanId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    keyStepId?: NullableStringFieldUpdateOperationsInput | string | null
    dayPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuarterPlanCreateInput = {
    id?: string
    quarter: number
    theme: string
    startDate: Date | string
    endDate: Date | string
    monthPlans?: MonthPlanCreateNestedManyWithoutQuarterPlanInput
    quarterFocuses?: QuarterFocusCreateNestedManyWithoutQuarterPlanInput
    objectives?: QuarterObjectiveCreateNestedManyWithoutQuarterPlanInput
    yearPlan: YearPlanCreateNestedOneWithoutQuarterPlansInput
  }

  export type QuarterPlanUncheckedCreateInput = {
    id?: string
    yearPlanId: string
    quarter: number
    theme: string
    startDate: Date | string
    endDate: Date | string
    monthPlans?: MonthPlanUncheckedCreateNestedManyWithoutQuarterPlanInput
    quarterFocuses?: QuarterFocusUncheckedCreateNestedManyWithoutQuarterPlanInput
    objectives?: QuarterObjectiveUncheckedCreateNestedManyWithoutQuarterPlanInput
  }

  export type QuarterPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quarter?: IntFieldUpdateOperationsInput | number
    theme?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    monthPlans?: MonthPlanUpdateManyWithoutQuarterPlanNestedInput
    quarterFocuses?: QuarterFocusUpdateManyWithoutQuarterPlanNestedInput
    objectives?: QuarterObjectiveUpdateManyWithoutQuarterPlanNestedInput
    yearPlan?: YearPlanUpdateOneRequiredWithoutQuarterPlansNestedInput
  }

  export type QuarterPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    yearPlanId?: StringFieldUpdateOperationsInput | string
    quarter?: IntFieldUpdateOperationsInput | number
    theme?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    monthPlans?: MonthPlanUncheckedUpdateManyWithoutQuarterPlanNestedInput
    quarterFocuses?: QuarterFocusUncheckedUpdateManyWithoutQuarterPlanNestedInput
    objectives?: QuarterObjectiveUncheckedUpdateManyWithoutQuarterPlanNestedInput
  }

  export type QuarterPlanCreateManyInput = {
    id?: string
    yearPlanId: string
    quarter: number
    theme: string
    startDate: Date | string
    endDate: Date | string
  }

  export type QuarterPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quarter?: IntFieldUpdateOperationsInput | number
    theme?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuarterPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    yearPlanId?: StringFieldUpdateOperationsInput | string
    quarter?: IntFieldUpdateOperationsInput | number
    theme?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuarterObjectiveCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    quarterPlan: QuarterPlanCreateNestedOneWithoutObjectivesInput
  }

  export type QuarterObjectiveUncheckedCreateInput = {
    id?: string
    quarterPlanId: string
    title: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuarterObjectiveUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quarterPlan?: QuarterPlanUpdateOneRequiredWithoutObjectivesNestedInput
  }

  export type QuarterObjectiveUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quarterPlanId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuarterObjectiveCreateManyInput = {
    id?: string
    quarterPlanId: string
    title: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuarterObjectiveUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuarterObjectiveUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quarterPlanId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuarterFocusCreateInput = {
    id?: string
    priority?: number
    progress?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    monthFocuses?: MonthFocusCreateNestedManyWithoutQuarterFocusInput
    goal: GoalCreateNestedOneWithoutQuarterFocusesInput
    quarterPlan: QuarterPlanCreateNestedOneWithoutQuarterFocusesInput
  }

  export type QuarterFocusUncheckedCreateInput = {
    id?: string
    quarterPlanId: string
    goalId: string
    priority?: number
    progress?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    monthFocuses?: MonthFocusUncheckedCreateNestedManyWithoutQuarterFocusInput
  }

  export type QuarterFocusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monthFocuses?: MonthFocusUpdateManyWithoutQuarterFocusNestedInput
    goal?: GoalUpdateOneRequiredWithoutQuarterFocusesNestedInput
    quarterPlan?: QuarterPlanUpdateOneRequiredWithoutQuarterFocusesNestedInput
  }

  export type QuarterFocusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quarterPlanId?: StringFieldUpdateOperationsInput | string
    goalId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monthFocuses?: MonthFocusUncheckedUpdateManyWithoutQuarterFocusNestedInput
  }

  export type QuarterFocusCreateManyInput = {
    id?: string
    quarterPlanId: string
    goalId: string
    priority?: number
    progress?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuarterFocusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuarterFocusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quarterPlanId?: StringFieldUpdateOperationsInput | string
    goalId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonthPlanCreateInput = {
    id?: string
    month: number
    year: number
    objectives?: MonthPlanCreateobjectivesInput | string[]
    completionRate?: number
    energyRating?: number | null
    rating?: number | null
    reviewNotes?: string | null
    theme?: string | null
    monthFocuses?: MonthFocusCreateNestedManyWithoutMonthPlanInput
    quarterPlan: QuarterPlanCreateNestedOneWithoutMonthPlansInput
    weekPlans?: WeekPlanCreateNestedManyWithoutMonthPlanInput
  }

  export type MonthPlanUncheckedCreateInput = {
    id?: string
    quarterPlanId: string
    month: number
    year: number
    objectives?: MonthPlanCreateobjectivesInput | string[]
    completionRate?: number
    energyRating?: number | null
    rating?: number | null
    reviewNotes?: string | null
    theme?: string | null
    monthFocuses?: MonthFocusUncheckedCreateNestedManyWithoutMonthPlanInput
    weekPlans?: WeekPlanUncheckedCreateNestedManyWithoutMonthPlanInput
  }

  export type MonthPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    objectives?: MonthPlanUpdateobjectivesInput | string[]
    completionRate?: FloatFieldUpdateOperationsInput | number
    energyRating?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    monthFocuses?: MonthFocusUpdateManyWithoutMonthPlanNestedInput
    quarterPlan?: QuarterPlanUpdateOneRequiredWithoutMonthPlansNestedInput
    weekPlans?: WeekPlanUpdateManyWithoutMonthPlanNestedInput
  }

  export type MonthPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quarterPlanId?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    objectives?: MonthPlanUpdateobjectivesInput | string[]
    completionRate?: FloatFieldUpdateOperationsInput | number
    energyRating?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    monthFocuses?: MonthFocusUncheckedUpdateManyWithoutMonthPlanNestedInput
    weekPlans?: WeekPlanUncheckedUpdateManyWithoutMonthPlanNestedInput
  }

  export type MonthPlanCreateManyInput = {
    id?: string
    quarterPlanId: string
    month: number
    year: number
    objectives?: MonthPlanCreateobjectivesInput | string[]
    completionRate?: number
    energyRating?: number | null
    rating?: number | null
    reviewNotes?: string | null
    theme?: string | null
  }

  export type MonthPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    objectives?: MonthPlanUpdateobjectivesInput | string[]
    completionRate?: FloatFieldUpdateOperationsInput | number
    energyRating?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MonthPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quarterPlanId?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    objectives?: MonthPlanUpdateobjectivesInput | string[]
    completionRate?: FloatFieldUpdateOperationsInput | number
    energyRating?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MonthFocusCreateInput = {
    id?: string
    priority?: number
    progress?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    monthPlan: MonthPlanCreateNestedOneWithoutMonthFocusesInput
    quarterFocus: QuarterFocusCreateNestedOneWithoutMonthFocusesInput
    weekFocuses?: WeekFocusCreateNestedManyWithoutMonthFocusInput
  }

  export type MonthFocusUncheckedCreateInput = {
    id?: string
    monthPlanId: string
    quarterFocusId: string
    priority?: number
    progress?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    weekFocuses?: WeekFocusUncheckedCreateNestedManyWithoutMonthFocusInput
  }

  export type MonthFocusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monthPlan?: MonthPlanUpdateOneRequiredWithoutMonthFocusesNestedInput
    quarterFocus?: QuarterFocusUpdateOneRequiredWithoutMonthFocusesNestedInput
    weekFocuses?: WeekFocusUpdateManyWithoutMonthFocusNestedInput
  }

  export type MonthFocusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthPlanId?: StringFieldUpdateOperationsInput | string
    quarterFocusId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weekFocuses?: WeekFocusUncheckedUpdateManyWithoutMonthFocusNestedInput
  }

  export type MonthFocusCreateManyInput = {
    id?: string
    monthPlanId: string
    quarterFocusId: string
    priority?: number
    progress?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MonthFocusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonthFocusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthPlanId?: StringFieldUpdateOperationsInput | string
    quarterFocusId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeekPlanCreateInput = {
    id?: string
    weekNumber: number
    year: number
    startDate: Date | string
    endDate: Date | string
    topOutcomes?: WeekPlanCreatetopOutcomesInput | string[]
    plannedClientHours?: number | null
    plannedPersonalHours?: number | null
    challenges?: WeekPlanCreatechallengesInput | string[]
    keyWins?: WeekPlanCreatekeyWinsInput | string[]
    lessonsLearned?: WeekPlanCreatelessonsLearnedInput | string[]
    rating?: number | null
    reviewNotes?: string | null
    dayPlans?: DayPlanCreateNestedManyWithoutWeekPlanInput
    weekFocuses?: WeekFocusCreateNestedManyWithoutWeekPlanInput
    monthPlan: MonthPlanCreateNestedOneWithoutWeekPlansInput
    user: UserCreateNestedOneWithoutWeekPlansInput
  }

  export type WeekPlanUncheckedCreateInput = {
    id?: string
    monthPlanId: string
    weekNumber: number
    year: number
    startDate: Date | string
    endDate: Date | string
    topOutcomes?: WeekPlanCreatetopOutcomesInput | string[]
    plannedClientHours?: number | null
    plannedPersonalHours?: number | null
    userId: string
    challenges?: WeekPlanCreatechallengesInput | string[]
    keyWins?: WeekPlanCreatekeyWinsInput | string[]
    lessonsLearned?: WeekPlanCreatelessonsLearnedInput | string[]
    rating?: number | null
    reviewNotes?: string | null
    dayPlans?: DayPlanUncheckedCreateNestedManyWithoutWeekPlanInput
    weekFocuses?: WeekFocusUncheckedCreateNestedManyWithoutWeekPlanInput
  }

  export type WeekPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    topOutcomes?: WeekPlanUpdatetopOutcomesInput | string[]
    plannedClientHours?: NullableFloatFieldUpdateOperationsInput | number | null
    plannedPersonalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    challenges?: WeekPlanUpdatechallengesInput | string[]
    keyWins?: WeekPlanUpdatekeyWinsInput | string[]
    lessonsLearned?: WeekPlanUpdatelessonsLearnedInput | string[]
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dayPlans?: DayPlanUpdateManyWithoutWeekPlanNestedInput
    weekFocuses?: WeekFocusUpdateManyWithoutWeekPlanNestedInput
    monthPlan?: MonthPlanUpdateOneRequiredWithoutWeekPlansNestedInput
    user?: UserUpdateOneRequiredWithoutWeekPlansNestedInput
  }

  export type WeekPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthPlanId?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    topOutcomes?: WeekPlanUpdatetopOutcomesInput | string[]
    plannedClientHours?: NullableFloatFieldUpdateOperationsInput | number | null
    plannedPersonalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    challenges?: WeekPlanUpdatechallengesInput | string[]
    keyWins?: WeekPlanUpdatekeyWinsInput | string[]
    lessonsLearned?: WeekPlanUpdatelessonsLearnedInput | string[]
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dayPlans?: DayPlanUncheckedUpdateManyWithoutWeekPlanNestedInput
    weekFocuses?: WeekFocusUncheckedUpdateManyWithoutWeekPlanNestedInput
  }

  export type WeekPlanCreateManyInput = {
    id?: string
    monthPlanId: string
    weekNumber: number
    year: number
    startDate: Date | string
    endDate: Date | string
    topOutcomes?: WeekPlanCreatetopOutcomesInput | string[]
    plannedClientHours?: number | null
    plannedPersonalHours?: number | null
    userId: string
    challenges?: WeekPlanCreatechallengesInput | string[]
    keyWins?: WeekPlanCreatekeyWinsInput | string[]
    lessonsLearned?: WeekPlanCreatelessonsLearnedInput | string[]
    rating?: number | null
    reviewNotes?: string | null
  }

  export type WeekPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    topOutcomes?: WeekPlanUpdatetopOutcomesInput | string[]
    plannedClientHours?: NullableFloatFieldUpdateOperationsInput | number | null
    plannedPersonalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    challenges?: WeekPlanUpdatechallengesInput | string[]
    keyWins?: WeekPlanUpdatekeyWinsInput | string[]
    lessonsLearned?: WeekPlanUpdatelessonsLearnedInput | string[]
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WeekPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthPlanId?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    topOutcomes?: WeekPlanUpdatetopOutcomesInput | string[]
    plannedClientHours?: NullableFloatFieldUpdateOperationsInput | number | null
    plannedPersonalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    challenges?: WeekPlanUpdatechallengesInput | string[]
    keyWins?: WeekPlanUpdatekeyWinsInput | string[]
    lessonsLearned?: WeekPlanUpdatelessonsLearnedInput | string[]
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WeekFocusCreateInput = {
    id?: string
    priority?: number
    progress?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dayFocuses?: DayFocusCreateNestedManyWithoutWeekFocusInput
    monthFocus: MonthFocusCreateNestedOneWithoutWeekFocusesInput
    weekPlan: WeekPlanCreateNestedOneWithoutWeekFocusesInput
  }

  export type WeekFocusUncheckedCreateInput = {
    id?: string
    weekPlanId: string
    monthFocusId: string
    priority?: number
    progress?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dayFocuses?: DayFocusUncheckedCreateNestedManyWithoutWeekFocusInput
  }

  export type WeekFocusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayFocuses?: DayFocusUpdateManyWithoutWeekFocusNestedInput
    monthFocus?: MonthFocusUpdateOneRequiredWithoutWeekFocusesNestedInput
    weekPlan?: WeekPlanUpdateOneRequiredWithoutWeekFocusesNestedInput
  }

  export type WeekFocusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekPlanId?: StringFieldUpdateOperationsInput | string
    monthFocusId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayFocuses?: DayFocusUncheckedUpdateManyWithoutWeekFocusNestedInput
  }

  export type WeekFocusCreateManyInput = {
    id?: string
    weekPlanId: string
    monthFocusId: string
    priority?: number
    progress?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeekFocusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeekFocusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekPlanId?: StringFieldUpdateOperationsInput | string
    monthFocusId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DayPlanCreateInput = {
    id?: string
    date: Date | string
    topPriorities?: DayPlanCreatetopPrioritiesInput | string[]
    morningEnergy?: number | null
    afternoonEnergy?: number | null
    eveningEnergy?: number | null
    dailyWin?: string | null
    gratitude?: DayPlanCreategratitudeInput | string[]
    tomorrowPrep?: DayPlanCreatetomorrowPrepInput | string[]
    completionRate?: number
    dayFocuses?: DayFocusCreateNestedManyWithoutDayPlanInput
    user: UserCreateNestedOneWithoutDayPlansInput
    weekPlan: WeekPlanCreateNestedOneWithoutDayPlansInput
    notes?: NoteCreateNestedManyWithoutDayPlanInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutDayPlanInput
  }

  export type DayPlanUncheckedCreateInput = {
    id?: string
    weekPlanId: string
    date: Date | string
    topPriorities?: DayPlanCreatetopPrioritiesInput | string[]
    morningEnergy?: number | null
    afternoonEnergy?: number | null
    eveningEnergy?: number | null
    dailyWin?: string | null
    gratitude?: DayPlanCreategratitudeInput | string[]
    tomorrowPrep?: DayPlanCreatetomorrowPrepInput | string[]
    completionRate?: number
    userId: string
    dayFocuses?: DayFocusUncheckedCreateNestedManyWithoutDayPlanInput
    notes?: NoteUncheckedCreateNestedManyWithoutDayPlanInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutDayPlanInput
  }

  export type DayPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topPriorities?: DayPlanUpdatetopPrioritiesInput | string[]
    morningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    afternoonEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    eveningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyWin?: NullableStringFieldUpdateOperationsInput | string | null
    gratitude?: DayPlanUpdategratitudeInput | string[]
    tomorrowPrep?: DayPlanUpdatetomorrowPrepInput | string[]
    completionRate?: FloatFieldUpdateOperationsInput | number
    dayFocuses?: DayFocusUpdateManyWithoutDayPlanNestedInput
    user?: UserUpdateOneRequiredWithoutDayPlansNestedInput
    weekPlan?: WeekPlanUpdateOneRequiredWithoutDayPlansNestedInput
    notes?: NoteUpdateManyWithoutDayPlanNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutDayPlanNestedInput
  }

  export type DayPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekPlanId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topPriorities?: DayPlanUpdatetopPrioritiesInput | string[]
    morningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    afternoonEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    eveningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyWin?: NullableStringFieldUpdateOperationsInput | string | null
    gratitude?: DayPlanUpdategratitudeInput | string[]
    tomorrowPrep?: DayPlanUpdatetomorrowPrepInput | string[]
    completionRate?: FloatFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    dayFocuses?: DayFocusUncheckedUpdateManyWithoutDayPlanNestedInput
    notes?: NoteUncheckedUpdateManyWithoutDayPlanNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutDayPlanNestedInput
  }

  export type DayPlanCreateManyInput = {
    id?: string
    weekPlanId: string
    date: Date | string
    topPriorities?: DayPlanCreatetopPrioritiesInput | string[]
    morningEnergy?: number | null
    afternoonEnergy?: number | null
    eveningEnergy?: number | null
    dailyWin?: string | null
    gratitude?: DayPlanCreategratitudeInput | string[]
    tomorrowPrep?: DayPlanCreatetomorrowPrepInput | string[]
    completionRate?: number
    userId: string
  }

  export type DayPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topPriorities?: DayPlanUpdatetopPrioritiesInput | string[]
    morningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    afternoonEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    eveningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyWin?: NullableStringFieldUpdateOperationsInput | string | null
    gratitude?: DayPlanUpdategratitudeInput | string[]
    tomorrowPrep?: DayPlanUpdatetomorrowPrepInput | string[]
    completionRate?: FloatFieldUpdateOperationsInput | number
  }

  export type DayPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekPlanId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topPriorities?: DayPlanUpdatetopPrioritiesInput | string[]
    morningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    afternoonEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    eveningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyWin?: NullableStringFieldUpdateOperationsInput | string | null
    gratitude?: DayPlanUpdategratitudeInput | string[]
    tomorrowPrep?: DayPlanUpdatetomorrowPrepInput | string[]
    completionRate?: FloatFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type DayFocusCreateInput = {
    id?: string
    priority?: number
    completed?: boolean
    completedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dayPlan: DayPlanCreateNestedOneWithoutDayFocusesInput
    weekFocus: WeekFocusCreateNestedOneWithoutDayFocusesInput
  }

  export type DayFocusUncheckedCreateInput = {
    id?: string
    dayPlanId: string
    weekFocusId: string
    priority?: number
    completed?: boolean
    completedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DayFocusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayPlan?: DayPlanUpdateOneRequiredWithoutDayFocusesNestedInput
    weekFocus?: WeekFocusUpdateOneRequiredWithoutDayFocusesNestedInput
  }

  export type DayFocusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayPlanId?: StringFieldUpdateOperationsInput | string
    weekFocusId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DayFocusCreateManyInput = {
    id?: string
    dayPlanId: string
    weekFocusId: string
    priority?: number
    completed?: boolean
    completedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DayFocusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DayFocusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayPlanId?: StringFieldUpdateOperationsInput | string
    weekFocusId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeBlockCreateInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    duration: number
    type: string
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    actualDuration?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    focusQuality?: number | null
    notes?: string | null
    client?: ClientCreateNestedOneWithoutTimeBlocksInput
    dayPlan: DayPlanCreateNestedOneWithoutTimeBlocksInput
    project?: ProjectCreateNestedOneWithoutTimeBlocksInput
    task?: TaskCreateNestedOneWithoutTimeBlocksInput
  }

  export type TimeBlockUncheckedCreateInput = {
    id?: string
    dayPlanId: string
    startTime: Date | string
    endTime: Date | string
    duration: number
    type: string
    taskId?: string | null
    projectId?: string | null
    clientId?: string | null
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    actualDuration?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    focusQuality?: number | null
    notes?: string | null
  }

  export type TimeBlockUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    energyBefore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneWithoutTimeBlocksNestedInput
    dayPlan?: DayPlanUpdateOneRequiredWithoutTimeBlocksNestedInput
    project?: ProjectUpdateOneWithoutTimeBlocksNestedInput
    task?: TaskUpdateOneWithoutTimeBlocksNestedInput
  }

  export type TimeBlockUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayPlanId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    energyBefore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimeBlockCreateManyInput = {
    id?: string
    dayPlanId: string
    startTime: Date | string
    endTime: Date | string
    duration: number
    type: string
    taskId?: string | null
    projectId?: string | null
    clientId?: string | null
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    actualDuration?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    focusQuality?: number | null
    notes?: string | null
  }

  export type TimeBlockUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    energyBefore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimeBlockUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayPlanId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    energyBefore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    status: string
    billable?: boolean
    hourlyRate?: number | null
    budgetHours?: number | null
    startDate?: Date | string | null
    deadline?: Date | string | null
    estimatedHours?: number | null
    actualHoursSpent?: number
    completionPercentage?: number
    goalId?: string | null
    parentProjectId?: string | null
    priority: string
    tags?: ProjectCreatetagsInput | string[]
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    archivedAt?: Date | string | null
    icon?: string | null
    client?: ClientCreateNestedOneWithoutProjectsInput
    user: UserCreateNestedOneWithoutProjectsInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutProjectInput
    timeEntries?: TimeEntryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    type: string
    status: string
    clientId?: string | null
    billable?: boolean
    hourlyRate?: number | null
    budgetHours?: number | null
    startDate?: Date | string | null
    deadline?: Date | string | null
    estimatedHours?: number | null
    actualHoursSpent?: number
    completionPercentage?: number
    goalId?: string | null
    parentProjectId?: string | null
    priority: string
    tags?: ProjectCreatetagsInput | string[]
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    archivedAt?: Date | string | null
    icon?: string | null
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutProjectInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    billable?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetHours?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHoursSpent?: FloatFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    parentProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    tags?: ProjectUpdatetagsInput | string[]
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneWithoutProjectsNestedInput
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutProjectNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    billable?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetHours?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHoursSpent?: FloatFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    parentProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    tags?: ProjectUpdatetagsInput | string[]
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutProjectNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    type: string
    status: string
    clientId?: string | null
    billable?: boolean
    hourlyRate?: number | null
    budgetHours?: number | null
    startDate?: Date | string | null
    deadline?: Date | string | null
    estimatedHours?: number | null
    actualHoursSpent?: number
    completionPercentage?: number
    goalId?: string | null
    parentProjectId?: string | null
    priority: string
    tags?: ProjectCreatetagsInput | string[]
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    archivedAt?: Date | string | null
    icon?: string | null
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    billable?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetHours?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHoursSpent?: FloatFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    parentProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    tags?: ProjectUpdatetagsInput | string[]
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    billable?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetHours?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHoursSpent?: FloatFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    parentProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    tags?: ProjectUpdatetagsInput | string[]
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    estimatedMinutes?: number | null
    actualMinutes?: number
    timerRunning?: boolean
    currentTimerStart?: Date | string | null
    scheduledDate?: Date | string | null
    dueDate?: Date | string | null
    priority: string
    type: string
    tags?: TaskCreatetagsInput | string[]
    parentTaskId?: string | null
    dependsOn?: TaskCreatedependsOnInput | string[]
    blocks?: TaskCreateblocksInput | string[]
    energyRequired?: number | null
    isAdHoc?: boolean
    isRecurring?: boolean
    recurringPattern?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actionItem?: ActionItemCreateNestedOneWithoutConvertedToTaskInput
    goal?: GoalCreateNestedOneWithoutTasksInput
    keyStep?: KeyStepCreateNestedOneWithoutTasksInput
    meeting?: MeetingCreateNestedOneWithoutTasksInput
    project?: ProjectCreateNestedOneWithoutTasksInput
    user: UserCreateNestedOneWithoutTasksInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutTaskInput
    timeEntries?: TimeEntryCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    userId: string
    projectId?: string | null
    title: string
    description?: string | null
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    estimatedMinutes?: number | null
    actualMinutes?: number
    timerRunning?: boolean
    currentTimerStart?: Date | string | null
    scheduledDate?: Date | string | null
    dueDate?: Date | string | null
    priority: string
    type: string
    tags?: TaskCreatetagsInput | string[]
    parentTaskId?: string | null
    dependsOn?: TaskCreatedependsOnInput | string[]
    blocks?: TaskCreateblocksInput | string[]
    energyRequired?: number | null
    isAdHoc?: boolean
    isRecurring?: boolean
    recurringPattern?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meetingId?: string | null
    goalId?: string | null
    keyStepId?: string | null
    actionItem?: ActionItemUncheckedCreateNestedOneWithoutConvertedToTaskInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutTaskInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    actualMinutes?: IntFieldUpdateOperationsInput | number
    timerRunning?: BoolFieldUpdateOperationsInput | boolean
    currentTimerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tags?: TaskUpdatetagsInput | string[]
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOn?: TaskUpdatedependsOnInput | string[]
    blocks?: TaskUpdateblocksInput | string[]
    energyRequired?: NullableFloatFieldUpdateOperationsInput | number | null
    isAdHoc?: BoolFieldUpdateOperationsInput | boolean
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionItem?: ActionItemUpdateOneWithoutConvertedToTaskNestedInput
    goal?: GoalUpdateOneWithoutTasksNestedInput
    keyStep?: KeyStepUpdateOneWithoutTasksNestedInput
    meeting?: MeetingUpdateOneWithoutTasksNestedInput
    project?: ProjectUpdateOneWithoutTasksNestedInput
    user?: UserUpdateOneRequiredWithoutTasksNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutTaskNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    actualMinutes?: IntFieldUpdateOperationsInput | number
    timerRunning?: BoolFieldUpdateOperationsInput | boolean
    currentTimerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tags?: TaskUpdatetagsInput | string[]
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOn?: TaskUpdatedependsOnInput | string[]
    blocks?: TaskUpdateblocksInput | string[]
    energyRequired?: NullableFloatFieldUpdateOperationsInput | number | null
    isAdHoc?: BoolFieldUpdateOperationsInput | boolean
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    keyStepId?: NullableStringFieldUpdateOperationsInput | string | null
    actionItem?: ActionItemUncheckedUpdateOneWithoutConvertedToTaskNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutTaskNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskCreateManyInput = {
    id?: string
    userId: string
    projectId?: string | null
    title: string
    description?: string | null
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    estimatedMinutes?: number | null
    actualMinutes?: number
    timerRunning?: boolean
    currentTimerStart?: Date | string | null
    scheduledDate?: Date | string | null
    dueDate?: Date | string | null
    priority: string
    type: string
    tags?: TaskCreatetagsInput | string[]
    parentTaskId?: string | null
    dependsOn?: TaskCreatedependsOnInput | string[]
    blocks?: TaskCreateblocksInput | string[]
    energyRequired?: number | null
    isAdHoc?: boolean
    isRecurring?: boolean
    recurringPattern?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meetingId?: string | null
    goalId?: string | null
    keyStepId?: string | null
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    actualMinutes?: IntFieldUpdateOperationsInput | number
    timerRunning?: BoolFieldUpdateOperationsInput | boolean
    currentTimerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tags?: TaskUpdatetagsInput | string[]
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOn?: TaskUpdatedependsOnInput | string[]
    blocks?: TaskUpdateblocksInput | string[]
    energyRequired?: NullableFloatFieldUpdateOperationsInput | number | null
    isAdHoc?: BoolFieldUpdateOperationsInput | boolean
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    actualMinutes?: IntFieldUpdateOperationsInput | number
    timerRunning?: BoolFieldUpdateOperationsInput | boolean
    currentTimerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tags?: TaskUpdatetagsInput | string[]
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOn?: TaskUpdatedependsOnInput | string[]
    blocks?: TaskUpdateblocksInput | string[]
    energyRequired?: NullableFloatFieldUpdateOperationsInput | number | null
    isAdHoc?: BoolFieldUpdateOperationsInput | boolean
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    keyStepId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimeEntryCreateInput = {
    id?: string
    startTime: Date | string
    endTime?: Date | string | null
    duration: number
    type: string
    description?: string | null
    tags?: TimeEntryCreatetagsInput | string[]
    focusQuality?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    distractions?: number
    billable?: boolean
    hourlyRate?: number | null
    amount?: number
    invoiced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutTimeEntriesInput
    project?: ProjectCreateNestedOneWithoutTimeEntriesInput
    task?: TaskCreateNestedOneWithoutTimeEntriesInput
    user: UserCreateNestedOneWithoutTimeEntriesInput
  }

  export type TimeEntryUncheckedCreateInput = {
    id?: string
    userId: string
    taskId?: string | null
    projectId?: string | null
    clientId?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    duration: number
    type: string
    description?: string | null
    tags?: TimeEntryCreatetagsInput | string[]
    focusQuality?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    distractions?: number
    billable?: boolean
    hourlyRate?: number | null
    amount?: number
    invoiced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TimeEntryUpdatetagsInput | string[]
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    energyBefore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    distractions?: IntFieldUpdateOperationsInput | number
    billable?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    invoiced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutTimeEntriesNestedInput
    project?: ProjectUpdateOneWithoutTimeEntriesNestedInput
    task?: TaskUpdateOneWithoutTimeEntriesNestedInput
    user?: UserUpdateOneRequiredWithoutTimeEntriesNestedInput
  }

  export type TimeEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TimeEntryUpdatetagsInput | string[]
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    energyBefore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    distractions?: IntFieldUpdateOperationsInput | number
    billable?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    invoiced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeEntryCreateManyInput = {
    id?: string
    userId: string
    taskId?: string | null
    projectId?: string | null
    clientId?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    duration: number
    type: string
    description?: string | null
    tags?: TimeEntryCreatetagsInput | string[]
    focusQuality?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    distractions?: number
    billable?: boolean
    hourlyRate?: number | null
    amount?: number
    invoiced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TimeEntryUpdatetagsInput | string[]
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    energyBefore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    distractions?: IntFieldUpdateOperationsInput | number
    billable?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    invoiced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TimeEntryUpdatetagsInput | string[]
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    energyBefore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    distractions?: IntFieldUpdateOperationsInput | number
    billable?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    invoiced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateInput = {
    id?: string
    name: string
    companyName?: string | null
    email: string
    phone?: string | null
    primaryContact?: NullableJsonNullValueInput | InputJsonValue
    additionalContacts?: ClientCreateadditionalContactsInput | InputJsonValue[]
    industry?: string | null
    website?: string | null
    timezone?: string | null
    relationshipHealth?: number | null
    lastContactedAt?: Date | string | null
    preferredCommunication?: string | null
    defaultHourlyRate?: number | null
    paymentTerms?: string | null
    outstandingBalance?: number
    notes?: string | null
    tags?: ClientCreatetagsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastInteractionAt?: Date | string | null
    user: UserCreateNestedOneWithoutClientsInput
    communications?: CommunicationCreateNestedManyWithoutClientInput
    meetings?: MeetingCreateNestedManyWithoutClientInput
    projects?: ProjectCreateNestedManyWithoutClientInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutClientInput
    timeEntries?: TimeEntryCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    companyName?: string | null
    email: string
    phone?: string | null
    primaryContact?: NullableJsonNullValueInput | InputJsonValue
    additionalContacts?: ClientCreateadditionalContactsInput | InputJsonValue[]
    industry?: string | null
    website?: string | null
    timezone?: string | null
    relationshipHealth?: number | null
    lastContactedAt?: Date | string | null
    preferredCommunication?: string | null
    defaultHourlyRate?: number | null
    paymentTerms?: string | null
    outstandingBalance?: number
    notes?: string | null
    tags?: ClientCreatetagsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastInteractionAt?: Date | string | null
    communications?: CommunicationUncheckedCreateNestedManyWithoutClientInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutClientInput
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutClientInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContact?: NullableJsonNullValueInput | InputJsonValue
    additionalContacts?: ClientUpdateadditionalContactsInput | InputJsonValue[]
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipHealth?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredCommunication?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    outstandingBalance?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ClientUpdatetagsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastInteractionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutClientsNestedInput
    communications?: CommunicationUpdateManyWithoutClientNestedInput
    meetings?: MeetingUpdateManyWithoutClientNestedInput
    projects?: ProjectUpdateManyWithoutClientNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutClientNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContact?: NullableJsonNullValueInput | InputJsonValue
    additionalContacts?: ClientUpdateadditionalContactsInput | InputJsonValue[]
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipHealth?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredCommunication?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    outstandingBalance?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ClientUpdatetagsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastInteractionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communications?: CommunicationUncheckedUpdateManyWithoutClientNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutClientNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutClientNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: string
    userId: string
    name: string
    companyName?: string | null
    email: string
    phone?: string | null
    primaryContact?: NullableJsonNullValueInput | InputJsonValue
    additionalContacts?: ClientCreateadditionalContactsInput | InputJsonValue[]
    industry?: string | null
    website?: string | null
    timezone?: string | null
    relationshipHealth?: number | null
    lastContactedAt?: Date | string | null
    preferredCommunication?: string | null
    defaultHourlyRate?: number | null
    paymentTerms?: string | null
    outstandingBalance?: number
    notes?: string | null
    tags?: ClientCreatetagsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastInteractionAt?: Date | string | null
  }

  export type ClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContact?: NullableJsonNullValueInput | InputJsonValue
    additionalContacts?: ClientUpdateadditionalContactsInput | InputJsonValue[]
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipHealth?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredCommunication?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    outstandingBalance?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ClientUpdatetagsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastInteractionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContact?: NullableJsonNullValueInput | InputJsonValue
    additionalContacts?: ClientUpdateadditionalContactsInput | InputJsonValue[]
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipHealth?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredCommunication?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    outstandingBalance?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ClientUpdatetagsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastInteractionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommunicationCreateInput = {
    id?: string
    projectId?: string | null
    type: string
    direction: string
    subject: string
    content: string
    summary?: string | null
    from?: string | null
    to?: CommunicationCreatetoInput | string[]
    cc?: CommunicationCreateccInput | string[]
    attachments?: CommunicationCreateattachmentsInput | InputJsonValue[]
    meetingDate?: Date | string | null
    meetingDuration?: number | null
    attendees?: CommunicationCreateattendeesInput | string[]
    meetingNotes?: string | null
    sentiment?: string | null
    requiresFollowUp?: boolean
    followUpDate?: Date | string | null
    createdAt?: Date | string
    responseTime?: number | null
    client: ClientCreateNestedOneWithoutCommunicationsInput
  }

  export type CommunicationUncheckedCreateInput = {
    id?: string
    clientId: string
    projectId?: string | null
    type: string
    direction: string
    subject: string
    content: string
    summary?: string | null
    from?: string | null
    to?: CommunicationCreatetoInput | string[]
    cc?: CommunicationCreateccInput | string[]
    attachments?: CommunicationCreateattachmentsInput | InputJsonValue[]
    meetingDate?: Date | string | null
    meetingDuration?: number | null
    attendees?: CommunicationCreateattendeesInput | string[]
    meetingNotes?: string | null
    sentiment?: string | null
    requiresFollowUp?: boolean
    followUpDate?: Date | string | null
    createdAt?: Date | string
    responseTime?: number | null
  }

  export type CommunicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    from?: NullableStringFieldUpdateOperationsInput | string | null
    to?: CommunicationUpdatetoInput | string[]
    cc?: CommunicationUpdateccInput | string[]
    attachments?: CommunicationUpdateattachmentsInput | InputJsonValue[]
    meetingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meetingDuration?: NullableIntFieldUpdateOperationsInput | number | null
    attendees?: CommunicationUpdateattendeesInput | string[]
    meetingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    requiresFollowUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    client?: ClientUpdateOneRequiredWithoutCommunicationsNestedInput
  }

  export type CommunicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    from?: NullableStringFieldUpdateOperationsInput | string | null
    to?: CommunicationUpdatetoInput | string[]
    cc?: CommunicationUpdateccInput | string[]
    attachments?: CommunicationUpdateattachmentsInput | InputJsonValue[]
    meetingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meetingDuration?: NullableIntFieldUpdateOperationsInput | number | null
    attendees?: CommunicationUpdateattendeesInput | string[]
    meetingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    requiresFollowUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CommunicationCreateManyInput = {
    id?: string
    clientId: string
    projectId?: string | null
    type: string
    direction: string
    subject: string
    content: string
    summary?: string | null
    from?: string | null
    to?: CommunicationCreatetoInput | string[]
    cc?: CommunicationCreateccInput | string[]
    attachments?: CommunicationCreateattachmentsInput | InputJsonValue[]
    meetingDate?: Date | string | null
    meetingDuration?: number | null
    attendees?: CommunicationCreateattendeesInput | string[]
    meetingNotes?: string | null
    sentiment?: string | null
    requiresFollowUp?: boolean
    followUpDate?: Date | string | null
    createdAt?: Date | string
    responseTime?: number | null
  }

  export type CommunicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    from?: NullableStringFieldUpdateOperationsInput | string | null
    to?: CommunicationUpdatetoInput | string[]
    cc?: CommunicationUpdateccInput | string[]
    attachments?: CommunicationUpdateattachmentsInput | InputJsonValue[]
    meetingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meetingDuration?: NullableIntFieldUpdateOperationsInput | number | null
    attendees?: CommunicationUpdateattendeesInput | string[]
    meetingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    requiresFollowUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CommunicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    from?: NullableStringFieldUpdateOperationsInput | string | null
    to?: CommunicationUpdatetoInput | string[]
    cc?: CommunicationUpdateccInput | string[]
    attachments?: CommunicationUpdateattachmentsInput | InputJsonValue[]
    meetingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meetingDuration?: NullableIntFieldUpdateOperationsInput | number | null
    attendees?: CommunicationUpdateattendeesInput | string[]
    meetingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    requiresFollowUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MeetingCreateInput = {
    id?: string
    projectId?: string | null
    title: string
    description?: string | null
    type?: string
    scheduledAt: Date | string
    duration: number
    timezone?: string
    organizer?: string
    requiredAttendees?: MeetingCreaterequiredAttendeesInput | string[]
    optionalAttendees?: MeetingCreateoptionalAttendeesInput | string[]
    location?: string | null
    meetingLink?: string | null
    agenda?: string | null
    meetingNotes?: string | null
    actionItems?: MeetingCreateactionItemsInput | InputJsonValue[]
    decisions?: MeetingCreatedecisionsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutMeetingsInput
    user: UserCreateNestedOneWithoutMeetingsInput
    tasks?: TaskCreateNestedManyWithoutMeetingInput
  }

  export type MeetingUncheckedCreateInput = {
    id?: string
    clientId?: string | null
    projectId?: string | null
    title: string
    description?: string | null
    type?: string
    scheduledAt: Date | string
    duration: number
    timezone?: string
    organizer?: string
    requiredAttendees?: MeetingCreaterequiredAttendeesInput | string[]
    optionalAttendees?: MeetingCreateoptionalAttendeesInput | string[]
    location?: string | null
    meetingLink?: string | null
    agenda?: string | null
    meetingNotes?: string | null
    actionItems?: MeetingCreateactionItemsInput | InputJsonValue[]
    decisions?: MeetingCreatedecisionsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    tasks?: TaskUncheckedCreateNestedManyWithoutMeetingInput
  }

  export type MeetingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    organizer?: StringFieldUpdateOperationsInput | string
    requiredAttendees?: MeetingUpdaterequiredAttendeesInput | string[]
    optionalAttendees?: MeetingUpdateoptionalAttendeesInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    meetingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    actionItems?: MeetingUpdateactionItemsInput | InputJsonValue[]
    decisions?: MeetingUpdatedecisionsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutMeetingsNestedInput
    user?: UserUpdateOneRequiredWithoutMeetingsNestedInput
    tasks?: TaskUpdateManyWithoutMeetingNestedInput
  }

  export type MeetingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    organizer?: StringFieldUpdateOperationsInput | string
    requiredAttendees?: MeetingUpdaterequiredAttendeesInput | string[]
    optionalAttendees?: MeetingUpdateoptionalAttendeesInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    meetingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    actionItems?: MeetingUpdateactionItemsInput | InputJsonValue[]
    decisions?: MeetingUpdatedecisionsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    tasks?: TaskUncheckedUpdateManyWithoutMeetingNestedInput
  }

  export type MeetingCreateManyInput = {
    id?: string
    clientId?: string | null
    projectId?: string | null
    title: string
    description?: string | null
    type?: string
    scheduledAt: Date | string
    duration: number
    timezone?: string
    organizer?: string
    requiredAttendees?: MeetingCreaterequiredAttendeesInput | string[]
    optionalAttendees?: MeetingCreateoptionalAttendeesInput | string[]
    location?: string | null
    meetingLink?: string | null
    agenda?: string | null
    meetingNotes?: string | null
    actionItems?: MeetingCreateactionItemsInput | InputJsonValue[]
    decisions?: MeetingCreatedecisionsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type MeetingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    organizer?: StringFieldUpdateOperationsInput | string
    requiredAttendees?: MeetingUpdaterequiredAttendeesInput | string[]
    optionalAttendees?: MeetingUpdateoptionalAttendeesInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    meetingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    actionItems?: MeetingUpdateactionItemsInput | InputJsonValue[]
    decisions?: MeetingUpdatedecisionsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    organizer?: StringFieldUpdateOperationsInput | string
    requiredAttendees?: MeetingUpdaterequiredAttendeesInput | string[]
    optionalAttendees?: MeetingUpdateoptionalAttendeesInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    meetingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    actionItems?: MeetingUpdateactionItemsInput | InputJsonValue[]
    decisions?: MeetingUpdatedecisionsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type WellBeingEntryCreateInput = {
    id?: string
    date: Date | string
    morningEnergy?: number | null
    afternoonEnergy?: number | null
    eveningEnergy?: number | null
    averageEnergy?: number | null
    exerciseMinutes?: number
    exerciseType?: string | null
    readingMinutes?: number
    learningMinutes?: number
    meditationMinutes?: number
    sleepHours?: number | null
    sleepQuality?: number | null
    morningJournal?: string | null
    eveningReflection?: string | null
    gratitude?: WellBeingEntryCreategratitudeInput | string[]
    dailyWin?: string | null
    mood?: number | null
    stressLevel?: number | null
    focusQuality?: number | null
    notes?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWellBeingEntriesInput
  }

  export type WellBeingEntryUncheckedCreateInput = {
    id?: string
    userId: string
    date: Date | string
    morningEnergy?: number | null
    afternoonEnergy?: number | null
    eveningEnergy?: number | null
    averageEnergy?: number | null
    exerciseMinutes?: number
    exerciseType?: string | null
    readingMinutes?: number
    learningMinutes?: number
    meditationMinutes?: number
    sleepHours?: number | null
    sleepQuality?: number | null
    morningJournal?: string | null
    eveningReflection?: string | null
    gratitude?: WellBeingEntryCreategratitudeInput | string[]
    dailyWin?: string | null
    mood?: number | null
    stressLevel?: number | null
    focusQuality?: number | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type WellBeingEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    morningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    afternoonEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    eveningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    averageEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    exerciseMinutes?: IntFieldUpdateOperationsInput | number
    exerciseType?: NullableStringFieldUpdateOperationsInput | string | null
    readingMinutes?: IntFieldUpdateOperationsInput | number
    learningMinutes?: IntFieldUpdateOperationsInput | number
    meditationMinutes?: IntFieldUpdateOperationsInput | number
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    sleepQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    morningJournal?: NullableStringFieldUpdateOperationsInput | string | null
    eveningReflection?: NullableStringFieldUpdateOperationsInput | string | null
    gratitude?: WellBeingEntryUpdategratitudeInput | string[]
    dailyWin?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: NullableFloatFieldUpdateOperationsInput | number | null
    stressLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWellBeingEntriesNestedInput
  }

  export type WellBeingEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    morningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    afternoonEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    eveningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    averageEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    exerciseMinutes?: IntFieldUpdateOperationsInput | number
    exerciseType?: NullableStringFieldUpdateOperationsInput | string | null
    readingMinutes?: IntFieldUpdateOperationsInput | number
    learningMinutes?: IntFieldUpdateOperationsInput | number
    meditationMinutes?: IntFieldUpdateOperationsInput | number
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    sleepQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    morningJournal?: NullableStringFieldUpdateOperationsInput | string | null
    eveningReflection?: NullableStringFieldUpdateOperationsInput | string | null
    gratitude?: WellBeingEntryUpdategratitudeInput | string[]
    dailyWin?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: NullableFloatFieldUpdateOperationsInput | number | null
    stressLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WellBeingEntryCreateManyInput = {
    id?: string
    userId: string
    date: Date | string
    morningEnergy?: number | null
    afternoonEnergy?: number | null
    eveningEnergy?: number | null
    averageEnergy?: number | null
    exerciseMinutes?: number
    exerciseType?: string | null
    readingMinutes?: number
    learningMinutes?: number
    meditationMinutes?: number
    sleepHours?: number | null
    sleepQuality?: number | null
    morningJournal?: string | null
    eveningReflection?: string | null
    gratitude?: WellBeingEntryCreategratitudeInput | string[]
    dailyWin?: string | null
    mood?: number | null
    stressLevel?: number | null
    focusQuality?: number | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type WellBeingEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    morningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    afternoonEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    eveningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    averageEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    exerciseMinutes?: IntFieldUpdateOperationsInput | number
    exerciseType?: NullableStringFieldUpdateOperationsInput | string | null
    readingMinutes?: IntFieldUpdateOperationsInput | number
    learningMinutes?: IntFieldUpdateOperationsInput | number
    meditationMinutes?: IntFieldUpdateOperationsInput | number
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    sleepQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    morningJournal?: NullableStringFieldUpdateOperationsInput | string | null
    eveningReflection?: NullableStringFieldUpdateOperationsInput | string | null
    gratitude?: WellBeingEntryUpdategratitudeInput | string[]
    dailyWin?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: NullableFloatFieldUpdateOperationsInput | number | null
    stressLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WellBeingEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    morningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    afternoonEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    eveningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    averageEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    exerciseMinutes?: IntFieldUpdateOperationsInput | number
    exerciseType?: NullableStringFieldUpdateOperationsInput | string | null
    readingMinutes?: IntFieldUpdateOperationsInput | number
    learningMinutes?: IntFieldUpdateOperationsInput | number
    meditationMinutes?: IntFieldUpdateOperationsInput | number
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    sleepQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    morningJournal?: NullableStringFieldUpdateOperationsInput | string | null
    eveningReflection?: NullableStringFieldUpdateOperationsInput | string | null
    gratitude?: WellBeingEntryUpdategratitudeInput | string[]
    dailyWin?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: NullableFloatFieldUpdateOperationsInput | number | null
    stressLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaptureCreateInput = {
    id?: string
    type: string
    content: string
    transcription?: string | null
    status?: string
    convertedToTaskId?: string | null
    convertedToNoteId?: string | null
    suggestedProject?: string | null
    suggestedDueDate?: Date | string | null
    suggestedPriority?: string | null
    tags?: CaptureCreatetagsInput | string[]
    createdAt?: Date | string
    processedAt?: Date | string | null
    user: UserCreateNestedOneWithoutCapturesInput
  }

  export type CaptureUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    content: string
    transcription?: string | null
    status?: string
    convertedToTaskId?: string | null
    convertedToNoteId?: string | null
    suggestedProject?: string | null
    suggestedDueDate?: Date | string | null
    suggestedPriority?: string | null
    tags?: CaptureCreatetagsInput | string[]
    createdAt?: Date | string
    processedAt?: Date | string | null
  }

  export type CaptureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    convertedToTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    convertedToNoteId?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedProject?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suggestedPriority?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CaptureUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutCapturesNestedInput
  }

  export type CaptureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    convertedToTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    convertedToNoteId?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedProject?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suggestedPriority?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CaptureUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CaptureCreateManyInput = {
    id?: string
    userId: string
    type: string
    content: string
    transcription?: string | null
    status?: string
    convertedToTaskId?: string | null
    convertedToNoteId?: string | null
    suggestedProject?: string | null
    suggestedDueDate?: Date | string | null
    suggestedPriority?: string | null
    tags?: CaptureCreatetagsInput | string[]
    createdAt?: Date | string
    processedAt?: Date | string | null
  }

  export type CaptureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    convertedToTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    convertedToNoteId?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedProject?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suggestedPriority?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CaptureUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CaptureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    convertedToTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    convertedToNoteId?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedProject?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suggestedPriority?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CaptureUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VoiceSessionCreateInput = {
    id?: string
    title: string
    duration: number
    recordedAt: Date | string
    audioFileUrl: string
    waveformData?: NullableJsonNullValueInput | InputJsonValue
    transcription?: string | null
    speakers?: VoiceSessionCreatespeakersInput | InputJsonValue[]
    timestamps?: VoiceSessionCreatetimestampsInput | InputJsonValue[]
    summary?: string | null
    keyPoints?: VoiceSessionCreatekeyPointsInput | string[]
    actionItems?: VoiceSessionCreateactionItemsInput | InputJsonValue[]
    projectId?: string | null
    tags?: VoiceSessionCreatetagsInput | string[]
    processed?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutVoiceSessionsInput
  }

  export type VoiceSessionUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    duration: number
    recordedAt: Date | string
    audioFileUrl: string
    waveformData?: NullableJsonNullValueInput | InputJsonValue
    transcription?: string | null
    speakers?: VoiceSessionCreatespeakersInput | InputJsonValue[]
    timestamps?: VoiceSessionCreatetimestampsInput | InputJsonValue[]
    summary?: string | null
    keyPoints?: VoiceSessionCreatekeyPointsInput | string[]
    actionItems?: VoiceSessionCreateactionItemsInput | InputJsonValue[]
    projectId?: string | null
    tags?: VoiceSessionCreatetagsInput | string[]
    processed?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type VoiceSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audioFileUrl?: StringFieldUpdateOperationsInput | string
    waveformData?: NullableJsonNullValueInput | InputJsonValue
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    speakers?: VoiceSessionUpdatespeakersInput | InputJsonValue[]
    timestamps?: VoiceSessionUpdatetimestampsInput | InputJsonValue[]
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyPoints?: VoiceSessionUpdatekeyPointsInput | string[]
    actionItems?: VoiceSessionUpdateactionItemsInput | InputJsonValue[]
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: VoiceSessionUpdatetagsInput | string[]
    processed?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVoiceSessionsNestedInput
  }

  export type VoiceSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audioFileUrl?: StringFieldUpdateOperationsInput | string
    waveformData?: NullableJsonNullValueInput | InputJsonValue
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    speakers?: VoiceSessionUpdatespeakersInput | InputJsonValue[]
    timestamps?: VoiceSessionUpdatetimestampsInput | InputJsonValue[]
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyPoints?: VoiceSessionUpdatekeyPointsInput | string[]
    actionItems?: VoiceSessionUpdateactionItemsInput | InputJsonValue[]
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: VoiceSessionUpdatetagsInput | string[]
    processed?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoiceSessionCreateManyInput = {
    id?: string
    userId: string
    title: string
    duration: number
    recordedAt: Date | string
    audioFileUrl: string
    waveformData?: NullableJsonNullValueInput | InputJsonValue
    transcription?: string | null
    speakers?: VoiceSessionCreatespeakersInput | InputJsonValue[]
    timestamps?: VoiceSessionCreatetimestampsInput | InputJsonValue[]
    summary?: string | null
    keyPoints?: VoiceSessionCreatekeyPointsInput | string[]
    actionItems?: VoiceSessionCreateactionItemsInput | InputJsonValue[]
    projectId?: string | null
    tags?: VoiceSessionCreatetagsInput | string[]
    processed?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type VoiceSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audioFileUrl?: StringFieldUpdateOperationsInput | string
    waveformData?: NullableJsonNullValueInput | InputJsonValue
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    speakers?: VoiceSessionUpdatespeakersInput | InputJsonValue[]
    timestamps?: VoiceSessionUpdatetimestampsInput | InputJsonValue[]
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyPoints?: VoiceSessionUpdatekeyPointsInput | string[]
    actionItems?: VoiceSessionUpdateactionItemsInput | InputJsonValue[]
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: VoiceSessionUpdatetagsInput | string[]
    processed?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoiceSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audioFileUrl?: StringFieldUpdateOperationsInput | string
    waveformData?: NullableJsonNullValueInput | InputJsonValue
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    speakers?: VoiceSessionUpdatespeakersInput | InputJsonValue[]
    timestamps?: VoiceSessionUpdatetimestampsInput | InputJsonValue[]
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyPoints?: VoiceSessionUpdatekeyPointsInput | string[]
    actionItems?: VoiceSessionUpdateactionItemsInput | InputJsonValue[]
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: VoiceSessionUpdatetagsInput | string[]
    processed?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventCreateInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    allDay?: boolean
    timezone: string
    isRecurring?: boolean
    recurrenceRule?: string | null
    projectId?: string | null
    taskId?: string | null
    clientId?: string | null
    meetingId?: string | null
    type: string
    reminders?: CalendarEventCreateremindersInput | InputJsonValue[]
    color?: string | null
    location?: string | null
    attendees?: CalendarEventCreateattendeesInput | string[]
    externalCalendarId?: string | null
    externalEventId?: string | null
    syncStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCalendarEventsInput
  }

  export type CalendarEventUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    allDay?: boolean
    timezone: string
    isRecurring?: boolean
    recurrenceRule?: string | null
    projectId?: string | null
    taskId?: string | null
    clientId?: string | null
    meetingId?: string | null
    type: string
    reminders?: CalendarEventCreateremindersInput | InputJsonValue[]
    color?: string | null
    location?: string | null
    attendees?: CalendarEventCreateattendeesInput | string[]
    externalCalendarId?: string | null
    externalEventId?: string | null
    syncStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    allDay?: BoolFieldUpdateOperationsInput | boolean
    timezone?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    reminders?: CalendarEventUpdateremindersInput | InputJsonValue[]
    color?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attendees?: CalendarEventUpdateattendeesInput | string[]
    externalCalendarId?: NullableStringFieldUpdateOperationsInput | string | null
    externalEventId?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCalendarEventsNestedInput
  }

  export type CalendarEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    allDay?: BoolFieldUpdateOperationsInput | boolean
    timezone?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    reminders?: CalendarEventUpdateremindersInput | InputJsonValue[]
    color?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attendees?: CalendarEventUpdateattendeesInput | string[]
    externalCalendarId?: NullableStringFieldUpdateOperationsInput | string | null
    externalEventId?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventCreateManyInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    allDay?: boolean
    timezone: string
    isRecurring?: boolean
    recurrenceRule?: string | null
    projectId?: string | null
    taskId?: string | null
    clientId?: string | null
    meetingId?: string | null
    type: string
    reminders?: CalendarEventCreateremindersInput | InputJsonValue[]
    color?: string | null
    location?: string | null
    attendees?: CalendarEventCreateattendeesInput | string[]
    externalCalendarId?: string | null
    externalEventId?: string | null
    syncStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    allDay?: BoolFieldUpdateOperationsInput | boolean
    timezone?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    reminders?: CalendarEventUpdateremindersInput | InputJsonValue[]
    color?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attendees?: CalendarEventUpdateattendeesInput | string[]
    externalCalendarId?: NullableStringFieldUpdateOperationsInput | string | null
    externalEventId?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    allDay?: BoolFieldUpdateOperationsInput | boolean
    timezone?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    reminders?: CalendarEventUpdateremindersInput | InputJsonValue[]
    color?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attendees?: CalendarEventUpdateattendeesInput | string[]
    externalCalendarId?: NullableStringFieldUpdateOperationsInput | string | null
    externalEventId?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventCreateInput = {
    id?: string
    eventType: string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAnalyticsEventsInput
  }

  export type AnalyticsEventUncheckedCreateInput = {
    id?: string
    userId: string
    eventType: string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: string | null
    createdAt?: Date | string
  }

  export type AnalyticsEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAnalyticsEventsNestedInput
  }

  export type AnalyticsEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventCreateManyInput = {
    id?: string
    userId: string
    eventType: string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: string | null
    createdAt?: Date | string
  }

  export type AnalyticsEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchCreateInput = {
    id?: string
    title: string
    scope: $Enums.ResearchScope
    searchMethod?: $Enums.SearchMethod
    status?: $Enums.ResearchStatus
    originalPrompt: string
    refinedPrompt: string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    errorMessage?: string | null
    isFavorited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    actionItems?: ActionItemCreateNestedManyWithoutResearchInput
    leadData?: LeadDataCreateNestedOneWithoutResearchInput
    goal?: GoalCreateNestedOneWithoutResearchesInput
    user: UserCreateNestedOneWithoutResearchesInput
    insights?: ResearchInsightCreateNestedManyWithoutResearchInput
    sources?: ResearchSourceCreateNestedManyWithoutResearchInput
  }

  export type ResearchUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    scope: $Enums.ResearchScope
    searchMethod?: $Enums.SearchMethod
    status?: $Enums.ResearchStatus
    originalPrompt: string
    refinedPrompt: string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    errorMessage?: string | null
    goalId?: string | null
    isFavorited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutResearchInput
    leadData?: LeadDataUncheckedCreateNestedOneWithoutResearchInput
    insights?: ResearchInsightUncheckedCreateNestedManyWithoutResearchInput
    sources?: ResearchSourceUncheckedCreateNestedManyWithoutResearchInput
  }

  export type ResearchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    scope?: EnumResearchScopeFieldUpdateOperationsInput | $Enums.ResearchScope
    searchMethod?: EnumSearchMethodFieldUpdateOperationsInput | $Enums.SearchMethod
    status?: EnumResearchStatusFieldUpdateOperationsInput | $Enums.ResearchStatus
    originalPrompt?: StringFieldUpdateOperationsInput | string
    refinedPrompt?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isFavorited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionItems?: ActionItemUpdateManyWithoutResearchNestedInput
    leadData?: LeadDataUpdateOneWithoutResearchNestedInput
    goal?: GoalUpdateOneWithoutResearchesNestedInput
    user?: UserUpdateOneRequiredWithoutResearchesNestedInput
    insights?: ResearchInsightUpdateManyWithoutResearchNestedInput
    sources?: ResearchSourceUpdateManyWithoutResearchNestedInput
  }

  export type ResearchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    scope?: EnumResearchScopeFieldUpdateOperationsInput | $Enums.ResearchScope
    searchMethod?: EnumSearchMethodFieldUpdateOperationsInput | $Enums.SearchMethod
    status?: EnumResearchStatusFieldUpdateOperationsInput | $Enums.ResearchStatus
    originalPrompt?: StringFieldUpdateOperationsInput | string
    refinedPrompt?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    isFavorited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionItems?: ActionItemUncheckedUpdateManyWithoutResearchNestedInput
    leadData?: LeadDataUncheckedUpdateOneWithoutResearchNestedInput
    insights?: ResearchInsightUncheckedUpdateManyWithoutResearchNestedInput
    sources?: ResearchSourceUncheckedUpdateManyWithoutResearchNestedInput
  }

  export type ResearchCreateManyInput = {
    id?: string
    userId: string
    title: string
    scope: $Enums.ResearchScope
    searchMethod?: $Enums.SearchMethod
    status?: $Enums.ResearchStatus
    originalPrompt: string
    refinedPrompt: string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    errorMessage?: string | null
    goalId?: string | null
    isFavorited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ResearchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    scope?: EnumResearchScopeFieldUpdateOperationsInput | $Enums.ResearchScope
    searchMethod?: EnumSearchMethodFieldUpdateOperationsInput | $Enums.SearchMethod
    status?: EnumResearchStatusFieldUpdateOperationsInput | $Enums.ResearchStatus
    originalPrompt?: StringFieldUpdateOperationsInput | string
    refinedPrompt?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isFavorited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ResearchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    scope?: EnumResearchScopeFieldUpdateOperationsInput | $Enums.ResearchScope
    searchMethod?: EnumSearchMethodFieldUpdateOperationsInput | $Enums.SearchMethod
    status?: EnumResearchStatusFieldUpdateOperationsInput | $Enums.ResearchStatus
    originalPrompt?: StringFieldUpdateOperationsInput | string
    refinedPrompt?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    isFavorited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ResearchSourceCreateInput = {
    id?: string
    url: string
    title: string
    content?: string
    excerpt: string
    credibility?: number
    citedInSections?: ResearchSourceCreatecitedInSectionsInput | string[]
    scrapedAt?: Date | string
    research: ResearchCreateNestedOneWithoutSourcesInput
  }

  export type ResearchSourceUncheckedCreateInput = {
    id?: string
    researchId: string
    url: string
    title: string
    content?: string
    excerpt: string
    credibility?: number
    citedInSections?: ResearchSourceCreatecitedInSectionsInput | string[]
    scrapedAt?: Date | string
  }

  export type ResearchSourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    credibility?: FloatFieldUpdateOperationsInput | number
    citedInSections?: ResearchSourceUpdatecitedInSectionsInput | string[]
    scrapedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    research?: ResearchUpdateOneRequiredWithoutSourcesNestedInput
  }

  export type ResearchSourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    researchId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    credibility?: FloatFieldUpdateOperationsInput | number
    citedInSections?: ResearchSourceUpdatecitedInSectionsInput | string[]
    scrapedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchSourceCreateManyInput = {
    id?: string
    researchId: string
    url: string
    title: string
    content?: string
    excerpt: string
    credibility?: number
    citedInSections?: ResearchSourceCreatecitedInSectionsInput | string[]
    scrapedAt?: Date | string
  }

  export type ResearchSourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    credibility?: FloatFieldUpdateOperationsInput | number
    citedInSections?: ResearchSourceUpdatecitedInSectionsInput | string[]
    scrapedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchSourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    researchId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    credibility?: FloatFieldUpdateOperationsInput | number
    citedInSections?: ResearchSourceUpdatecitedInSectionsInput | string[]
    scrapedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchInsightCreateInput = {
    id?: string
    title: string
    content: string
    category: string
    visualData?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number
    order?: number
    createdAt?: Date | string
    research: ResearchCreateNestedOneWithoutInsightsInput
  }

  export type ResearchInsightUncheckedCreateInput = {
    id?: string
    researchId: string
    title: string
    content: string
    category: string
    visualData?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number
    order?: number
    createdAt?: Date | string
  }

  export type ResearchInsightUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    visualData?: NullableJsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    research?: ResearchUpdateOneRequiredWithoutInsightsNestedInput
  }

  export type ResearchInsightUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    researchId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    visualData?: NullableJsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchInsightCreateManyInput = {
    id?: string
    researchId: string
    title: string
    content: string
    category: string
    visualData?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number
    order?: number
    createdAt?: Date | string
  }

  export type ResearchInsightUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    visualData?: NullableJsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchInsightUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    researchId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    visualData?: NullableJsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionItemCreateInput = {
    id?: string
    description: string
    priority?: $Enums.ActionPriority
    effort?: number
    convertedAt?: Date | string | null
    createdAt?: Date | string
    convertedToTask?: TaskCreateNestedOneWithoutActionItemInput
    research: ResearchCreateNestedOneWithoutActionItemsInput
  }

  export type ActionItemUncheckedCreateInput = {
    id?: string
    researchId: string
    description: string
    priority?: $Enums.ActionPriority
    effort?: number
    convertedToTaskId?: string | null
    convertedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ActionItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumActionPriorityFieldUpdateOperationsInput | $Enums.ActionPriority
    effort?: IntFieldUpdateOperationsInput | number
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    convertedToTask?: TaskUpdateOneWithoutActionItemNestedInput
    research?: ResearchUpdateOneRequiredWithoutActionItemsNestedInput
  }

  export type ActionItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    researchId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumActionPriorityFieldUpdateOperationsInput | $Enums.ActionPriority
    effort?: IntFieldUpdateOperationsInput | number
    convertedToTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionItemCreateManyInput = {
    id?: string
    researchId: string
    description: string
    priority?: $Enums.ActionPriority
    effort?: number
    convertedToTaskId?: string | null
    convertedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ActionItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumActionPriorityFieldUpdateOperationsInput | $Enums.ActionPriority
    effort?: IntFieldUpdateOperationsInput | number
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    researchId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumActionPriorityFieldUpdateOperationsInput | $Enums.ActionPriority
    effort?: IntFieldUpdateOperationsInput | number
    convertedToTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadDataCreateInput = {
    id?: string
    totalFound?: number
    exportedAt?: Date | string | null
    leads?: LeadCreateNestedManyWithoutLeadDataInput
    research: ResearchCreateNestedOneWithoutLeadDataInput
  }

  export type LeadDataUncheckedCreateInput = {
    id?: string
    researchId: string
    totalFound?: number
    exportedAt?: Date | string | null
    leads?: LeadUncheckedCreateNestedManyWithoutLeadDataInput
  }

  export type LeadDataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalFound?: IntFieldUpdateOperationsInput | number
    exportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leads?: LeadUpdateManyWithoutLeadDataNestedInput
    research?: ResearchUpdateOneRequiredWithoutLeadDataNestedInput
  }

  export type LeadDataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    researchId?: StringFieldUpdateOperationsInput | string
    totalFound?: IntFieldUpdateOperationsInput | number
    exportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leads?: LeadUncheckedUpdateManyWithoutLeadDataNestedInput
  }

  export type LeadDataCreateManyInput = {
    id?: string
    researchId: string
    totalFound?: number
    exportedAt?: Date | string | null
  }

  export type LeadDataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalFound?: IntFieldUpdateOperationsInput | number
    exportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeadDataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    researchId?: StringFieldUpdateOperationsInput | string
    totalFound?: IntFieldUpdateOperationsInput | number
    exportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeadCreateInput = {
    id?: string
    name: string
    company?: string | null
    email?: string | null
    phone?: string | null
    website?: string | null
    industry?: string | null
    location?: string | null
    painPoints?: LeadCreatepainPointsInput | string[]
    suggestedDM: string
    suggestedEmail: string
    personalization?: NullableJsonNullValueInput | InputJsonValue
    contacted?: boolean
    contactedAt?: Date | string | null
    createdAt?: Date | string
    leadData: LeadDataCreateNestedOneWithoutLeadsInput
  }

  export type LeadUncheckedCreateInput = {
    id?: string
    leadDataId: string
    name: string
    company?: string | null
    email?: string | null
    phone?: string | null
    website?: string | null
    industry?: string | null
    location?: string | null
    painPoints?: LeadCreatepainPointsInput | string[]
    suggestedDM: string
    suggestedEmail: string
    personalization?: NullableJsonNullValueInput | InputJsonValue
    contacted?: boolean
    contactedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type LeadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    painPoints?: LeadUpdatepainPointsInput | string[]
    suggestedDM?: StringFieldUpdateOperationsInput | string
    suggestedEmail?: StringFieldUpdateOperationsInput | string
    personalization?: NullableJsonNullValueInput | InputJsonValue
    contacted?: BoolFieldUpdateOperationsInput | boolean
    contactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadData?: LeadDataUpdateOneRequiredWithoutLeadsNestedInput
  }

  export type LeadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadDataId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    painPoints?: LeadUpdatepainPointsInput | string[]
    suggestedDM?: StringFieldUpdateOperationsInput | string
    suggestedEmail?: StringFieldUpdateOperationsInput | string
    personalization?: NullableJsonNullValueInput | InputJsonValue
    contacted?: BoolFieldUpdateOperationsInput | boolean
    contactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadCreateManyInput = {
    id?: string
    leadDataId: string
    name: string
    company?: string | null
    email?: string | null
    phone?: string | null
    website?: string | null
    industry?: string | null
    location?: string | null
    painPoints?: LeadCreatepainPointsInput | string[]
    suggestedDM: string
    suggestedEmail: string
    personalization?: NullableJsonNullValueInput | InputJsonValue
    contacted?: boolean
    contactedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type LeadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    painPoints?: LeadUpdatepainPointsInput | string[]
    suggestedDM?: StringFieldUpdateOperationsInput | string
    suggestedEmail?: StringFieldUpdateOperationsInput | string
    personalization?: NullableJsonNullValueInput | InputJsonValue
    contacted?: BoolFieldUpdateOperationsInput | boolean
    contactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadDataId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    painPoints?: LeadUpdatepainPointsInput | string[]
    suggestedDM?: StringFieldUpdateOperationsInput | string
    suggestedEmail?: StringFieldUpdateOperationsInput | string
    personalization?: NullableJsonNullValueInput | InputJsonValue
    contacted?: BoolFieldUpdateOperationsInput | boolean
    contactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type AnalyticsEventListRelationFilter = {
    every?: AnalyticsEventWhereInput
    some?: AnalyticsEventWhereInput
    none?: AnalyticsEventWhereInput
  }

  export type CalendarEventListRelationFilter = {
    every?: CalendarEventWhereInput
    some?: CalendarEventWhereInput
    none?: CalendarEventWhereInput
  }

  export type CaptureListRelationFilter = {
    every?: CaptureWhereInput
    some?: CaptureWhereInput
    none?: CaptureWhereInput
  }

  export type ClientListRelationFilter = {
    every?: ClientWhereInput
    some?: ClientWhereInput
    none?: ClientWhereInput
  }

  export type DayPlanListRelationFilter = {
    every?: DayPlanWhereInput
    some?: DayPlanWhereInput
    none?: DayPlanWhereInput
  }

  export type MeetingListRelationFilter = {
    every?: MeetingWhereInput
    some?: MeetingWhereInput
    none?: MeetingWhereInput
  }

  export type NoteListRelationFilter = {
    every?: NoteWhereInput
    some?: NoteWhereInput
    none?: NoteWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type ResearchListRelationFilter = {
    every?: ResearchWhereInput
    some?: ResearchWhereInput
    none?: ResearchWhereInput
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type TimeEntryListRelationFilter = {
    every?: TimeEntryWhereInput
    some?: TimeEntryWhereInput
    none?: TimeEntryWhereInput
  }

  export type VoiceSessionListRelationFilter = {
    every?: VoiceSessionWhereInput
    some?: VoiceSessionWhereInput
    none?: VoiceSessionWhereInput
  }

  export type WeekPlanListRelationFilter = {
    every?: WeekPlanWhereInput
    some?: WeekPlanWhereInput
    none?: WeekPlanWhereInput
  }

  export type WellBeingEntryListRelationFilter = {
    every?: WellBeingEntryWhereInput
    some?: WellBeingEntryWhereInput
    none?: WellBeingEntryWhereInput
  }

  export type YearPlanListRelationFilter = {
    every?: YearPlanWhereInput
    some?: YearPlanWhereInput
    none?: YearPlanWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AnalyticsEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CalendarEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CaptureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DayPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MeetingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResearchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TimeEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VoiceSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WeekPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WellBeingEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YearPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    geminiApiKey?: SortOrder
    geminiModel?: SortOrder
    groqApiKey?: SortOrder
    llmProvider?: SortOrder
    serperApiKey?: SortOrder
    researchLimit?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    researchLimit?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    geminiApiKey?: SortOrder
    geminiModel?: SortOrder
    groqApiKey?: SortOrder
    llmProvider?: SortOrder
    serperApiKey?: SortOrder
    researchLimit?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    geminiApiKey?: SortOrder
    geminiModel?: SortOrder
    groqApiKey?: SortOrder
    llmProvider?: SortOrder
    serperApiKey?: SortOrder
    researchLimit?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    researchLimit?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type GoalListRelationFilter = {
    every?: GoalWhereInput
    some?: GoalWhereInput
    none?: GoalWhereInput
  }

  export type QuarterPlanListRelationFilter = {
    every?: QuarterPlanWhereInput
    some?: QuarterPlanWhereInput
    none?: QuarterPlanWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type GoalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuarterPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YearPlanUserIdYearCompoundUniqueInput = {
    userId: string
    year: number
  }

  export type YearPlanCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    theme?: SortOrder
    vision?: SortOrder
    focusAreas?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type YearPlanAvgOrderByAggregateInput = {
    year?: SortOrder
  }

  export type YearPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    theme?: SortOrder
    vision?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type YearPlanMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    theme?: SortOrder
    vision?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type YearPlanSumOrderByAggregateInput = {
    year?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type YearPlanScalarRelationFilter = {
    is?: YearPlanWhereInput
    isNot?: YearPlanWhereInput
  }

  export type KeyStepListRelationFilter = {
    every?: KeyStepWhereInput
    some?: KeyStepWhereInput
    none?: KeyStepWhereInput
  }

  export type MilestoneListRelationFilter = {
    every?: MilestoneWhereInput
    some?: MilestoneWhereInput
    none?: MilestoneWhereInput
  }

  export type QuarterFocusListRelationFilter = {
    every?: QuarterFocusWhereInput
    some?: QuarterFocusWhereInput
    none?: QuarterFocusWhereInput
  }

  export type KeyStepOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MilestoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuarterFocusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GoalCountOrderByAggregateInput = {
    id?: SortOrder
    yearPlanId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kpis?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
    risks?: SortOrder
    strategies?: SortOrder
    targetDate?: SortOrder
  }

  export type GoalAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type GoalMaxOrderByAggregateInput = {
    id?: SortOrder
    yearPlanId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
    targetDate?: SortOrder
  }

  export type GoalMinOrderByAggregateInput = {
    id?: SortOrder
    yearPlanId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
    targetDate?: SortOrder
  }

  export type GoalSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type GoalScalarRelationFilter = {
    is?: GoalWhereInput
    isNot?: GoalWhereInput
  }

  export type MilestoneCountOrderByAggregateInput = {
    id?: SortOrder
    goalId?: SortOrder
    title?: SortOrder
    targetDate?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MilestoneMaxOrderByAggregateInput = {
    id?: SortOrder
    goalId?: SortOrder
    title?: SortOrder
    targetDate?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MilestoneMinOrderByAggregateInput = {
    id?: SortOrder
    goalId?: SortOrder
    title?: SortOrder
    targetDate?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type KeyStepCountOrderByAggregateInput = {
    id?: SortOrder
    goalId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    order?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrder
    progress?: SortOrder
    targetDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KeyStepAvgOrderByAggregateInput = {
    order?: SortOrder
    progress?: SortOrder
  }

  export type KeyStepMaxOrderByAggregateInput = {
    id?: SortOrder
    goalId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    order?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrder
    progress?: SortOrder
    targetDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KeyStepMinOrderByAggregateInput = {
    id?: SortOrder
    goalId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    order?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrder
    progress?: SortOrder
    targetDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KeyStepSumOrderByAggregateInput = {
    order?: SortOrder
    progress?: SortOrder
  }

  export type DayPlanNullableScalarRelationFilter = {
    is?: DayPlanWhereInput | null
    isNot?: DayPlanWhereInput | null
  }

  export type GoalNullableScalarRelationFilter = {
    is?: GoalWhereInput | null
    isNot?: GoalWhereInput | null
  }

  export type KeyStepNullableScalarRelationFilter = {
    is?: KeyStepWhereInput | null
    isNot?: KeyStepWhereInput | null
  }

  export type NoteCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    goalId?: SortOrder
    keyStepId?: SortOrder
    dayPlanId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NoteMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    goalId?: SortOrder
    keyStepId?: SortOrder
    dayPlanId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NoteMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    goalId?: SortOrder
    keyStepId?: SortOrder
    dayPlanId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MonthPlanListRelationFilter = {
    every?: MonthPlanWhereInput
    some?: MonthPlanWhereInput
    none?: MonthPlanWhereInput
  }

  export type QuarterObjectiveListRelationFilter = {
    every?: QuarterObjectiveWhereInput
    some?: QuarterObjectiveWhereInput
    none?: QuarterObjectiveWhereInput
  }

  export type MonthPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuarterObjectiveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuarterPlanYearPlanIdQuarterCompoundUniqueInput = {
    yearPlanId: string
    quarter: number
  }

  export type QuarterPlanCountOrderByAggregateInput = {
    id?: SortOrder
    yearPlanId?: SortOrder
    quarter?: SortOrder
    theme?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type QuarterPlanAvgOrderByAggregateInput = {
    quarter?: SortOrder
  }

  export type QuarterPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    yearPlanId?: SortOrder
    quarter?: SortOrder
    theme?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type QuarterPlanMinOrderByAggregateInput = {
    id?: SortOrder
    yearPlanId?: SortOrder
    quarter?: SortOrder
    theme?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type QuarterPlanSumOrderByAggregateInput = {
    quarter?: SortOrder
  }

  export type QuarterPlanScalarRelationFilter = {
    is?: QuarterPlanWhereInput
    isNot?: QuarterPlanWhereInput
  }

  export type QuarterObjectiveCountOrderByAggregateInput = {
    id?: SortOrder
    quarterPlanId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuarterObjectiveMaxOrderByAggregateInput = {
    id?: SortOrder
    quarterPlanId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuarterObjectiveMinOrderByAggregateInput = {
    id?: SortOrder
    quarterPlanId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MonthFocusListRelationFilter = {
    every?: MonthFocusWhereInput
    some?: MonthFocusWhereInput
    none?: MonthFocusWhereInput
  }

  export type MonthFocusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuarterFocusQuarterPlanIdGoalIdCompoundUniqueInput = {
    quarterPlanId: string
    goalId: string
  }

  export type QuarterFocusCountOrderByAggregateInput = {
    id?: SortOrder
    quarterPlanId?: SortOrder
    goalId?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuarterFocusAvgOrderByAggregateInput = {
    priority?: SortOrder
    progress?: SortOrder
  }

  export type QuarterFocusMaxOrderByAggregateInput = {
    id?: SortOrder
    quarterPlanId?: SortOrder
    goalId?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuarterFocusMinOrderByAggregateInput = {
    id?: SortOrder
    quarterPlanId?: SortOrder
    goalId?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuarterFocusSumOrderByAggregateInput = {
    priority?: SortOrder
    progress?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type MonthPlanQuarterPlanIdMonthCompoundUniqueInput = {
    quarterPlanId: string
    month: number
  }

  export type MonthPlanCountOrderByAggregateInput = {
    id?: SortOrder
    quarterPlanId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    objectives?: SortOrder
    completionRate?: SortOrder
    energyRating?: SortOrder
    rating?: SortOrder
    reviewNotes?: SortOrder
    theme?: SortOrder
  }

  export type MonthPlanAvgOrderByAggregateInput = {
    month?: SortOrder
    year?: SortOrder
    completionRate?: SortOrder
    energyRating?: SortOrder
    rating?: SortOrder
  }

  export type MonthPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    quarterPlanId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    completionRate?: SortOrder
    energyRating?: SortOrder
    rating?: SortOrder
    reviewNotes?: SortOrder
    theme?: SortOrder
  }

  export type MonthPlanMinOrderByAggregateInput = {
    id?: SortOrder
    quarterPlanId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    completionRate?: SortOrder
    energyRating?: SortOrder
    rating?: SortOrder
    reviewNotes?: SortOrder
    theme?: SortOrder
  }

  export type MonthPlanSumOrderByAggregateInput = {
    month?: SortOrder
    year?: SortOrder
    completionRate?: SortOrder
    energyRating?: SortOrder
    rating?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type MonthPlanScalarRelationFilter = {
    is?: MonthPlanWhereInput
    isNot?: MonthPlanWhereInput
  }

  export type QuarterFocusScalarRelationFilter = {
    is?: QuarterFocusWhereInput
    isNot?: QuarterFocusWhereInput
  }

  export type WeekFocusListRelationFilter = {
    every?: WeekFocusWhereInput
    some?: WeekFocusWhereInput
    none?: WeekFocusWhereInput
  }

  export type WeekFocusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MonthFocusMonthPlanIdQuarterFocusIdCompoundUniqueInput = {
    monthPlanId: string
    quarterFocusId: string
  }

  export type MonthFocusCountOrderByAggregateInput = {
    id?: SortOrder
    monthPlanId?: SortOrder
    quarterFocusId?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MonthFocusAvgOrderByAggregateInput = {
    priority?: SortOrder
    progress?: SortOrder
  }

  export type MonthFocusMaxOrderByAggregateInput = {
    id?: SortOrder
    monthPlanId?: SortOrder
    quarterFocusId?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MonthFocusMinOrderByAggregateInput = {
    id?: SortOrder
    monthPlanId?: SortOrder
    quarterFocusId?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MonthFocusSumOrderByAggregateInput = {
    priority?: SortOrder
    progress?: SortOrder
  }

  export type WeekPlanCountOrderByAggregateInput = {
    id?: SortOrder
    monthPlanId?: SortOrder
    weekNumber?: SortOrder
    year?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    topOutcomes?: SortOrder
    plannedClientHours?: SortOrder
    plannedPersonalHours?: SortOrder
    userId?: SortOrder
    challenges?: SortOrder
    keyWins?: SortOrder
    lessonsLearned?: SortOrder
    rating?: SortOrder
    reviewNotes?: SortOrder
  }

  export type WeekPlanAvgOrderByAggregateInput = {
    weekNumber?: SortOrder
    year?: SortOrder
    plannedClientHours?: SortOrder
    plannedPersonalHours?: SortOrder
    rating?: SortOrder
  }

  export type WeekPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    monthPlanId?: SortOrder
    weekNumber?: SortOrder
    year?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    plannedClientHours?: SortOrder
    plannedPersonalHours?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    reviewNotes?: SortOrder
  }

  export type WeekPlanMinOrderByAggregateInput = {
    id?: SortOrder
    monthPlanId?: SortOrder
    weekNumber?: SortOrder
    year?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    plannedClientHours?: SortOrder
    plannedPersonalHours?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    reviewNotes?: SortOrder
  }

  export type WeekPlanSumOrderByAggregateInput = {
    weekNumber?: SortOrder
    year?: SortOrder
    plannedClientHours?: SortOrder
    plannedPersonalHours?: SortOrder
    rating?: SortOrder
  }

  export type DayFocusListRelationFilter = {
    every?: DayFocusWhereInput
    some?: DayFocusWhereInput
    none?: DayFocusWhereInput
  }

  export type MonthFocusScalarRelationFilter = {
    is?: MonthFocusWhereInput
    isNot?: MonthFocusWhereInput
  }

  export type WeekPlanScalarRelationFilter = {
    is?: WeekPlanWhereInput
    isNot?: WeekPlanWhereInput
  }

  export type DayFocusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WeekFocusWeekPlanIdMonthFocusIdCompoundUniqueInput = {
    weekPlanId: string
    monthFocusId: string
  }

  export type WeekFocusCountOrderByAggregateInput = {
    id?: SortOrder
    weekPlanId?: SortOrder
    monthFocusId?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeekFocusAvgOrderByAggregateInput = {
    priority?: SortOrder
    progress?: SortOrder
  }

  export type WeekFocusMaxOrderByAggregateInput = {
    id?: SortOrder
    weekPlanId?: SortOrder
    monthFocusId?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeekFocusMinOrderByAggregateInput = {
    id?: SortOrder
    weekPlanId?: SortOrder
    monthFocusId?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeekFocusSumOrderByAggregateInput = {
    priority?: SortOrder
    progress?: SortOrder
  }

  export type TimeBlockListRelationFilter = {
    every?: TimeBlockWhereInput
    some?: TimeBlockWhereInput
    none?: TimeBlockWhereInput
  }

  export type TimeBlockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DayPlanUserIdDateCompoundUniqueInput = {
    userId: string
    date: Date | string
  }

  export type DayPlanCountOrderByAggregateInput = {
    id?: SortOrder
    weekPlanId?: SortOrder
    date?: SortOrder
    topPriorities?: SortOrder
    morningEnergy?: SortOrder
    afternoonEnergy?: SortOrder
    eveningEnergy?: SortOrder
    dailyWin?: SortOrder
    gratitude?: SortOrder
    tomorrowPrep?: SortOrder
    completionRate?: SortOrder
    userId?: SortOrder
  }

  export type DayPlanAvgOrderByAggregateInput = {
    morningEnergy?: SortOrder
    afternoonEnergy?: SortOrder
    eveningEnergy?: SortOrder
    completionRate?: SortOrder
  }

  export type DayPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    weekPlanId?: SortOrder
    date?: SortOrder
    morningEnergy?: SortOrder
    afternoonEnergy?: SortOrder
    eveningEnergy?: SortOrder
    dailyWin?: SortOrder
    completionRate?: SortOrder
    userId?: SortOrder
  }

  export type DayPlanMinOrderByAggregateInput = {
    id?: SortOrder
    weekPlanId?: SortOrder
    date?: SortOrder
    morningEnergy?: SortOrder
    afternoonEnergy?: SortOrder
    eveningEnergy?: SortOrder
    dailyWin?: SortOrder
    completionRate?: SortOrder
    userId?: SortOrder
  }

  export type DayPlanSumOrderByAggregateInput = {
    morningEnergy?: SortOrder
    afternoonEnergy?: SortOrder
    eveningEnergy?: SortOrder
    completionRate?: SortOrder
  }

  export type DayPlanScalarRelationFilter = {
    is?: DayPlanWhereInput
    isNot?: DayPlanWhereInput
  }

  export type WeekFocusScalarRelationFilter = {
    is?: WeekFocusWhereInput
    isNot?: WeekFocusWhereInput
  }

  export type DayFocusDayPlanIdWeekFocusIdCompoundUniqueInput = {
    dayPlanId: string
    weekFocusId: string
  }

  export type DayFocusCountOrderByAggregateInput = {
    id?: SortOrder
    dayPlanId?: SortOrder
    weekFocusId?: SortOrder
    priority?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DayFocusAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type DayFocusMaxOrderByAggregateInput = {
    id?: SortOrder
    dayPlanId?: SortOrder
    weekFocusId?: SortOrder
    priority?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DayFocusMinOrderByAggregateInput = {
    id?: SortOrder
    dayPlanId?: SortOrder
    weekFocusId?: SortOrder
    priority?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DayFocusSumOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type ClientNullableScalarRelationFilter = {
    is?: ClientWhereInput | null
    isNot?: ClientWhereInput | null
  }

  export type ProjectNullableScalarRelationFilter = {
    is?: ProjectWhereInput | null
    isNot?: ProjectWhereInput | null
  }

  export type TaskNullableScalarRelationFilter = {
    is?: TaskWhereInput | null
    isNot?: TaskWhereInput | null
  }

  export type TimeBlockCountOrderByAggregateInput = {
    id?: SortOrder
    dayPlanId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    type?: SortOrder
    taskId?: SortOrder
    projectId?: SortOrder
    clientId?: SortOrder
    actualStartTime?: SortOrder
    actualEndTime?: SortOrder
    actualDuration?: SortOrder
    energyBefore?: SortOrder
    energyAfter?: SortOrder
    focusQuality?: SortOrder
    notes?: SortOrder
  }

  export type TimeBlockAvgOrderByAggregateInput = {
    duration?: SortOrder
    actualDuration?: SortOrder
    energyBefore?: SortOrder
    energyAfter?: SortOrder
    focusQuality?: SortOrder
  }

  export type TimeBlockMaxOrderByAggregateInput = {
    id?: SortOrder
    dayPlanId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    type?: SortOrder
    taskId?: SortOrder
    projectId?: SortOrder
    clientId?: SortOrder
    actualStartTime?: SortOrder
    actualEndTime?: SortOrder
    actualDuration?: SortOrder
    energyBefore?: SortOrder
    energyAfter?: SortOrder
    focusQuality?: SortOrder
    notes?: SortOrder
  }

  export type TimeBlockMinOrderByAggregateInput = {
    id?: SortOrder
    dayPlanId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    type?: SortOrder
    taskId?: SortOrder
    projectId?: SortOrder
    clientId?: SortOrder
    actualStartTime?: SortOrder
    actualEndTime?: SortOrder
    actualDuration?: SortOrder
    energyBefore?: SortOrder
    energyAfter?: SortOrder
    focusQuality?: SortOrder
    notes?: SortOrder
  }

  export type TimeBlockSumOrderByAggregateInput = {
    duration?: SortOrder
    actualDuration?: SortOrder
    energyBefore?: SortOrder
    energyAfter?: SortOrder
    focusQuality?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    clientId?: SortOrder
    billable?: SortOrder
    hourlyRate?: SortOrder
    budgetHours?: SortOrder
    startDate?: SortOrder
    deadline?: SortOrder
    estimatedHours?: SortOrder
    actualHoursSpent?: SortOrder
    completionPercentage?: SortOrder
    goalId?: SortOrder
    parentProjectId?: SortOrder
    priority?: SortOrder
    tags?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    archivedAt?: SortOrder
    icon?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    hourlyRate?: SortOrder
    budgetHours?: SortOrder
    estimatedHours?: SortOrder
    actualHoursSpent?: SortOrder
    completionPercentage?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    clientId?: SortOrder
    billable?: SortOrder
    hourlyRate?: SortOrder
    budgetHours?: SortOrder
    startDate?: SortOrder
    deadline?: SortOrder
    estimatedHours?: SortOrder
    actualHoursSpent?: SortOrder
    completionPercentage?: SortOrder
    goalId?: SortOrder
    parentProjectId?: SortOrder
    priority?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    archivedAt?: SortOrder
    icon?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    clientId?: SortOrder
    billable?: SortOrder
    hourlyRate?: SortOrder
    budgetHours?: SortOrder
    startDate?: SortOrder
    deadline?: SortOrder
    estimatedHours?: SortOrder
    actualHoursSpent?: SortOrder
    completionPercentage?: SortOrder
    goalId?: SortOrder
    parentProjectId?: SortOrder
    priority?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    archivedAt?: SortOrder
    icon?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    hourlyRate?: SortOrder
    budgetHours?: SortOrder
    estimatedHours?: SortOrder
    actualHoursSpent?: SortOrder
    completionPercentage?: SortOrder
  }

  export type ActionItemNullableScalarRelationFilter = {
    is?: ActionItemWhereInput | null
    isNot?: ActionItemWhereInput | null
  }

  export type MeetingNullableScalarRelationFilter = {
    is?: MeetingWhereInput | null
    isNot?: MeetingWhereInput | null
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    estimatedMinutes?: SortOrder
    actualMinutes?: SortOrder
    timerRunning?: SortOrder
    currentTimerStart?: SortOrder
    scheduledDate?: SortOrder
    dueDate?: SortOrder
    priority?: SortOrder
    type?: SortOrder
    tags?: SortOrder
    parentTaskId?: SortOrder
    dependsOn?: SortOrder
    blocks?: SortOrder
    energyRequired?: SortOrder
    isAdHoc?: SortOrder
    isRecurring?: SortOrder
    recurringPattern?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    meetingId?: SortOrder
    goalId?: SortOrder
    keyStepId?: SortOrder
  }

  export type TaskAvgOrderByAggregateInput = {
    estimatedMinutes?: SortOrder
    actualMinutes?: SortOrder
    energyRequired?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    estimatedMinutes?: SortOrder
    actualMinutes?: SortOrder
    timerRunning?: SortOrder
    currentTimerStart?: SortOrder
    scheduledDate?: SortOrder
    dueDate?: SortOrder
    priority?: SortOrder
    type?: SortOrder
    parentTaskId?: SortOrder
    energyRequired?: SortOrder
    isAdHoc?: SortOrder
    isRecurring?: SortOrder
    recurringPattern?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    meetingId?: SortOrder
    goalId?: SortOrder
    keyStepId?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    estimatedMinutes?: SortOrder
    actualMinutes?: SortOrder
    timerRunning?: SortOrder
    currentTimerStart?: SortOrder
    scheduledDate?: SortOrder
    dueDate?: SortOrder
    priority?: SortOrder
    type?: SortOrder
    parentTaskId?: SortOrder
    energyRequired?: SortOrder
    isAdHoc?: SortOrder
    isRecurring?: SortOrder
    recurringPattern?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    meetingId?: SortOrder
    goalId?: SortOrder
    keyStepId?: SortOrder
  }

  export type TaskSumOrderByAggregateInput = {
    estimatedMinutes?: SortOrder
    actualMinutes?: SortOrder
    energyRequired?: SortOrder
  }

  export type TimeEntryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    projectId?: SortOrder
    clientId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    type?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    focusQuality?: SortOrder
    energyBefore?: SortOrder
    energyAfter?: SortOrder
    distractions?: SortOrder
    billable?: SortOrder
    hourlyRate?: SortOrder
    amount?: SortOrder
    invoiced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimeEntryAvgOrderByAggregateInput = {
    duration?: SortOrder
    focusQuality?: SortOrder
    energyBefore?: SortOrder
    energyAfter?: SortOrder
    distractions?: SortOrder
    hourlyRate?: SortOrder
    amount?: SortOrder
  }

  export type TimeEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    projectId?: SortOrder
    clientId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    type?: SortOrder
    description?: SortOrder
    focusQuality?: SortOrder
    energyBefore?: SortOrder
    energyAfter?: SortOrder
    distractions?: SortOrder
    billable?: SortOrder
    hourlyRate?: SortOrder
    amount?: SortOrder
    invoiced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimeEntryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    projectId?: SortOrder
    clientId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    type?: SortOrder
    description?: SortOrder
    focusQuality?: SortOrder
    energyBefore?: SortOrder
    energyAfter?: SortOrder
    distractions?: SortOrder
    billable?: SortOrder
    hourlyRate?: SortOrder
    amount?: SortOrder
    invoiced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimeEntrySumOrderByAggregateInput = {
    duration?: SortOrder
    focusQuality?: SortOrder
    energyBefore?: SortOrder
    energyAfter?: SortOrder
    distractions?: SortOrder
    hourlyRate?: SortOrder
    amount?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type JsonNullableListFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableListFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableListFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableListFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableListFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableListFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel> | null
    has?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    hasEvery?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>
    hasSome?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type CommunicationListRelationFilter = {
    every?: CommunicationWhereInput
    some?: CommunicationWhereInput
    none?: CommunicationWhereInput
  }

  export type CommunicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    companyName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    primaryContact?: SortOrder
    additionalContacts?: SortOrder
    industry?: SortOrder
    website?: SortOrder
    timezone?: SortOrder
    relationshipHealth?: SortOrder
    lastContactedAt?: SortOrder
    preferredCommunication?: SortOrder
    defaultHourlyRate?: SortOrder
    paymentTerms?: SortOrder
    outstandingBalance?: SortOrder
    notes?: SortOrder
    tags?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastInteractionAt?: SortOrder
  }

  export type ClientAvgOrderByAggregateInput = {
    relationshipHealth?: SortOrder
    defaultHourlyRate?: SortOrder
    outstandingBalance?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    companyName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    industry?: SortOrder
    website?: SortOrder
    timezone?: SortOrder
    relationshipHealth?: SortOrder
    lastContactedAt?: SortOrder
    preferredCommunication?: SortOrder
    defaultHourlyRate?: SortOrder
    paymentTerms?: SortOrder
    outstandingBalance?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastInteractionAt?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    companyName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    industry?: SortOrder
    website?: SortOrder
    timezone?: SortOrder
    relationshipHealth?: SortOrder
    lastContactedAt?: SortOrder
    preferredCommunication?: SortOrder
    defaultHourlyRate?: SortOrder
    paymentTerms?: SortOrder
    outstandingBalance?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastInteractionAt?: SortOrder
  }

  export type ClientSumOrderByAggregateInput = {
    relationshipHealth?: SortOrder
    defaultHourlyRate?: SortOrder
    outstandingBalance?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type ClientScalarRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type CommunicationCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    direction?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    summary?: SortOrder
    from?: SortOrder
    to?: SortOrder
    cc?: SortOrder
    attachments?: SortOrder
    meetingDate?: SortOrder
    meetingDuration?: SortOrder
    attendees?: SortOrder
    meetingNotes?: SortOrder
    sentiment?: SortOrder
    requiresFollowUp?: SortOrder
    followUpDate?: SortOrder
    createdAt?: SortOrder
    responseTime?: SortOrder
  }

  export type CommunicationAvgOrderByAggregateInput = {
    meetingDuration?: SortOrder
    responseTime?: SortOrder
  }

  export type CommunicationMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    direction?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    summary?: SortOrder
    from?: SortOrder
    meetingDate?: SortOrder
    meetingDuration?: SortOrder
    meetingNotes?: SortOrder
    sentiment?: SortOrder
    requiresFollowUp?: SortOrder
    followUpDate?: SortOrder
    createdAt?: SortOrder
    responseTime?: SortOrder
  }

  export type CommunicationMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    direction?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    summary?: SortOrder
    from?: SortOrder
    meetingDate?: SortOrder
    meetingDuration?: SortOrder
    meetingNotes?: SortOrder
    sentiment?: SortOrder
    requiresFollowUp?: SortOrder
    followUpDate?: SortOrder
    createdAt?: SortOrder
    responseTime?: SortOrder
  }

  export type CommunicationSumOrderByAggregateInput = {
    meetingDuration?: SortOrder
    responseTime?: SortOrder
  }

  export type MeetingCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    timezone?: SortOrder
    organizer?: SortOrder
    requiredAttendees?: SortOrder
    optionalAttendees?: SortOrder
    location?: SortOrder
    meetingLink?: SortOrder
    agenda?: SortOrder
    meetingNotes?: SortOrder
    actionItems?: SortOrder
    decisions?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type MeetingAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type MeetingMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    timezone?: SortOrder
    organizer?: SortOrder
    location?: SortOrder
    meetingLink?: SortOrder
    agenda?: SortOrder
    meetingNotes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type MeetingMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    timezone?: SortOrder
    organizer?: SortOrder
    location?: SortOrder
    meetingLink?: SortOrder
    agenda?: SortOrder
    meetingNotes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type MeetingSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type WellBeingEntryUserIdDateCompoundUniqueInput = {
    userId: string
    date: Date | string
  }

  export type WellBeingEntryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    morningEnergy?: SortOrder
    afternoonEnergy?: SortOrder
    eveningEnergy?: SortOrder
    averageEnergy?: SortOrder
    exerciseMinutes?: SortOrder
    exerciseType?: SortOrder
    readingMinutes?: SortOrder
    learningMinutes?: SortOrder
    meditationMinutes?: SortOrder
    sleepHours?: SortOrder
    sleepQuality?: SortOrder
    morningJournal?: SortOrder
    eveningReflection?: SortOrder
    gratitude?: SortOrder
    dailyWin?: SortOrder
    mood?: SortOrder
    stressLevel?: SortOrder
    focusQuality?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type WellBeingEntryAvgOrderByAggregateInput = {
    morningEnergy?: SortOrder
    afternoonEnergy?: SortOrder
    eveningEnergy?: SortOrder
    averageEnergy?: SortOrder
    exerciseMinutes?: SortOrder
    readingMinutes?: SortOrder
    learningMinutes?: SortOrder
    meditationMinutes?: SortOrder
    sleepHours?: SortOrder
    sleepQuality?: SortOrder
    mood?: SortOrder
    stressLevel?: SortOrder
    focusQuality?: SortOrder
  }

  export type WellBeingEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    morningEnergy?: SortOrder
    afternoonEnergy?: SortOrder
    eveningEnergy?: SortOrder
    averageEnergy?: SortOrder
    exerciseMinutes?: SortOrder
    exerciseType?: SortOrder
    readingMinutes?: SortOrder
    learningMinutes?: SortOrder
    meditationMinutes?: SortOrder
    sleepHours?: SortOrder
    sleepQuality?: SortOrder
    morningJournal?: SortOrder
    eveningReflection?: SortOrder
    dailyWin?: SortOrder
    mood?: SortOrder
    stressLevel?: SortOrder
    focusQuality?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type WellBeingEntryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    morningEnergy?: SortOrder
    afternoonEnergy?: SortOrder
    eveningEnergy?: SortOrder
    averageEnergy?: SortOrder
    exerciseMinutes?: SortOrder
    exerciseType?: SortOrder
    readingMinutes?: SortOrder
    learningMinutes?: SortOrder
    meditationMinutes?: SortOrder
    sleepHours?: SortOrder
    sleepQuality?: SortOrder
    morningJournal?: SortOrder
    eveningReflection?: SortOrder
    dailyWin?: SortOrder
    mood?: SortOrder
    stressLevel?: SortOrder
    focusQuality?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type WellBeingEntrySumOrderByAggregateInput = {
    morningEnergy?: SortOrder
    afternoonEnergy?: SortOrder
    eveningEnergy?: SortOrder
    averageEnergy?: SortOrder
    exerciseMinutes?: SortOrder
    readingMinutes?: SortOrder
    learningMinutes?: SortOrder
    meditationMinutes?: SortOrder
    sleepHours?: SortOrder
    sleepQuality?: SortOrder
    mood?: SortOrder
    stressLevel?: SortOrder
    focusQuality?: SortOrder
  }

  export type CaptureCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    transcription?: SortOrder
    status?: SortOrder
    convertedToTaskId?: SortOrder
    convertedToNoteId?: SortOrder
    suggestedProject?: SortOrder
    suggestedDueDate?: SortOrder
    suggestedPriority?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
  }

  export type CaptureMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    transcription?: SortOrder
    status?: SortOrder
    convertedToTaskId?: SortOrder
    convertedToNoteId?: SortOrder
    suggestedProject?: SortOrder
    suggestedDueDate?: SortOrder
    suggestedPriority?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
  }

  export type CaptureMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    transcription?: SortOrder
    status?: SortOrder
    convertedToTaskId?: SortOrder
    convertedToNoteId?: SortOrder
    suggestedProject?: SortOrder
    suggestedDueDate?: SortOrder
    suggestedPriority?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
  }

  export type VoiceSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    duration?: SortOrder
    recordedAt?: SortOrder
    audioFileUrl?: SortOrder
    waveformData?: SortOrder
    transcription?: SortOrder
    speakers?: SortOrder
    timestamps?: SortOrder
    summary?: SortOrder
    keyPoints?: SortOrder
    actionItems?: SortOrder
    projectId?: SortOrder
    tags?: SortOrder
    processed?: SortOrder
    archivedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type VoiceSessionAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type VoiceSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    duration?: SortOrder
    recordedAt?: SortOrder
    audioFileUrl?: SortOrder
    transcription?: SortOrder
    summary?: SortOrder
    projectId?: SortOrder
    processed?: SortOrder
    archivedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type VoiceSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    duration?: SortOrder
    recordedAt?: SortOrder
    audioFileUrl?: SortOrder
    transcription?: SortOrder
    summary?: SortOrder
    projectId?: SortOrder
    processed?: SortOrder
    archivedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type VoiceSessionSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type CalendarEventCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    allDay?: SortOrder
    timezone?: SortOrder
    isRecurring?: SortOrder
    recurrenceRule?: SortOrder
    projectId?: SortOrder
    taskId?: SortOrder
    clientId?: SortOrder
    meetingId?: SortOrder
    type?: SortOrder
    reminders?: SortOrder
    color?: SortOrder
    location?: SortOrder
    attendees?: SortOrder
    externalCalendarId?: SortOrder
    externalEventId?: SortOrder
    syncStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalendarEventMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    allDay?: SortOrder
    timezone?: SortOrder
    isRecurring?: SortOrder
    recurrenceRule?: SortOrder
    projectId?: SortOrder
    taskId?: SortOrder
    clientId?: SortOrder
    meetingId?: SortOrder
    type?: SortOrder
    color?: SortOrder
    location?: SortOrder
    externalCalendarId?: SortOrder
    externalEventId?: SortOrder
    syncStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalendarEventMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    allDay?: SortOrder
    timezone?: SortOrder
    isRecurring?: SortOrder
    recurrenceRule?: SortOrder
    projectId?: SortOrder
    taskId?: SortOrder
    clientId?: SortOrder
    meetingId?: SortOrder
    type?: SortOrder
    color?: SortOrder
    location?: SortOrder
    externalCalendarId?: SortOrder
    externalEventId?: SortOrder
    syncStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalyticsEventCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    eventData?: SortOrder
    sessionId?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsEventMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    sessionId?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsEventMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    sessionId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumResearchScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.ResearchScope | EnumResearchScopeFieldRefInput<$PrismaModel>
    in?: $Enums.ResearchScope[] | ListEnumResearchScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResearchScope[] | ListEnumResearchScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumResearchScopeFilter<$PrismaModel> | $Enums.ResearchScope
  }

  export type EnumSearchMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.SearchMethod | EnumSearchMethodFieldRefInput<$PrismaModel>
    in?: $Enums.SearchMethod[] | ListEnumSearchMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.SearchMethod[] | ListEnumSearchMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumSearchMethodFilter<$PrismaModel> | $Enums.SearchMethod
  }

  export type EnumResearchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ResearchStatus | EnumResearchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ResearchStatus[] | ListEnumResearchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResearchStatus[] | ListEnumResearchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumResearchStatusFilter<$PrismaModel> | $Enums.ResearchStatus
  }

  export type ActionItemListRelationFilter = {
    every?: ActionItemWhereInput
    some?: ActionItemWhereInput
    none?: ActionItemWhereInput
  }

  export type LeadDataNullableScalarRelationFilter = {
    is?: LeadDataWhereInput | null
    isNot?: LeadDataWhereInput | null
  }

  export type ResearchInsightListRelationFilter = {
    every?: ResearchInsightWhereInput
    some?: ResearchInsightWhereInput
    none?: ResearchInsightWhereInput
  }

  export type ResearchSourceListRelationFilter = {
    every?: ResearchSourceWhereInput
    some?: ResearchSourceWhereInput
    none?: ResearchSourceWhereInput
  }

  export type ActionItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResearchInsightOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResearchSourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResearchCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    scope?: SortOrder
    searchMethod?: SortOrder
    status?: SortOrder
    originalPrompt?: SortOrder
    refinedPrompt?: SortOrder
    rawData?: SortOrder
    progress?: SortOrder
    errorMessage?: SortOrder
    goalId?: SortOrder
    isFavorited?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ResearchAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type ResearchMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    scope?: SortOrder
    searchMethod?: SortOrder
    status?: SortOrder
    originalPrompt?: SortOrder
    refinedPrompt?: SortOrder
    progress?: SortOrder
    errorMessage?: SortOrder
    goalId?: SortOrder
    isFavorited?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ResearchMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    scope?: SortOrder
    searchMethod?: SortOrder
    status?: SortOrder
    originalPrompt?: SortOrder
    refinedPrompt?: SortOrder
    progress?: SortOrder
    errorMessage?: SortOrder
    goalId?: SortOrder
    isFavorited?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ResearchSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type EnumResearchScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResearchScope | EnumResearchScopeFieldRefInput<$PrismaModel>
    in?: $Enums.ResearchScope[] | ListEnumResearchScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResearchScope[] | ListEnumResearchScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumResearchScopeWithAggregatesFilter<$PrismaModel> | $Enums.ResearchScope
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResearchScopeFilter<$PrismaModel>
    _max?: NestedEnumResearchScopeFilter<$PrismaModel>
  }

  export type EnumSearchMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SearchMethod | EnumSearchMethodFieldRefInput<$PrismaModel>
    in?: $Enums.SearchMethod[] | ListEnumSearchMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.SearchMethod[] | ListEnumSearchMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumSearchMethodWithAggregatesFilter<$PrismaModel> | $Enums.SearchMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSearchMethodFilter<$PrismaModel>
    _max?: NestedEnumSearchMethodFilter<$PrismaModel>
  }

  export type EnumResearchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResearchStatus | EnumResearchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ResearchStatus[] | ListEnumResearchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResearchStatus[] | ListEnumResearchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumResearchStatusWithAggregatesFilter<$PrismaModel> | $Enums.ResearchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResearchStatusFilter<$PrismaModel>
    _max?: NestedEnumResearchStatusFilter<$PrismaModel>
  }

  export type ResearchScalarRelationFilter = {
    is?: ResearchWhereInput
    isNot?: ResearchWhereInput
  }

  export type ResearchSourceCountOrderByAggregateInput = {
    id?: SortOrder
    researchId?: SortOrder
    url?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    credibility?: SortOrder
    citedInSections?: SortOrder
    scrapedAt?: SortOrder
  }

  export type ResearchSourceAvgOrderByAggregateInput = {
    credibility?: SortOrder
  }

  export type ResearchSourceMaxOrderByAggregateInput = {
    id?: SortOrder
    researchId?: SortOrder
    url?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    credibility?: SortOrder
    scrapedAt?: SortOrder
  }

  export type ResearchSourceMinOrderByAggregateInput = {
    id?: SortOrder
    researchId?: SortOrder
    url?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    credibility?: SortOrder
    scrapedAt?: SortOrder
  }

  export type ResearchSourceSumOrderByAggregateInput = {
    credibility?: SortOrder
  }

  export type ResearchInsightCountOrderByAggregateInput = {
    id?: SortOrder
    researchId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    visualData?: SortOrder
    confidence?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type ResearchInsightAvgOrderByAggregateInput = {
    confidence?: SortOrder
    order?: SortOrder
  }

  export type ResearchInsightMaxOrderByAggregateInput = {
    id?: SortOrder
    researchId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    confidence?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type ResearchInsightMinOrderByAggregateInput = {
    id?: SortOrder
    researchId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    confidence?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type ResearchInsightSumOrderByAggregateInput = {
    confidence?: SortOrder
    order?: SortOrder
  }

  export type EnumActionPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionPriority | EnumActionPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.ActionPriority[] | ListEnumActionPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionPriority[] | ListEnumActionPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumActionPriorityFilter<$PrismaModel> | $Enums.ActionPriority
  }

  export type ActionItemCountOrderByAggregateInput = {
    id?: SortOrder
    researchId?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    effort?: SortOrder
    convertedToTaskId?: SortOrder
    convertedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ActionItemAvgOrderByAggregateInput = {
    effort?: SortOrder
  }

  export type ActionItemMaxOrderByAggregateInput = {
    id?: SortOrder
    researchId?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    effort?: SortOrder
    convertedToTaskId?: SortOrder
    convertedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ActionItemMinOrderByAggregateInput = {
    id?: SortOrder
    researchId?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    effort?: SortOrder
    convertedToTaskId?: SortOrder
    convertedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ActionItemSumOrderByAggregateInput = {
    effort?: SortOrder
  }

  export type EnumActionPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionPriority | EnumActionPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.ActionPriority[] | ListEnumActionPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionPriority[] | ListEnumActionPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumActionPriorityWithAggregatesFilter<$PrismaModel> | $Enums.ActionPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionPriorityFilter<$PrismaModel>
    _max?: NestedEnumActionPriorityFilter<$PrismaModel>
  }

  export type LeadListRelationFilter = {
    every?: LeadWhereInput
    some?: LeadWhereInput
    none?: LeadWhereInput
  }

  export type LeadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeadDataCountOrderByAggregateInput = {
    id?: SortOrder
    researchId?: SortOrder
    totalFound?: SortOrder
    exportedAt?: SortOrder
  }

  export type LeadDataAvgOrderByAggregateInput = {
    totalFound?: SortOrder
  }

  export type LeadDataMaxOrderByAggregateInput = {
    id?: SortOrder
    researchId?: SortOrder
    totalFound?: SortOrder
    exportedAt?: SortOrder
  }

  export type LeadDataMinOrderByAggregateInput = {
    id?: SortOrder
    researchId?: SortOrder
    totalFound?: SortOrder
    exportedAt?: SortOrder
  }

  export type LeadDataSumOrderByAggregateInput = {
    totalFound?: SortOrder
  }

  export type LeadDataScalarRelationFilter = {
    is?: LeadDataWhereInput
    isNot?: LeadDataWhereInput
  }

  export type LeadCountOrderByAggregateInput = {
    id?: SortOrder
    leadDataId?: SortOrder
    name?: SortOrder
    company?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    industry?: SortOrder
    location?: SortOrder
    painPoints?: SortOrder
    suggestedDM?: SortOrder
    suggestedEmail?: SortOrder
    personalization?: SortOrder
    contacted?: SortOrder
    contactedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type LeadMaxOrderByAggregateInput = {
    id?: SortOrder
    leadDataId?: SortOrder
    name?: SortOrder
    company?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    industry?: SortOrder
    location?: SortOrder
    suggestedDM?: SortOrder
    suggestedEmail?: SortOrder
    contacted?: SortOrder
    contactedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type LeadMinOrderByAggregateInput = {
    id?: SortOrder
    leadDataId?: SortOrder
    name?: SortOrder
    company?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    industry?: SortOrder
    location?: SortOrder
    suggestedDM?: SortOrder
    suggestedEmail?: SortOrder
    contacted?: SortOrder
    contactedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsEventCreateNestedManyWithoutUserInput = {
    create?: XOR<AnalyticsEventCreateWithoutUserInput, AnalyticsEventUncheckedCreateWithoutUserInput> | AnalyticsEventCreateWithoutUserInput[] | AnalyticsEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnalyticsEventCreateOrConnectWithoutUserInput | AnalyticsEventCreateOrConnectWithoutUserInput[]
    createMany?: AnalyticsEventCreateManyUserInputEnvelope
    connect?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
  }

  export type CalendarEventCreateNestedManyWithoutUserInput = {
    create?: XOR<CalendarEventCreateWithoutUserInput, CalendarEventUncheckedCreateWithoutUserInput> | CalendarEventCreateWithoutUserInput[] | CalendarEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutUserInput | CalendarEventCreateOrConnectWithoutUserInput[]
    createMany?: CalendarEventCreateManyUserInputEnvelope
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
  }

  export type CaptureCreateNestedManyWithoutUserInput = {
    create?: XOR<CaptureCreateWithoutUserInput, CaptureUncheckedCreateWithoutUserInput> | CaptureCreateWithoutUserInput[] | CaptureUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CaptureCreateOrConnectWithoutUserInput | CaptureCreateOrConnectWithoutUserInput[]
    createMany?: CaptureCreateManyUserInputEnvelope
    connect?: CaptureWhereUniqueInput | CaptureWhereUniqueInput[]
  }

  export type ClientCreateNestedManyWithoutUserInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput> | ClientCreateWithoutUserInput[] | ClientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput | ClientCreateOrConnectWithoutUserInput[]
    createMany?: ClientCreateManyUserInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type DayPlanCreateNestedManyWithoutUserInput = {
    create?: XOR<DayPlanCreateWithoutUserInput, DayPlanUncheckedCreateWithoutUserInput> | DayPlanCreateWithoutUserInput[] | DayPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DayPlanCreateOrConnectWithoutUserInput | DayPlanCreateOrConnectWithoutUserInput[]
    createMany?: DayPlanCreateManyUserInputEnvelope
    connect?: DayPlanWhereUniqueInput | DayPlanWhereUniqueInput[]
  }

  export type MeetingCreateNestedManyWithoutUserInput = {
    create?: XOR<MeetingCreateWithoutUserInput, MeetingUncheckedCreateWithoutUserInput> | MeetingCreateWithoutUserInput[] | MeetingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutUserInput | MeetingCreateOrConnectWithoutUserInput[]
    createMany?: MeetingCreateManyUserInputEnvelope
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
  }

  export type NoteCreateNestedManyWithoutUserInput = {
    create?: XOR<NoteCreateWithoutUserInput, NoteUncheckedCreateWithoutUserInput> | NoteCreateWithoutUserInput[] | NoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutUserInput | NoteCreateOrConnectWithoutUserInput[]
    createMany?: NoteCreateManyUserInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ResearchCreateNestedManyWithoutUserInput = {
    create?: XOR<ResearchCreateWithoutUserInput, ResearchUncheckedCreateWithoutUserInput> | ResearchCreateWithoutUserInput[] | ResearchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResearchCreateOrConnectWithoutUserInput | ResearchCreateOrConnectWithoutUserInput[]
    createMany?: ResearchCreateManyUserInputEnvelope
    connect?: ResearchWhereUniqueInput | ResearchWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput> | TaskCreateWithoutUserInput[] | TaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutUserInput | TaskCreateOrConnectWithoutUserInput[]
    createMany?: TaskCreateManyUserInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TimeEntryCreateNestedManyWithoutUserInput = {
    create?: XOR<TimeEntryCreateWithoutUserInput, TimeEntryUncheckedCreateWithoutUserInput> | TimeEntryCreateWithoutUserInput[] | TimeEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutUserInput | TimeEntryCreateOrConnectWithoutUserInput[]
    createMany?: TimeEntryCreateManyUserInputEnvelope
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
  }

  export type VoiceSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<VoiceSessionCreateWithoutUserInput, VoiceSessionUncheckedCreateWithoutUserInput> | VoiceSessionCreateWithoutUserInput[] | VoiceSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoiceSessionCreateOrConnectWithoutUserInput | VoiceSessionCreateOrConnectWithoutUserInput[]
    createMany?: VoiceSessionCreateManyUserInputEnvelope
    connect?: VoiceSessionWhereUniqueInput | VoiceSessionWhereUniqueInput[]
  }

  export type WeekPlanCreateNestedManyWithoutUserInput = {
    create?: XOR<WeekPlanCreateWithoutUserInput, WeekPlanUncheckedCreateWithoutUserInput> | WeekPlanCreateWithoutUserInput[] | WeekPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WeekPlanCreateOrConnectWithoutUserInput | WeekPlanCreateOrConnectWithoutUserInput[]
    createMany?: WeekPlanCreateManyUserInputEnvelope
    connect?: WeekPlanWhereUniqueInput | WeekPlanWhereUniqueInput[]
  }

  export type WellBeingEntryCreateNestedManyWithoutUserInput = {
    create?: XOR<WellBeingEntryCreateWithoutUserInput, WellBeingEntryUncheckedCreateWithoutUserInput> | WellBeingEntryCreateWithoutUserInput[] | WellBeingEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WellBeingEntryCreateOrConnectWithoutUserInput | WellBeingEntryCreateOrConnectWithoutUserInput[]
    createMany?: WellBeingEntryCreateManyUserInputEnvelope
    connect?: WellBeingEntryWhereUniqueInput | WellBeingEntryWhereUniqueInput[]
  }

  export type YearPlanCreateNestedManyWithoutUserInput = {
    create?: XOR<YearPlanCreateWithoutUserInput, YearPlanUncheckedCreateWithoutUserInput> | YearPlanCreateWithoutUserInput[] | YearPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: YearPlanCreateOrConnectWithoutUserInput | YearPlanCreateOrConnectWithoutUserInput[]
    createMany?: YearPlanCreateManyUserInputEnvelope
    connect?: YearPlanWhereUniqueInput | YearPlanWhereUniqueInput[]
  }

  export type AnalyticsEventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AnalyticsEventCreateWithoutUserInput, AnalyticsEventUncheckedCreateWithoutUserInput> | AnalyticsEventCreateWithoutUserInput[] | AnalyticsEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnalyticsEventCreateOrConnectWithoutUserInput | AnalyticsEventCreateOrConnectWithoutUserInput[]
    createMany?: AnalyticsEventCreateManyUserInputEnvelope
    connect?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
  }

  export type CalendarEventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CalendarEventCreateWithoutUserInput, CalendarEventUncheckedCreateWithoutUserInput> | CalendarEventCreateWithoutUserInput[] | CalendarEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutUserInput | CalendarEventCreateOrConnectWithoutUserInput[]
    createMany?: CalendarEventCreateManyUserInputEnvelope
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
  }

  export type CaptureUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CaptureCreateWithoutUserInput, CaptureUncheckedCreateWithoutUserInput> | CaptureCreateWithoutUserInput[] | CaptureUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CaptureCreateOrConnectWithoutUserInput | CaptureCreateOrConnectWithoutUserInput[]
    createMany?: CaptureCreateManyUserInputEnvelope
    connect?: CaptureWhereUniqueInput | CaptureWhereUniqueInput[]
  }

  export type ClientUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput> | ClientCreateWithoutUserInput[] | ClientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput | ClientCreateOrConnectWithoutUserInput[]
    createMany?: ClientCreateManyUserInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type DayPlanUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DayPlanCreateWithoutUserInput, DayPlanUncheckedCreateWithoutUserInput> | DayPlanCreateWithoutUserInput[] | DayPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DayPlanCreateOrConnectWithoutUserInput | DayPlanCreateOrConnectWithoutUserInput[]
    createMany?: DayPlanCreateManyUserInputEnvelope
    connect?: DayPlanWhereUniqueInput | DayPlanWhereUniqueInput[]
  }

  export type MeetingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MeetingCreateWithoutUserInput, MeetingUncheckedCreateWithoutUserInput> | MeetingCreateWithoutUserInput[] | MeetingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutUserInput | MeetingCreateOrConnectWithoutUserInput[]
    createMany?: MeetingCreateManyUserInputEnvelope
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
  }

  export type NoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NoteCreateWithoutUserInput, NoteUncheckedCreateWithoutUserInput> | NoteCreateWithoutUserInput[] | NoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutUserInput | NoteCreateOrConnectWithoutUserInput[]
    createMany?: NoteCreateManyUserInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ResearchUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ResearchCreateWithoutUserInput, ResearchUncheckedCreateWithoutUserInput> | ResearchCreateWithoutUserInput[] | ResearchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResearchCreateOrConnectWithoutUserInput | ResearchCreateOrConnectWithoutUserInput[]
    createMany?: ResearchCreateManyUserInputEnvelope
    connect?: ResearchWhereUniqueInput | ResearchWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput> | TaskCreateWithoutUserInput[] | TaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutUserInput | TaskCreateOrConnectWithoutUserInput[]
    createMany?: TaskCreateManyUserInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TimeEntryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TimeEntryCreateWithoutUserInput, TimeEntryUncheckedCreateWithoutUserInput> | TimeEntryCreateWithoutUserInput[] | TimeEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutUserInput | TimeEntryCreateOrConnectWithoutUserInput[]
    createMany?: TimeEntryCreateManyUserInputEnvelope
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
  }

  export type VoiceSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<VoiceSessionCreateWithoutUserInput, VoiceSessionUncheckedCreateWithoutUserInput> | VoiceSessionCreateWithoutUserInput[] | VoiceSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoiceSessionCreateOrConnectWithoutUserInput | VoiceSessionCreateOrConnectWithoutUserInput[]
    createMany?: VoiceSessionCreateManyUserInputEnvelope
    connect?: VoiceSessionWhereUniqueInput | VoiceSessionWhereUniqueInput[]
  }

  export type WeekPlanUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WeekPlanCreateWithoutUserInput, WeekPlanUncheckedCreateWithoutUserInput> | WeekPlanCreateWithoutUserInput[] | WeekPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WeekPlanCreateOrConnectWithoutUserInput | WeekPlanCreateOrConnectWithoutUserInput[]
    createMany?: WeekPlanCreateManyUserInputEnvelope
    connect?: WeekPlanWhereUniqueInput | WeekPlanWhereUniqueInput[]
  }

  export type WellBeingEntryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WellBeingEntryCreateWithoutUserInput, WellBeingEntryUncheckedCreateWithoutUserInput> | WellBeingEntryCreateWithoutUserInput[] | WellBeingEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WellBeingEntryCreateOrConnectWithoutUserInput | WellBeingEntryCreateOrConnectWithoutUserInput[]
    createMany?: WellBeingEntryCreateManyUserInputEnvelope
    connect?: WellBeingEntryWhereUniqueInput | WellBeingEntryWhereUniqueInput[]
  }

  export type YearPlanUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<YearPlanCreateWithoutUserInput, YearPlanUncheckedCreateWithoutUserInput> | YearPlanCreateWithoutUserInput[] | YearPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: YearPlanCreateOrConnectWithoutUserInput | YearPlanCreateOrConnectWithoutUserInput[]
    createMany?: YearPlanCreateManyUserInputEnvelope
    connect?: YearPlanWhereUniqueInput | YearPlanWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AnalyticsEventUpdateManyWithoutUserNestedInput = {
    create?: XOR<AnalyticsEventCreateWithoutUserInput, AnalyticsEventUncheckedCreateWithoutUserInput> | AnalyticsEventCreateWithoutUserInput[] | AnalyticsEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnalyticsEventCreateOrConnectWithoutUserInput | AnalyticsEventCreateOrConnectWithoutUserInput[]
    upsert?: AnalyticsEventUpsertWithWhereUniqueWithoutUserInput | AnalyticsEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AnalyticsEventCreateManyUserInputEnvelope
    set?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    disconnect?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    delete?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    connect?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    update?: AnalyticsEventUpdateWithWhereUniqueWithoutUserInput | AnalyticsEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AnalyticsEventUpdateManyWithWhereWithoutUserInput | AnalyticsEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AnalyticsEventScalarWhereInput | AnalyticsEventScalarWhereInput[]
  }

  export type CalendarEventUpdateManyWithoutUserNestedInput = {
    create?: XOR<CalendarEventCreateWithoutUserInput, CalendarEventUncheckedCreateWithoutUserInput> | CalendarEventCreateWithoutUserInput[] | CalendarEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutUserInput | CalendarEventCreateOrConnectWithoutUserInput[]
    upsert?: CalendarEventUpsertWithWhereUniqueWithoutUserInput | CalendarEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CalendarEventCreateManyUserInputEnvelope
    set?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    disconnect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    delete?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    update?: CalendarEventUpdateWithWhereUniqueWithoutUserInput | CalendarEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CalendarEventUpdateManyWithWhereWithoutUserInput | CalendarEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
  }

  export type CaptureUpdateManyWithoutUserNestedInput = {
    create?: XOR<CaptureCreateWithoutUserInput, CaptureUncheckedCreateWithoutUserInput> | CaptureCreateWithoutUserInput[] | CaptureUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CaptureCreateOrConnectWithoutUserInput | CaptureCreateOrConnectWithoutUserInput[]
    upsert?: CaptureUpsertWithWhereUniqueWithoutUserInput | CaptureUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CaptureCreateManyUserInputEnvelope
    set?: CaptureWhereUniqueInput | CaptureWhereUniqueInput[]
    disconnect?: CaptureWhereUniqueInput | CaptureWhereUniqueInput[]
    delete?: CaptureWhereUniqueInput | CaptureWhereUniqueInput[]
    connect?: CaptureWhereUniqueInput | CaptureWhereUniqueInput[]
    update?: CaptureUpdateWithWhereUniqueWithoutUserInput | CaptureUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CaptureUpdateManyWithWhereWithoutUserInput | CaptureUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CaptureScalarWhereInput | CaptureScalarWhereInput[]
  }

  export type ClientUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput> | ClientCreateWithoutUserInput[] | ClientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput | ClientCreateOrConnectWithoutUserInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutUserInput | ClientUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClientCreateManyUserInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutUserInput | ClientUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutUserInput | ClientUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type DayPlanUpdateManyWithoutUserNestedInput = {
    create?: XOR<DayPlanCreateWithoutUserInput, DayPlanUncheckedCreateWithoutUserInput> | DayPlanCreateWithoutUserInput[] | DayPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DayPlanCreateOrConnectWithoutUserInput | DayPlanCreateOrConnectWithoutUserInput[]
    upsert?: DayPlanUpsertWithWhereUniqueWithoutUserInput | DayPlanUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DayPlanCreateManyUserInputEnvelope
    set?: DayPlanWhereUniqueInput | DayPlanWhereUniqueInput[]
    disconnect?: DayPlanWhereUniqueInput | DayPlanWhereUniqueInput[]
    delete?: DayPlanWhereUniqueInput | DayPlanWhereUniqueInput[]
    connect?: DayPlanWhereUniqueInput | DayPlanWhereUniqueInput[]
    update?: DayPlanUpdateWithWhereUniqueWithoutUserInput | DayPlanUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DayPlanUpdateManyWithWhereWithoutUserInput | DayPlanUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DayPlanScalarWhereInput | DayPlanScalarWhereInput[]
  }

  export type MeetingUpdateManyWithoutUserNestedInput = {
    create?: XOR<MeetingCreateWithoutUserInput, MeetingUncheckedCreateWithoutUserInput> | MeetingCreateWithoutUserInput[] | MeetingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutUserInput | MeetingCreateOrConnectWithoutUserInput[]
    upsert?: MeetingUpsertWithWhereUniqueWithoutUserInput | MeetingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MeetingCreateManyUserInputEnvelope
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    update?: MeetingUpdateWithWhereUniqueWithoutUserInput | MeetingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MeetingUpdateManyWithWhereWithoutUserInput | MeetingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
  }

  export type NoteUpdateManyWithoutUserNestedInput = {
    create?: XOR<NoteCreateWithoutUserInput, NoteUncheckedCreateWithoutUserInput> | NoteCreateWithoutUserInput[] | NoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutUserInput | NoteCreateOrConnectWithoutUserInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutUserInput | NoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NoteCreateManyUserInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutUserInput | NoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutUserInput | NoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutUserInput | ProjectUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutUserInput | ProjectUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutUserInput | ProjectUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ResearchUpdateManyWithoutUserNestedInput = {
    create?: XOR<ResearchCreateWithoutUserInput, ResearchUncheckedCreateWithoutUserInput> | ResearchCreateWithoutUserInput[] | ResearchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResearchCreateOrConnectWithoutUserInput | ResearchCreateOrConnectWithoutUserInput[]
    upsert?: ResearchUpsertWithWhereUniqueWithoutUserInput | ResearchUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ResearchCreateManyUserInputEnvelope
    set?: ResearchWhereUniqueInput | ResearchWhereUniqueInput[]
    disconnect?: ResearchWhereUniqueInput | ResearchWhereUniqueInput[]
    delete?: ResearchWhereUniqueInput | ResearchWhereUniqueInput[]
    connect?: ResearchWhereUniqueInput | ResearchWhereUniqueInput[]
    update?: ResearchUpdateWithWhereUniqueWithoutUserInput | ResearchUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ResearchUpdateManyWithWhereWithoutUserInput | ResearchUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ResearchScalarWhereInput | ResearchScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput> | TaskCreateWithoutUserInput[] | TaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutUserInput | TaskCreateOrConnectWithoutUserInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutUserInput | TaskUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskCreateManyUserInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutUserInput | TaskUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutUserInput | TaskUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TimeEntryUpdateManyWithoutUserNestedInput = {
    create?: XOR<TimeEntryCreateWithoutUserInput, TimeEntryUncheckedCreateWithoutUserInput> | TimeEntryCreateWithoutUserInput[] | TimeEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutUserInput | TimeEntryCreateOrConnectWithoutUserInput[]
    upsert?: TimeEntryUpsertWithWhereUniqueWithoutUserInput | TimeEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TimeEntryCreateManyUserInputEnvelope
    set?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    disconnect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    delete?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    update?: TimeEntryUpdateWithWhereUniqueWithoutUserInput | TimeEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TimeEntryUpdateManyWithWhereWithoutUserInput | TimeEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TimeEntryScalarWhereInput | TimeEntryScalarWhereInput[]
  }

  export type VoiceSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<VoiceSessionCreateWithoutUserInput, VoiceSessionUncheckedCreateWithoutUserInput> | VoiceSessionCreateWithoutUserInput[] | VoiceSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoiceSessionCreateOrConnectWithoutUserInput | VoiceSessionCreateOrConnectWithoutUserInput[]
    upsert?: VoiceSessionUpsertWithWhereUniqueWithoutUserInput | VoiceSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VoiceSessionCreateManyUserInputEnvelope
    set?: VoiceSessionWhereUniqueInput | VoiceSessionWhereUniqueInput[]
    disconnect?: VoiceSessionWhereUniqueInput | VoiceSessionWhereUniqueInput[]
    delete?: VoiceSessionWhereUniqueInput | VoiceSessionWhereUniqueInput[]
    connect?: VoiceSessionWhereUniqueInput | VoiceSessionWhereUniqueInput[]
    update?: VoiceSessionUpdateWithWhereUniqueWithoutUserInput | VoiceSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VoiceSessionUpdateManyWithWhereWithoutUserInput | VoiceSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VoiceSessionScalarWhereInput | VoiceSessionScalarWhereInput[]
  }

  export type WeekPlanUpdateManyWithoutUserNestedInput = {
    create?: XOR<WeekPlanCreateWithoutUserInput, WeekPlanUncheckedCreateWithoutUserInput> | WeekPlanCreateWithoutUserInput[] | WeekPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WeekPlanCreateOrConnectWithoutUserInput | WeekPlanCreateOrConnectWithoutUserInput[]
    upsert?: WeekPlanUpsertWithWhereUniqueWithoutUserInput | WeekPlanUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WeekPlanCreateManyUserInputEnvelope
    set?: WeekPlanWhereUniqueInput | WeekPlanWhereUniqueInput[]
    disconnect?: WeekPlanWhereUniqueInput | WeekPlanWhereUniqueInput[]
    delete?: WeekPlanWhereUniqueInput | WeekPlanWhereUniqueInput[]
    connect?: WeekPlanWhereUniqueInput | WeekPlanWhereUniqueInput[]
    update?: WeekPlanUpdateWithWhereUniqueWithoutUserInput | WeekPlanUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WeekPlanUpdateManyWithWhereWithoutUserInput | WeekPlanUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WeekPlanScalarWhereInput | WeekPlanScalarWhereInput[]
  }

  export type WellBeingEntryUpdateManyWithoutUserNestedInput = {
    create?: XOR<WellBeingEntryCreateWithoutUserInput, WellBeingEntryUncheckedCreateWithoutUserInput> | WellBeingEntryCreateWithoutUserInput[] | WellBeingEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WellBeingEntryCreateOrConnectWithoutUserInput | WellBeingEntryCreateOrConnectWithoutUserInput[]
    upsert?: WellBeingEntryUpsertWithWhereUniqueWithoutUserInput | WellBeingEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WellBeingEntryCreateManyUserInputEnvelope
    set?: WellBeingEntryWhereUniqueInput | WellBeingEntryWhereUniqueInput[]
    disconnect?: WellBeingEntryWhereUniqueInput | WellBeingEntryWhereUniqueInput[]
    delete?: WellBeingEntryWhereUniqueInput | WellBeingEntryWhereUniqueInput[]
    connect?: WellBeingEntryWhereUniqueInput | WellBeingEntryWhereUniqueInput[]
    update?: WellBeingEntryUpdateWithWhereUniqueWithoutUserInput | WellBeingEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WellBeingEntryUpdateManyWithWhereWithoutUserInput | WellBeingEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WellBeingEntryScalarWhereInput | WellBeingEntryScalarWhereInput[]
  }

  export type YearPlanUpdateManyWithoutUserNestedInput = {
    create?: XOR<YearPlanCreateWithoutUserInput, YearPlanUncheckedCreateWithoutUserInput> | YearPlanCreateWithoutUserInput[] | YearPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: YearPlanCreateOrConnectWithoutUserInput | YearPlanCreateOrConnectWithoutUserInput[]
    upsert?: YearPlanUpsertWithWhereUniqueWithoutUserInput | YearPlanUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: YearPlanCreateManyUserInputEnvelope
    set?: YearPlanWhereUniqueInput | YearPlanWhereUniqueInput[]
    disconnect?: YearPlanWhereUniqueInput | YearPlanWhereUniqueInput[]
    delete?: YearPlanWhereUniqueInput | YearPlanWhereUniqueInput[]
    connect?: YearPlanWhereUniqueInput | YearPlanWhereUniqueInput[]
    update?: YearPlanUpdateWithWhereUniqueWithoutUserInput | YearPlanUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: YearPlanUpdateManyWithWhereWithoutUserInput | YearPlanUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: YearPlanScalarWhereInput | YearPlanScalarWhereInput[]
  }

  export type AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AnalyticsEventCreateWithoutUserInput, AnalyticsEventUncheckedCreateWithoutUserInput> | AnalyticsEventCreateWithoutUserInput[] | AnalyticsEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnalyticsEventCreateOrConnectWithoutUserInput | AnalyticsEventCreateOrConnectWithoutUserInput[]
    upsert?: AnalyticsEventUpsertWithWhereUniqueWithoutUserInput | AnalyticsEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AnalyticsEventCreateManyUserInputEnvelope
    set?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    disconnect?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    delete?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    connect?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    update?: AnalyticsEventUpdateWithWhereUniqueWithoutUserInput | AnalyticsEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AnalyticsEventUpdateManyWithWhereWithoutUserInput | AnalyticsEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AnalyticsEventScalarWhereInput | AnalyticsEventScalarWhereInput[]
  }

  export type CalendarEventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CalendarEventCreateWithoutUserInput, CalendarEventUncheckedCreateWithoutUserInput> | CalendarEventCreateWithoutUserInput[] | CalendarEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutUserInput | CalendarEventCreateOrConnectWithoutUserInput[]
    upsert?: CalendarEventUpsertWithWhereUniqueWithoutUserInput | CalendarEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CalendarEventCreateManyUserInputEnvelope
    set?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    disconnect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    delete?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    update?: CalendarEventUpdateWithWhereUniqueWithoutUserInput | CalendarEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CalendarEventUpdateManyWithWhereWithoutUserInput | CalendarEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
  }

  export type CaptureUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CaptureCreateWithoutUserInput, CaptureUncheckedCreateWithoutUserInput> | CaptureCreateWithoutUserInput[] | CaptureUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CaptureCreateOrConnectWithoutUserInput | CaptureCreateOrConnectWithoutUserInput[]
    upsert?: CaptureUpsertWithWhereUniqueWithoutUserInput | CaptureUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CaptureCreateManyUserInputEnvelope
    set?: CaptureWhereUniqueInput | CaptureWhereUniqueInput[]
    disconnect?: CaptureWhereUniqueInput | CaptureWhereUniqueInput[]
    delete?: CaptureWhereUniqueInput | CaptureWhereUniqueInput[]
    connect?: CaptureWhereUniqueInput | CaptureWhereUniqueInput[]
    update?: CaptureUpdateWithWhereUniqueWithoutUserInput | CaptureUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CaptureUpdateManyWithWhereWithoutUserInput | CaptureUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CaptureScalarWhereInput | CaptureScalarWhereInput[]
  }

  export type ClientUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput> | ClientCreateWithoutUserInput[] | ClientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput | ClientCreateOrConnectWithoutUserInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutUserInput | ClientUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClientCreateManyUserInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutUserInput | ClientUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutUserInput | ClientUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type DayPlanUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DayPlanCreateWithoutUserInput, DayPlanUncheckedCreateWithoutUserInput> | DayPlanCreateWithoutUserInput[] | DayPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DayPlanCreateOrConnectWithoutUserInput | DayPlanCreateOrConnectWithoutUserInput[]
    upsert?: DayPlanUpsertWithWhereUniqueWithoutUserInput | DayPlanUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DayPlanCreateManyUserInputEnvelope
    set?: DayPlanWhereUniqueInput | DayPlanWhereUniqueInput[]
    disconnect?: DayPlanWhereUniqueInput | DayPlanWhereUniqueInput[]
    delete?: DayPlanWhereUniqueInput | DayPlanWhereUniqueInput[]
    connect?: DayPlanWhereUniqueInput | DayPlanWhereUniqueInput[]
    update?: DayPlanUpdateWithWhereUniqueWithoutUserInput | DayPlanUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DayPlanUpdateManyWithWhereWithoutUserInput | DayPlanUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DayPlanScalarWhereInput | DayPlanScalarWhereInput[]
  }

  export type MeetingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MeetingCreateWithoutUserInput, MeetingUncheckedCreateWithoutUserInput> | MeetingCreateWithoutUserInput[] | MeetingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutUserInput | MeetingCreateOrConnectWithoutUserInput[]
    upsert?: MeetingUpsertWithWhereUniqueWithoutUserInput | MeetingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MeetingCreateManyUserInputEnvelope
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    update?: MeetingUpdateWithWhereUniqueWithoutUserInput | MeetingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MeetingUpdateManyWithWhereWithoutUserInput | MeetingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
  }

  export type NoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NoteCreateWithoutUserInput, NoteUncheckedCreateWithoutUserInput> | NoteCreateWithoutUserInput[] | NoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutUserInput | NoteCreateOrConnectWithoutUserInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutUserInput | NoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NoteCreateManyUserInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutUserInput | NoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutUserInput | NoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutUserInput | ProjectUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutUserInput | ProjectUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutUserInput | ProjectUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ResearchUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ResearchCreateWithoutUserInput, ResearchUncheckedCreateWithoutUserInput> | ResearchCreateWithoutUserInput[] | ResearchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResearchCreateOrConnectWithoutUserInput | ResearchCreateOrConnectWithoutUserInput[]
    upsert?: ResearchUpsertWithWhereUniqueWithoutUserInput | ResearchUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ResearchCreateManyUserInputEnvelope
    set?: ResearchWhereUniqueInput | ResearchWhereUniqueInput[]
    disconnect?: ResearchWhereUniqueInput | ResearchWhereUniqueInput[]
    delete?: ResearchWhereUniqueInput | ResearchWhereUniqueInput[]
    connect?: ResearchWhereUniqueInput | ResearchWhereUniqueInput[]
    update?: ResearchUpdateWithWhereUniqueWithoutUserInput | ResearchUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ResearchUpdateManyWithWhereWithoutUserInput | ResearchUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ResearchScalarWhereInput | ResearchScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput> | TaskCreateWithoutUserInput[] | TaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutUserInput | TaskCreateOrConnectWithoutUserInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutUserInput | TaskUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskCreateManyUserInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutUserInput | TaskUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutUserInput | TaskUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TimeEntryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TimeEntryCreateWithoutUserInput, TimeEntryUncheckedCreateWithoutUserInput> | TimeEntryCreateWithoutUserInput[] | TimeEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutUserInput | TimeEntryCreateOrConnectWithoutUserInput[]
    upsert?: TimeEntryUpsertWithWhereUniqueWithoutUserInput | TimeEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TimeEntryCreateManyUserInputEnvelope
    set?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    disconnect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    delete?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    update?: TimeEntryUpdateWithWhereUniqueWithoutUserInput | TimeEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TimeEntryUpdateManyWithWhereWithoutUserInput | TimeEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TimeEntryScalarWhereInput | TimeEntryScalarWhereInput[]
  }

  export type VoiceSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<VoiceSessionCreateWithoutUserInput, VoiceSessionUncheckedCreateWithoutUserInput> | VoiceSessionCreateWithoutUserInput[] | VoiceSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoiceSessionCreateOrConnectWithoutUserInput | VoiceSessionCreateOrConnectWithoutUserInput[]
    upsert?: VoiceSessionUpsertWithWhereUniqueWithoutUserInput | VoiceSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VoiceSessionCreateManyUserInputEnvelope
    set?: VoiceSessionWhereUniqueInput | VoiceSessionWhereUniqueInput[]
    disconnect?: VoiceSessionWhereUniqueInput | VoiceSessionWhereUniqueInput[]
    delete?: VoiceSessionWhereUniqueInput | VoiceSessionWhereUniqueInput[]
    connect?: VoiceSessionWhereUniqueInput | VoiceSessionWhereUniqueInput[]
    update?: VoiceSessionUpdateWithWhereUniqueWithoutUserInput | VoiceSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VoiceSessionUpdateManyWithWhereWithoutUserInput | VoiceSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VoiceSessionScalarWhereInput | VoiceSessionScalarWhereInput[]
  }

  export type WeekPlanUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WeekPlanCreateWithoutUserInput, WeekPlanUncheckedCreateWithoutUserInput> | WeekPlanCreateWithoutUserInput[] | WeekPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WeekPlanCreateOrConnectWithoutUserInput | WeekPlanCreateOrConnectWithoutUserInput[]
    upsert?: WeekPlanUpsertWithWhereUniqueWithoutUserInput | WeekPlanUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WeekPlanCreateManyUserInputEnvelope
    set?: WeekPlanWhereUniqueInput | WeekPlanWhereUniqueInput[]
    disconnect?: WeekPlanWhereUniqueInput | WeekPlanWhereUniqueInput[]
    delete?: WeekPlanWhereUniqueInput | WeekPlanWhereUniqueInput[]
    connect?: WeekPlanWhereUniqueInput | WeekPlanWhereUniqueInput[]
    update?: WeekPlanUpdateWithWhereUniqueWithoutUserInput | WeekPlanUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WeekPlanUpdateManyWithWhereWithoutUserInput | WeekPlanUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WeekPlanScalarWhereInput | WeekPlanScalarWhereInput[]
  }

  export type WellBeingEntryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WellBeingEntryCreateWithoutUserInput, WellBeingEntryUncheckedCreateWithoutUserInput> | WellBeingEntryCreateWithoutUserInput[] | WellBeingEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WellBeingEntryCreateOrConnectWithoutUserInput | WellBeingEntryCreateOrConnectWithoutUserInput[]
    upsert?: WellBeingEntryUpsertWithWhereUniqueWithoutUserInput | WellBeingEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WellBeingEntryCreateManyUserInputEnvelope
    set?: WellBeingEntryWhereUniqueInput | WellBeingEntryWhereUniqueInput[]
    disconnect?: WellBeingEntryWhereUniqueInput | WellBeingEntryWhereUniqueInput[]
    delete?: WellBeingEntryWhereUniqueInput | WellBeingEntryWhereUniqueInput[]
    connect?: WellBeingEntryWhereUniqueInput | WellBeingEntryWhereUniqueInput[]
    update?: WellBeingEntryUpdateWithWhereUniqueWithoutUserInput | WellBeingEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WellBeingEntryUpdateManyWithWhereWithoutUserInput | WellBeingEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WellBeingEntryScalarWhereInput | WellBeingEntryScalarWhereInput[]
  }

  export type YearPlanUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<YearPlanCreateWithoutUserInput, YearPlanUncheckedCreateWithoutUserInput> | YearPlanCreateWithoutUserInput[] | YearPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: YearPlanCreateOrConnectWithoutUserInput | YearPlanCreateOrConnectWithoutUserInput[]
    upsert?: YearPlanUpsertWithWhereUniqueWithoutUserInput | YearPlanUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: YearPlanCreateManyUserInputEnvelope
    set?: YearPlanWhereUniqueInput | YearPlanWhereUniqueInput[]
    disconnect?: YearPlanWhereUniqueInput | YearPlanWhereUniqueInput[]
    delete?: YearPlanWhereUniqueInput | YearPlanWhereUniqueInput[]
    connect?: YearPlanWhereUniqueInput | YearPlanWhereUniqueInput[]
    update?: YearPlanUpdateWithWhereUniqueWithoutUserInput | YearPlanUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: YearPlanUpdateManyWithWhereWithoutUserInput | YearPlanUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: YearPlanScalarWhereInput | YearPlanScalarWhereInput[]
  }

  export type YearPlanCreatefocusAreasInput = {
    set: string[]
  }

  export type GoalCreateNestedManyWithoutYearPlanInput = {
    create?: XOR<GoalCreateWithoutYearPlanInput, GoalUncheckedCreateWithoutYearPlanInput> | GoalCreateWithoutYearPlanInput[] | GoalUncheckedCreateWithoutYearPlanInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutYearPlanInput | GoalCreateOrConnectWithoutYearPlanInput[]
    createMany?: GoalCreateManyYearPlanInputEnvelope
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
  }

  export type QuarterPlanCreateNestedManyWithoutYearPlanInput = {
    create?: XOR<QuarterPlanCreateWithoutYearPlanInput, QuarterPlanUncheckedCreateWithoutYearPlanInput> | QuarterPlanCreateWithoutYearPlanInput[] | QuarterPlanUncheckedCreateWithoutYearPlanInput[]
    connectOrCreate?: QuarterPlanCreateOrConnectWithoutYearPlanInput | QuarterPlanCreateOrConnectWithoutYearPlanInput[]
    createMany?: QuarterPlanCreateManyYearPlanInputEnvelope
    connect?: QuarterPlanWhereUniqueInput | QuarterPlanWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutYearPlansInput = {
    create?: XOR<UserCreateWithoutYearPlansInput, UserUncheckedCreateWithoutYearPlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutYearPlansInput
    connect?: UserWhereUniqueInput
  }

  export type GoalUncheckedCreateNestedManyWithoutYearPlanInput = {
    create?: XOR<GoalCreateWithoutYearPlanInput, GoalUncheckedCreateWithoutYearPlanInput> | GoalCreateWithoutYearPlanInput[] | GoalUncheckedCreateWithoutYearPlanInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutYearPlanInput | GoalCreateOrConnectWithoutYearPlanInput[]
    createMany?: GoalCreateManyYearPlanInputEnvelope
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
  }

  export type QuarterPlanUncheckedCreateNestedManyWithoutYearPlanInput = {
    create?: XOR<QuarterPlanCreateWithoutYearPlanInput, QuarterPlanUncheckedCreateWithoutYearPlanInput> | QuarterPlanCreateWithoutYearPlanInput[] | QuarterPlanUncheckedCreateWithoutYearPlanInput[]
    connectOrCreate?: QuarterPlanCreateOrConnectWithoutYearPlanInput | QuarterPlanCreateOrConnectWithoutYearPlanInput[]
    createMany?: QuarterPlanCreateManyYearPlanInputEnvelope
    connect?: QuarterPlanWhereUniqueInput | QuarterPlanWhereUniqueInput[]
  }

  export type YearPlanUpdatefocusAreasInput = {
    set?: string[]
    push?: string | string[]
  }

  export type GoalUpdateManyWithoutYearPlanNestedInput = {
    create?: XOR<GoalCreateWithoutYearPlanInput, GoalUncheckedCreateWithoutYearPlanInput> | GoalCreateWithoutYearPlanInput[] | GoalUncheckedCreateWithoutYearPlanInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutYearPlanInput | GoalCreateOrConnectWithoutYearPlanInput[]
    upsert?: GoalUpsertWithWhereUniqueWithoutYearPlanInput | GoalUpsertWithWhereUniqueWithoutYearPlanInput[]
    createMany?: GoalCreateManyYearPlanInputEnvelope
    set?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    disconnect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    delete?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    update?: GoalUpdateWithWhereUniqueWithoutYearPlanInput | GoalUpdateWithWhereUniqueWithoutYearPlanInput[]
    updateMany?: GoalUpdateManyWithWhereWithoutYearPlanInput | GoalUpdateManyWithWhereWithoutYearPlanInput[]
    deleteMany?: GoalScalarWhereInput | GoalScalarWhereInput[]
  }

  export type QuarterPlanUpdateManyWithoutYearPlanNestedInput = {
    create?: XOR<QuarterPlanCreateWithoutYearPlanInput, QuarterPlanUncheckedCreateWithoutYearPlanInput> | QuarterPlanCreateWithoutYearPlanInput[] | QuarterPlanUncheckedCreateWithoutYearPlanInput[]
    connectOrCreate?: QuarterPlanCreateOrConnectWithoutYearPlanInput | QuarterPlanCreateOrConnectWithoutYearPlanInput[]
    upsert?: QuarterPlanUpsertWithWhereUniqueWithoutYearPlanInput | QuarterPlanUpsertWithWhereUniqueWithoutYearPlanInput[]
    createMany?: QuarterPlanCreateManyYearPlanInputEnvelope
    set?: QuarterPlanWhereUniqueInput | QuarterPlanWhereUniqueInput[]
    disconnect?: QuarterPlanWhereUniqueInput | QuarterPlanWhereUniqueInput[]
    delete?: QuarterPlanWhereUniqueInput | QuarterPlanWhereUniqueInput[]
    connect?: QuarterPlanWhereUniqueInput | QuarterPlanWhereUniqueInput[]
    update?: QuarterPlanUpdateWithWhereUniqueWithoutYearPlanInput | QuarterPlanUpdateWithWhereUniqueWithoutYearPlanInput[]
    updateMany?: QuarterPlanUpdateManyWithWhereWithoutYearPlanInput | QuarterPlanUpdateManyWithWhereWithoutYearPlanInput[]
    deleteMany?: QuarterPlanScalarWhereInput | QuarterPlanScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutYearPlansNestedInput = {
    create?: XOR<UserCreateWithoutYearPlansInput, UserUncheckedCreateWithoutYearPlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutYearPlansInput
    upsert?: UserUpsertWithoutYearPlansInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutYearPlansInput, UserUpdateWithoutYearPlansInput>, UserUncheckedUpdateWithoutYearPlansInput>
  }

  export type GoalUncheckedUpdateManyWithoutYearPlanNestedInput = {
    create?: XOR<GoalCreateWithoutYearPlanInput, GoalUncheckedCreateWithoutYearPlanInput> | GoalCreateWithoutYearPlanInput[] | GoalUncheckedCreateWithoutYearPlanInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutYearPlanInput | GoalCreateOrConnectWithoutYearPlanInput[]
    upsert?: GoalUpsertWithWhereUniqueWithoutYearPlanInput | GoalUpsertWithWhereUniqueWithoutYearPlanInput[]
    createMany?: GoalCreateManyYearPlanInputEnvelope
    set?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    disconnect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    delete?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    update?: GoalUpdateWithWhereUniqueWithoutYearPlanInput | GoalUpdateWithWhereUniqueWithoutYearPlanInput[]
    updateMany?: GoalUpdateManyWithWhereWithoutYearPlanInput | GoalUpdateManyWithWhereWithoutYearPlanInput[]
    deleteMany?: GoalScalarWhereInput | GoalScalarWhereInput[]
  }

  export type QuarterPlanUncheckedUpdateManyWithoutYearPlanNestedInput = {
    create?: XOR<QuarterPlanCreateWithoutYearPlanInput, QuarterPlanUncheckedCreateWithoutYearPlanInput> | QuarterPlanCreateWithoutYearPlanInput[] | QuarterPlanUncheckedCreateWithoutYearPlanInput[]
    connectOrCreate?: QuarterPlanCreateOrConnectWithoutYearPlanInput | QuarterPlanCreateOrConnectWithoutYearPlanInput[]
    upsert?: QuarterPlanUpsertWithWhereUniqueWithoutYearPlanInput | QuarterPlanUpsertWithWhereUniqueWithoutYearPlanInput[]
    createMany?: QuarterPlanCreateManyYearPlanInputEnvelope
    set?: QuarterPlanWhereUniqueInput | QuarterPlanWhereUniqueInput[]
    disconnect?: QuarterPlanWhereUniqueInput | QuarterPlanWhereUniqueInput[]
    delete?: QuarterPlanWhereUniqueInput | QuarterPlanWhereUniqueInput[]
    connect?: QuarterPlanWhereUniqueInput | QuarterPlanWhereUniqueInput[]
    update?: QuarterPlanUpdateWithWhereUniqueWithoutYearPlanInput | QuarterPlanUpdateWithWhereUniqueWithoutYearPlanInput[]
    updateMany?: QuarterPlanUpdateManyWithWhereWithoutYearPlanInput | QuarterPlanUpdateManyWithWhereWithoutYearPlanInput[]
    deleteMany?: QuarterPlanScalarWhereInput | QuarterPlanScalarWhereInput[]
  }

  export type GoalCreatekpisInput = {
    set: string[]
  }

  export type GoalCreaterisksInput = {
    set: string[]
  }

  export type GoalCreatestrategiesInput = {
    set: string[]
  }

  export type YearPlanCreateNestedOneWithoutGoalsInput = {
    create?: XOR<YearPlanCreateWithoutGoalsInput, YearPlanUncheckedCreateWithoutGoalsInput>
    connectOrCreate?: YearPlanCreateOrConnectWithoutGoalsInput
    connect?: YearPlanWhereUniqueInput
  }

  export type KeyStepCreateNestedManyWithoutGoalInput = {
    create?: XOR<KeyStepCreateWithoutGoalInput, KeyStepUncheckedCreateWithoutGoalInput> | KeyStepCreateWithoutGoalInput[] | KeyStepUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: KeyStepCreateOrConnectWithoutGoalInput | KeyStepCreateOrConnectWithoutGoalInput[]
    createMany?: KeyStepCreateManyGoalInputEnvelope
    connect?: KeyStepWhereUniqueInput | KeyStepWhereUniqueInput[]
  }

  export type MilestoneCreateNestedManyWithoutGoalInput = {
    create?: XOR<MilestoneCreateWithoutGoalInput, MilestoneUncheckedCreateWithoutGoalInput> | MilestoneCreateWithoutGoalInput[] | MilestoneUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutGoalInput | MilestoneCreateOrConnectWithoutGoalInput[]
    createMany?: MilestoneCreateManyGoalInputEnvelope
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
  }

  export type NoteCreateNestedManyWithoutGoalInput = {
    create?: XOR<NoteCreateWithoutGoalInput, NoteUncheckedCreateWithoutGoalInput> | NoteCreateWithoutGoalInput[] | NoteUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutGoalInput | NoteCreateOrConnectWithoutGoalInput[]
    createMany?: NoteCreateManyGoalInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type QuarterFocusCreateNestedManyWithoutGoalInput = {
    create?: XOR<QuarterFocusCreateWithoutGoalInput, QuarterFocusUncheckedCreateWithoutGoalInput> | QuarterFocusCreateWithoutGoalInput[] | QuarterFocusUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: QuarterFocusCreateOrConnectWithoutGoalInput | QuarterFocusCreateOrConnectWithoutGoalInput[]
    createMany?: QuarterFocusCreateManyGoalInputEnvelope
    connect?: QuarterFocusWhereUniqueInput | QuarterFocusWhereUniqueInput[]
  }

  export type ResearchCreateNestedManyWithoutGoalInput = {
    create?: XOR<ResearchCreateWithoutGoalInput, ResearchUncheckedCreateWithoutGoalInput> | ResearchCreateWithoutGoalInput[] | ResearchUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: ResearchCreateOrConnectWithoutGoalInput | ResearchCreateOrConnectWithoutGoalInput[]
    createMany?: ResearchCreateManyGoalInputEnvelope
    connect?: ResearchWhereUniqueInput | ResearchWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutGoalInput = {
    create?: XOR<TaskCreateWithoutGoalInput, TaskUncheckedCreateWithoutGoalInput> | TaskCreateWithoutGoalInput[] | TaskUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutGoalInput | TaskCreateOrConnectWithoutGoalInput[]
    createMany?: TaskCreateManyGoalInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type KeyStepUncheckedCreateNestedManyWithoutGoalInput = {
    create?: XOR<KeyStepCreateWithoutGoalInput, KeyStepUncheckedCreateWithoutGoalInput> | KeyStepCreateWithoutGoalInput[] | KeyStepUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: KeyStepCreateOrConnectWithoutGoalInput | KeyStepCreateOrConnectWithoutGoalInput[]
    createMany?: KeyStepCreateManyGoalInputEnvelope
    connect?: KeyStepWhereUniqueInput | KeyStepWhereUniqueInput[]
  }

  export type MilestoneUncheckedCreateNestedManyWithoutGoalInput = {
    create?: XOR<MilestoneCreateWithoutGoalInput, MilestoneUncheckedCreateWithoutGoalInput> | MilestoneCreateWithoutGoalInput[] | MilestoneUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutGoalInput | MilestoneCreateOrConnectWithoutGoalInput[]
    createMany?: MilestoneCreateManyGoalInputEnvelope
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
  }

  export type NoteUncheckedCreateNestedManyWithoutGoalInput = {
    create?: XOR<NoteCreateWithoutGoalInput, NoteUncheckedCreateWithoutGoalInput> | NoteCreateWithoutGoalInput[] | NoteUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutGoalInput | NoteCreateOrConnectWithoutGoalInput[]
    createMany?: NoteCreateManyGoalInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type QuarterFocusUncheckedCreateNestedManyWithoutGoalInput = {
    create?: XOR<QuarterFocusCreateWithoutGoalInput, QuarterFocusUncheckedCreateWithoutGoalInput> | QuarterFocusCreateWithoutGoalInput[] | QuarterFocusUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: QuarterFocusCreateOrConnectWithoutGoalInput | QuarterFocusCreateOrConnectWithoutGoalInput[]
    createMany?: QuarterFocusCreateManyGoalInputEnvelope
    connect?: QuarterFocusWhereUniqueInput | QuarterFocusWhereUniqueInput[]
  }

  export type ResearchUncheckedCreateNestedManyWithoutGoalInput = {
    create?: XOR<ResearchCreateWithoutGoalInput, ResearchUncheckedCreateWithoutGoalInput> | ResearchCreateWithoutGoalInput[] | ResearchUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: ResearchCreateOrConnectWithoutGoalInput | ResearchCreateOrConnectWithoutGoalInput[]
    createMany?: ResearchCreateManyGoalInputEnvelope
    connect?: ResearchWhereUniqueInput | ResearchWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutGoalInput = {
    create?: XOR<TaskCreateWithoutGoalInput, TaskUncheckedCreateWithoutGoalInput> | TaskCreateWithoutGoalInput[] | TaskUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutGoalInput | TaskCreateOrConnectWithoutGoalInput[]
    createMany?: TaskCreateManyGoalInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type GoalUpdatekpisInput = {
    set?: string[]
    push?: string | string[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type GoalUpdaterisksInput = {
    set?: string[]
    push?: string | string[]
  }

  export type GoalUpdatestrategiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type YearPlanUpdateOneRequiredWithoutGoalsNestedInput = {
    create?: XOR<YearPlanCreateWithoutGoalsInput, YearPlanUncheckedCreateWithoutGoalsInput>
    connectOrCreate?: YearPlanCreateOrConnectWithoutGoalsInput
    upsert?: YearPlanUpsertWithoutGoalsInput
    connect?: YearPlanWhereUniqueInput
    update?: XOR<XOR<YearPlanUpdateToOneWithWhereWithoutGoalsInput, YearPlanUpdateWithoutGoalsInput>, YearPlanUncheckedUpdateWithoutGoalsInput>
  }

  export type KeyStepUpdateManyWithoutGoalNestedInput = {
    create?: XOR<KeyStepCreateWithoutGoalInput, KeyStepUncheckedCreateWithoutGoalInput> | KeyStepCreateWithoutGoalInput[] | KeyStepUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: KeyStepCreateOrConnectWithoutGoalInput | KeyStepCreateOrConnectWithoutGoalInput[]
    upsert?: KeyStepUpsertWithWhereUniqueWithoutGoalInput | KeyStepUpsertWithWhereUniqueWithoutGoalInput[]
    createMany?: KeyStepCreateManyGoalInputEnvelope
    set?: KeyStepWhereUniqueInput | KeyStepWhereUniqueInput[]
    disconnect?: KeyStepWhereUniqueInput | KeyStepWhereUniqueInput[]
    delete?: KeyStepWhereUniqueInput | KeyStepWhereUniqueInput[]
    connect?: KeyStepWhereUniqueInput | KeyStepWhereUniqueInput[]
    update?: KeyStepUpdateWithWhereUniqueWithoutGoalInput | KeyStepUpdateWithWhereUniqueWithoutGoalInput[]
    updateMany?: KeyStepUpdateManyWithWhereWithoutGoalInput | KeyStepUpdateManyWithWhereWithoutGoalInput[]
    deleteMany?: KeyStepScalarWhereInput | KeyStepScalarWhereInput[]
  }

  export type MilestoneUpdateManyWithoutGoalNestedInput = {
    create?: XOR<MilestoneCreateWithoutGoalInput, MilestoneUncheckedCreateWithoutGoalInput> | MilestoneCreateWithoutGoalInput[] | MilestoneUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutGoalInput | MilestoneCreateOrConnectWithoutGoalInput[]
    upsert?: MilestoneUpsertWithWhereUniqueWithoutGoalInput | MilestoneUpsertWithWhereUniqueWithoutGoalInput[]
    createMany?: MilestoneCreateManyGoalInputEnvelope
    set?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    disconnect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    delete?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    update?: MilestoneUpdateWithWhereUniqueWithoutGoalInput | MilestoneUpdateWithWhereUniqueWithoutGoalInput[]
    updateMany?: MilestoneUpdateManyWithWhereWithoutGoalInput | MilestoneUpdateManyWithWhereWithoutGoalInput[]
    deleteMany?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
  }

  export type NoteUpdateManyWithoutGoalNestedInput = {
    create?: XOR<NoteCreateWithoutGoalInput, NoteUncheckedCreateWithoutGoalInput> | NoteCreateWithoutGoalInput[] | NoteUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutGoalInput | NoteCreateOrConnectWithoutGoalInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutGoalInput | NoteUpsertWithWhereUniqueWithoutGoalInput[]
    createMany?: NoteCreateManyGoalInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutGoalInput | NoteUpdateWithWhereUniqueWithoutGoalInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutGoalInput | NoteUpdateManyWithWhereWithoutGoalInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type QuarterFocusUpdateManyWithoutGoalNestedInput = {
    create?: XOR<QuarterFocusCreateWithoutGoalInput, QuarterFocusUncheckedCreateWithoutGoalInput> | QuarterFocusCreateWithoutGoalInput[] | QuarterFocusUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: QuarterFocusCreateOrConnectWithoutGoalInput | QuarterFocusCreateOrConnectWithoutGoalInput[]
    upsert?: QuarterFocusUpsertWithWhereUniqueWithoutGoalInput | QuarterFocusUpsertWithWhereUniqueWithoutGoalInput[]
    createMany?: QuarterFocusCreateManyGoalInputEnvelope
    set?: QuarterFocusWhereUniqueInput | QuarterFocusWhereUniqueInput[]
    disconnect?: QuarterFocusWhereUniqueInput | QuarterFocusWhereUniqueInput[]
    delete?: QuarterFocusWhereUniqueInput | QuarterFocusWhereUniqueInput[]
    connect?: QuarterFocusWhereUniqueInput | QuarterFocusWhereUniqueInput[]
    update?: QuarterFocusUpdateWithWhereUniqueWithoutGoalInput | QuarterFocusUpdateWithWhereUniqueWithoutGoalInput[]
    updateMany?: QuarterFocusUpdateManyWithWhereWithoutGoalInput | QuarterFocusUpdateManyWithWhereWithoutGoalInput[]
    deleteMany?: QuarterFocusScalarWhereInput | QuarterFocusScalarWhereInput[]
  }

  export type ResearchUpdateManyWithoutGoalNestedInput = {
    create?: XOR<ResearchCreateWithoutGoalInput, ResearchUncheckedCreateWithoutGoalInput> | ResearchCreateWithoutGoalInput[] | ResearchUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: ResearchCreateOrConnectWithoutGoalInput | ResearchCreateOrConnectWithoutGoalInput[]
    upsert?: ResearchUpsertWithWhereUniqueWithoutGoalInput | ResearchUpsertWithWhereUniqueWithoutGoalInput[]
    createMany?: ResearchCreateManyGoalInputEnvelope
    set?: ResearchWhereUniqueInput | ResearchWhereUniqueInput[]
    disconnect?: ResearchWhereUniqueInput | ResearchWhereUniqueInput[]
    delete?: ResearchWhereUniqueInput | ResearchWhereUniqueInput[]
    connect?: ResearchWhereUniqueInput | ResearchWhereUniqueInput[]
    update?: ResearchUpdateWithWhereUniqueWithoutGoalInput | ResearchUpdateWithWhereUniqueWithoutGoalInput[]
    updateMany?: ResearchUpdateManyWithWhereWithoutGoalInput | ResearchUpdateManyWithWhereWithoutGoalInput[]
    deleteMany?: ResearchScalarWhereInput | ResearchScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutGoalNestedInput = {
    create?: XOR<TaskCreateWithoutGoalInput, TaskUncheckedCreateWithoutGoalInput> | TaskCreateWithoutGoalInput[] | TaskUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutGoalInput | TaskCreateOrConnectWithoutGoalInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutGoalInput | TaskUpsertWithWhereUniqueWithoutGoalInput[]
    createMany?: TaskCreateManyGoalInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutGoalInput | TaskUpdateWithWhereUniqueWithoutGoalInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutGoalInput | TaskUpdateManyWithWhereWithoutGoalInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type KeyStepUncheckedUpdateManyWithoutGoalNestedInput = {
    create?: XOR<KeyStepCreateWithoutGoalInput, KeyStepUncheckedCreateWithoutGoalInput> | KeyStepCreateWithoutGoalInput[] | KeyStepUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: KeyStepCreateOrConnectWithoutGoalInput | KeyStepCreateOrConnectWithoutGoalInput[]
    upsert?: KeyStepUpsertWithWhereUniqueWithoutGoalInput | KeyStepUpsertWithWhereUniqueWithoutGoalInput[]
    createMany?: KeyStepCreateManyGoalInputEnvelope
    set?: KeyStepWhereUniqueInput | KeyStepWhereUniqueInput[]
    disconnect?: KeyStepWhereUniqueInput | KeyStepWhereUniqueInput[]
    delete?: KeyStepWhereUniqueInput | KeyStepWhereUniqueInput[]
    connect?: KeyStepWhereUniqueInput | KeyStepWhereUniqueInput[]
    update?: KeyStepUpdateWithWhereUniqueWithoutGoalInput | KeyStepUpdateWithWhereUniqueWithoutGoalInput[]
    updateMany?: KeyStepUpdateManyWithWhereWithoutGoalInput | KeyStepUpdateManyWithWhereWithoutGoalInput[]
    deleteMany?: KeyStepScalarWhereInput | KeyStepScalarWhereInput[]
  }

  export type MilestoneUncheckedUpdateManyWithoutGoalNestedInput = {
    create?: XOR<MilestoneCreateWithoutGoalInput, MilestoneUncheckedCreateWithoutGoalInput> | MilestoneCreateWithoutGoalInput[] | MilestoneUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutGoalInput | MilestoneCreateOrConnectWithoutGoalInput[]
    upsert?: MilestoneUpsertWithWhereUniqueWithoutGoalInput | MilestoneUpsertWithWhereUniqueWithoutGoalInput[]
    createMany?: MilestoneCreateManyGoalInputEnvelope
    set?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    disconnect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    delete?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    update?: MilestoneUpdateWithWhereUniqueWithoutGoalInput | MilestoneUpdateWithWhereUniqueWithoutGoalInput[]
    updateMany?: MilestoneUpdateManyWithWhereWithoutGoalInput | MilestoneUpdateManyWithWhereWithoutGoalInput[]
    deleteMany?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
  }

  export type NoteUncheckedUpdateManyWithoutGoalNestedInput = {
    create?: XOR<NoteCreateWithoutGoalInput, NoteUncheckedCreateWithoutGoalInput> | NoteCreateWithoutGoalInput[] | NoteUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutGoalInput | NoteCreateOrConnectWithoutGoalInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutGoalInput | NoteUpsertWithWhereUniqueWithoutGoalInput[]
    createMany?: NoteCreateManyGoalInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutGoalInput | NoteUpdateWithWhereUniqueWithoutGoalInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutGoalInput | NoteUpdateManyWithWhereWithoutGoalInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type QuarterFocusUncheckedUpdateManyWithoutGoalNestedInput = {
    create?: XOR<QuarterFocusCreateWithoutGoalInput, QuarterFocusUncheckedCreateWithoutGoalInput> | QuarterFocusCreateWithoutGoalInput[] | QuarterFocusUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: QuarterFocusCreateOrConnectWithoutGoalInput | QuarterFocusCreateOrConnectWithoutGoalInput[]
    upsert?: QuarterFocusUpsertWithWhereUniqueWithoutGoalInput | QuarterFocusUpsertWithWhereUniqueWithoutGoalInput[]
    createMany?: QuarterFocusCreateManyGoalInputEnvelope
    set?: QuarterFocusWhereUniqueInput | QuarterFocusWhereUniqueInput[]
    disconnect?: QuarterFocusWhereUniqueInput | QuarterFocusWhereUniqueInput[]
    delete?: QuarterFocusWhereUniqueInput | QuarterFocusWhereUniqueInput[]
    connect?: QuarterFocusWhereUniqueInput | QuarterFocusWhereUniqueInput[]
    update?: QuarterFocusUpdateWithWhereUniqueWithoutGoalInput | QuarterFocusUpdateWithWhereUniqueWithoutGoalInput[]
    updateMany?: QuarterFocusUpdateManyWithWhereWithoutGoalInput | QuarterFocusUpdateManyWithWhereWithoutGoalInput[]
    deleteMany?: QuarterFocusScalarWhereInput | QuarterFocusScalarWhereInput[]
  }

  export type ResearchUncheckedUpdateManyWithoutGoalNestedInput = {
    create?: XOR<ResearchCreateWithoutGoalInput, ResearchUncheckedCreateWithoutGoalInput> | ResearchCreateWithoutGoalInput[] | ResearchUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: ResearchCreateOrConnectWithoutGoalInput | ResearchCreateOrConnectWithoutGoalInput[]
    upsert?: ResearchUpsertWithWhereUniqueWithoutGoalInput | ResearchUpsertWithWhereUniqueWithoutGoalInput[]
    createMany?: ResearchCreateManyGoalInputEnvelope
    set?: ResearchWhereUniqueInput | ResearchWhereUniqueInput[]
    disconnect?: ResearchWhereUniqueInput | ResearchWhereUniqueInput[]
    delete?: ResearchWhereUniqueInput | ResearchWhereUniqueInput[]
    connect?: ResearchWhereUniqueInput | ResearchWhereUniqueInput[]
    update?: ResearchUpdateWithWhereUniqueWithoutGoalInput | ResearchUpdateWithWhereUniqueWithoutGoalInput[]
    updateMany?: ResearchUpdateManyWithWhereWithoutGoalInput | ResearchUpdateManyWithWhereWithoutGoalInput[]
    deleteMany?: ResearchScalarWhereInput | ResearchScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutGoalNestedInput = {
    create?: XOR<TaskCreateWithoutGoalInput, TaskUncheckedCreateWithoutGoalInput> | TaskCreateWithoutGoalInput[] | TaskUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutGoalInput | TaskCreateOrConnectWithoutGoalInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutGoalInput | TaskUpsertWithWhereUniqueWithoutGoalInput[]
    createMany?: TaskCreateManyGoalInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutGoalInput | TaskUpdateWithWhereUniqueWithoutGoalInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutGoalInput | TaskUpdateManyWithWhereWithoutGoalInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type GoalCreateNestedOneWithoutMilestonesInput = {
    create?: XOR<GoalCreateWithoutMilestonesInput, GoalUncheckedCreateWithoutMilestonesInput>
    connectOrCreate?: GoalCreateOrConnectWithoutMilestonesInput
    connect?: GoalWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type GoalUpdateOneRequiredWithoutMilestonesNestedInput = {
    create?: XOR<GoalCreateWithoutMilestonesInput, GoalUncheckedCreateWithoutMilestonesInput>
    connectOrCreate?: GoalCreateOrConnectWithoutMilestonesInput
    upsert?: GoalUpsertWithoutMilestonesInput
    connect?: GoalWhereUniqueInput
    update?: XOR<XOR<GoalUpdateToOneWithWhereWithoutMilestonesInput, GoalUpdateWithoutMilestonesInput>, GoalUncheckedUpdateWithoutMilestonesInput>
  }

  export type GoalCreateNestedOneWithoutKeyStepsInput = {
    create?: XOR<GoalCreateWithoutKeyStepsInput, GoalUncheckedCreateWithoutKeyStepsInput>
    connectOrCreate?: GoalCreateOrConnectWithoutKeyStepsInput
    connect?: GoalWhereUniqueInput
  }

  export type NoteCreateNestedManyWithoutKeyStepInput = {
    create?: XOR<NoteCreateWithoutKeyStepInput, NoteUncheckedCreateWithoutKeyStepInput> | NoteCreateWithoutKeyStepInput[] | NoteUncheckedCreateWithoutKeyStepInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutKeyStepInput | NoteCreateOrConnectWithoutKeyStepInput[]
    createMany?: NoteCreateManyKeyStepInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutKeyStepInput = {
    create?: XOR<TaskCreateWithoutKeyStepInput, TaskUncheckedCreateWithoutKeyStepInput> | TaskCreateWithoutKeyStepInput[] | TaskUncheckedCreateWithoutKeyStepInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutKeyStepInput | TaskCreateOrConnectWithoutKeyStepInput[]
    createMany?: TaskCreateManyKeyStepInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type NoteUncheckedCreateNestedManyWithoutKeyStepInput = {
    create?: XOR<NoteCreateWithoutKeyStepInput, NoteUncheckedCreateWithoutKeyStepInput> | NoteCreateWithoutKeyStepInput[] | NoteUncheckedCreateWithoutKeyStepInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutKeyStepInput | NoteCreateOrConnectWithoutKeyStepInput[]
    createMany?: NoteCreateManyKeyStepInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutKeyStepInput = {
    create?: XOR<TaskCreateWithoutKeyStepInput, TaskUncheckedCreateWithoutKeyStepInput> | TaskCreateWithoutKeyStepInput[] | TaskUncheckedCreateWithoutKeyStepInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutKeyStepInput | TaskCreateOrConnectWithoutKeyStepInput[]
    createMany?: TaskCreateManyKeyStepInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type GoalUpdateOneRequiredWithoutKeyStepsNestedInput = {
    create?: XOR<GoalCreateWithoutKeyStepsInput, GoalUncheckedCreateWithoutKeyStepsInput>
    connectOrCreate?: GoalCreateOrConnectWithoutKeyStepsInput
    upsert?: GoalUpsertWithoutKeyStepsInput
    connect?: GoalWhereUniqueInput
    update?: XOR<XOR<GoalUpdateToOneWithWhereWithoutKeyStepsInput, GoalUpdateWithoutKeyStepsInput>, GoalUncheckedUpdateWithoutKeyStepsInput>
  }

  export type NoteUpdateManyWithoutKeyStepNestedInput = {
    create?: XOR<NoteCreateWithoutKeyStepInput, NoteUncheckedCreateWithoutKeyStepInput> | NoteCreateWithoutKeyStepInput[] | NoteUncheckedCreateWithoutKeyStepInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutKeyStepInput | NoteCreateOrConnectWithoutKeyStepInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutKeyStepInput | NoteUpsertWithWhereUniqueWithoutKeyStepInput[]
    createMany?: NoteCreateManyKeyStepInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutKeyStepInput | NoteUpdateWithWhereUniqueWithoutKeyStepInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutKeyStepInput | NoteUpdateManyWithWhereWithoutKeyStepInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutKeyStepNestedInput = {
    create?: XOR<TaskCreateWithoutKeyStepInput, TaskUncheckedCreateWithoutKeyStepInput> | TaskCreateWithoutKeyStepInput[] | TaskUncheckedCreateWithoutKeyStepInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutKeyStepInput | TaskCreateOrConnectWithoutKeyStepInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutKeyStepInput | TaskUpsertWithWhereUniqueWithoutKeyStepInput[]
    createMany?: TaskCreateManyKeyStepInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutKeyStepInput | TaskUpdateWithWhereUniqueWithoutKeyStepInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutKeyStepInput | TaskUpdateManyWithWhereWithoutKeyStepInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type NoteUncheckedUpdateManyWithoutKeyStepNestedInput = {
    create?: XOR<NoteCreateWithoutKeyStepInput, NoteUncheckedCreateWithoutKeyStepInput> | NoteCreateWithoutKeyStepInput[] | NoteUncheckedCreateWithoutKeyStepInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutKeyStepInput | NoteCreateOrConnectWithoutKeyStepInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutKeyStepInput | NoteUpsertWithWhereUniqueWithoutKeyStepInput[]
    createMany?: NoteCreateManyKeyStepInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutKeyStepInput | NoteUpdateWithWhereUniqueWithoutKeyStepInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutKeyStepInput | NoteUpdateManyWithWhereWithoutKeyStepInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutKeyStepNestedInput = {
    create?: XOR<TaskCreateWithoutKeyStepInput, TaskUncheckedCreateWithoutKeyStepInput> | TaskCreateWithoutKeyStepInput[] | TaskUncheckedCreateWithoutKeyStepInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutKeyStepInput | TaskCreateOrConnectWithoutKeyStepInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutKeyStepInput | TaskUpsertWithWhereUniqueWithoutKeyStepInput[]
    createMany?: TaskCreateManyKeyStepInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutKeyStepInput | TaskUpdateWithWhereUniqueWithoutKeyStepInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutKeyStepInput | TaskUpdateManyWithWhereWithoutKeyStepInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type DayPlanCreateNestedOneWithoutNotesInput = {
    create?: XOR<DayPlanCreateWithoutNotesInput, DayPlanUncheckedCreateWithoutNotesInput>
    connectOrCreate?: DayPlanCreateOrConnectWithoutNotesInput
    connect?: DayPlanWhereUniqueInput
  }

  export type GoalCreateNestedOneWithoutNotesInput = {
    create?: XOR<GoalCreateWithoutNotesInput, GoalUncheckedCreateWithoutNotesInput>
    connectOrCreate?: GoalCreateOrConnectWithoutNotesInput
    connect?: GoalWhereUniqueInput
  }

  export type KeyStepCreateNestedOneWithoutNotesInput = {
    create?: XOR<KeyStepCreateWithoutNotesInput, KeyStepUncheckedCreateWithoutNotesInput>
    connectOrCreate?: KeyStepCreateOrConnectWithoutNotesInput
    connect?: KeyStepWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotesInput = {
    create?: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotesInput
    connect?: UserWhereUniqueInput
  }

  export type DayPlanUpdateOneWithoutNotesNestedInput = {
    create?: XOR<DayPlanCreateWithoutNotesInput, DayPlanUncheckedCreateWithoutNotesInput>
    connectOrCreate?: DayPlanCreateOrConnectWithoutNotesInput
    upsert?: DayPlanUpsertWithoutNotesInput
    disconnect?: DayPlanWhereInput | boolean
    delete?: DayPlanWhereInput | boolean
    connect?: DayPlanWhereUniqueInput
    update?: XOR<XOR<DayPlanUpdateToOneWithWhereWithoutNotesInput, DayPlanUpdateWithoutNotesInput>, DayPlanUncheckedUpdateWithoutNotesInput>
  }

  export type GoalUpdateOneWithoutNotesNestedInput = {
    create?: XOR<GoalCreateWithoutNotesInput, GoalUncheckedCreateWithoutNotesInput>
    connectOrCreate?: GoalCreateOrConnectWithoutNotesInput
    upsert?: GoalUpsertWithoutNotesInput
    disconnect?: GoalWhereInput | boolean
    delete?: GoalWhereInput | boolean
    connect?: GoalWhereUniqueInput
    update?: XOR<XOR<GoalUpdateToOneWithWhereWithoutNotesInput, GoalUpdateWithoutNotesInput>, GoalUncheckedUpdateWithoutNotesInput>
  }

  export type KeyStepUpdateOneWithoutNotesNestedInput = {
    create?: XOR<KeyStepCreateWithoutNotesInput, KeyStepUncheckedCreateWithoutNotesInput>
    connectOrCreate?: KeyStepCreateOrConnectWithoutNotesInput
    upsert?: KeyStepUpsertWithoutNotesInput
    disconnect?: KeyStepWhereInput | boolean
    delete?: KeyStepWhereInput | boolean
    connect?: KeyStepWhereUniqueInput
    update?: XOR<XOR<KeyStepUpdateToOneWithWhereWithoutNotesInput, KeyStepUpdateWithoutNotesInput>, KeyStepUncheckedUpdateWithoutNotesInput>
  }

  export type UserUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotesInput
    upsert?: UserUpsertWithoutNotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotesInput, UserUpdateWithoutNotesInput>, UserUncheckedUpdateWithoutNotesInput>
  }

  export type MonthPlanCreateNestedManyWithoutQuarterPlanInput = {
    create?: XOR<MonthPlanCreateWithoutQuarterPlanInput, MonthPlanUncheckedCreateWithoutQuarterPlanInput> | MonthPlanCreateWithoutQuarterPlanInput[] | MonthPlanUncheckedCreateWithoutQuarterPlanInput[]
    connectOrCreate?: MonthPlanCreateOrConnectWithoutQuarterPlanInput | MonthPlanCreateOrConnectWithoutQuarterPlanInput[]
    createMany?: MonthPlanCreateManyQuarterPlanInputEnvelope
    connect?: MonthPlanWhereUniqueInput | MonthPlanWhereUniqueInput[]
  }

  export type QuarterFocusCreateNestedManyWithoutQuarterPlanInput = {
    create?: XOR<QuarterFocusCreateWithoutQuarterPlanInput, QuarterFocusUncheckedCreateWithoutQuarterPlanInput> | QuarterFocusCreateWithoutQuarterPlanInput[] | QuarterFocusUncheckedCreateWithoutQuarterPlanInput[]
    connectOrCreate?: QuarterFocusCreateOrConnectWithoutQuarterPlanInput | QuarterFocusCreateOrConnectWithoutQuarterPlanInput[]
    createMany?: QuarterFocusCreateManyQuarterPlanInputEnvelope
    connect?: QuarterFocusWhereUniqueInput | QuarterFocusWhereUniqueInput[]
  }

  export type QuarterObjectiveCreateNestedManyWithoutQuarterPlanInput = {
    create?: XOR<QuarterObjectiveCreateWithoutQuarterPlanInput, QuarterObjectiveUncheckedCreateWithoutQuarterPlanInput> | QuarterObjectiveCreateWithoutQuarterPlanInput[] | QuarterObjectiveUncheckedCreateWithoutQuarterPlanInput[]
    connectOrCreate?: QuarterObjectiveCreateOrConnectWithoutQuarterPlanInput | QuarterObjectiveCreateOrConnectWithoutQuarterPlanInput[]
    createMany?: QuarterObjectiveCreateManyQuarterPlanInputEnvelope
    connect?: QuarterObjectiveWhereUniqueInput | QuarterObjectiveWhereUniqueInput[]
  }

  export type YearPlanCreateNestedOneWithoutQuarterPlansInput = {
    create?: XOR<YearPlanCreateWithoutQuarterPlansInput, YearPlanUncheckedCreateWithoutQuarterPlansInput>
    connectOrCreate?: YearPlanCreateOrConnectWithoutQuarterPlansInput
    connect?: YearPlanWhereUniqueInput
  }

  export type MonthPlanUncheckedCreateNestedManyWithoutQuarterPlanInput = {
    create?: XOR<MonthPlanCreateWithoutQuarterPlanInput, MonthPlanUncheckedCreateWithoutQuarterPlanInput> | MonthPlanCreateWithoutQuarterPlanInput[] | MonthPlanUncheckedCreateWithoutQuarterPlanInput[]
    connectOrCreate?: MonthPlanCreateOrConnectWithoutQuarterPlanInput | MonthPlanCreateOrConnectWithoutQuarterPlanInput[]
    createMany?: MonthPlanCreateManyQuarterPlanInputEnvelope
    connect?: MonthPlanWhereUniqueInput | MonthPlanWhereUniqueInput[]
  }

  export type QuarterFocusUncheckedCreateNestedManyWithoutQuarterPlanInput = {
    create?: XOR<QuarterFocusCreateWithoutQuarterPlanInput, QuarterFocusUncheckedCreateWithoutQuarterPlanInput> | QuarterFocusCreateWithoutQuarterPlanInput[] | QuarterFocusUncheckedCreateWithoutQuarterPlanInput[]
    connectOrCreate?: QuarterFocusCreateOrConnectWithoutQuarterPlanInput | QuarterFocusCreateOrConnectWithoutQuarterPlanInput[]
    createMany?: QuarterFocusCreateManyQuarterPlanInputEnvelope
    connect?: QuarterFocusWhereUniqueInput | QuarterFocusWhereUniqueInput[]
  }

  export type QuarterObjectiveUncheckedCreateNestedManyWithoutQuarterPlanInput = {
    create?: XOR<QuarterObjectiveCreateWithoutQuarterPlanInput, QuarterObjectiveUncheckedCreateWithoutQuarterPlanInput> | QuarterObjectiveCreateWithoutQuarterPlanInput[] | QuarterObjectiveUncheckedCreateWithoutQuarterPlanInput[]
    connectOrCreate?: QuarterObjectiveCreateOrConnectWithoutQuarterPlanInput | QuarterObjectiveCreateOrConnectWithoutQuarterPlanInput[]
    createMany?: QuarterObjectiveCreateManyQuarterPlanInputEnvelope
    connect?: QuarterObjectiveWhereUniqueInput | QuarterObjectiveWhereUniqueInput[]
  }

  export type MonthPlanUpdateManyWithoutQuarterPlanNestedInput = {
    create?: XOR<MonthPlanCreateWithoutQuarterPlanInput, MonthPlanUncheckedCreateWithoutQuarterPlanInput> | MonthPlanCreateWithoutQuarterPlanInput[] | MonthPlanUncheckedCreateWithoutQuarterPlanInput[]
    connectOrCreate?: MonthPlanCreateOrConnectWithoutQuarterPlanInput | MonthPlanCreateOrConnectWithoutQuarterPlanInput[]
    upsert?: MonthPlanUpsertWithWhereUniqueWithoutQuarterPlanInput | MonthPlanUpsertWithWhereUniqueWithoutQuarterPlanInput[]
    createMany?: MonthPlanCreateManyQuarterPlanInputEnvelope
    set?: MonthPlanWhereUniqueInput | MonthPlanWhereUniqueInput[]
    disconnect?: MonthPlanWhereUniqueInput | MonthPlanWhereUniqueInput[]
    delete?: MonthPlanWhereUniqueInput | MonthPlanWhereUniqueInput[]
    connect?: MonthPlanWhereUniqueInput | MonthPlanWhereUniqueInput[]
    update?: MonthPlanUpdateWithWhereUniqueWithoutQuarterPlanInput | MonthPlanUpdateWithWhereUniqueWithoutQuarterPlanInput[]
    updateMany?: MonthPlanUpdateManyWithWhereWithoutQuarterPlanInput | MonthPlanUpdateManyWithWhereWithoutQuarterPlanInput[]
    deleteMany?: MonthPlanScalarWhereInput | MonthPlanScalarWhereInput[]
  }

  export type QuarterFocusUpdateManyWithoutQuarterPlanNestedInput = {
    create?: XOR<QuarterFocusCreateWithoutQuarterPlanInput, QuarterFocusUncheckedCreateWithoutQuarterPlanInput> | QuarterFocusCreateWithoutQuarterPlanInput[] | QuarterFocusUncheckedCreateWithoutQuarterPlanInput[]
    connectOrCreate?: QuarterFocusCreateOrConnectWithoutQuarterPlanInput | QuarterFocusCreateOrConnectWithoutQuarterPlanInput[]
    upsert?: QuarterFocusUpsertWithWhereUniqueWithoutQuarterPlanInput | QuarterFocusUpsertWithWhereUniqueWithoutQuarterPlanInput[]
    createMany?: QuarterFocusCreateManyQuarterPlanInputEnvelope
    set?: QuarterFocusWhereUniqueInput | QuarterFocusWhereUniqueInput[]
    disconnect?: QuarterFocusWhereUniqueInput | QuarterFocusWhereUniqueInput[]
    delete?: QuarterFocusWhereUniqueInput | QuarterFocusWhereUniqueInput[]
    connect?: QuarterFocusWhereUniqueInput | QuarterFocusWhereUniqueInput[]
    update?: QuarterFocusUpdateWithWhereUniqueWithoutQuarterPlanInput | QuarterFocusUpdateWithWhereUniqueWithoutQuarterPlanInput[]
    updateMany?: QuarterFocusUpdateManyWithWhereWithoutQuarterPlanInput | QuarterFocusUpdateManyWithWhereWithoutQuarterPlanInput[]
    deleteMany?: QuarterFocusScalarWhereInput | QuarterFocusScalarWhereInput[]
  }

  export type QuarterObjectiveUpdateManyWithoutQuarterPlanNestedInput = {
    create?: XOR<QuarterObjectiveCreateWithoutQuarterPlanInput, QuarterObjectiveUncheckedCreateWithoutQuarterPlanInput> | QuarterObjectiveCreateWithoutQuarterPlanInput[] | QuarterObjectiveUncheckedCreateWithoutQuarterPlanInput[]
    connectOrCreate?: QuarterObjectiveCreateOrConnectWithoutQuarterPlanInput | QuarterObjectiveCreateOrConnectWithoutQuarterPlanInput[]
    upsert?: QuarterObjectiveUpsertWithWhereUniqueWithoutQuarterPlanInput | QuarterObjectiveUpsertWithWhereUniqueWithoutQuarterPlanInput[]
    createMany?: QuarterObjectiveCreateManyQuarterPlanInputEnvelope
    set?: QuarterObjectiveWhereUniqueInput | QuarterObjectiveWhereUniqueInput[]
    disconnect?: QuarterObjectiveWhereUniqueInput | QuarterObjectiveWhereUniqueInput[]
    delete?: QuarterObjectiveWhereUniqueInput | QuarterObjectiveWhereUniqueInput[]
    connect?: QuarterObjectiveWhereUniqueInput | QuarterObjectiveWhereUniqueInput[]
    update?: QuarterObjectiveUpdateWithWhereUniqueWithoutQuarterPlanInput | QuarterObjectiveUpdateWithWhereUniqueWithoutQuarterPlanInput[]
    updateMany?: QuarterObjectiveUpdateManyWithWhereWithoutQuarterPlanInput | QuarterObjectiveUpdateManyWithWhereWithoutQuarterPlanInput[]
    deleteMany?: QuarterObjectiveScalarWhereInput | QuarterObjectiveScalarWhereInput[]
  }

  export type YearPlanUpdateOneRequiredWithoutQuarterPlansNestedInput = {
    create?: XOR<YearPlanCreateWithoutQuarterPlansInput, YearPlanUncheckedCreateWithoutQuarterPlansInput>
    connectOrCreate?: YearPlanCreateOrConnectWithoutQuarterPlansInput
    upsert?: YearPlanUpsertWithoutQuarterPlansInput
    connect?: YearPlanWhereUniqueInput
    update?: XOR<XOR<YearPlanUpdateToOneWithWhereWithoutQuarterPlansInput, YearPlanUpdateWithoutQuarterPlansInput>, YearPlanUncheckedUpdateWithoutQuarterPlansInput>
  }

  export type MonthPlanUncheckedUpdateManyWithoutQuarterPlanNestedInput = {
    create?: XOR<MonthPlanCreateWithoutQuarterPlanInput, MonthPlanUncheckedCreateWithoutQuarterPlanInput> | MonthPlanCreateWithoutQuarterPlanInput[] | MonthPlanUncheckedCreateWithoutQuarterPlanInput[]
    connectOrCreate?: MonthPlanCreateOrConnectWithoutQuarterPlanInput | MonthPlanCreateOrConnectWithoutQuarterPlanInput[]
    upsert?: MonthPlanUpsertWithWhereUniqueWithoutQuarterPlanInput | MonthPlanUpsertWithWhereUniqueWithoutQuarterPlanInput[]
    createMany?: MonthPlanCreateManyQuarterPlanInputEnvelope
    set?: MonthPlanWhereUniqueInput | MonthPlanWhereUniqueInput[]
    disconnect?: MonthPlanWhereUniqueInput | MonthPlanWhereUniqueInput[]
    delete?: MonthPlanWhereUniqueInput | MonthPlanWhereUniqueInput[]
    connect?: MonthPlanWhereUniqueInput | MonthPlanWhereUniqueInput[]
    update?: MonthPlanUpdateWithWhereUniqueWithoutQuarterPlanInput | MonthPlanUpdateWithWhereUniqueWithoutQuarterPlanInput[]
    updateMany?: MonthPlanUpdateManyWithWhereWithoutQuarterPlanInput | MonthPlanUpdateManyWithWhereWithoutQuarterPlanInput[]
    deleteMany?: MonthPlanScalarWhereInput | MonthPlanScalarWhereInput[]
  }

  export type QuarterFocusUncheckedUpdateManyWithoutQuarterPlanNestedInput = {
    create?: XOR<QuarterFocusCreateWithoutQuarterPlanInput, QuarterFocusUncheckedCreateWithoutQuarterPlanInput> | QuarterFocusCreateWithoutQuarterPlanInput[] | QuarterFocusUncheckedCreateWithoutQuarterPlanInput[]
    connectOrCreate?: QuarterFocusCreateOrConnectWithoutQuarterPlanInput | QuarterFocusCreateOrConnectWithoutQuarterPlanInput[]
    upsert?: QuarterFocusUpsertWithWhereUniqueWithoutQuarterPlanInput | QuarterFocusUpsertWithWhereUniqueWithoutQuarterPlanInput[]
    createMany?: QuarterFocusCreateManyQuarterPlanInputEnvelope
    set?: QuarterFocusWhereUniqueInput | QuarterFocusWhereUniqueInput[]
    disconnect?: QuarterFocusWhereUniqueInput | QuarterFocusWhereUniqueInput[]
    delete?: QuarterFocusWhereUniqueInput | QuarterFocusWhereUniqueInput[]
    connect?: QuarterFocusWhereUniqueInput | QuarterFocusWhereUniqueInput[]
    update?: QuarterFocusUpdateWithWhereUniqueWithoutQuarterPlanInput | QuarterFocusUpdateWithWhereUniqueWithoutQuarterPlanInput[]
    updateMany?: QuarterFocusUpdateManyWithWhereWithoutQuarterPlanInput | QuarterFocusUpdateManyWithWhereWithoutQuarterPlanInput[]
    deleteMany?: QuarterFocusScalarWhereInput | QuarterFocusScalarWhereInput[]
  }

  export type QuarterObjectiveUncheckedUpdateManyWithoutQuarterPlanNestedInput = {
    create?: XOR<QuarterObjectiveCreateWithoutQuarterPlanInput, QuarterObjectiveUncheckedCreateWithoutQuarterPlanInput> | QuarterObjectiveCreateWithoutQuarterPlanInput[] | QuarterObjectiveUncheckedCreateWithoutQuarterPlanInput[]
    connectOrCreate?: QuarterObjectiveCreateOrConnectWithoutQuarterPlanInput | QuarterObjectiveCreateOrConnectWithoutQuarterPlanInput[]
    upsert?: QuarterObjectiveUpsertWithWhereUniqueWithoutQuarterPlanInput | QuarterObjectiveUpsertWithWhereUniqueWithoutQuarterPlanInput[]
    createMany?: QuarterObjectiveCreateManyQuarterPlanInputEnvelope
    set?: QuarterObjectiveWhereUniqueInput | QuarterObjectiveWhereUniqueInput[]
    disconnect?: QuarterObjectiveWhereUniqueInput | QuarterObjectiveWhereUniqueInput[]
    delete?: QuarterObjectiveWhereUniqueInput | QuarterObjectiveWhereUniqueInput[]
    connect?: QuarterObjectiveWhereUniqueInput | QuarterObjectiveWhereUniqueInput[]
    update?: QuarterObjectiveUpdateWithWhereUniqueWithoutQuarterPlanInput | QuarterObjectiveUpdateWithWhereUniqueWithoutQuarterPlanInput[]
    updateMany?: QuarterObjectiveUpdateManyWithWhereWithoutQuarterPlanInput | QuarterObjectiveUpdateManyWithWhereWithoutQuarterPlanInput[]
    deleteMany?: QuarterObjectiveScalarWhereInput | QuarterObjectiveScalarWhereInput[]
  }

  export type QuarterPlanCreateNestedOneWithoutObjectivesInput = {
    create?: XOR<QuarterPlanCreateWithoutObjectivesInput, QuarterPlanUncheckedCreateWithoutObjectivesInput>
    connectOrCreate?: QuarterPlanCreateOrConnectWithoutObjectivesInput
    connect?: QuarterPlanWhereUniqueInput
  }

  export type QuarterPlanUpdateOneRequiredWithoutObjectivesNestedInput = {
    create?: XOR<QuarterPlanCreateWithoutObjectivesInput, QuarterPlanUncheckedCreateWithoutObjectivesInput>
    connectOrCreate?: QuarterPlanCreateOrConnectWithoutObjectivesInput
    upsert?: QuarterPlanUpsertWithoutObjectivesInput
    connect?: QuarterPlanWhereUniqueInput
    update?: XOR<XOR<QuarterPlanUpdateToOneWithWhereWithoutObjectivesInput, QuarterPlanUpdateWithoutObjectivesInput>, QuarterPlanUncheckedUpdateWithoutObjectivesInput>
  }

  export type MonthFocusCreateNestedManyWithoutQuarterFocusInput = {
    create?: XOR<MonthFocusCreateWithoutQuarterFocusInput, MonthFocusUncheckedCreateWithoutQuarterFocusInput> | MonthFocusCreateWithoutQuarterFocusInput[] | MonthFocusUncheckedCreateWithoutQuarterFocusInput[]
    connectOrCreate?: MonthFocusCreateOrConnectWithoutQuarterFocusInput | MonthFocusCreateOrConnectWithoutQuarterFocusInput[]
    createMany?: MonthFocusCreateManyQuarterFocusInputEnvelope
    connect?: MonthFocusWhereUniqueInput | MonthFocusWhereUniqueInput[]
  }

  export type GoalCreateNestedOneWithoutQuarterFocusesInput = {
    create?: XOR<GoalCreateWithoutQuarterFocusesInput, GoalUncheckedCreateWithoutQuarterFocusesInput>
    connectOrCreate?: GoalCreateOrConnectWithoutQuarterFocusesInput
    connect?: GoalWhereUniqueInput
  }

  export type QuarterPlanCreateNestedOneWithoutQuarterFocusesInput = {
    create?: XOR<QuarterPlanCreateWithoutQuarterFocusesInput, QuarterPlanUncheckedCreateWithoutQuarterFocusesInput>
    connectOrCreate?: QuarterPlanCreateOrConnectWithoutQuarterFocusesInput
    connect?: QuarterPlanWhereUniqueInput
  }

  export type MonthFocusUncheckedCreateNestedManyWithoutQuarterFocusInput = {
    create?: XOR<MonthFocusCreateWithoutQuarterFocusInput, MonthFocusUncheckedCreateWithoutQuarterFocusInput> | MonthFocusCreateWithoutQuarterFocusInput[] | MonthFocusUncheckedCreateWithoutQuarterFocusInput[]
    connectOrCreate?: MonthFocusCreateOrConnectWithoutQuarterFocusInput | MonthFocusCreateOrConnectWithoutQuarterFocusInput[]
    createMany?: MonthFocusCreateManyQuarterFocusInputEnvelope
    connect?: MonthFocusWhereUniqueInput | MonthFocusWhereUniqueInput[]
  }

  export type MonthFocusUpdateManyWithoutQuarterFocusNestedInput = {
    create?: XOR<MonthFocusCreateWithoutQuarterFocusInput, MonthFocusUncheckedCreateWithoutQuarterFocusInput> | MonthFocusCreateWithoutQuarterFocusInput[] | MonthFocusUncheckedCreateWithoutQuarterFocusInput[]
    connectOrCreate?: MonthFocusCreateOrConnectWithoutQuarterFocusInput | MonthFocusCreateOrConnectWithoutQuarterFocusInput[]
    upsert?: MonthFocusUpsertWithWhereUniqueWithoutQuarterFocusInput | MonthFocusUpsertWithWhereUniqueWithoutQuarterFocusInput[]
    createMany?: MonthFocusCreateManyQuarterFocusInputEnvelope
    set?: MonthFocusWhereUniqueInput | MonthFocusWhereUniqueInput[]
    disconnect?: MonthFocusWhereUniqueInput | MonthFocusWhereUniqueInput[]
    delete?: MonthFocusWhereUniqueInput | MonthFocusWhereUniqueInput[]
    connect?: MonthFocusWhereUniqueInput | MonthFocusWhereUniqueInput[]
    update?: MonthFocusUpdateWithWhereUniqueWithoutQuarterFocusInput | MonthFocusUpdateWithWhereUniqueWithoutQuarterFocusInput[]
    updateMany?: MonthFocusUpdateManyWithWhereWithoutQuarterFocusInput | MonthFocusUpdateManyWithWhereWithoutQuarterFocusInput[]
    deleteMany?: MonthFocusScalarWhereInput | MonthFocusScalarWhereInput[]
  }

  export type GoalUpdateOneRequiredWithoutQuarterFocusesNestedInput = {
    create?: XOR<GoalCreateWithoutQuarterFocusesInput, GoalUncheckedCreateWithoutQuarterFocusesInput>
    connectOrCreate?: GoalCreateOrConnectWithoutQuarterFocusesInput
    upsert?: GoalUpsertWithoutQuarterFocusesInput
    connect?: GoalWhereUniqueInput
    update?: XOR<XOR<GoalUpdateToOneWithWhereWithoutQuarterFocusesInput, GoalUpdateWithoutQuarterFocusesInput>, GoalUncheckedUpdateWithoutQuarterFocusesInput>
  }

  export type QuarterPlanUpdateOneRequiredWithoutQuarterFocusesNestedInput = {
    create?: XOR<QuarterPlanCreateWithoutQuarterFocusesInput, QuarterPlanUncheckedCreateWithoutQuarterFocusesInput>
    connectOrCreate?: QuarterPlanCreateOrConnectWithoutQuarterFocusesInput
    upsert?: QuarterPlanUpsertWithoutQuarterFocusesInput
    connect?: QuarterPlanWhereUniqueInput
    update?: XOR<XOR<QuarterPlanUpdateToOneWithWhereWithoutQuarterFocusesInput, QuarterPlanUpdateWithoutQuarterFocusesInput>, QuarterPlanUncheckedUpdateWithoutQuarterFocusesInput>
  }

  export type MonthFocusUncheckedUpdateManyWithoutQuarterFocusNestedInput = {
    create?: XOR<MonthFocusCreateWithoutQuarterFocusInput, MonthFocusUncheckedCreateWithoutQuarterFocusInput> | MonthFocusCreateWithoutQuarterFocusInput[] | MonthFocusUncheckedCreateWithoutQuarterFocusInput[]
    connectOrCreate?: MonthFocusCreateOrConnectWithoutQuarterFocusInput | MonthFocusCreateOrConnectWithoutQuarterFocusInput[]
    upsert?: MonthFocusUpsertWithWhereUniqueWithoutQuarterFocusInput | MonthFocusUpsertWithWhereUniqueWithoutQuarterFocusInput[]
    createMany?: MonthFocusCreateManyQuarterFocusInputEnvelope
    set?: MonthFocusWhereUniqueInput | MonthFocusWhereUniqueInput[]
    disconnect?: MonthFocusWhereUniqueInput | MonthFocusWhereUniqueInput[]
    delete?: MonthFocusWhereUniqueInput | MonthFocusWhereUniqueInput[]
    connect?: MonthFocusWhereUniqueInput | MonthFocusWhereUniqueInput[]
    update?: MonthFocusUpdateWithWhereUniqueWithoutQuarterFocusInput | MonthFocusUpdateWithWhereUniqueWithoutQuarterFocusInput[]
    updateMany?: MonthFocusUpdateManyWithWhereWithoutQuarterFocusInput | MonthFocusUpdateManyWithWhereWithoutQuarterFocusInput[]
    deleteMany?: MonthFocusScalarWhereInput | MonthFocusScalarWhereInput[]
  }

  export type MonthPlanCreateobjectivesInput = {
    set: string[]
  }

  export type MonthFocusCreateNestedManyWithoutMonthPlanInput = {
    create?: XOR<MonthFocusCreateWithoutMonthPlanInput, MonthFocusUncheckedCreateWithoutMonthPlanInput> | MonthFocusCreateWithoutMonthPlanInput[] | MonthFocusUncheckedCreateWithoutMonthPlanInput[]
    connectOrCreate?: MonthFocusCreateOrConnectWithoutMonthPlanInput | MonthFocusCreateOrConnectWithoutMonthPlanInput[]
    createMany?: MonthFocusCreateManyMonthPlanInputEnvelope
    connect?: MonthFocusWhereUniqueInput | MonthFocusWhereUniqueInput[]
  }

  export type QuarterPlanCreateNestedOneWithoutMonthPlansInput = {
    create?: XOR<QuarterPlanCreateWithoutMonthPlansInput, QuarterPlanUncheckedCreateWithoutMonthPlansInput>
    connectOrCreate?: QuarterPlanCreateOrConnectWithoutMonthPlansInput
    connect?: QuarterPlanWhereUniqueInput
  }

  export type WeekPlanCreateNestedManyWithoutMonthPlanInput = {
    create?: XOR<WeekPlanCreateWithoutMonthPlanInput, WeekPlanUncheckedCreateWithoutMonthPlanInput> | WeekPlanCreateWithoutMonthPlanInput[] | WeekPlanUncheckedCreateWithoutMonthPlanInput[]
    connectOrCreate?: WeekPlanCreateOrConnectWithoutMonthPlanInput | WeekPlanCreateOrConnectWithoutMonthPlanInput[]
    createMany?: WeekPlanCreateManyMonthPlanInputEnvelope
    connect?: WeekPlanWhereUniqueInput | WeekPlanWhereUniqueInput[]
  }

  export type MonthFocusUncheckedCreateNestedManyWithoutMonthPlanInput = {
    create?: XOR<MonthFocusCreateWithoutMonthPlanInput, MonthFocusUncheckedCreateWithoutMonthPlanInput> | MonthFocusCreateWithoutMonthPlanInput[] | MonthFocusUncheckedCreateWithoutMonthPlanInput[]
    connectOrCreate?: MonthFocusCreateOrConnectWithoutMonthPlanInput | MonthFocusCreateOrConnectWithoutMonthPlanInput[]
    createMany?: MonthFocusCreateManyMonthPlanInputEnvelope
    connect?: MonthFocusWhereUniqueInput | MonthFocusWhereUniqueInput[]
  }

  export type WeekPlanUncheckedCreateNestedManyWithoutMonthPlanInput = {
    create?: XOR<WeekPlanCreateWithoutMonthPlanInput, WeekPlanUncheckedCreateWithoutMonthPlanInput> | WeekPlanCreateWithoutMonthPlanInput[] | WeekPlanUncheckedCreateWithoutMonthPlanInput[]
    connectOrCreate?: WeekPlanCreateOrConnectWithoutMonthPlanInput | WeekPlanCreateOrConnectWithoutMonthPlanInput[]
    createMany?: WeekPlanCreateManyMonthPlanInputEnvelope
    connect?: WeekPlanWhereUniqueInput | WeekPlanWhereUniqueInput[]
  }

  export type MonthPlanUpdateobjectivesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MonthFocusUpdateManyWithoutMonthPlanNestedInput = {
    create?: XOR<MonthFocusCreateWithoutMonthPlanInput, MonthFocusUncheckedCreateWithoutMonthPlanInput> | MonthFocusCreateWithoutMonthPlanInput[] | MonthFocusUncheckedCreateWithoutMonthPlanInput[]
    connectOrCreate?: MonthFocusCreateOrConnectWithoutMonthPlanInput | MonthFocusCreateOrConnectWithoutMonthPlanInput[]
    upsert?: MonthFocusUpsertWithWhereUniqueWithoutMonthPlanInput | MonthFocusUpsertWithWhereUniqueWithoutMonthPlanInput[]
    createMany?: MonthFocusCreateManyMonthPlanInputEnvelope
    set?: MonthFocusWhereUniqueInput | MonthFocusWhereUniqueInput[]
    disconnect?: MonthFocusWhereUniqueInput | MonthFocusWhereUniqueInput[]
    delete?: MonthFocusWhereUniqueInput | MonthFocusWhereUniqueInput[]
    connect?: MonthFocusWhereUniqueInput | MonthFocusWhereUniqueInput[]
    update?: MonthFocusUpdateWithWhereUniqueWithoutMonthPlanInput | MonthFocusUpdateWithWhereUniqueWithoutMonthPlanInput[]
    updateMany?: MonthFocusUpdateManyWithWhereWithoutMonthPlanInput | MonthFocusUpdateManyWithWhereWithoutMonthPlanInput[]
    deleteMany?: MonthFocusScalarWhereInput | MonthFocusScalarWhereInput[]
  }

  export type QuarterPlanUpdateOneRequiredWithoutMonthPlansNestedInput = {
    create?: XOR<QuarterPlanCreateWithoutMonthPlansInput, QuarterPlanUncheckedCreateWithoutMonthPlansInput>
    connectOrCreate?: QuarterPlanCreateOrConnectWithoutMonthPlansInput
    upsert?: QuarterPlanUpsertWithoutMonthPlansInput
    connect?: QuarterPlanWhereUniqueInput
    update?: XOR<XOR<QuarterPlanUpdateToOneWithWhereWithoutMonthPlansInput, QuarterPlanUpdateWithoutMonthPlansInput>, QuarterPlanUncheckedUpdateWithoutMonthPlansInput>
  }

  export type WeekPlanUpdateManyWithoutMonthPlanNestedInput = {
    create?: XOR<WeekPlanCreateWithoutMonthPlanInput, WeekPlanUncheckedCreateWithoutMonthPlanInput> | WeekPlanCreateWithoutMonthPlanInput[] | WeekPlanUncheckedCreateWithoutMonthPlanInput[]
    connectOrCreate?: WeekPlanCreateOrConnectWithoutMonthPlanInput | WeekPlanCreateOrConnectWithoutMonthPlanInput[]
    upsert?: WeekPlanUpsertWithWhereUniqueWithoutMonthPlanInput | WeekPlanUpsertWithWhereUniqueWithoutMonthPlanInput[]
    createMany?: WeekPlanCreateManyMonthPlanInputEnvelope
    set?: WeekPlanWhereUniqueInput | WeekPlanWhereUniqueInput[]
    disconnect?: WeekPlanWhereUniqueInput | WeekPlanWhereUniqueInput[]
    delete?: WeekPlanWhereUniqueInput | WeekPlanWhereUniqueInput[]
    connect?: WeekPlanWhereUniqueInput | WeekPlanWhereUniqueInput[]
    update?: WeekPlanUpdateWithWhereUniqueWithoutMonthPlanInput | WeekPlanUpdateWithWhereUniqueWithoutMonthPlanInput[]
    updateMany?: WeekPlanUpdateManyWithWhereWithoutMonthPlanInput | WeekPlanUpdateManyWithWhereWithoutMonthPlanInput[]
    deleteMany?: WeekPlanScalarWhereInput | WeekPlanScalarWhereInput[]
  }

  export type MonthFocusUncheckedUpdateManyWithoutMonthPlanNestedInput = {
    create?: XOR<MonthFocusCreateWithoutMonthPlanInput, MonthFocusUncheckedCreateWithoutMonthPlanInput> | MonthFocusCreateWithoutMonthPlanInput[] | MonthFocusUncheckedCreateWithoutMonthPlanInput[]
    connectOrCreate?: MonthFocusCreateOrConnectWithoutMonthPlanInput | MonthFocusCreateOrConnectWithoutMonthPlanInput[]
    upsert?: MonthFocusUpsertWithWhereUniqueWithoutMonthPlanInput | MonthFocusUpsertWithWhereUniqueWithoutMonthPlanInput[]
    createMany?: MonthFocusCreateManyMonthPlanInputEnvelope
    set?: MonthFocusWhereUniqueInput | MonthFocusWhereUniqueInput[]
    disconnect?: MonthFocusWhereUniqueInput | MonthFocusWhereUniqueInput[]
    delete?: MonthFocusWhereUniqueInput | MonthFocusWhereUniqueInput[]
    connect?: MonthFocusWhereUniqueInput | MonthFocusWhereUniqueInput[]
    update?: MonthFocusUpdateWithWhereUniqueWithoutMonthPlanInput | MonthFocusUpdateWithWhereUniqueWithoutMonthPlanInput[]
    updateMany?: MonthFocusUpdateManyWithWhereWithoutMonthPlanInput | MonthFocusUpdateManyWithWhereWithoutMonthPlanInput[]
    deleteMany?: MonthFocusScalarWhereInput | MonthFocusScalarWhereInput[]
  }

  export type WeekPlanUncheckedUpdateManyWithoutMonthPlanNestedInput = {
    create?: XOR<WeekPlanCreateWithoutMonthPlanInput, WeekPlanUncheckedCreateWithoutMonthPlanInput> | WeekPlanCreateWithoutMonthPlanInput[] | WeekPlanUncheckedCreateWithoutMonthPlanInput[]
    connectOrCreate?: WeekPlanCreateOrConnectWithoutMonthPlanInput | WeekPlanCreateOrConnectWithoutMonthPlanInput[]
    upsert?: WeekPlanUpsertWithWhereUniqueWithoutMonthPlanInput | WeekPlanUpsertWithWhereUniqueWithoutMonthPlanInput[]
    createMany?: WeekPlanCreateManyMonthPlanInputEnvelope
    set?: WeekPlanWhereUniqueInput | WeekPlanWhereUniqueInput[]
    disconnect?: WeekPlanWhereUniqueInput | WeekPlanWhereUniqueInput[]
    delete?: WeekPlanWhereUniqueInput | WeekPlanWhereUniqueInput[]
    connect?: WeekPlanWhereUniqueInput | WeekPlanWhereUniqueInput[]
    update?: WeekPlanUpdateWithWhereUniqueWithoutMonthPlanInput | WeekPlanUpdateWithWhereUniqueWithoutMonthPlanInput[]
    updateMany?: WeekPlanUpdateManyWithWhereWithoutMonthPlanInput | WeekPlanUpdateManyWithWhereWithoutMonthPlanInput[]
    deleteMany?: WeekPlanScalarWhereInput | WeekPlanScalarWhereInput[]
  }

  export type MonthPlanCreateNestedOneWithoutMonthFocusesInput = {
    create?: XOR<MonthPlanCreateWithoutMonthFocusesInput, MonthPlanUncheckedCreateWithoutMonthFocusesInput>
    connectOrCreate?: MonthPlanCreateOrConnectWithoutMonthFocusesInput
    connect?: MonthPlanWhereUniqueInput
  }

  export type QuarterFocusCreateNestedOneWithoutMonthFocusesInput = {
    create?: XOR<QuarterFocusCreateWithoutMonthFocusesInput, QuarterFocusUncheckedCreateWithoutMonthFocusesInput>
    connectOrCreate?: QuarterFocusCreateOrConnectWithoutMonthFocusesInput
    connect?: QuarterFocusWhereUniqueInput
  }

  export type WeekFocusCreateNestedManyWithoutMonthFocusInput = {
    create?: XOR<WeekFocusCreateWithoutMonthFocusInput, WeekFocusUncheckedCreateWithoutMonthFocusInput> | WeekFocusCreateWithoutMonthFocusInput[] | WeekFocusUncheckedCreateWithoutMonthFocusInput[]
    connectOrCreate?: WeekFocusCreateOrConnectWithoutMonthFocusInput | WeekFocusCreateOrConnectWithoutMonthFocusInput[]
    createMany?: WeekFocusCreateManyMonthFocusInputEnvelope
    connect?: WeekFocusWhereUniqueInput | WeekFocusWhereUniqueInput[]
  }

  export type WeekFocusUncheckedCreateNestedManyWithoutMonthFocusInput = {
    create?: XOR<WeekFocusCreateWithoutMonthFocusInput, WeekFocusUncheckedCreateWithoutMonthFocusInput> | WeekFocusCreateWithoutMonthFocusInput[] | WeekFocusUncheckedCreateWithoutMonthFocusInput[]
    connectOrCreate?: WeekFocusCreateOrConnectWithoutMonthFocusInput | WeekFocusCreateOrConnectWithoutMonthFocusInput[]
    createMany?: WeekFocusCreateManyMonthFocusInputEnvelope
    connect?: WeekFocusWhereUniqueInput | WeekFocusWhereUniqueInput[]
  }

  export type MonthPlanUpdateOneRequiredWithoutMonthFocusesNestedInput = {
    create?: XOR<MonthPlanCreateWithoutMonthFocusesInput, MonthPlanUncheckedCreateWithoutMonthFocusesInput>
    connectOrCreate?: MonthPlanCreateOrConnectWithoutMonthFocusesInput
    upsert?: MonthPlanUpsertWithoutMonthFocusesInput
    connect?: MonthPlanWhereUniqueInput
    update?: XOR<XOR<MonthPlanUpdateToOneWithWhereWithoutMonthFocusesInput, MonthPlanUpdateWithoutMonthFocusesInput>, MonthPlanUncheckedUpdateWithoutMonthFocusesInput>
  }

  export type QuarterFocusUpdateOneRequiredWithoutMonthFocusesNestedInput = {
    create?: XOR<QuarterFocusCreateWithoutMonthFocusesInput, QuarterFocusUncheckedCreateWithoutMonthFocusesInput>
    connectOrCreate?: QuarterFocusCreateOrConnectWithoutMonthFocusesInput
    upsert?: QuarterFocusUpsertWithoutMonthFocusesInput
    connect?: QuarterFocusWhereUniqueInput
    update?: XOR<XOR<QuarterFocusUpdateToOneWithWhereWithoutMonthFocusesInput, QuarterFocusUpdateWithoutMonthFocusesInput>, QuarterFocusUncheckedUpdateWithoutMonthFocusesInput>
  }

  export type WeekFocusUpdateManyWithoutMonthFocusNestedInput = {
    create?: XOR<WeekFocusCreateWithoutMonthFocusInput, WeekFocusUncheckedCreateWithoutMonthFocusInput> | WeekFocusCreateWithoutMonthFocusInput[] | WeekFocusUncheckedCreateWithoutMonthFocusInput[]
    connectOrCreate?: WeekFocusCreateOrConnectWithoutMonthFocusInput | WeekFocusCreateOrConnectWithoutMonthFocusInput[]
    upsert?: WeekFocusUpsertWithWhereUniqueWithoutMonthFocusInput | WeekFocusUpsertWithWhereUniqueWithoutMonthFocusInput[]
    createMany?: WeekFocusCreateManyMonthFocusInputEnvelope
    set?: WeekFocusWhereUniqueInput | WeekFocusWhereUniqueInput[]
    disconnect?: WeekFocusWhereUniqueInput | WeekFocusWhereUniqueInput[]
    delete?: WeekFocusWhereUniqueInput | WeekFocusWhereUniqueInput[]
    connect?: WeekFocusWhereUniqueInput | WeekFocusWhereUniqueInput[]
    update?: WeekFocusUpdateWithWhereUniqueWithoutMonthFocusInput | WeekFocusUpdateWithWhereUniqueWithoutMonthFocusInput[]
    updateMany?: WeekFocusUpdateManyWithWhereWithoutMonthFocusInput | WeekFocusUpdateManyWithWhereWithoutMonthFocusInput[]
    deleteMany?: WeekFocusScalarWhereInput | WeekFocusScalarWhereInput[]
  }

  export type WeekFocusUncheckedUpdateManyWithoutMonthFocusNestedInput = {
    create?: XOR<WeekFocusCreateWithoutMonthFocusInput, WeekFocusUncheckedCreateWithoutMonthFocusInput> | WeekFocusCreateWithoutMonthFocusInput[] | WeekFocusUncheckedCreateWithoutMonthFocusInput[]
    connectOrCreate?: WeekFocusCreateOrConnectWithoutMonthFocusInput | WeekFocusCreateOrConnectWithoutMonthFocusInput[]
    upsert?: WeekFocusUpsertWithWhereUniqueWithoutMonthFocusInput | WeekFocusUpsertWithWhereUniqueWithoutMonthFocusInput[]
    createMany?: WeekFocusCreateManyMonthFocusInputEnvelope
    set?: WeekFocusWhereUniqueInput | WeekFocusWhereUniqueInput[]
    disconnect?: WeekFocusWhereUniqueInput | WeekFocusWhereUniqueInput[]
    delete?: WeekFocusWhereUniqueInput | WeekFocusWhereUniqueInput[]
    connect?: WeekFocusWhereUniqueInput | WeekFocusWhereUniqueInput[]
    update?: WeekFocusUpdateWithWhereUniqueWithoutMonthFocusInput | WeekFocusUpdateWithWhereUniqueWithoutMonthFocusInput[]
    updateMany?: WeekFocusUpdateManyWithWhereWithoutMonthFocusInput | WeekFocusUpdateManyWithWhereWithoutMonthFocusInput[]
    deleteMany?: WeekFocusScalarWhereInput | WeekFocusScalarWhereInput[]
  }

  export type WeekPlanCreatetopOutcomesInput = {
    set: string[]
  }

  export type WeekPlanCreatechallengesInput = {
    set: string[]
  }

  export type WeekPlanCreatekeyWinsInput = {
    set: string[]
  }

  export type WeekPlanCreatelessonsLearnedInput = {
    set: string[]
  }

  export type DayPlanCreateNestedManyWithoutWeekPlanInput = {
    create?: XOR<DayPlanCreateWithoutWeekPlanInput, DayPlanUncheckedCreateWithoutWeekPlanInput> | DayPlanCreateWithoutWeekPlanInput[] | DayPlanUncheckedCreateWithoutWeekPlanInput[]
    connectOrCreate?: DayPlanCreateOrConnectWithoutWeekPlanInput | DayPlanCreateOrConnectWithoutWeekPlanInput[]
    createMany?: DayPlanCreateManyWeekPlanInputEnvelope
    connect?: DayPlanWhereUniqueInput | DayPlanWhereUniqueInput[]
  }

  export type WeekFocusCreateNestedManyWithoutWeekPlanInput = {
    create?: XOR<WeekFocusCreateWithoutWeekPlanInput, WeekFocusUncheckedCreateWithoutWeekPlanInput> | WeekFocusCreateWithoutWeekPlanInput[] | WeekFocusUncheckedCreateWithoutWeekPlanInput[]
    connectOrCreate?: WeekFocusCreateOrConnectWithoutWeekPlanInput | WeekFocusCreateOrConnectWithoutWeekPlanInput[]
    createMany?: WeekFocusCreateManyWeekPlanInputEnvelope
    connect?: WeekFocusWhereUniqueInput | WeekFocusWhereUniqueInput[]
  }

  export type MonthPlanCreateNestedOneWithoutWeekPlansInput = {
    create?: XOR<MonthPlanCreateWithoutWeekPlansInput, MonthPlanUncheckedCreateWithoutWeekPlansInput>
    connectOrCreate?: MonthPlanCreateOrConnectWithoutWeekPlansInput
    connect?: MonthPlanWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutWeekPlansInput = {
    create?: XOR<UserCreateWithoutWeekPlansInput, UserUncheckedCreateWithoutWeekPlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutWeekPlansInput
    connect?: UserWhereUniqueInput
  }

  export type DayPlanUncheckedCreateNestedManyWithoutWeekPlanInput = {
    create?: XOR<DayPlanCreateWithoutWeekPlanInput, DayPlanUncheckedCreateWithoutWeekPlanInput> | DayPlanCreateWithoutWeekPlanInput[] | DayPlanUncheckedCreateWithoutWeekPlanInput[]
    connectOrCreate?: DayPlanCreateOrConnectWithoutWeekPlanInput | DayPlanCreateOrConnectWithoutWeekPlanInput[]
    createMany?: DayPlanCreateManyWeekPlanInputEnvelope
    connect?: DayPlanWhereUniqueInput | DayPlanWhereUniqueInput[]
  }

  export type WeekFocusUncheckedCreateNestedManyWithoutWeekPlanInput = {
    create?: XOR<WeekFocusCreateWithoutWeekPlanInput, WeekFocusUncheckedCreateWithoutWeekPlanInput> | WeekFocusCreateWithoutWeekPlanInput[] | WeekFocusUncheckedCreateWithoutWeekPlanInput[]
    connectOrCreate?: WeekFocusCreateOrConnectWithoutWeekPlanInput | WeekFocusCreateOrConnectWithoutWeekPlanInput[]
    createMany?: WeekFocusCreateManyWeekPlanInputEnvelope
    connect?: WeekFocusWhereUniqueInput | WeekFocusWhereUniqueInput[]
  }

  export type WeekPlanUpdatetopOutcomesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type WeekPlanUpdatechallengesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type WeekPlanUpdatekeyWinsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type WeekPlanUpdatelessonsLearnedInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DayPlanUpdateManyWithoutWeekPlanNestedInput = {
    create?: XOR<DayPlanCreateWithoutWeekPlanInput, DayPlanUncheckedCreateWithoutWeekPlanInput> | DayPlanCreateWithoutWeekPlanInput[] | DayPlanUncheckedCreateWithoutWeekPlanInput[]
    connectOrCreate?: DayPlanCreateOrConnectWithoutWeekPlanInput | DayPlanCreateOrConnectWithoutWeekPlanInput[]
    upsert?: DayPlanUpsertWithWhereUniqueWithoutWeekPlanInput | DayPlanUpsertWithWhereUniqueWithoutWeekPlanInput[]
    createMany?: DayPlanCreateManyWeekPlanInputEnvelope
    set?: DayPlanWhereUniqueInput | DayPlanWhereUniqueInput[]
    disconnect?: DayPlanWhereUniqueInput | DayPlanWhereUniqueInput[]
    delete?: DayPlanWhereUniqueInput | DayPlanWhereUniqueInput[]
    connect?: DayPlanWhereUniqueInput | DayPlanWhereUniqueInput[]
    update?: DayPlanUpdateWithWhereUniqueWithoutWeekPlanInput | DayPlanUpdateWithWhereUniqueWithoutWeekPlanInput[]
    updateMany?: DayPlanUpdateManyWithWhereWithoutWeekPlanInput | DayPlanUpdateManyWithWhereWithoutWeekPlanInput[]
    deleteMany?: DayPlanScalarWhereInput | DayPlanScalarWhereInput[]
  }

  export type WeekFocusUpdateManyWithoutWeekPlanNestedInput = {
    create?: XOR<WeekFocusCreateWithoutWeekPlanInput, WeekFocusUncheckedCreateWithoutWeekPlanInput> | WeekFocusCreateWithoutWeekPlanInput[] | WeekFocusUncheckedCreateWithoutWeekPlanInput[]
    connectOrCreate?: WeekFocusCreateOrConnectWithoutWeekPlanInput | WeekFocusCreateOrConnectWithoutWeekPlanInput[]
    upsert?: WeekFocusUpsertWithWhereUniqueWithoutWeekPlanInput | WeekFocusUpsertWithWhereUniqueWithoutWeekPlanInput[]
    createMany?: WeekFocusCreateManyWeekPlanInputEnvelope
    set?: WeekFocusWhereUniqueInput | WeekFocusWhereUniqueInput[]
    disconnect?: WeekFocusWhereUniqueInput | WeekFocusWhereUniqueInput[]
    delete?: WeekFocusWhereUniqueInput | WeekFocusWhereUniqueInput[]
    connect?: WeekFocusWhereUniqueInput | WeekFocusWhereUniqueInput[]
    update?: WeekFocusUpdateWithWhereUniqueWithoutWeekPlanInput | WeekFocusUpdateWithWhereUniqueWithoutWeekPlanInput[]
    updateMany?: WeekFocusUpdateManyWithWhereWithoutWeekPlanInput | WeekFocusUpdateManyWithWhereWithoutWeekPlanInput[]
    deleteMany?: WeekFocusScalarWhereInput | WeekFocusScalarWhereInput[]
  }

  export type MonthPlanUpdateOneRequiredWithoutWeekPlansNestedInput = {
    create?: XOR<MonthPlanCreateWithoutWeekPlansInput, MonthPlanUncheckedCreateWithoutWeekPlansInput>
    connectOrCreate?: MonthPlanCreateOrConnectWithoutWeekPlansInput
    upsert?: MonthPlanUpsertWithoutWeekPlansInput
    connect?: MonthPlanWhereUniqueInput
    update?: XOR<XOR<MonthPlanUpdateToOneWithWhereWithoutWeekPlansInput, MonthPlanUpdateWithoutWeekPlansInput>, MonthPlanUncheckedUpdateWithoutWeekPlansInput>
  }

  export type UserUpdateOneRequiredWithoutWeekPlansNestedInput = {
    create?: XOR<UserCreateWithoutWeekPlansInput, UserUncheckedCreateWithoutWeekPlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutWeekPlansInput
    upsert?: UserUpsertWithoutWeekPlansInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWeekPlansInput, UserUpdateWithoutWeekPlansInput>, UserUncheckedUpdateWithoutWeekPlansInput>
  }

  export type DayPlanUncheckedUpdateManyWithoutWeekPlanNestedInput = {
    create?: XOR<DayPlanCreateWithoutWeekPlanInput, DayPlanUncheckedCreateWithoutWeekPlanInput> | DayPlanCreateWithoutWeekPlanInput[] | DayPlanUncheckedCreateWithoutWeekPlanInput[]
    connectOrCreate?: DayPlanCreateOrConnectWithoutWeekPlanInput | DayPlanCreateOrConnectWithoutWeekPlanInput[]
    upsert?: DayPlanUpsertWithWhereUniqueWithoutWeekPlanInput | DayPlanUpsertWithWhereUniqueWithoutWeekPlanInput[]
    createMany?: DayPlanCreateManyWeekPlanInputEnvelope
    set?: DayPlanWhereUniqueInput | DayPlanWhereUniqueInput[]
    disconnect?: DayPlanWhereUniqueInput | DayPlanWhereUniqueInput[]
    delete?: DayPlanWhereUniqueInput | DayPlanWhereUniqueInput[]
    connect?: DayPlanWhereUniqueInput | DayPlanWhereUniqueInput[]
    update?: DayPlanUpdateWithWhereUniqueWithoutWeekPlanInput | DayPlanUpdateWithWhereUniqueWithoutWeekPlanInput[]
    updateMany?: DayPlanUpdateManyWithWhereWithoutWeekPlanInput | DayPlanUpdateManyWithWhereWithoutWeekPlanInput[]
    deleteMany?: DayPlanScalarWhereInput | DayPlanScalarWhereInput[]
  }

  export type WeekFocusUncheckedUpdateManyWithoutWeekPlanNestedInput = {
    create?: XOR<WeekFocusCreateWithoutWeekPlanInput, WeekFocusUncheckedCreateWithoutWeekPlanInput> | WeekFocusCreateWithoutWeekPlanInput[] | WeekFocusUncheckedCreateWithoutWeekPlanInput[]
    connectOrCreate?: WeekFocusCreateOrConnectWithoutWeekPlanInput | WeekFocusCreateOrConnectWithoutWeekPlanInput[]
    upsert?: WeekFocusUpsertWithWhereUniqueWithoutWeekPlanInput | WeekFocusUpsertWithWhereUniqueWithoutWeekPlanInput[]
    createMany?: WeekFocusCreateManyWeekPlanInputEnvelope
    set?: WeekFocusWhereUniqueInput | WeekFocusWhereUniqueInput[]
    disconnect?: WeekFocusWhereUniqueInput | WeekFocusWhereUniqueInput[]
    delete?: WeekFocusWhereUniqueInput | WeekFocusWhereUniqueInput[]
    connect?: WeekFocusWhereUniqueInput | WeekFocusWhereUniqueInput[]
    update?: WeekFocusUpdateWithWhereUniqueWithoutWeekPlanInput | WeekFocusUpdateWithWhereUniqueWithoutWeekPlanInput[]
    updateMany?: WeekFocusUpdateManyWithWhereWithoutWeekPlanInput | WeekFocusUpdateManyWithWhereWithoutWeekPlanInput[]
    deleteMany?: WeekFocusScalarWhereInput | WeekFocusScalarWhereInput[]
  }

  export type DayFocusCreateNestedManyWithoutWeekFocusInput = {
    create?: XOR<DayFocusCreateWithoutWeekFocusInput, DayFocusUncheckedCreateWithoutWeekFocusInput> | DayFocusCreateWithoutWeekFocusInput[] | DayFocusUncheckedCreateWithoutWeekFocusInput[]
    connectOrCreate?: DayFocusCreateOrConnectWithoutWeekFocusInput | DayFocusCreateOrConnectWithoutWeekFocusInput[]
    createMany?: DayFocusCreateManyWeekFocusInputEnvelope
    connect?: DayFocusWhereUniqueInput | DayFocusWhereUniqueInput[]
  }

  export type MonthFocusCreateNestedOneWithoutWeekFocusesInput = {
    create?: XOR<MonthFocusCreateWithoutWeekFocusesInput, MonthFocusUncheckedCreateWithoutWeekFocusesInput>
    connectOrCreate?: MonthFocusCreateOrConnectWithoutWeekFocusesInput
    connect?: MonthFocusWhereUniqueInput
  }

  export type WeekPlanCreateNestedOneWithoutWeekFocusesInput = {
    create?: XOR<WeekPlanCreateWithoutWeekFocusesInput, WeekPlanUncheckedCreateWithoutWeekFocusesInput>
    connectOrCreate?: WeekPlanCreateOrConnectWithoutWeekFocusesInput
    connect?: WeekPlanWhereUniqueInput
  }

  export type DayFocusUncheckedCreateNestedManyWithoutWeekFocusInput = {
    create?: XOR<DayFocusCreateWithoutWeekFocusInput, DayFocusUncheckedCreateWithoutWeekFocusInput> | DayFocusCreateWithoutWeekFocusInput[] | DayFocusUncheckedCreateWithoutWeekFocusInput[]
    connectOrCreate?: DayFocusCreateOrConnectWithoutWeekFocusInput | DayFocusCreateOrConnectWithoutWeekFocusInput[]
    createMany?: DayFocusCreateManyWeekFocusInputEnvelope
    connect?: DayFocusWhereUniqueInput | DayFocusWhereUniqueInput[]
  }

  export type DayFocusUpdateManyWithoutWeekFocusNestedInput = {
    create?: XOR<DayFocusCreateWithoutWeekFocusInput, DayFocusUncheckedCreateWithoutWeekFocusInput> | DayFocusCreateWithoutWeekFocusInput[] | DayFocusUncheckedCreateWithoutWeekFocusInput[]
    connectOrCreate?: DayFocusCreateOrConnectWithoutWeekFocusInput | DayFocusCreateOrConnectWithoutWeekFocusInput[]
    upsert?: DayFocusUpsertWithWhereUniqueWithoutWeekFocusInput | DayFocusUpsertWithWhereUniqueWithoutWeekFocusInput[]
    createMany?: DayFocusCreateManyWeekFocusInputEnvelope
    set?: DayFocusWhereUniqueInput | DayFocusWhereUniqueInput[]
    disconnect?: DayFocusWhereUniqueInput | DayFocusWhereUniqueInput[]
    delete?: DayFocusWhereUniqueInput | DayFocusWhereUniqueInput[]
    connect?: DayFocusWhereUniqueInput | DayFocusWhereUniqueInput[]
    update?: DayFocusUpdateWithWhereUniqueWithoutWeekFocusInput | DayFocusUpdateWithWhereUniqueWithoutWeekFocusInput[]
    updateMany?: DayFocusUpdateManyWithWhereWithoutWeekFocusInput | DayFocusUpdateManyWithWhereWithoutWeekFocusInput[]
    deleteMany?: DayFocusScalarWhereInput | DayFocusScalarWhereInput[]
  }

  export type MonthFocusUpdateOneRequiredWithoutWeekFocusesNestedInput = {
    create?: XOR<MonthFocusCreateWithoutWeekFocusesInput, MonthFocusUncheckedCreateWithoutWeekFocusesInput>
    connectOrCreate?: MonthFocusCreateOrConnectWithoutWeekFocusesInput
    upsert?: MonthFocusUpsertWithoutWeekFocusesInput
    connect?: MonthFocusWhereUniqueInput
    update?: XOR<XOR<MonthFocusUpdateToOneWithWhereWithoutWeekFocusesInput, MonthFocusUpdateWithoutWeekFocusesInput>, MonthFocusUncheckedUpdateWithoutWeekFocusesInput>
  }

  export type WeekPlanUpdateOneRequiredWithoutWeekFocusesNestedInput = {
    create?: XOR<WeekPlanCreateWithoutWeekFocusesInput, WeekPlanUncheckedCreateWithoutWeekFocusesInput>
    connectOrCreate?: WeekPlanCreateOrConnectWithoutWeekFocusesInput
    upsert?: WeekPlanUpsertWithoutWeekFocusesInput
    connect?: WeekPlanWhereUniqueInput
    update?: XOR<XOR<WeekPlanUpdateToOneWithWhereWithoutWeekFocusesInput, WeekPlanUpdateWithoutWeekFocusesInput>, WeekPlanUncheckedUpdateWithoutWeekFocusesInput>
  }

  export type DayFocusUncheckedUpdateManyWithoutWeekFocusNestedInput = {
    create?: XOR<DayFocusCreateWithoutWeekFocusInput, DayFocusUncheckedCreateWithoutWeekFocusInput> | DayFocusCreateWithoutWeekFocusInput[] | DayFocusUncheckedCreateWithoutWeekFocusInput[]
    connectOrCreate?: DayFocusCreateOrConnectWithoutWeekFocusInput | DayFocusCreateOrConnectWithoutWeekFocusInput[]
    upsert?: DayFocusUpsertWithWhereUniqueWithoutWeekFocusInput | DayFocusUpsertWithWhereUniqueWithoutWeekFocusInput[]
    createMany?: DayFocusCreateManyWeekFocusInputEnvelope
    set?: DayFocusWhereUniqueInput | DayFocusWhereUniqueInput[]
    disconnect?: DayFocusWhereUniqueInput | DayFocusWhereUniqueInput[]
    delete?: DayFocusWhereUniqueInput | DayFocusWhereUniqueInput[]
    connect?: DayFocusWhereUniqueInput | DayFocusWhereUniqueInput[]
    update?: DayFocusUpdateWithWhereUniqueWithoutWeekFocusInput | DayFocusUpdateWithWhereUniqueWithoutWeekFocusInput[]
    updateMany?: DayFocusUpdateManyWithWhereWithoutWeekFocusInput | DayFocusUpdateManyWithWhereWithoutWeekFocusInput[]
    deleteMany?: DayFocusScalarWhereInput | DayFocusScalarWhereInput[]
  }

  export type DayPlanCreatetopPrioritiesInput = {
    set: string[]
  }

  export type DayPlanCreategratitudeInput = {
    set: string[]
  }

  export type DayPlanCreatetomorrowPrepInput = {
    set: string[]
  }

  export type DayFocusCreateNestedManyWithoutDayPlanInput = {
    create?: XOR<DayFocusCreateWithoutDayPlanInput, DayFocusUncheckedCreateWithoutDayPlanInput> | DayFocusCreateWithoutDayPlanInput[] | DayFocusUncheckedCreateWithoutDayPlanInput[]
    connectOrCreate?: DayFocusCreateOrConnectWithoutDayPlanInput | DayFocusCreateOrConnectWithoutDayPlanInput[]
    createMany?: DayFocusCreateManyDayPlanInputEnvelope
    connect?: DayFocusWhereUniqueInput | DayFocusWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutDayPlansInput = {
    create?: XOR<UserCreateWithoutDayPlansInput, UserUncheckedCreateWithoutDayPlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutDayPlansInput
    connect?: UserWhereUniqueInput
  }

  export type WeekPlanCreateNestedOneWithoutDayPlansInput = {
    create?: XOR<WeekPlanCreateWithoutDayPlansInput, WeekPlanUncheckedCreateWithoutDayPlansInput>
    connectOrCreate?: WeekPlanCreateOrConnectWithoutDayPlansInput
    connect?: WeekPlanWhereUniqueInput
  }

  export type NoteCreateNestedManyWithoutDayPlanInput = {
    create?: XOR<NoteCreateWithoutDayPlanInput, NoteUncheckedCreateWithoutDayPlanInput> | NoteCreateWithoutDayPlanInput[] | NoteUncheckedCreateWithoutDayPlanInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutDayPlanInput | NoteCreateOrConnectWithoutDayPlanInput[]
    createMany?: NoteCreateManyDayPlanInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type TimeBlockCreateNestedManyWithoutDayPlanInput = {
    create?: XOR<TimeBlockCreateWithoutDayPlanInput, TimeBlockUncheckedCreateWithoutDayPlanInput> | TimeBlockCreateWithoutDayPlanInput[] | TimeBlockUncheckedCreateWithoutDayPlanInput[]
    connectOrCreate?: TimeBlockCreateOrConnectWithoutDayPlanInput | TimeBlockCreateOrConnectWithoutDayPlanInput[]
    createMany?: TimeBlockCreateManyDayPlanInputEnvelope
    connect?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
  }

  export type DayFocusUncheckedCreateNestedManyWithoutDayPlanInput = {
    create?: XOR<DayFocusCreateWithoutDayPlanInput, DayFocusUncheckedCreateWithoutDayPlanInput> | DayFocusCreateWithoutDayPlanInput[] | DayFocusUncheckedCreateWithoutDayPlanInput[]
    connectOrCreate?: DayFocusCreateOrConnectWithoutDayPlanInput | DayFocusCreateOrConnectWithoutDayPlanInput[]
    createMany?: DayFocusCreateManyDayPlanInputEnvelope
    connect?: DayFocusWhereUniqueInput | DayFocusWhereUniqueInput[]
  }

  export type NoteUncheckedCreateNestedManyWithoutDayPlanInput = {
    create?: XOR<NoteCreateWithoutDayPlanInput, NoteUncheckedCreateWithoutDayPlanInput> | NoteCreateWithoutDayPlanInput[] | NoteUncheckedCreateWithoutDayPlanInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutDayPlanInput | NoteCreateOrConnectWithoutDayPlanInput[]
    createMany?: NoteCreateManyDayPlanInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type TimeBlockUncheckedCreateNestedManyWithoutDayPlanInput = {
    create?: XOR<TimeBlockCreateWithoutDayPlanInput, TimeBlockUncheckedCreateWithoutDayPlanInput> | TimeBlockCreateWithoutDayPlanInput[] | TimeBlockUncheckedCreateWithoutDayPlanInput[]
    connectOrCreate?: TimeBlockCreateOrConnectWithoutDayPlanInput | TimeBlockCreateOrConnectWithoutDayPlanInput[]
    createMany?: TimeBlockCreateManyDayPlanInputEnvelope
    connect?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
  }

  export type DayPlanUpdatetopPrioritiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DayPlanUpdategratitudeInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DayPlanUpdatetomorrowPrepInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DayFocusUpdateManyWithoutDayPlanNestedInput = {
    create?: XOR<DayFocusCreateWithoutDayPlanInput, DayFocusUncheckedCreateWithoutDayPlanInput> | DayFocusCreateWithoutDayPlanInput[] | DayFocusUncheckedCreateWithoutDayPlanInput[]
    connectOrCreate?: DayFocusCreateOrConnectWithoutDayPlanInput | DayFocusCreateOrConnectWithoutDayPlanInput[]
    upsert?: DayFocusUpsertWithWhereUniqueWithoutDayPlanInput | DayFocusUpsertWithWhereUniqueWithoutDayPlanInput[]
    createMany?: DayFocusCreateManyDayPlanInputEnvelope
    set?: DayFocusWhereUniqueInput | DayFocusWhereUniqueInput[]
    disconnect?: DayFocusWhereUniqueInput | DayFocusWhereUniqueInput[]
    delete?: DayFocusWhereUniqueInput | DayFocusWhereUniqueInput[]
    connect?: DayFocusWhereUniqueInput | DayFocusWhereUniqueInput[]
    update?: DayFocusUpdateWithWhereUniqueWithoutDayPlanInput | DayFocusUpdateWithWhereUniqueWithoutDayPlanInput[]
    updateMany?: DayFocusUpdateManyWithWhereWithoutDayPlanInput | DayFocusUpdateManyWithWhereWithoutDayPlanInput[]
    deleteMany?: DayFocusScalarWhereInput | DayFocusScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutDayPlansNestedInput = {
    create?: XOR<UserCreateWithoutDayPlansInput, UserUncheckedCreateWithoutDayPlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutDayPlansInput
    upsert?: UserUpsertWithoutDayPlansInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDayPlansInput, UserUpdateWithoutDayPlansInput>, UserUncheckedUpdateWithoutDayPlansInput>
  }

  export type WeekPlanUpdateOneRequiredWithoutDayPlansNestedInput = {
    create?: XOR<WeekPlanCreateWithoutDayPlansInput, WeekPlanUncheckedCreateWithoutDayPlansInput>
    connectOrCreate?: WeekPlanCreateOrConnectWithoutDayPlansInput
    upsert?: WeekPlanUpsertWithoutDayPlansInput
    connect?: WeekPlanWhereUniqueInput
    update?: XOR<XOR<WeekPlanUpdateToOneWithWhereWithoutDayPlansInput, WeekPlanUpdateWithoutDayPlansInput>, WeekPlanUncheckedUpdateWithoutDayPlansInput>
  }

  export type NoteUpdateManyWithoutDayPlanNestedInput = {
    create?: XOR<NoteCreateWithoutDayPlanInput, NoteUncheckedCreateWithoutDayPlanInput> | NoteCreateWithoutDayPlanInput[] | NoteUncheckedCreateWithoutDayPlanInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutDayPlanInput | NoteCreateOrConnectWithoutDayPlanInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutDayPlanInput | NoteUpsertWithWhereUniqueWithoutDayPlanInput[]
    createMany?: NoteCreateManyDayPlanInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutDayPlanInput | NoteUpdateWithWhereUniqueWithoutDayPlanInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutDayPlanInput | NoteUpdateManyWithWhereWithoutDayPlanInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type TimeBlockUpdateManyWithoutDayPlanNestedInput = {
    create?: XOR<TimeBlockCreateWithoutDayPlanInput, TimeBlockUncheckedCreateWithoutDayPlanInput> | TimeBlockCreateWithoutDayPlanInput[] | TimeBlockUncheckedCreateWithoutDayPlanInput[]
    connectOrCreate?: TimeBlockCreateOrConnectWithoutDayPlanInput | TimeBlockCreateOrConnectWithoutDayPlanInput[]
    upsert?: TimeBlockUpsertWithWhereUniqueWithoutDayPlanInput | TimeBlockUpsertWithWhereUniqueWithoutDayPlanInput[]
    createMany?: TimeBlockCreateManyDayPlanInputEnvelope
    set?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    disconnect?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    delete?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    connect?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    update?: TimeBlockUpdateWithWhereUniqueWithoutDayPlanInput | TimeBlockUpdateWithWhereUniqueWithoutDayPlanInput[]
    updateMany?: TimeBlockUpdateManyWithWhereWithoutDayPlanInput | TimeBlockUpdateManyWithWhereWithoutDayPlanInput[]
    deleteMany?: TimeBlockScalarWhereInput | TimeBlockScalarWhereInput[]
  }

  export type DayFocusUncheckedUpdateManyWithoutDayPlanNestedInput = {
    create?: XOR<DayFocusCreateWithoutDayPlanInput, DayFocusUncheckedCreateWithoutDayPlanInput> | DayFocusCreateWithoutDayPlanInput[] | DayFocusUncheckedCreateWithoutDayPlanInput[]
    connectOrCreate?: DayFocusCreateOrConnectWithoutDayPlanInput | DayFocusCreateOrConnectWithoutDayPlanInput[]
    upsert?: DayFocusUpsertWithWhereUniqueWithoutDayPlanInput | DayFocusUpsertWithWhereUniqueWithoutDayPlanInput[]
    createMany?: DayFocusCreateManyDayPlanInputEnvelope
    set?: DayFocusWhereUniqueInput | DayFocusWhereUniqueInput[]
    disconnect?: DayFocusWhereUniqueInput | DayFocusWhereUniqueInput[]
    delete?: DayFocusWhereUniqueInput | DayFocusWhereUniqueInput[]
    connect?: DayFocusWhereUniqueInput | DayFocusWhereUniqueInput[]
    update?: DayFocusUpdateWithWhereUniqueWithoutDayPlanInput | DayFocusUpdateWithWhereUniqueWithoutDayPlanInput[]
    updateMany?: DayFocusUpdateManyWithWhereWithoutDayPlanInput | DayFocusUpdateManyWithWhereWithoutDayPlanInput[]
    deleteMany?: DayFocusScalarWhereInput | DayFocusScalarWhereInput[]
  }

  export type NoteUncheckedUpdateManyWithoutDayPlanNestedInput = {
    create?: XOR<NoteCreateWithoutDayPlanInput, NoteUncheckedCreateWithoutDayPlanInput> | NoteCreateWithoutDayPlanInput[] | NoteUncheckedCreateWithoutDayPlanInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutDayPlanInput | NoteCreateOrConnectWithoutDayPlanInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutDayPlanInput | NoteUpsertWithWhereUniqueWithoutDayPlanInput[]
    createMany?: NoteCreateManyDayPlanInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutDayPlanInput | NoteUpdateWithWhereUniqueWithoutDayPlanInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutDayPlanInput | NoteUpdateManyWithWhereWithoutDayPlanInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type TimeBlockUncheckedUpdateManyWithoutDayPlanNestedInput = {
    create?: XOR<TimeBlockCreateWithoutDayPlanInput, TimeBlockUncheckedCreateWithoutDayPlanInput> | TimeBlockCreateWithoutDayPlanInput[] | TimeBlockUncheckedCreateWithoutDayPlanInput[]
    connectOrCreate?: TimeBlockCreateOrConnectWithoutDayPlanInput | TimeBlockCreateOrConnectWithoutDayPlanInput[]
    upsert?: TimeBlockUpsertWithWhereUniqueWithoutDayPlanInput | TimeBlockUpsertWithWhereUniqueWithoutDayPlanInput[]
    createMany?: TimeBlockCreateManyDayPlanInputEnvelope
    set?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    disconnect?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    delete?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    connect?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    update?: TimeBlockUpdateWithWhereUniqueWithoutDayPlanInput | TimeBlockUpdateWithWhereUniqueWithoutDayPlanInput[]
    updateMany?: TimeBlockUpdateManyWithWhereWithoutDayPlanInput | TimeBlockUpdateManyWithWhereWithoutDayPlanInput[]
    deleteMany?: TimeBlockScalarWhereInput | TimeBlockScalarWhereInput[]
  }

  export type DayPlanCreateNestedOneWithoutDayFocusesInput = {
    create?: XOR<DayPlanCreateWithoutDayFocusesInput, DayPlanUncheckedCreateWithoutDayFocusesInput>
    connectOrCreate?: DayPlanCreateOrConnectWithoutDayFocusesInput
    connect?: DayPlanWhereUniqueInput
  }

  export type WeekFocusCreateNestedOneWithoutDayFocusesInput = {
    create?: XOR<WeekFocusCreateWithoutDayFocusesInput, WeekFocusUncheckedCreateWithoutDayFocusesInput>
    connectOrCreate?: WeekFocusCreateOrConnectWithoutDayFocusesInput
    connect?: WeekFocusWhereUniqueInput
  }

  export type DayPlanUpdateOneRequiredWithoutDayFocusesNestedInput = {
    create?: XOR<DayPlanCreateWithoutDayFocusesInput, DayPlanUncheckedCreateWithoutDayFocusesInput>
    connectOrCreate?: DayPlanCreateOrConnectWithoutDayFocusesInput
    upsert?: DayPlanUpsertWithoutDayFocusesInput
    connect?: DayPlanWhereUniqueInput
    update?: XOR<XOR<DayPlanUpdateToOneWithWhereWithoutDayFocusesInput, DayPlanUpdateWithoutDayFocusesInput>, DayPlanUncheckedUpdateWithoutDayFocusesInput>
  }

  export type WeekFocusUpdateOneRequiredWithoutDayFocusesNestedInput = {
    create?: XOR<WeekFocusCreateWithoutDayFocusesInput, WeekFocusUncheckedCreateWithoutDayFocusesInput>
    connectOrCreate?: WeekFocusCreateOrConnectWithoutDayFocusesInput
    upsert?: WeekFocusUpsertWithoutDayFocusesInput
    connect?: WeekFocusWhereUniqueInput
    update?: XOR<XOR<WeekFocusUpdateToOneWithWhereWithoutDayFocusesInput, WeekFocusUpdateWithoutDayFocusesInput>, WeekFocusUncheckedUpdateWithoutDayFocusesInput>
  }

  export type ClientCreateNestedOneWithoutTimeBlocksInput = {
    create?: XOR<ClientCreateWithoutTimeBlocksInput, ClientUncheckedCreateWithoutTimeBlocksInput>
    connectOrCreate?: ClientCreateOrConnectWithoutTimeBlocksInput
    connect?: ClientWhereUniqueInput
  }

  export type DayPlanCreateNestedOneWithoutTimeBlocksInput = {
    create?: XOR<DayPlanCreateWithoutTimeBlocksInput, DayPlanUncheckedCreateWithoutTimeBlocksInput>
    connectOrCreate?: DayPlanCreateOrConnectWithoutTimeBlocksInput
    connect?: DayPlanWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutTimeBlocksInput = {
    create?: XOR<ProjectCreateWithoutTimeBlocksInput, ProjectUncheckedCreateWithoutTimeBlocksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTimeBlocksInput
    connect?: ProjectWhereUniqueInput
  }

  export type TaskCreateNestedOneWithoutTimeBlocksInput = {
    create?: XOR<TaskCreateWithoutTimeBlocksInput, TaskUncheckedCreateWithoutTimeBlocksInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTimeBlocksInput
    connect?: TaskWhereUniqueInput
  }

  export type ClientUpdateOneWithoutTimeBlocksNestedInput = {
    create?: XOR<ClientCreateWithoutTimeBlocksInput, ClientUncheckedCreateWithoutTimeBlocksInput>
    connectOrCreate?: ClientCreateOrConnectWithoutTimeBlocksInput
    upsert?: ClientUpsertWithoutTimeBlocksInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutTimeBlocksInput, ClientUpdateWithoutTimeBlocksInput>, ClientUncheckedUpdateWithoutTimeBlocksInput>
  }

  export type DayPlanUpdateOneRequiredWithoutTimeBlocksNestedInput = {
    create?: XOR<DayPlanCreateWithoutTimeBlocksInput, DayPlanUncheckedCreateWithoutTimeBlocksInput>
    connectOrCreate?: DayPlanCreateOrConnectWithoutTimeBlocksInput
    upsert?: DayPlanUpsertWithoutTimeBlocksInput
    connect?: DayPlanWhereUniqueInput
    update?: XOR<XOR<DayPlanUpdateToOneWithWhereWithoutTimeBlocksInput, DayPlanUpdateWithoutTimeBlocksInput>, DayPlanUncheckedUpdateWithoutTimeBlocksInput>
  }

  export type ProjectUpdateOneWithoutTimeBlocksNestedInput = {
    create?: XOR<ProjectCreateWithoutTimeBlocksInput, ProjectUncheckedCreateWithoutTimeBlocksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTimeBlocksInput
    upsert?: ProjectUpsertWithoutTimeBlocksInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTimeBlocksInput, ProjectUpdateWithoutTimeBlocksInput>, ProjectUncheckedUpdateWithoutTimeBlocksInput>
  }

  export type TaskUpdateOneWithoutTimeBlocksNestedInput = {
    create?: XOR<TaskCreateWithoutTimeBlocksInput, TaskUncheckedCreateWithoutTimeBlocksInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTimeBlocksInput
    upsert?: TaskUpsertWithoutTimeBlocksInput
    disconnect?: TaskWhereInput | boolean
    delete?: TaskWhereInput | boolean
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutTimeBlocksInput, TaskUpdateWithoutTimeBlocksInput>, TaskUncheckedUpdateWithoutTimeBlocksInput>
  }

  export type ProjectCreatetagsInput = {
    set: string[]
  }

  export type ClientCreateNestedOneWithoutProjectsInput = {
    create?: XOR<ClientCreateWithoutProjectsInput, ClientUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutProjectsInput
    connect?: ClientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProjectsInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type TaskCreateNestedManyWithoutProjectInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TimeBlockCreateNestedManyWithoutProjectInput = {
    create?: XOR<TimeBlockCreateWithoutProjectInput, TimeBlockUncheckedCreateWithoutProjectInput> | TimeBlockCreateWithoutProjectInput[] | TimeBlockUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TimeBlockCreateOrConnectWithoutProjectInput | TimeBlockCreateOrConnectWithoutProjectInput[]
    createMany?: TimeBlockCreateManyProjectInputEnvelope
    connect?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
  }

  export type TimeEntryCreateNestedManyWithoutProjectInput = {
    create?: XOR<TimeEntryCreateWithoutProjectInput, TimeEntryUncheckedCreateWithoutProjectInput> | TimeEntryCreateWithoutProjectInput[] | TimeEntryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutProjectInput | TimeEntryCreateOrConnectWithoutProjectInput[]
    createMany?: TimeEntryCreateManyProjectInputEnvelope
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TimeBlockUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<TimeBlockCreateWithoutProjectInput, TimeBlockUncheckedCreateWithoutProjectInput> | TimeBlockCreateWithoutProjectInput[] | TimeBlockUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TimeBlockCreateOrConnectWithoutProjectInput | TimeBlockCreateOrConnectWithoutProjectInput[]
    createMany?: TimeBlockCreateManyProjectInputEnvelope
    connect?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
  }

  export type TimeEntryUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<TimeEntryCreateWithoutProjectInput, TimeEntryUncheckedCreateWithoutProjectInput> | TimeEntryCreateWithoutProjectInput[] | TimeEntryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutProjectInput | TimeEntryCreateOrConnectWithoutProjectInput[]
    createMany?: TimeEntryCreateManyProjectInputEnvelope
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
  }

  export type ProjectUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ClientUpdateOneWithoutProjectsNestedInput = {
    create?: XOR<ClientCreateWithoutProjectsInput, ClientUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutProjectsInput
    upsert?: ClientUpsertWithoutProjectsInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutProjectsInput, ClientUpdateWithoutProjectsInput>, ClientUncheckedUpdateWithoutProjectsInput>
  }

  export type UserUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    upsert?: UserUpsertWithoutProjectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectsInput, UserUpdateWithoutProjectsInput>, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type TaskUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutProjectInput | TaskUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutProjectInput | TaskUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutProjectInput | TaskUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TimeBlockUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TimeBlockCreateWithoutProjectInput, TimeBlockUncheckedCreateWithoutProjectInput> | TimeBlockCreateWithoutProjectInput[] | TimeBlockUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TimeBlockCreateOrConnectWithoutProjectInput | TimeBlockCreateOrConnectWithoutProjectInput[]
    upsert?: TimeBlockUpsertWithWhereUniqueWithoutProjectInput | TimeBlockUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TimeBlockCreateManyProjectInputEnvelope
    set?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    disconnect?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    delete?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    connect?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    update?: TimeBlockUpdateWithWhereUniqueWithoutProjectInput | TimeBlockUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TimeBlockUpdateManyWithWhereWithoutProjectInput | TimeBlockUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TimeBlockScalarWhereInput | TimeBlockScalarWhereInput[]
  }

  export type TimeEntryUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TimeEntryCreateWithoutProjectInput, TimeEntryUncheckedCreateWithoutProjectInput> | TimeEntryCreateWithoutProjectInput[] | TimeEntryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutProjectInput | TimeEntryCreateOrConnectWithoutProjectInput[]
    upsert?: TimeEntryUpsertWithWhereUniqueWithoutProjectInput | TimeEntryUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TimeEntryCreateManyProjectInputEnvelope
    set?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    disconnect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    delete?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    update?: TimeEntryUpdateWithWhereUniqueWithoutProjectInput | TimeEntryUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TimeEntryUpdateManyWithWhereWithoutProjectInput | TimeEntryUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TimeEntryScalarWhereInput | TimeEntryScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutProjectInput | TaskUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutProjectInput | TaskUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutProjectInput | TaskUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TimeBlockUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TimeBlockCreateWithoutProjectInput, TimeBlockUncheckedCreateWithoutProjectInput> | TimeBlockCreateWithoutProjectInput[] | TimeBlockUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TimeBlockCreateOrConnectWithoutProjectInput | TimeBlockCreateOrConnectWithoutProjectInput[]
    upsert?: TimeBlockUpsertWithWhereUniqueWithoutProjectInput | TimeBlockUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TimeBlockCreateManyProjectInputEnvelope
    set?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    disconnect?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    delete?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    connect?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    update?: TimeBlockUpdateWithWhereUniqueWithoutProjectInput | TimeBlockUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TimeBlockUpdateManyWithWhereWithoutProjectInput | TimeBlockUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TimeBlockScalarWhereInput | TimeBlockScalarWhereInput[]
  }

  export type TimeEntryUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TimeEntryCreateWithoutProjectInput, TimeEntryUncheckedCreateWithoutProjectInput> | TimeEntryCreateWithoutProjectInput[] | TimeEntryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutProjectInput | TimeEntryCreateOrConnectWithoutProjectInput[]
    upsert?: TimeEntryUpsertWithWhereUniqueWithoutProjectInput | TimeEntryUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TimeEntryCreateManyProjectInputEnvelope
    set?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    disconnect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    delete?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    update?: TimeEntryUpdateWithWhereUniqueWithoutProjectInput | TimeEntryUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TimeEntryUpdateManyWithWhereWithoutProjectInput | TimeEntryUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TimeEntryScalarWhereInput | TimeEntryScalarWhereInput[]
  }

  export type TaskCreatetagsInput = {
    set: string[]
  }

  export type TaskCreatedependsOnInput = {
    set: string[]
  }

  export type TaskCreateblocksInput = {
    set: string[]
  }

  export type ActionItemCreateNestedOneWithoutConvertedToTaskInput = {
    create?: XOR<ActionItemCreateWithoutConvertedToTaskInput, ActionItemUncheckedCreateWithoutConvertedToTaskInput>
    connectOrCreate?: ActionItemCreateOrConnectWithoutConvertedToTaskInput
    connect?: ActionItemWhereUniqueInput
  }

  export type GoalCreateNestedOneWithoutTasksInput = {
    create?: XOR<GoalCreateWithoutTasksInput, GoalUncheckedCreateWithoutTasksInput>
    connectOrCreate?: GoalCreateOrConnectWithoutTasksInput
    connect?: GoalWhereUniqueInput
  }

  export type KeyStepCreateNestedOneWithoutTasksInput = {
    create?: XOR<KeyStepCreateWithoutTasksInput, KeyStepUncheckedCreateWithoutTasksInput>
    connectOrCreate?: KeyStepCreateOrConnectWithoutTasksInput
    connect?: KeyStepWhereUniqueInput
  }

  export type MeetingCreateNestedOneWithoutTasksInput = {
    create?: XOR<MeetingCreateWithoutTasksInput, MeetingUncheckedCreateWithoutTasksInput>
    connectOrCreate?: MeetingCreateOrConnectWithoutTasksInput
    connect?: MeetingWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutTasksInput = {
    create?: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTasksInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTasksInput = {
    create?: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksInput
    connect?: UserWhereUniqueInput
  }

  export type TimeBlockCreateNestedManyWithoutTaskInput = {
    create?: XOR<TimeBlockCreateWithoutTaskInput, TimeBlockUncheckedCreateWithoutTaskInput> | TimeBlockCreateWithoutTaskInput[] | TimeBlockUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TimeBlockCreateOrConnectWithoutTaskInput | TimeBlockCreateOrConnectWithoutTaskInput[]
    createMany?: TimeBlockCreateManyTaskInputEnvelope
    connect?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
  }

  export type TimeEntryCreateNestedManyWithoutTaskInput = {
    create?: XOR<TimeEntryCreateWithoutTaskInput, TimeEntryUncheckedCreateWithoutTaskInput> | TimeEntryCreateWithoutTaskInput[] | TimeEntryUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutTaskInput | TimeEntryCreateOrConnectWithoutTaskInput[]
    createMany?: TimeEntryCreateManyTaskInputEnvelope
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
  }

  export type ActionItemUncheckedCreateNestedOneWithoutConvertedToTaskInput = {
    create?: XOR<ActionItemCreateWithoutConvertedToTaskInput, ActionItemUncheckedCreateWithoutConvertedToTaskInput>
    connectOrCreate?: ActionItemCreateOrConnectWithoutConvertedToTaskInput
    connect?: ActionItemWhereUniqueInput
  }

  export type TimeBlockUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TimeBlockCreateWithoutTaskInput, TimeBlockUncheckedCreateWithoutTaskInput> | TimeBlockCreateWithoutTaskInput[] | TimeBlockUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TimeBlockCreateOrConnectWithoutTaskInput | TimeBlockCreateOrConnectWithoutTaskInput[]
    createMany?: TimeBlockCreateManyTaskInputEnvelope
    connect?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
  }

  export type TimeEntryUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TimeEntryCreateWithoutTaskInput, TimeEntryUncheckedCreateWithoutTaskInput> | TimeEntryCreateWithoutTaskInput[] | TimeEntryUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutTaskInput | TimeEntryCreateOrConnectWithoutTaskInput[]
    createMany?: TimeEntryCreateManyTaskInputEnvelope
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
  }

  export type TaskUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TaskUpdatedependsOnInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TaskUpdateblocksInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ActionItemUpdateOneWithoutConvertedToTaskNestedInput = {
    create?: XOR<ActionItemCreateWithoutConvertedToTaskInput, ActionItemUncheckedCreateWithoutConvertedToTaskInput>
    connectOrCreate?: ActionItemCreateOrConnectWithoutConvertedToTaskInput
    upsert?: ActionItemUpsertWithoutConvertedToTaskInput
    disconnect?: ActionItemWhereInput | boolean
    delete?: ActionItemWhereInput | boolean
    connect?: ActionItemWhereUniqueInput
    update?: XOR<XOR<ActionItemUpdateToOneWithWhereWithoutConvertedToTaskInput, ActionItemUpdateWithoutConvertedToTaskInput>, ActionItemUncheckedUpdateWithoutConvertedToTaskInput>
  }

  export type GoalUpdateOneWithoutTasksNestedInput = {
    create?: XOR<GoalCreateWithoutTasksInput, GoalUncheckedCreateWithoutTasksInput>
    connectOrCreate?: GoalCreateOrConnectWithoutTasksInput
    upsert?: GoalUpsertWithoutTasksInput
    disconnect?: GoalWhereInput | boolean
    delete?: GoalWhereInput | boolean
    connect?: GoalWhereUniqueInput
    update?: XOR<XOR<GoalUpdateToOneWithWhereWithoutTasksInput, GoalUpdateWithoutTasksInput>, GoalUncheckedUpdateWithoutTasksInput>
  }

  export type KeyStepUpdateOneWithoutTasksNestedInput = {
    create?: XOR<KeyStepCreateWithoutTasksInput, KeyStepUncheckedCreateWithoutTasksInput>
    connectOrCreate?: KeyStepCreateOrConnectWithoutTasksInput
    upsert?: KeyStepUpsertWithoutTasksInput
    disconnect?: KeyStepWhereInput | boolean
    delete?: KeyStepWhereInput | boolean
    connect?: KeyStepWhereUniqueInput
    update?: XOR<XOR<KeyStepUpdateToOneWithWhereWithoutTasksInput, KeyStepUpdateWithoutTasksInput>, KeyStepUncheckedUpdateWithoutTasksInput>
  }

  export type MeetingUpdateOneWithoutTasksNestedInput = {
    create?: XOR<MeetingCreateWithoutTasksInput, MeetingUncheckedCreateWithoutTasksInput>
    connectOrCreate?: MeetingCreateOrConnectWithoutTasksInput
    upsert?: MeetingUpsertWithoutTasksInput
    disconnect?: MeetingWhereInput | boolean
    delete?: MeetingWhereInput | boolean
    connect?: MeetingWhereUniqueInput
    update?: XOR<XOR<MeetingUpdateToOneWithWhereWithoutTasksInput, MeetingUpdateWithoutTasksInput>, MeetingUncheckedUpdateWithoutTasksInput>
  }

  export type ProjectUpdateOneWithoutTasksNestedInput = {
    create?: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTasksInput
    upsert?: ProjectUpsertWithoutTasksInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTasksInput, ProjectUpdateWithoutTasksInput>, ProjectUncheckedUpdateWithoutTasksInput>
  }

  export type UserUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksInput
    upsert?: UserUpsertWithoutTasksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTasksInput, UserUpdateWithoutTasksInput>, UserUncheckedUpdateWithoutTasksInput>
  }

  export type TimeBlockUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TimeBlockCreateWithoutTaskInput, TimeBlockUncheckedCreateWithoutTaskInput> | TimeBlockCreateWithoutTaskInput[] | TimeBlockUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TimeBlockCreateOrConnectWithoutTaskInput | TimeBlockCreateOrConnectWithoutTaskInput[]
    upsert?: TimeBlockUpsertWithWhereUniqueWithoutTaskInput | TimeBlockUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TimeBlockCreateManyTaskInputEnvelope
    set?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    disconnect?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    delete?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    connect?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    update?: TimeBlockUpdateWithWhereUniqueWithoutTaskInput | TimeBlockUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TimeBlockUpdateManyWithWhereWithoutTaskInput | TimeBlockUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TimeBlockScalarWhereInput | TimeBlockScalarWhereInput[]
  }

  export type TimeEntryUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TimeEntryCreateWithoutTaskInput, TimeEntryUncheckedCreateWithoutTaskInput> | TimeEntryCreateWithoutTaskInput[] | TimeEntryUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutTaskInput | TimeEntryCreateOrConnectWithoutTaskInput[]
    upsert?: TimeEntryUpsertWithWhereUniqueWithoutTaskInput | TimeEntryUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TimeEntryCreateManyTaskInputEnvelope
    set?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    disconnect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    delete?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    update?: TimeEntryUpdateWithWhereUniqueWithoutTaskInput | TimeEntryUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TimeEntryUpdateManyWithWhereWithoutTaskInput | TimeEntryUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TimeEntryScalarWhereInput | TimeEntryScalarWhereInput[]
  }

  export type ActionItemUncheckedUpdateOneWithoutConvertedToTaskNestedInput = {
    create?: XOR<ActionItemCreateWithoutConvertedToTaskInput, ActionItemUncheckedCreateWithoutConvertedToTaskInput>
    connectOrCreate?: ActionItemCreateOrConnectWithoutConvertedToTaskInput
    upsert?: ActionItemUpsertWithoutConvertedToTaskInput
    disconnect?: ActionItemWhereInput | boolean
    delete?: ActionItemWhereInput | boolean
    connect?: ActionItemWhereUniqueInput
    update?: XOR<XOR<ActionItemUpdateToOneWithWhereWithoutConvertedToTaskInput, ActionItemUpdateWithoutConvertedToTaskInput>, ActionItemUncheckedUpdateWithoutConvertedToTaskInput>
  }

  export type TimeBlockUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TimeBlockCreateWithoutTaskInput, TimeBlockUncheckedCreateWithoutTaskInput> | TimeBlockCreateWithoutTaskInput[] | TimeBlockUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TimeBlockCreateOrConnectWithoutTaskInput | TimeBlockCreateOrConnectWithoutTaskInput[]
    upsert?: TimeBlockUpsertWithWhereUniqueWithoutTaskInput | TimeBlockUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TimeBlockCreateManyTaskInputEnvelope
    set?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    disconnect?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    delete?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    connect?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    update?: TimeBlockUpdateWithWhereUniqueWithoutTaskInput | TimeBlockUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TimeBlockUpdateManyWithWhereWithoutTaskInput | TimeBlockUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TimeBlockScalarWhereInput | TimeBlockScalarWhereInput[]
  }

  export type TimeEntryUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TimeEntryCreateWithoutTaskInput, TimeEntryUncheckedCreateWithoutTaskInput> | TimeEntryCreateWithoutTaskInput[] | TimeEntryUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutTaskInput | TimeEntryCreateOrConnectWithoutTaskInput[]
    upsert?: TimeEntryUpsertWithWhereUniqueWithoutTaskInput | TimeEntryUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TimeEntryCreateManyTaskInputEnvelope
    set?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    disconnect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    delete?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    update?: TimeEntryUpdateWithWhereUniqueWithoutTaskInput | TimeEntryUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TimeEntryUpdateManyWithWhereWithoutTaskInput | TimeEntryUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TimeEntryScalarWhereInput | TimeEntryScalarWhereInput[]
  }

  export type TimeEntryCreatetagsInput = {
    set: string[]
  }

  export type ClientCreateNestedOneWithoutTimeEntriesInput = {
    create?: XOR<ClientCreateWithoutTimeEntriesInput, ClientUncheckedCreateWithoutTimeEntriesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutTimeEntriesInput
    connect?: ClientWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutTimeEntriesInput = {
    create?: XOR<ProjectCreateWithoutTimeEntriesInput, ProjectUncheckedCreateWithoutTimeEntriesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTimeEntriesInput
    connect?: ProjectWhereUniqueInput
  }

  export type TaskCreateNestedOneWithoutTimeEntriesInput = {
    create?: XOR<TaskCreateWithoutTimeEntriesInput, TaskUncheckedCreateWithoutTimeEntriesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTimeEntriesInput
    connect?: TaskWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTimeEntriesInput = {
    create?: XOR<UserCreateWithoutTimeEntriesInput, UserUncheckedCreateWithoutTimeEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTimeEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type TimeEntryUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ClientUpdateOneWithoutTimeEntriesNestedInput = {
    create?: XOR<ClientCreateWithoutTimeEntriesInput, ClientUncheckedCreateWithoutTimeEntriesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutTimeEntriesInput
    upsert?: ClientUpsertWithoutTimeEntriesInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutTimeEntriesInput, ClientUpdateWithoutTimeEntriesInput>, ClientUncheckedUpdateWithoutTimeEntriesInput>
  }

  export type ProjectUpdateOneWithoutTimeEntriesNestedInput = {
    create?: XOR<ProjectCreateWithoutTimeEntriesInput, ProjectUncheckedCreateWithoutTimeEntriesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTimeEntriesInput
    upsert?: ProjectUpsertWithoutTimeEntriesInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTimeEntriesInput, ProjectUpdateWithoutTimeEntriesInput>, ProjectUncheckedUpdateWithoutTimeEntriesInput>
  }

  export type TaskUpdateOneWithoutTimeEntriesNestedInput = {
    create?: XOR<TaskCreateWithoutTimeEntriesInput, TaskUncheckedCreateWithoutTimeEntriesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTimeEntriesInput
    upsert?: TaskUpsertWithoutTimeEntriesInput
    disconnect?: TaskWhereInput | boolean
    delete?: TaskWhereInput | boolean
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutTimeEntriesInput, TaskUpdateWithoutTimeEntriesInput>, TaskUncheckedUpdateWithoutTimeEntriesInput>
  }

  export type UserUpdateOneRequiredWithoutTimeEntriesNestedInput = {
    create?: XOR<UserCreateWithoutTimeEntriesInput, UserUncheckedCreateWithoutTimeEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTimeEntriesInput
    upsert?: UserUpsertWithoutTimeEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTimeEntriesInput, UserUpdateWithoutTimeEntriesInput>, UserUncheckedUpdateWithoutTimeEntriesInput>
  }

  export type ClientCreateadditionalContactsInput = {
    set: InputJsonValue[]
  }

  export type ClientCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutClientsInput = {
    create?: XOR<UserCreateWithoutClientsInput, UserUncheckedCreateWithoutClientsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientsInput
    connect?: UserWhereUniqueInput
  }

  export type CommunicationCreateNestedManyWithoutClientInput = {
    create?: XOR<CommunicationCreateWithoutClientInput, CommunicationUncheckedCreateWithoutClientInput> | CommunicationCreateWithoutClientInput[] | CommunicationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutClientInput | CommunicationCreateOrConnectWithoutClientInput[]
    createMany?: CommunicationCreateManyClientInputEnvelope
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
  }

  export type MeetingCreateNestedManyWithoutClientInput = {
    create?: XOR<MeetingCreateWithoutClientInput, MeetingUncheckedCreateWithoutClientInput> | MeetingCreateWithoutClientInput[] | MeetingUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutClientInput | MeetingCreateOrConnectWithoutClientInput[]
    createMany?: MeetingCreateManyClientInputEnvelope
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutClientInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type TimeBlockCreateNestedManyWithoutClientInput = {
    create?: XOR<TimeBlockCreateWithoutClientInput, TimeBlockUncheckedCreateWithoutClientInput> | TimeBlockCreateWithoutClientInput[] | TimeBlockUncheckedCreateWithoutClientInput[]
    connectOrCreate?: TimeBlockCreateOrConnectWithoutClientInput | TimeBlockCreateOrConnectWithoutClientInput[]
    createMany?: TimeBlockCreateManyClientInputEnvelope
    connect?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
  }

  export type TimeEntryCreateNestedManyWithoutClientInput = {
    create?: XOR<TimeEntryCreateWithoutClientInput, TimeEntryUncheckedCreateWithoutClientInput> | TimeEntryCreateWithoutClientInput[] | TimeEntryUncheckedCreateWithoutClientInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutClientInput | TimeEntryCreateOrConnectWithoutClientInput[]
    createMany?: TimeEntryCreateManyClientInputEnvelope
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
  }

  export type CommunicationUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<CommunicationCreateWithoutClientInput, CommunicationUncheckedCreateWithoutClientInput> | CommunicationCreateWithoutClientInput[] | CommunicationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutClientInput | CommunicationCreateOrConnectWithoutClientInput[]
    createMany?: CommunicationCreateManyClientInputEnvelope
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
  }

  export type MeetingUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<MeetingCreateWithoutClientInput, MeetingUncheckedCreateWithoutClientInput> | MeetingCreateWithoutClientInput[] | MeetingUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutClientInput | MeetingCreateOrConnectWithoutClientInput[]
    createMany?: MeetingCreateManyClientInputEnvelope
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type TimeBlockUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<TimeBlockCreateWithoutClientInput, TimeBlockUncheckedCreateWithoutClientInput> | TimeBlockCreateWithoutClientInput[] | TimeBlockUncheckedCreateWithoutClientInput[]
    connectOrCreate?: TimeBlockCreateOrConnectWithoutClientInput | TimeBlockCreateOrConnectWithoutClientInput[]
    createMany?: TimeBlockCreateManyClientInputEnvelope
    connect?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
  }

  export type TimeEntryUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<TimeEntryCreateWithoutClientInput, TimeEntryUncheckedCreateWithoutClientInput> | TimeEntryCreateWithoutClientInput[] | TimeEntryUncheckedCreateWithoutClientInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutClientInput | TimeEntryCreateOrConnectWithoutClientInput[]
    createMany?: TimeEntryCreateManyClientInputEnvelope
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
  }

  export type ClientUpdateadditionalContactsInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type ClientUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutClientsNestedInput = {
    create?: XOR<UserCreateWithoutClientsInput, UserUncheckedCreateWithoutClientsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientsInput
    upsert?: UserUpsertWithoutClientsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClientsInput, UserUpdateWithoutClientsInput>, UserUncheckedUpdateWithoutClientsInput>
  }

  export type CommunicationUpdateManyWithoutClientNestedInput = {
    create?: XOR<CommunicationCreateWithoutClientInput, CommunicationUncheckedCreateWithoutClientInput> | CommunicationCreateWithoutClientInput[] | CommunicationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutClientInput | CommunicationCreateOrConnectWithoutClientInput[]
    upsert?: CommunicationUpsertWithWhereUniqueWithoutClientInput | CommunicationUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: CommunicationCreateManyClientInputEnvelope
    set?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    disconnect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    delete?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    update?: CommunicationUpdateWithWhereUniqueWithoutClientInput | CommunicationUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: CommunicationUpdateManyWithWhereWithoutClientInput | CommunicationUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: CommunicationScalarWhereInput | CommunicationScalarWhereInput[]
  }

  export type MeetingUpdateManyWithoutClientNestedInput = {
    create?: XOR<MeetingCreateWithoutClientInput, MeetingUncheckedCreateWithoutClientInput> | MeetingCreateWithoutClientInput[] | MeetingUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutClientInput | MeetingCreateOrConnectWithoutClientInput[]
    upsert?: MeetingUpsertWithWhereUniqueWithoutClientInput | MeetingUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: MeetingCreateManyClientInputEnvelope
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    update?: MeetingUpdateWithWhereUniqueWithoutClientInput | MeetingUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: MeetingUpdateManyWithWhereWithoutClientInput | MeetingUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutClientNestedInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutClientInput | ProjectUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutClientInput | ProjectUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutClientInput | ProjectUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type TimeBlockUpdateManyWithoutClientNestedInput = {
    create?: XOR<TimeBlockCreateWithoutClientInput, TimeBlockUncheckedCreateWithoutClientInput> | TimeBlockCreateWithoutClientInput[] | TimeBlockUncheckedCreateWithoutClientInput[]
    connectOrCreate?: TimeBlockCreateOrConnectWithoutClientInput | TimeBlockCreateOrConnectWithoutClientInput[]
    upsert?: TimeBlockUpsertWithWhereUniqueWithoutClientInput | TimeBlockUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: TimeBlockCreateManyClientInputEnvelope
    set?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    disconnect?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    delete?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    connect?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    update?: TimeBlockUpdateWithWhereUniqueWithoutClientInput | TimeBlockUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: TimeBlockUpdateManyWithWhereWithoutClientInput | TimeBlockUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: TimeBlockScalarWhereInput | TimeBlockScalarWhereInput[]
  }

  export type TimeEntryUpdateManyWithoutClientNestedInput = {
    create?: XOR<TimeEntryCreateWithoutClientInput, TimeEntryUncheckedCreateWithoutClientInput> | TimeEntryCreateWithoutClientInput[] | TimeEntryUncheckedCreateWithoutClientInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutClientInput | TimeEntryCreateOrConnectWithoutClientInput[]
    upsert?: TimeEntryUpsertWithWhereUniqueWithoutClientInput | TimeEntryUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: TimeEntryCreateManyClientInputEnvelope
    set?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    disconnect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    delete?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    update?: TimeEntryUpdateWithWhereUniqueWithoutClientInput | TimeEntryUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: TimeEntryUpdateManyWithWhereWithoutClientInput | TimeEntryUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: TimeEntryScalarWhereInput | TimeEntryScalarWhereInput[]
  }

  export type CommunicationUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<CommunicationCreateWithoutClientInput, CommunicationUncheckedCreateWithoutClientInput> | CommunicationCreateWithoutClientInput[] | CommunicationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutClientInput | CommunicationCreateOrConnectWithoutClientInput[]
    upsert?: CommunicationUpsertWithWhereUniqueWithoutClientInput | CommunicationUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: CommunicationCreateManyClientInputEnvelope
    set?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    disconnect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    delete?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    update?: CommunicationUpdateWithWhereUniqueWithoutClientInput | CommunicationUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: CommunicationUpdateManyWithWhereWithoutClientInput | CommunicationUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: CommunicationScalarWhereInput | CommunicationScalarWhereInput[]
  }

  export type MeetingUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<MeetingCreateWithoutClientInput, MeetingUncheckedCreateWithoutClientInput> | MeetingCreateWithoutClientInput[] | MeetingUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutClientInput | MeetingCreateOrConnectWithoutClientInput[]
    upsert?: MeetingUpsertWithWhereUniqueWithoutClientInput | MeetingUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: MeetingCreateManyClientInputEnvelope
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    update?: MeetingUpdateWithWhereUniqueWithoutClientInput | MeetingUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: MeetingUpdateManyWithWhereWithoutClientInput | MeetingUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutClientInput | ProjectUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutClientInput | ProjectUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutClientInput | ProjectUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type TimeBlockUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<TimeBlockCreateWithoutClientInput, TimeBlockUncheckedCreateWithoutClientInput> | TimeBlockCreateWithoutClientInput[] | TimeBlockUncheckedCreateWithoutClientInput[]
    connectOrCreate?: TimeBlockCreateOrConnectWithoutClientInput | TimeBlockCreateOrConnectWithoutClientInput[]
    upsert?: TimeBlockUpsertWithWhereUniqueWithoutClientInput | TimeBlockUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: TimeBlockCreateManyClientInputEnvelope
    set?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    disconnect?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    delete?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    connect?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    update?: TimeBlockUpdateWithWhereUniqueWithoutClientInput | TimeBlockUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: TimeBlockUpdateManyWithWhereWithoutClientInput | TimeBlockUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: TimeBlockScalarWhereInput | TimeBlockScalarWhereInput[]
  }

  export type TimeEntryUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<TimeEntryCreateWithoutClientInput, TimeEntryUncheckedCreateWithoutClientInput> | TimeEntryCreateWithoutClientInput[] | TimeEntryUncheckedCreateWithoutClientInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutClientInput | TimeEntryCreateOrConnectWithoutClientInput[]
    upsert?: TimeEntryUpsertWithWhereUniqueWithoutClientInput | TimeEntryUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: TimeEntryCreateManyClientInputEnvelope
    set?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    disconnect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    delete?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    update?: TimeEntryUpdateWithWhereUniqueWithoutClientInput | TimeEntryUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: TimeEntryUpdateManyWithWhereWithoutClientInput | TimeEntryUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: TimeEntryScalarWhereInput | TimeEntryScalarWhereInput[]
  }

  export type CommunicationCreatetoInput = {
    set: string[]
  }

  export type CommunicationCreateccInput = {
    set: string[]
  }

  export type CommunicationCreateattachmentsInput = {
    set: InputJsonValue[]
  }

  export type CommunicationCreateattendeesInput = {
    set: string[]
  }

  export type ClientCreateNestedOneWithoutCommunicationsInput = {
    create?: XOR<ClientCreateWithoutCommunicationsInput, ClientUncheckedCreateWithoutCommunicationsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutCommunicationsInput
    connect?: ClientWhereUniqueInput
  }

  export type CommunicationUpdatetoInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CommunicationUpdateccInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CommunicationUpdateattachmentsInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type CommunicationUpdateattendeesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ClientUpdateOneRequiredWithoutCommunicationsNestedInput = {
    create?: XOR<ClientCreateWithoutCommunicationsInput, ClientUncheckedCreateWithoutCommunicationsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutCommunicationsInput
    upsert?: ClientUpsertWithoutCommunicationsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutCommunicationsInput, ClientUpdateWithoutCommunicationsInput>, ClientUncheckedUpdateWithoutCommunicationsInput>
  }

  export type MeetingCreaterequiredAttendeesInput = {
    set: string[]
  }

  export type MeetingCreateoptionalAttendeesInput = {
    set: string[]
  }

  export type MeetingCreateactionItemsInput = {
    set: InputJsonValue[]
  }

  export type MeetingCreatedecisionsInput = {
    set: string[]
  }

  export type ClientCreateNestedOneWithoutMeetingsInput = {
    create?: XOR<ClientCreateWithoutMeetingsInput, ClientUncheckedCreateWithoutMeetingsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutMeetingsInput
    connect?: ClientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMeetingsInput = {
    create?: XOR<UserCreateWithoutMeetingsInput, UserUncheckedCreateWithoutMeetingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMeetingsInput
    connect?: UserWhereUniqueInput
  }

  export type TaskCreateNestedManyWithoutMeetingInput = {
    create?: XOR<TaskCreateWithoutMeetingInput, TaskUncheckedCreateWithoutMeetingInput> | TaskCreateWithoutMeetingInput[] | TaskUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutMeetingInput | TaskCreateOrConnectWithoutMeetingInput[]
    createMany?: TaskCreateManyMeetingInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutMeetingInput = {
    create?: XOR<TaskCreateWithoutMeetingInput, TaskUncheckedCreateWithoutMeetingInput> | TaskCreateWithoutMeetingInput[] | TaskUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutMeetingInput | TaskCreateOrConnectWithoutMeetingInput[]
    createMany?: TaskCreateManyMeetingInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type MeetingUpdaterequiredAttendeesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MeetingUpdateoptionalAttendeesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MeetingUpdateactionItemsInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type MeetingUpdatedecisionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ClientUpdateOneWithoutMeetingsNestedInput = {
    create?: XOR<ClientCreateWithoutMeetingsInput, ClientUncheckedCreateWithoutMeetingsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutMeetingsInput
    upsert?: ClientUpsertWithoutMeetingsInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutMeetingsInput, ClientUpdateWithoutMeetingsInput>, ClientUncheckedUpdateWithoutMeetingsInput>
  }

  export type UserUpdateOneRequiredWithoutMeetingsNestedInput = {
    create?: XOR<UserCreateWithoutMeetingsInput, UserUncheckedCreateWithoutMeetingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMeetingsInput
    upsert?: UserUpsertWithoutMeetingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMeetingsInput, UserUpdateWithoutMeetingsInput>, UserUncheckedUpdateWithoutMeetingsInput>
  }

  export type TaskUpdateManyWithoutMeetingNestedInput = {
    create?: XOR<TaskCreateWithoutMeetingInput, TaskUncheckedCreateWithoutMeetingInput> | TaskCreateWithoutMeetingInput[] | TaskUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutMeetingInput | TaskCreateOrConnectWithoutMeetingInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutMeetingInput | TaskUpsertWithWhereUniqueWithoutMeetingInput[]
    createMany?: TaskCreateManyMeetingInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutMeetingInput | TaskUpdateWithWhereUniqueWithoutMeetingInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutMeetingInput | TaskUpdateManyWithWhereWithoutMeetingInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutMeetingNestedInput = {
    create?: XOR<TaskCreateWithoutMeetingInput, TaskUncheckedCreateWithoutMeetingInput> | TaskCreateWithoutMeetingInput[] | TaskUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutMeetingInput | TaskCreateOrConnectWithoutMeetingInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutMeetingInput | TaskUpsertWithWhereUniqueWithoutMeetingInput[]
    createMany?: TaskCreateManyMeetingInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutMeetingInput | TaskUpdateWithWhereUniqueWithoutMeetingInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutMeetingInput | TaskUpdateManyWithWhereWithoutMeetingInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type WellBeingEntryCreategratitudeInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutWellBeingEntriesInput = {
    create?: XOR<UserCreateWithoutWellBeingEntriesInput, UserUncheckedCreateWithoutWellBeingEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWellBeingEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type WellBeingEntryUpdategratitudeInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutWellBeingEntriesNestedInput = {
    create?: XOR<UserCreateWithoutWellBeingEntriesInput, UserUncheckedCreateWithoutWellBeingEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWellBeingEntriesInput
    upsert?: UserUpsertWithoutWellBeingEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWellBeingEntriesInput, UserUpdateWithoutWellBeingEntriesInput>, UserUncheckedUpdateWithoutWellBeingEntriesInput>
  }

  export type CaptureCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutCapturesInput = {
    create?: XOR<UserCreateWithoutCapturesInput, UserUncheckedCreateWithoutCapturesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCapturesInput
    connect?: UserWhereUniqueInput
  }

  export type CaptureUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutCapturesNestedInput = {
    create?: XOR<UserCreateWithoutCapturesInput, UserUncheckedCreateWithoutCapturesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCapturesInput
    upsert?: UserUpsertWithoutCapturesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCapturesInput, UserUpdateWithoutCapturesInput>, UserUncheckedUpdateWithoutCapturesInput>
  }

  export type VoiceSessionCreatespeakersInput = {
    set: InputJsonValue[]
  }

  export type VoiceSessionCreatetimestampsInput = {
    set: InputJsonValue[]
  }

  export type VoiceSessionCreatekeyPointsInput = {
    set: string[]
  }

  export type VoiceSessionCreateactionItemsInput = {
    set: InputJsonValue[]
  }

  export type VoiceSessionCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutVoiceSessionsInput = {
    create?: XOR<UserCreateWithoutVoiceSessionsInput, UserUncheckedCreateWithoutVoiceSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVoiceSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type VoiceSessionUpdatespeakersInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type VoiceSessionUpdatetimestampsInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type VoiceSessionUpdatekeyPointsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type VoiceSessionUpdateactionItemsInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type VoiceSessionUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutVoiceSessionsNestedInput = {
    create?: XOR<UserCreateWithoutVoiceSessionsInput, UserUncheckedCreateWithoutVoiceSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVoiceSessionsInput
    upsert?: UserUpsertWithoutVoiceSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVoiceSessionsInput, UserUpdateWithoutVoiceSessionsInput>, UserUncheckedUpdateWithoutVoiceSessionsInput>
  }

  export type CalendarEventCreateremindersInput = {
    set: InputJsonValue[]
  }

  export type CalendarEventCreateattendeesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutCalendarEventsInput = {
    create?: XOR<UserCreateWithoutCalendarEventsInput, UserUncheckedCreateWithoutCalendarEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCalendarEventsInput
    connect?: UserWhereUniqueInput
  }

  export type CalendarEventUpdateremindersInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type CalendarEventUpdateattendeesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutCalendarEventsNestedInput = {
    create?: XOR<UserCreateWithoutCalendarEventsInput, UserUncheckedCreateWithoutCalendarEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCalendarEventsInput
    upsert?: UserUpsertWithoutCalendarEventsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCalendarEventsInput, UserUpdateWithoutCalendarEventsInput>, UserUncheckedUpdateWithoutCalendarEventsInput>
  }

  export type UserCreateNestedOneWithoutAnalyticsEventsInput = {
    create?: XOR<UserCreateWithoutAnalyticsEventsInput, UserUncheckedCreateWithoutAnalyticsEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnalyticsEventsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAnalyticsEventsNestedInput = {
    create?: XOR<UserCreateWithoutAnalyticsEventsInput, UserUncheckedCreateWithoutAnalyticsEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnalyticsEventsInput
    upsert?: UserUpsertWithoutAnalyticsEventsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAnalyticsEventsInput, UserUpdateWithoutAnalyticsEventsInput>, UserUncheckedUpdateWithoutAnalyticsEventsInput>
  }

  export type ActionItemCreateNestedManyWithoutResearchInput = {
    create?: XOR<ActionItemCreateWithoutResearchInput, ActionItemUncheckedCreateWithoutResearchInput> | ActionItemCreateWithoutResearchInput[] | ActionItemUncheckedCreateWithoutResearchInput[]
    connectOrCreate?: ActionItemCreateOrConnectWithoutResearchInput | ActionItemCreateOrConnectWithoutResearchInput[]
    createMany?: ActionItemCreateManyResearchInputEnvelope
    connect?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
  }

  export type LeadDataCreateNestedOneWithoutResearchInput = {
    create?: XOR<LeadDataCreateWithoutResearchInput, LeadDataUncheckedCreateWithoutResearchInput>
    connectOrCreate?: LeadDataCreateOrConnectWithoutResearchInput
    connect?: LeadDataWhereUniqueInput
  }

  export type GoalCreateNestedOneWithoutResearchesInput = {
    create?: XOR<GoalCreateWithoutResearchesInput, GoalUncheckedCreateWithoutResearchesInput>
    connectOrCreate?: GoalCreateOrConnectWithoutResearchesInput
    connect?: GoalWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutResearchesInput = {
    create?: XOR<UserCreateWithoutResearchesInput, UserUncheckedCreateWithoutResearchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutResearchesInput
    connect?: UserWhereUniqueInput
  }

  export type ResearchInsightCreateNestedManyWithoutResearchInput = {
    create?: XOR<ResearchInsightCreateWithoutResearchInput, ResearchInsightUncheckedCreateWithoutResearchInput> | ResearchInsightCreateWithoutResearchInput[] | ResearchInsightUncheckedCreateWithoutResearchInput[]
    connectOrCreate?: ResearchInsightCreateOrConnectWithoutResearchInput | ResearchInsightCreateOrConnectWithoutResearchInput[]
    createMany?: ResearchInsightCreateManyResearchInputEnvelope
    connect?: ResearchInsightWhereUniqueInput | ResearchInsightWhereUniqueInput[]
  }

  export type ResearchSourceCreateNestedManyWithoutResearchInput = {
    create?: XOR<ResearchSourceCreateWithoutResearchInput, ResearchSourceUncheckedCreateWithoutResearchInput> | ResearchSourceCreateWithoutResearchInput[] | ResearchSourceUncheckedCreateWithoutResearchInput[]
    connectOrCreate?: ResearchSourceCreateOrConnectWithoutResearchInput | ResearchSourceCreateOrConnectWithoutResearchInput[]
    createMany?: ResearchSourceCreateManyResearchInputEnvelope
    connect?: ResearchSourceWhereUniqueInput | ResearchSourceWhereUniqueInput[]
  }

  export type ActionItemUncheckedCreateNestedManyWithoutResearchInput = {
    create?: XOR<ActionItemCreateWithoutResearchInput, ActionItemUncheckedCreateWithoutResearchInput> | ActionItemCreateWithoutResearchInput[] | ActionItemUncheckedCreateWithoutResearchInput[]
    connectOrCreate?: ActionItemCreateOrConnectWithoutResearchInput | ActionItemCreateOrConnectWithoutResearchInput[]
    createMany?: ActionItemCreateManyResearchInputEnvelope
    connect?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
  }

  export type LeadDataUncheckedCreateNestedOneWithoutResearchInput = {
    create?: XOR<LeadDataCreateWithoutResearchInput, LeadDataUncheckedCreateWithoutResearchInput>
    connectOrCreate?: LeadDataCreateOrConnectWithoutResearchInput
    connect?: LeadDataWhereUniqueInput
  }

  export type ResearchInsightUncheckedCreateNestedManyWithoutResearchInput = {
    create?: XOR<ResearchInsightCreateWithoutResearchInput, ResearchInsightUncheckedCreateWithoutResearchInput> | ResearchInsightCreateWithoutResearchInput[] | ResearchInsightUncheckedCreateWithoutResearchInput[]
    connectOrCreate?: ResearchInsightCreateOrConnectWithoutResearchInput | ResearchInsightCreateOrConnectWithoutResearchInput[]
    createMany?: ResearchInsightCreateManyResearchInputEnvelope
    connect?: ResearchInsightWhereUniqueInput | ResearchInsightWhereUniqueInput[]
  }

  export type ResearchSourceUncheckedCreateNestedManyWithoutResearchInput = {
    create?: XOR<ResearchSourceCreateWithoutResearchInput, ResearchSourceUncheckedCreateWithoutResearchInput> | ResearchSourceCreateWithoutResearchInput[] | ResearchSourceUncheckedCreateWithoutResearchInput[]
    connectOrCreate?: ResearchSourceCreateOrConnectWithoutResearchInput | ResearchSourceCreateOrConnectWithoutResearchInput[]
    createMany?: ResearchSourceCreateManyResearchInputEnvelope
    connect?: ResearchSourceWhereUniqueInput | ResearchSourceWhereUniqueInput[]
  }

  export type EnumResearchScopeFieldUpdateOperationsInput = {
    set?: $Enums.ResearchScope
  }

  export type EnumSearchMethodFieldUpdateOperationsInput = {
    set?: $Enums.SearchMethod
  }

  export type EnumResearchStatusFieldUpdateOperationsInput = {
    set?: $Enums.ResearchStatus
  }

  export type ActionItemUpdateManyWithoutResearchNestedInput = {
    create?: XOR<ActionItemCreateWithoutResearchInput, ActionItemUncheckedCreateWithoutResearchInput> | ActionItemCreateWithoutResearchInput[] | ActionItemUncheckedCreateWithoutResearchInput[]
    connectOrCreate?: ActionItemCreateOrConnectWithoutResearchInput | ActionItemCreateOrConnectWithoutResearchInput[]
    upsert?: ActionItemUpsertWithWhereUniqueWithoutResearchInput | ActionItemUpsertWithWhereUniqueWithoutResearchInput[]
    createMany?: ActionItemCreateManyResearchInputEnvelope
    set?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
    disconnect?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
    delete?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
    connect?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
    update?: ActionItemUpdateWithWhereUniqueWithoutResearchInput | ActionItemUpdateWithWhereUniqueWithoutResearchInput[]
    updateMany?: ActionItemUpdateManyWithWhereWithoutResearchInput | ActionItemUpdateManyWithWhereWithoutResearchInput[]
    deleteMany?: ActionItemScalarWhereInput | ActionItemScalarWhereInput[]
  }

  export type LeadDataUpdateOneWithoutResearchNestedInput = {
    create?: XOR<LeadDataCreateWithoutResearchInput, LeadDataUncheckedCreateWithoutResearchInput>
    connectOrCreate?: LeadDataCreateOrConnectWithoutResearchInput
    upsert?: LeadDataUpsertWithoutResearchInput
    disconnect?: LeadDataWhereInput | boolean
    delete?: LeadDataWhereInput | boolean
    connect?: LeadDataWhereUniqueInput
    update?: XOR<XOR<LeadDataUpdateToOneWithWhereWithoutResearchInput, LeadDataUpdateWithoutResearchInput>, LeadDataUncheckedUpdateWithoutResearchInput>
  }

  export type GoalUpdateOneWithoutResearchesNestedInput = {
    create?: XOR<GoalCreateWithoutResearchesInput, GoalUncheckedCreateWithoutResearchesInput>
    connectOrCreate?: GoalCreateOrConnectWithoutResearchesInput
    upsert?: GoalUpsertWithoutResearchesInput
    disconnect?: GoalWhereInput | boolean
    delete?: GoalWhereInput | boolean
    connect?: GoalWhereUniqueInput
    update?: XOR<XOR<GoalUpdateToOneWithWhereWithoutResearchesInput, GoalUpdateWithoutResearchesInput>, GoalUncheckedUpdateWithoutResearchesInput>
  }

  export type UserUpdateOneRequiredWithoutResearchesNestedInput = {
    create?: XOR<UserCreateWithoutResearchesInput, UserUncheckedCreateWithoutResearchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutResearchesInput
    upsert?: UserUpsertWithoutResearchesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResearchesInput, UserUpdateWithoutResearchesInput>, UserUncheckedUpdateWithoutResearchesInput>
  }

  export type ResearchInsightUpdateManyWithoutResearchNestedInput = {
    create?: XOR<ResearchInsightCreateWithoutResearchInput, ResearchInsightUncheckedCreateWithoutResearchInput> | ResearchInsightCreateWithoutResearchInput[] | ResearchInsightUncheckedCreateWithoutResearchInput[]
    connectOrCreate?: ResearchInsightCreateOrConnectWithoutResearchInput | ResearchInsightCreateOrConnectWithoutResearchInput[]
    upsert?: ResearchInsightUpsertWithWhereUniqueWithoutResearchInput | ResearchInsightUpsertWithWhereUniqueWithoutResearchInput[]
    createMany?: ResearchInsightCreateManyResearchInputEnvelope
    set?: ResearchInsightWhereUniqueInput | ResearchInsightWhereUniqueInput[]
    disconnect?: ResearchInsightWhereUniqueInput | ResearchInsightWhereUniqueInput[]
    delete?: ResearchInsightWhereUniqueInput | ResearchInsightWhereUniqueInput[]
    connect?: ResearchInsightWhereUniqueInput | ResearchInsightWhereUniqueInput[]
    update?: ResearchInsightUpdateWithWhereUniqueWithoutResearchInput | ResearchInsightUpdateWithWhereUniqueWithoutResearchInput[]
    updateMany?: ResearchInsightUpdateManyWithWhereWithoutResearchInput | ResearchInsightUpdateManyWithWhereWithoutResearchInput[]
    deleteMany?: ResearchInsightScalarWhereInput | ResearchInsightScalarWhereInput[]
  }

  export type ResearchSourceUpdateManyWithoutResearchNestedInput = {
    create?: XOR<ResearchSourceCreateWithoutResearchInput, ResearchSourceUncheckedCreateWithoutResearchInput> | ResearchSourceCreateWithoutResearchInput[] | ResearchSourceUncheckedCreateWithoutResearchInput[]
    connectOrCreate?: ResearchSourceCreateOrConnectWithoutResearchInput | ResearchSourceCreateOrConnectWithoutResearchInput[]
    upsert?: ResearchSourceUpsertWithWhereUniqueWithoutResearchInput | ResearchSourceUpsertWithWhereUniqueWithoutResearchInput[]
    createMany?: ResearchSourceCreateManyResearchInputEnvelope
    set?: ResearchSourceWhereUniqueInput | ResearchSourceWhereUniqueInput[]
    disconnect?: ResearchSourceWhereUniqueInput | ResearchSourceWhereUniqueInput[]
    delete?: ResearchSourceWhereUniqueInput | ResearchSourceWhereUniqueInput[]
    connect?: ResearchSourceWhereUniqueInput | ResearchSourceWhereUniqueInput[]
    update?: ResearchSourceUpdateWithWhereUniqueWithoutResearchInput | ResearchSourceUpdateWithWhereUniqueWithoutResearchInput[]
    updateMany?: ResearchSourceUpdateManyWithWhereWithoutResearchInput | ResearchSourceUpdateManyWithWhereWithoutResearchInput[]
    deleteMany?: ResearchSourceScalarWhereInput | ResearchSourceScalarWhereInput[]
  }

  export type ActionItemUncheckedUpdateManyWithoutResearchNestedInput = {
    create?: XOR<ActionItemCreateWithoutResearchInput, ActionItemUncheckedCreateWithoutResearchInput> | ActionItemCreateWithoutResearchInput[] | ActionItemUncheckedCreateWithoutResearchInput[]
    connectOrCreate?: ActionItemCreateOrConnectWithoutResearchInput | ActionItemCreateOrConnectWithoutResearchInput[]
    upsert?: ActionItemUpsertWithWhereUniqueWithoutResearchInput | ActionItemUpsertWithWhereUniqueWithoutResearchInput[]
    createMany?: ActionItemCreateManyResearchInputEnvelope
    set?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
    disconnect?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
    delete?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
    connect?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
    update?: ActionItemUpdateWithWhereUniqueWithoutResearchInput | ActionItemUpdateWithWhereUniqueWithoutResearchInput[]
    updateMany?: ActionItemUpdateManyWithWhereWithoutResearchInput | ActionItemUpdateManyWithWhereWithoutResearchInput[]
    deleteMany?: ActionItemScalarWhereInput | ActionItemScalarWhereInput[]
  }

  export type LeadDataUncheckedUpdateOneWithoutResearchNestedInput = {
    create?: XOR<LeadDataCreateWithoutResearchInput, LeadDataUncheckedCreateWithoutResearchInput>
    connectOrCreate?: LeadDataCreateOrConnectWithoutResearchInput
    upsert?: LeadDataUpsertWithoutResearchInput
    disconnect?: LeadDataWhereInput | boolean
    delete?: LeadDataWhereInput | boolean
    connect?: LeadDataWhereUniqueInput
    update?: XOR<XOR<LeadDataUpdateToOneWithWhereWithoutResearchInput, LeadDataUpdateWithoutResearchInput>, LeadDataUncheckedUpdateWithoutResearchInput>
  }

  export type ResearchInsightUncheckedUpdateManyWithoutResearchNestedInput = {
    create?: XOR<ResearchInsightCreateWithoutResearchInput, ResearchInsightUncheckedCreateWithoutResearchInput> | ResearchInsightCreateWithoutResearchInput[] | ResearchInsightUncheckedCreateWithoutResearchInput[]
    connectOrCreate?: ResearchInsightCreateOrConnectWithoutResearchInput | ResearchInsightCreateOrConnectWithoutResearchInput[]
    upsert?: ResearchInsightUpsertWithWhereUniqueWithoutResearchInput | ResearchInsightUpsertWithWhereUniqueWithoutResearchInput[]
    createMany?: ResearchInsightCreateManyResearchInputEnvelope
    set?: ResearchInsightWhereUniqueInput | ResearchInsightWhereUniqueInput[]
    disconnect?: ResearchInsightWhereUniqueInput | ResearchInsightWhereUniqueInput[]
    delete?: ResearchInsightWhereUniqueInput | ResearchInsightWhereUniqueInput[]
    connect?: ResearchInsightWhereUniqueInput | ResearchInsightWhereUniqueInput[]
    update?: ResearchInsightUpdateWithWhereUniqueWithoutResearchInput | ResearchInsightUpdateWithWhereUniqueWithoutResearchInput[]
    updateMany?: ResearchInsightUpdateManyWithWhereWithoutResearchInput | ResearchInsightUpdateManyWithWhereWithoutResearchInput[]
    deleteMany?: ResearchInsightScalarWhereInput | ResearchInsightScalarWhereInput[]
  }

  export type ResearchSourceUncheckedUpdateManyWithoutResearchNestedInput = {
    create?: XOR<ResearchSourceCreateWithoutResearchInput, ResearchSourceUncheckedCreateWithoutResearchInput> | ResearchSourceCreateWithoutResearchInput[] | ResearchSourceUncheckedCreateWithoutResearchInput[]
    connectOrCreate?: ResearchSourceCreateOrConnectWithoutResearchInput | ResearchSourceCreateOrConnectWithoutResearchInput[]
    upsert?: ResearchSourceUpsertWithWhereUniqueWithoutResearchInput | ResearchSourceUpsertWithWhereUniqueWithoutResearchInput[]
    createMany?: ResearchSourceCreateManyResearchInputEnvelope
    set?: ResearchSourceWhereUniqueInput | ResearchSourceWhereUniqueInput[]
    disconnect?: ResearchSourceWhereUniqueInput | ResearchSourceWhereUniqueInput[]
    delete?: ResearchSourceWhereUniqueInput | ResearchSourceWhereUniqueInput[]
    connect?: ResearchSourceWhereUniqueInput | ResearchSourceWhereUniqueInput[]
    update?: ResearchSourceUpdateWithWhereUniqueWithoutResearchInput | ResearchSourceUpdateWithWhereUniqueWithoutResearchInput[]
    updateMany?: ResearchSourceUpdateManyWithWhereWithoutResearchInput | ResearchSourceUpdateManyWithWhereWithoutResearchInput[]
    deleteMany?: ResearchSourceScalarWhereInput | ResearchSourceScalarWhereInput[]
  }

  export type ResearchSourceCreatecitedInSectionsInput = {
    set: string[]
  }

  export type ResearchCreateNestedOneWithoutSourcesInput = {
    create?: XOR<ResearchCreateWithoutSourcesInput, ResearchUncheckedCreateWithoutSourcesInput>
    connectOrCreate?: ResearchCreateOrConnectWithoutSourcesInput
    connect?: ResearchWhereUniqueInput
  }

  export type ResearchSourceUpdatecitedInSectionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ResearchUpdateOneRequiredWithoutSourcesNestedInput = {
    create?: XOR<ResearchCreateWithoutSourcesInput, ResearchUncheckedCreateWithoutSourcesInput>
    connectOrCreate?: ResearchCreateOrConnectWithoutSourcesInput
    upsert?: ResearchUpsertWithoutSourcesInput
    connect?: ResearchWhereUniqueInput
    update?: XOR<XOR<ResearchUpdateToOneWithWhereWithoutSourcesInput, ResearchUpdateWithoutSourcesInput>, ResearchUncheckedUpdateWithoutSourcesInput>
  }

  export type ResearchCreateNestedOneWithoutInsightsInput = {
    create?: XOR<ResearchCreateWithoutInsightsInput, ResearchUncheckedCreateWithoutInsightsInput>
    connectOrCreate?: ResearchCreateOrConnectWithoutInsightsInput
    connect?: ResearchWhereUniqueInput
  }

  export type ResearchUpdateOneRequiredWithoutInsightsNestedInput = {
    create?: XOR<ResearchCreateWithoutInsightsInput, ResearchUncheckedCreateWithoutInsightsInput>
    connectOrCreate?: ResearchCreateOrConnectWithoutInsightsInput
    upsert?: ResearchUpsertWithoutInsightsInput
    connect?: ResearchWhereUniqueInput
    update?: XOR<XOR<ResearchUpdateToOneWithWhereWithoutInsightsInput, ResearchUpdateWithoutInsightsInput>, ResearchUncheckedUpdateWithoutInsightsInput>
  }

  export type TaskCreateNestedOneWithoutActionItemInput = {
    create?: XOR<TaskCreateWithoutActionItemInput, TaskUncheckedCreateWithoutActionItemInput>
    connectOrCreate?: TaskCreateOrConnectWithoutActionItemInput
    connect?: TaskWhereUniqueInput
  }

  export type ResearchCreateNestedOneWithoutActionItemsInput = {
    create?: XOR<ResearchCreateWithoutActionItemsInput, ResearchUncheckedCreateWithoutActionItemsInput>
    connectOrCreate?: ResearchCreateOrConnectWithoutActionItemsInput
    connect?: ResearchWhereUniqueInput
  }

  export type EnumActionPriorityFieldUpdateOperationsInput = {
    set?: $Enums.ActionPriority
  }

  export type TaskUpdateOneWithoutActionItemNestedInput = {
    create?: XOR<TaskCreateWithoutActionItemInput, TaskUncheckedCreateWithoutActionItemInput>
    connectOrCreate?: TaskCreateOrConnectWithoutActionItemInput
    upsert?: TaskUpsertWithoutActionItemInput
    disconnect?: TaskWhereInput | boolean
    delete?: TaskWhereInput | boolean
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutActionItemInput, TaskUpdateWithoutActionItemInput>, TaskUncheckedUpdateWithoutActionItemInput>
  }

  export type ResearchUpdateOneRequiredWithoutActionItemsNestedInput = {
    create?: XOR<ResearchCreateWithoutActionItemsInput, ResearchUncheckedCreateWithoutActionItemsInput>
    connectOrCreate?: ResearchCreateOrConnectWithoutActionItemsInput
    upsert?: ResearchUpsertWithoutActionItemsInput
    connect?: ResearchWhereUniqueInput
    update?: XOR<XOR<ResearchUpdateToOneWithWhereWithoutActionItemsInput, ResearchUpdateWithoutActionItemsInput>, ResearchUncheckedUpdateWithoutActionItemsInput>
  }

  export type LeadCreateNestedManyWithoutLeadDataInput = {
    create?: XOR<LeadCreateWithoutLeadDataInput, LeadUncheckedCreateWithoutLeadDataInput> | LeadCreateWithoutLeadDataInput[] | LeadUncheckedCreateWithoutLeadDataInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutLeadDataInput | LeadCreateOrConnectWithoutLeadDataInput[]
    createMany?: LeadCreateManyLeadDataInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type ResearchCreateNestedOneWithoutLeadDataInput = {
    create?: XOR<ResearchCreateWithoutLeadDataInput, ResearchUncheckedCreateWithoutLeadDataInput>
    connectOrCreate?: ResearchCreateOrConnectWithoutLeadDataInput
    connect?: ResearchWhereUniqueInput
  }

  export type LeadUncheckedCreateNestedManyWithoutLeadDataInput = {
    create?: XOR<LeadCreateWithoutLeadDataInput, LeadUncheckedCreateWithoutLeadDataInput> | LeadCreateWithoutLeadDataInput[] | LeadUncheckedCreateWithoutLeadDataInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutLeadDataInput | LeadCreateOrConnectWithoutLeadDataInput[]
    createMany?: LeadCreateManyLeadDataInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type LeadUpdateManyWithoutLeadDataNestedInput = {
    create?: XOR<LeadCreateWithoutLeadDataInput, LeadUncheckedCreateWithoutLeadDataInput> | LeadCreateWithoutLeadDataInput[] | LeadUncheckedCreateWithoutLeadDataInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutLeadDataInput | LeadCreateOrConnectWithoutLeadDataInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutLeadDataInput | LeadUpsertWithWhereUniqueWithoutLeadDataInput[]
    createMany?: LeadCreateManyLeadDataInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutLeadDataInput | LeadUpdateWithWhereUniqueWithoutLeadDataInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutLeadDataInput | LeadUpdateManyWithWhereWithoutLeadDataInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type ResearchUpdateOneRequiredWithoutLeadDataNestedInput = {
    create?: XOR<ResearchCreateWithoutLeadDataInput, ResearchUncheckedCreateWithoutLeadDataInput>
    connectOrCreate?: ResearchCreateOrConnectWithoutLeadDataInput
    upsert?: ResearchUpsertWithoutLeadDataInput
    connect?: ResearchWhereUniqueInput
    update?: XOR<XOR<ResearchUpdateToOneWithWhereWithoutLeadDataInput, ResearchUpdateWithoutLeadDataInput>, ResearchUncheckedUpdateWithoutLeadDataInput>
  }

  export type LeadUncheckedUpdateManyWithoutLeadDataNestedInput = {
    create?: XOR<LeadCreateWithoutLeadDataInput, LeadUncheckedCreateWithoutLeadDataInput> | LeadCreateWithoutLeadDataInput[] | LeadUncheckedCreateWithoutLeadDataInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutLeadDataInput | LeadCreateOrConnectWithoutLeadDataInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutLeadDataInput | LeadUpsertWithWhereUniqueWithoutLeadDataInput[]
    createMany?: LeadCreateManyLeadDataInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutLeadDataInput | LeadUpdateWithWhereUniqueWithoutLeadDataInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutLeadDataInput | LeadUpdateManyWithWhereWithoutLeadDataInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type LeadCreatepainPointsInput = {
    set: string[]
  }

  export type LeadDataCreateNestedOneWithoutLeadsInput = {
    create?: XOR<LeadDataCreateWithoutLeadsInput, LeadDataUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: LeadDataCreateOrConnectWithoutLeadsInput
    connect?: LeadDataWhereUniqueInput
  }

  export type LeadUpdatepainPointsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type LeadDataUpdateOneRequiredWithoutLeadsNestedInput = {
    create?: XOR<LeadDataCreateWithoutLeadsInput, LeadDataUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: LeadDataCreateOrConnectWithoutLeadsInput
    upsert?: LeadDataUpsertWithoutLeadsInput
    connect?: LeadDataWhereUniqueInput
    update?: XOR<XOR<LeadDataUpdateToOneWithWhereWithoutLeadsInput, LeadDataUpdateWithoutLeadsInput>, LeadDataUncheckedUpdateWithoutLeadsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumResearchScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.ResearchScope | EnumResearchScopeFieldRefInput<$PrismaModel>
    in?: $Enums.ResearchScope[] | ListEnumResearchScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResearchScope[] | ListEnumResearchScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumResearchScopeFilter<$PrismaModel> | $Enums.ResearchScope
  }

  export type NestedEnumSearchMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.SearchMethod | EnumSearchMethodFieldRefInput<$PrismaModel>
    in?: $Enums.SearchMethod[] | ListEnumSearchMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.SearchMethod[] | ListEnumSearchMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumSearchMethodFilter<$PrismaModel> | $Enums.SearchMethod
  }

  export type NestedEnumResearchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ResearchStatus | EnumResearchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ResearchStatus[] | ListEnumResearchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResearchStatus[] | ListEnumResearchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumResearchStatusFilter<$PrismaModel> | $Enums.ResearchStatus
  }

  export type NestedEnumResearchScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResearchScope | EnumResearchScopeFieldRefInput<$PrismaModel>
    in?: $Enums.ResearchScope[] | ListEnumResearchScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResearchScope[] | ListEnumResearchScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumResearchScopeWithAggregatesFilter<$PrismaModel> | $Enums.ResearchScope
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResearchScopeFilter<$PrismaModel>
    _max?: NestedEnumResearchScopeFilter<$PrismaModel>
  }

  export type NestedEnumSearchMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SearchMethod | EnumSearchMethodFieldRefInput<$PrismaModel>
    in?: $Enums.SearchMethod[] | ListEnumSearchMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.SearchMethod[] | ListEnumSearchMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumSearchMethodWithAggregatesFilter<$PrismaModel> | $Enums.SearchMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSearchMethodFilter<$PrismaModel>
    _max?: NestedEnumSearchMethodFilter<$PrismaModel>
  }

  export type NestedEnumResearchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResearchStatus | EnumResearchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ResearchStatus[] | ListEnumResearchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResearchStatus[] | ListEnumResearchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumResearchStatusWithAggregatesFilter<$PrismaModel> | $Enums.ResearchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResearchStatusFilter<$PrismaModel>
    _max?: NestedEnumResearchStatusFilter<$PrismaModel>
  }

  export type NestedEnumActionPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionPriority | EnumActionPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.ActionPriority[] | ListEnumActionPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionPriority[] | ListEnumActionPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumActionPriorityFilter<$PrismaModel> | $Enums.ActionPriority
  }

  export type NestedEnumActionPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionPriority | EnumActionPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.ActionPriority[] | ListEnumActionPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionPriority[] | ListEnumActionPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumActionPriorityWithAggregatesFilter<$PrismaModel> | $Enums.ActionPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionPriorityFilter<$PrismaModel>
    _max?: NestedEnumActionPriorityFilter<$PrismaModel>
  }

  export type AnalyticsEventCreateWithoutUserInput = {
    id?: string
    eventType: string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: string | null
    createdAt?: Date | string
  }

  export type AnalyticsEventUncheckedCreateWithoutUserInput = {
    id?: string
    eventType: string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: string | null
    createdAt?: Date | string
  }

  export type AnalyticsEventCreateOrConnectWithoutUserInput = {
    where: AnalyticsEventWhereUniqueInput
    create: XOR<AnalyticsEventCreateWithoutUserInput, AnalyticsEventUncheckedCreateWithoutUserInput>
  }

  export type AnalyticsEventCreateManyUserInputEnvelope = {
    data: AnalyticsEventCreateManyUserInput | AnalyticsEventCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CalendarEventCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    allDay?: boolean
    timezone: string
    isRecurring?: boolean
    recurrenceRule?: string | null
    projectId?: string | null
    taskId?: string | null
    clientId?: string | null
    meetingId?: string | null
    type: string
    reminders?: CalendarEventCreateremindersInput | InputJsonValue[]
    color?: string | null
    location?: string | null
    attendees?: CalendarEventCreateattendeesInput | string[]
    externalCalendarId?: string | null
    externalEventId?: string | null
    syncStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarEventUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    allDay?: boolean
    timezone: string
    isRecurring?: boolean
    recurrenceRule?: string | null
    projectId?: string | null
    taskId?: string | null
    clientId?: string | null
    meetingId?: string | null
    type: string
    reminders?: CalendarEventCreateremindersInput | InputJsonValue[]
    color?: string | null
    location?: string | null
    attendees?: CalendarEventCreateattendeesInput | string[]
    externalCalendarId?: string | null
    externalEventId?: string | null
    syncStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarEventCreateOrConnectWithoutUserInput = {
    where: CalendarEventWhereUniqueInput
    create: XOR<CalendarEventCreateWithoutUserInput, CalendarEventUncheckedCreateWithoutUserInput>
  }

  export type CalendarEventCreateManyUserInputEnvelope = {
    data: CalendarEventCreateManyUserInput | CalendarEventCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CaptureCreateWithoutUserInput = {
    id?: string
    type: string
    content: string
    transcription?: string | null
    status?: string
    convertedToTaskId?: string | null
    convertedToNoteId?: string | null
    suggestedProject?: string | null
    suggestedDueDate?: Date | string | null
    suggestedPriority?: string | null
    tags?: CaptureCreatetagsInput | string[]
    createdAt?: Date | string
    processedAt?: Date | string | null
  }

  export type CaptureUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    content: string
    transcription?: string | null
    status?: string
    convertedToTaskId?: string | null
    convertedToNoteId?: string | null
    suggestedProject?: string | null
    suggestedDueDate?: Date | string | null
    suggestedPriority?: string | null
    tags?: CaptureCreatetagsInput | string[]
    createdAt?: Date | string
    processedAt?: Date | string | null
  }

  export type CaptureCreateOrConnectWithoutUserInput = {
    where: CaptureWhereUniqueInput
    create: XOR<CaptureCreateWithoutUserInput, CaptureUncheckedCreateWithoutUserInput>
  }

  export type CaptureCreateManyUserInputEnvelope = {
    data: CaptureCreateManyUserInput | CaptureCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ClientCreateWithoutUserInput = {
    id?: string
    name: string
    companyName?: string | null
    email: string
    phone?: string | null
    primaryContact?: NullableJsonNullValueInput | InputJsonValue
    additionalContacts?: ClientCreateadditionalContactsInput | InputJsonValue[]
    industry?: string | null
    website?: string | null
    timezone?: string | null
    relationshipHealth?: number | null
    lastContactedAt?: Date | string | null
    preferredCommunication?: string | null
    defaultHourlyRate?: number | null
    paymentTerms?: string | null
    outstandingBalance?: number
    notes?: string | null
    tags?: ClientCreatetagsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastInteractionAt?: Date | string | null
    communications?: CommunicationCreateNestedManyWithoutClientInput
    meetings?: MeetingCreateNestedManyWithoutClientInput
    projects?: ProjectCreateNestedManyWithoutClientInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutClientInput
    timeEntries?: TimeEntryCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    companyName?: string | null
    email: string
    phone?: string | null
    primaryContact?: NullableJsonNullValueInput | InputJsonValue
    additionalContacts?: ClientCreateadditionalContactsInput | InputJsonValue[]
    industry?: string | null
    website?: string | null
    timezone?: string | null
    relationshipHealth?: number | null
    lastContactedAt?: Date | string | null
    preferredCommunication?: string | null
    defaultHourlyRate?: number | null
    paymentTerms?: string | null
    outstandingBalance?: number
    notes?: string | null
    tags?: ClientCreatetagsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastInteractionAt?: Date | string | null
    communications?: CommunicationUncheckedCreateNestedManyWithoutClientInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutClientInput
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutClientInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutUserInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
  }

  export type ClientCreateManyUserInputEnvelope = {
    data: ClientCreateManyUserInput | ClientCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DayPlanCreateWithoutUserInput = {
    id?: string
    date: Date | string
    topPriorities?: DayPlanCreatetopPrioritiesInput | string[]
    morningEnergy?: number | null
    afternoonEnergy?: number | null
    eveningEnergy?: number | null
    dailyWin?: string | null
    gratitude?: DayPlanCreategratitudeInput | string[]
    tomorrowPrep?: DayPlanCreatetomorrowPrepInput | string[]
    completionRate?: number
    dayFocuses?: DayFocusCreateNestedManyWithoutDayPlanInput
    weekPlan: WeekPlanCreateNestedOneWithoutDayPlansInput
    notes?: NoteCreateNestedManyWithoutDayPlanInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutDayPlanInput
  }

  export type DayPlanUncheckedCreateWithoutUserInput = {
    id?: string
    weekPlanId: string
    date: Date | string
    topPriorities?: DayPlanCreatetopPrioritiesInput | string[]
    morningEnergy?: number | null
    afternoonEnergy?: number | null
    eveningEnergy?: number | null
    dailyWin?: string | null
    gratitude?: DayPlanCreategratitudeInput | string[]
    tomorrowPrep?: DayPlanCreatetomorrowPrepInput | string[]
    completionRate?: number
    dayFocuses?: DayFocusUncheckedCreateNestedManyWithoutDayPlanInput
    notes?: NoteUncheckedCreateNestedManyWithoutDayPlanInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutDayPlanInput
  }

  export type DayPlanCreateOrConnectWithoutUserInput = {
    where: DayPlanWhereUniqueInput
    create: XOR<DayPlanCreateWithoutUserInput, DayPlanUncheckedCreateWithoutUserInput>
  }

  export type DayPlanCreateManyUserInputEnvelope = {
    data: DayPlanCreateManyUserInput | DayPlanCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MeetingCreateWithoutUserInput = {
    id?: string
    projectId?: string | null
    title: string
    description?: string | null
    type?: string
    scheduledAt: Date | string
    duration: number
    timezone?: string
    organizer?: string
    requiredAttendees?: MeetingCreaterequiredAttendeesInput | string[]
    optionalAttendees?: MeetingCreateoptionalAttendeesInput | string[]
    location?: string | null
    meetingLink?: string | null
    agenda?: string | null
    meetingNotes?: string | null
    actionItems?: MeetingCreateactionItemsInput | InputJsonValue[]
    decisions?: MeetingCreatedecisionsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutMeetingsInput
    tasks?: TaskCreateNestedManyWithoutMeetingInput
  }

  export type MeetingUncheckedCreateWithoutUserInput = {
    id?: string
    clientId?: string | null
    projectId?: string | null
    title: string
    description?: string | null
    type?: string
    scheduledAt: Date | string
    duration: number
    timezone?: string
    organizer?: string
    requiredAttendees?: MeetingCreaterequiredAttendeesInput | string[]
    optionalAttendees?: MeetingCreateoptionalAttendeesInput | string[]
    location?: string | null
    meetingLink?: string | null
    agenda?: string | null
    meetingNotes?: string | null
    actionItems?: MeetingCreateactionItemsInput | InputJsonValue[]
    decisions?: MeetingCreatedecisionsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutMeetingInput
  }

  export type MeetingCreateOrConnectWithoutUserInput = {
    where: MeetingWhereUniqueInput
    create: XOR<MeetingCreateWithoutUserInput, MeetingUncheckedCreateWithoutUserInput>
  }

  export type MeetingCreateManyUserInputEnvelope = {
    data: MeetingCreateManyUserInput | MeetingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NoteCreateWithoutUserInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dayPlan?: DayPlanCreateNestedOneWithoutNotesInput
    goal?: GoalCreateNestedOneWithoutNotesInput
    keyStep?: KeyStepCreateNestedOneWithoutNotesInput
  }

  export type NoteUncheckedCreateWithoutUserInput = {
    id?: string
    content: string
    goalId?: string | null
    keyStepId?: string | null
    dayPlanId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoteCreateOrConnectWithoutUserInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutUserInput, NoteUncheckedCreateWithoutUserInput>
  }

  export type NoteCreateManyUserInputEnvelope = {
    data: NoteCreateManyUserInput | NoteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    status: string
    billable?: boolean
    hourlyRate?: number | null
    budgetHours?: number | null
    startDate?: Date | string | null
    deadline?: Date | string | null
    estimatedHours?: number | null
    actualHoursSpent?: number
    completionPercentage?: number
    goalId?: string | null
    parentProjectId?: string | null
    priority: string
    tags?: ProjectCreatetagsInput | string[]
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    archivedAt?: Date | string | null
    icon?: string | null
    client?: ClientCreateNestedOneWithoutProjectsInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutProjectInput
    timeEntries?: TimeEntryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    status: string
    clientId?: string | null
    billable?: boolean
    hourlyRate?: number | null
    budgetHours?: number | null
    startDate?: Date | string | null
    deadline?: Date | string | null
    estimatedHours?: number | null
    actualHoursSpent?: number
    completionPercentage?: number
    goalId?: string | null
    parentProjectId?: string | null
    priority: string
    tags?: ProjectCreatetagsInput | string[]
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    archivedAt?: Date | string | null
    icon?: string | null
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutProjectInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutUserInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput>
  }

  export type ProjectCreateManyUserInputEnvelope = {
    data: ProjectCreateManyUserInput | ProjectCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ResearchCreateWithoutUserInput = {
    id?: string
    title: string
    scope: $Enums.ResearchScope
    searchMethod?: $Enums.SearchMethod
    status?: $Enums.ResearchStatus
    originalPrompt: string
    refinedPrompt: string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    errorMessage?: string | null
    isFavorited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    actionItems?: ActionItemCreateNestedManyWithoutResearchInput
    leadData?: LeadDataCreateNestedOneWithoutResearchInput
    goal?: GoalCreateNestedOneWithoutResearchesInput
    insights?: ResearchInsightCreateNestedManyWithoutResearchInput
    sources?: ResearchSourceCreateNestedManyWithoutResearchInput
  }

  export type ResearchUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    scope: $Enums.ResearchScope
    searchMethod?: $Enums.SearchMethod
    status?: $Enums.ResearchStatus
    originalPrompt: string
    refinedPrompt: string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    errorMessage?: string | null
    goalId?: string | null
    isFavorited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutResearchInput
    leadData?: LeadDataUncheckedCreateNestedOneWithoutResearchInput
    insights?: ResearchInsightUncheckedCreateNestedManyWithoutResearchInput
    sources?: ResearchSourceUncheckedCreateNestedManyWithoutResearchInput
  }

  export type ResearchCreateOrConnectWithoutUserInput = {
    where: ResearchWhereUniqueInput
    create: XOR<ResearchCreateWithoutUserInput, ResearchUncheckedCreateWithoutUserInput>
  }

  export type ResearchCreateManyUserInputEnvelope = {
    data: ResearchCreateManyUserInput | ResearchCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    estimatedMinutes?: number | null
    actualMinutes?: number
    timerRunning?: boolean
    currentTimerStart?: Date | string | null
    scheduledDate?: Date | string | null
    dueDate?: Date | string | null
    priority: string
    type: string
    tags?: TaskCreatetagsInput | string[]
    parentTaskId?: string | null
    dependsOn?: TaskCreatedependsOnInput | string[]
    blocks?: TaskCreateblocksInput | string[]
    energyRequired?: number | null
    isAdHoc?: boolean
    isRecurring?: boolean
    recurringPattern?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actionItem?: ActionItemCreateNestedOneWithoutConvertedToTaskInput
    goal?: GoalCreateNestedOneWithoutTasksInput
    keyStep?: KeyStepCreateNestedOneWithoutTasksInput
    meeting?: MeetingCreateNestedOneWithoutTasksInput
    project?: ProjectCreateNestedOneWithoutTasksInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutTaskInput
    timeEntries?: TimeEntryCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutUserInput = {
    id?: string
    projectId?: string | null
    title: string
    description?: string | null
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    estimatedMinutes?: number | null
    actualMinutes?: number
    timerRunning?: boolean
    currentTimerStart?: Date | string | null
    scheduledDate?: Date | string | null
    dueDate?: Date | string | null
    priority: string
    type: string
    tags?: TaskCreatetagsInput | string[]
    parentTaskId?: string | null
    dependsOn?: TaskCreatedependsOnInput | string[]
    blocks?: TaskCreateblocksInput | string[]
    energyRequired?: number | null
    isAdHoc?: boolean
    isRecurring?: boolean
    recurringPattern?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meetingId?: string | null
    goalId?: string | null
    keyStepId?: string | null
    actionItem?: ActionItemUncheckedCreateNestedOneWithoutConvertedToTaskInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutTaskInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutUserInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput>
  }

  export type TaskCreateManyUserInputEnvelope = {
    data: TaskCreateManyUserInput | TaskCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TimeEntryCreateWithoutUserInput = {
    id?: string
    startTime: Date | string
    endTime?: Date | string | null
    duration: number
    type: string
    description?: string | null
    tags?: TimeEntryCreatetagsInput | string[]
    focusQuality?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    distractions?: number
    billable?: boolean
    hourlyRate?: number | null
    amount?: number
    invoiced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutTimeEntriesInput
    project?: ProjectCreateNestedOneWithoutTimeEntriesInput
    task?: TaskCreateNestedOneWithoutTimeEntriesInput
  }

  export type TimeEntryUncheckedCreateWithoutUserInput = {
    id?: string
    taskId?: string | null
    projectId?: string | null
    clientId?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    duration: number
    type: string
    description?: string | null
    tags?: TimeEntryCreatetagsInput | string[]
    focusQuality?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    distractions?: number
    billable?: boolean
    hourlyRate?: number | null
    amount?: number
    invoiced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeEntryCreateOrConnectWithoutUserInput = {
    where: TimeEntryWhereUniqueInput
    create: XOR<TimeEntryCreateWithoutUserInput, TimeEntryUncheckedCreateWithoutUserInput>
  }

  export type TimeEntryCreateManyUserInputEnvelope = {
    data: TimeEntryCreateManyUserInput | TimeEntryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type VoiceSessionCreateWithoutUserInput = {
    id?: string
    title: string
    duration: number
    recordedAt: Date | string
    audioFileUrl: string
    waveformData?: NullableJsonNullValueInput | InputJsonValue
    transcription?: string | null
    speakers?: VoiceSessionCreatespeakersInput | InputJsonValue[]
    timestamps?: VoiceSessionCreatetimestampsInput | InputJsonValue[]
    summary?: string | null
    keyPoints?: VoiceSessionCreatekeyPointsInput | string[]
    actionItems?: VoiceSessionCreateactionItemsInput | InputJsonValue[]
    projectId?: string | null
    tags?: VoiceSessionCreatetagsInput | string[]
    processed?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type VoiceSessionUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    duration: number
    recordedAt: Date | string
    audioFileUrl: string
    waveformData?: NullableJsonNullValueInput | InputJsonValue
    transcription?: string | null
    speakers?: VoiceSessionCreatespeakersInput | InputJsonValue[]
    timestamps?: VoiceSessionCreatetimestampsInput | InputJsonValue[]
    summary?: string | null
    keyPoints?: VoiceSessionCreatekeyPointsInput | string[]
    actionItems?: VoiceSessionCreateactionItemsInput | InputJsonValue[]
    projectId?: string | null
    tags?: VoiceSessionCreatetagsInput | string[]
    processed?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type VoiceSessionCreateOrConnectWithoutUserInput = {
    where: VoiceSessionWhereUniqueInput
    create: XOR<VoiceSessionCreateWithoutUserInput, VoiceSessionUncheckedCreateWithoutUserInput>
  }

  export type VoiceSessionCreateManyUserInputEnvelope = {
    data: VoiceSessionCreateManyUserInput | VoiceSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WeekPlanCreateWithoutUserInput = {
    id?: string
    weekNumber: number
    year: number
    startDate: Date | string
    endDate: Date | string
    topOutcomes?: WeekPlanCreatetopOutcomesInput | string[]
    plannedClientHours?: number | null
    plannedPersonalHours?: number | null
    challenges?: WeekPlanCreatechallengesInput | string[]
    keyWins?: WeekPlanCreatekeyWinsInput | string[]
    lessonsLearned?: WeekPlanCreatelessonsLearnedInput | string[]
    rating?: number | null
    reviewNotes?: string | null
    dayPlans?: DayPlanCreateNestedManyWithoutWeekPlanInput
    weekFocuses?: WeekFocusCreateNestedManyWithoutWeekPlanInput
    monthPlan: MonthPlanCreateNestedOneWithoutWeekPlansInput
  }

  export type WeekPlanUncheckedCreateWithoutUserInput = {
    id?: string
    monthPlanId: string
    weekNumber: number
    year: number
    startDate: Date | string
    endDate: Date | string
    topOutcomes?: WeekPlanCreatetopOutcomesInput | string[]
    plannedClientHours?: number | null
    plannedPersonalHours?: number | null
    challenges?: WeekPlanCreatechallengesInput | string[]
    keyWins?: WeekPlanCreatekeyWinsInput | string[]
    lessonsLearned?: WeekPlanCreatelessonsLearnedInput | string[]
    rating?: number | null
    reviewNotes?: string | null
    dayPlans?: DayPlanUncheckedCreateNestedManyWithoutWeekPlanInput
    weekFocuses?: WeekFocusUncheckedCreateNestedManyWithoutWeekPlanInput
  }

  export type WeekPlanCreateOrConnectWithoutUserInput = {
    where: WeekPlanWhereUniqueInput
    create: XOR<WeekPlanCreateWithoutUserInput, WeekPlanUncheckedCreateWithoutUserInput>
  }

  export type WeekPlanCreateManyUserInputEnvelope = {
    data: WeekPlanCreateManyUserInput | WeekPlanCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WellBeingEntryCreateWithoutUserInput = {
    id?: string
    date: Date | string
    morningEnergy?: number | null
    afternoonEnergy?: number | null
    eveningEnergy?: number | null
    averageEnergy?: number | null
    exerciseMinutes?: number
    exerciseType?: string | null
    readingMinutes?: number
    learningMinutes?: number
    meditationMinutes?: number
    sleepHours?: number | null
    sleepQuality?: number | null
    morningJournal?: string | null
    eveningReflection?: string | null
    gratitude?: WellBeingEntryCreategratitudeInput | string[]
    dailyWin?: string | null
    mood?: number | null
    stressLevel?: number | null
    focusQuality?: number | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type WellBeingEntryUncheckedCreateWithoutUserInput = {
    id?: string
    date: Date | string
    morningEnergy?: number | null
    afternoonEnergy?: number | null
    eveningEnergy?: number | null
    averageEnergy?: number | null
    exerciseMinutes?: number
    exerciseType?: string | null
    readingMinutes?: number
    learningMinutes?: number
    meditationMinutes?: number
    sleepHours?: number | null
    sleepQuality?: number | null
    morningJournal?: string | null
    eveningReflection?: string | null
    gratitude?: WellBeingEntryCreategratitudeInput | string[]
    dailyWin?: string | null
    mood?: number | null
    stressLevel?: number | null
    focusQuality?: number | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type WellBeingEntryCreateOrConnectWithoutUserInput = {
    where: WellBeingEntryWhereUniqueInput
    create: XOR<WellBeingEntryCreateWithoutUserInput, WellBeingEntryUncheckedCreateWithoutUserInput>
  }

  export type WellBeingEntryCreateManyUserInputEnvelope = {
    data: WellBeingEntryCreateManyUserInput | WellBeingEntryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type YearPlanCreateWithoutUserInput = {
    id?: string
    year: number
    theme: string
    vision: string
    focusAreas?: YearPlanCreatefocusAreasInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    goals?: GoalCreateNestedManyWithoutYearPlanInput
    quarterPlans?: QuarterPlanCreateNestedManyWithoutYearPlanInput
  }

  export type YearPlanUncheckedCreateWithoutUserInput = {
    id?: string
    year: number
    theme: string
    vision: string
    focusAreas?: YearPlanCreatefocusAreasInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    goals?: GoalUncheckedCreateNestedManyWithoutYearPlanInput
    quarterPlans?: QuarterPlanUncheckedCreateNestedManyWithoutYearPlanInput
  }

  export type YearPlanCreateOrConnectWithoutUserInput = {
    where: YearPlanWhereUniqueInput
    create: XOR<YearPlanCreateWithoutUserInput, YearPlanUncheckedCreateWithoutUserInput>
  }

  export type YearPlanCreateManyUserInputEnvelope = {
    data: YearPlanCreateManyUserInput | YearPlanCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AnalyticsEventUpsertWithWhereUniqueWithoutUserInput = {
    where: AnalyticsEventWhereUniqueInput
    update: XOR<AnalyticsEventUpdateWithoutUserInput, AnalyticsEventUncheckedUpdateWithoutUserInput>
    create: XOR<AnalyticsEventCreateWithoutUserInput, AnalyticsEventUncheckedCreateWithoutUserInput>
  }

  export type AnalyticsEventUpdateWithWhereUniqueWithoutUserInput = {
    where: AnalyticsEventWhereUniqueInput
    data: XOR<AnalyticsEventUpdateWithoutUserInput, AnalyticsEventUncheckedUpdateWithoutUserInput>
  }

  export type AnalyticsEventUpdateManyWithWhereWithoutUserInput = {
    where: AnalyticsEventScalarWhereInput
    data: XOR<AnalyticsEventUpdateManyMutationInput, AnalyticsEventUncheckedUpdateManyWithoutUserInput>
  }

  export type AnalyticsEventScalarWhereInput = {
    AND?: AnalyticsEventScalarWhereInput | AnalyticsEventScalarWhereInput[]
    OR?: AnalyticsEventScalarWhereInput[]
    NOT?: AnalyticsEventScalarWhereInput | AnalyticsEventScalarWhereInput[]
    id?: StringFilter<"AnalyticsEvent"> | string
    userId?: StringFilter<"AnalyticsEvent"> | string
    eventType?: StringFilter<"AnalyticsEvent"> | string
    eventData?: JsonNullableFilter<"AnalyticsEvent">
    sessionId?: StringNullableFilter<"AnalyticsEvent"> | string | null
    createdAt?: DateTimeFilter<"AnalyticsEvent"> | Date | string
  }

  export type CalendarEventUpsertWithWhereUniqueWithoutUserInput = {
    where: CalendarEventWhereUniqueInput
    update: XOR<CalendarEventUpdateWithoutUserInput, CalendarEventUncheckedUpdateWithoutUserInput>
    create: XOR<CalendarEventCreateWithoutUserInput, CalendarEventUncheckedCreateWithoutUserInput>
  }

  export type CalendarEventUpdateWithWhereUniqueWithoutUserInput = {
    where: CalendarEventWhereUniqueInput
    data: XOR<CalendarEventUpdateWithoutUserInput, CalendarEventUncheckedUpdateWithoutUserInput>
  }

  export type CalendarEventUpdateManyWithWhereWithoutUserInput = {
    where: CalendarEventScalarWhereInput
    data: XOR<CalendarEventUpdateManyMutationInput, CalendarEventUncheckedUpdateManyWithoutUserInput>
  }

  export type CalendarEventScalarWhereInput = {
    AND?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
    OR?: CalendarEventScalarWhereInput[]
    NOT?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
    id?: StringFilter<"CalendarEvent"> | string
    userId?: StringFilter<"CalendarEvent"> | string
    title?: StringFilter<"CalendarEvent"> | string
    description?: StringNullableFilter<"CalendarEvent"> | string | null
    startTime?: DateTimeFilter<"CalendarEvent"> | Date | string
    endTime?: DateTimeFilter<"CalendarEvent"> | Date | string
    allDay?: BoolFilter<"CalendarEvent"> | boolean
    timezone?: StringFilter<"CalendarEvent"> | string
    isRecurring?: BoolFilter<"CalendarEvent"> | boolean
    recurrenceRule?: StringNullableFilter<"CalendarEvent"> | string | null
    projectId?: StringNullableFilter<"CalendarEvent"> | string | null
    taskId?: StringNullableFilter<"CalendarEvent"> | string | null
    clientId?: StringNullableFilter<"CalendarEvent"> | string | null
    meetingId?: StringNullableFilter<"CalendarEvent"> | string | null
    type?: StringFilter<"CalendarEvent"> | string
    reminders?: JsonNullableListFilter<"CalendarEvent">
    color?: StringNullableFilter<"CalendarEvent"> | string | null
    location?: StringNullableFilter<"CalendarEvent"> | string | null
    attendees?: StringNullableListFilter<"CalendarEvent">
    externalCalendarId?: StringNullableFilter<"CalendarEvent"> | string | null
    externalEventId?: StringNullableFilter<"CalendarEvent"> | string | null
    syncStatus?: StringNullableFilter<"CalendarEvent"> | string | null
    createdAt?: DateTimeFilter<"CalendarEvent"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarEvent"> | Date | string
  }

  export type CaptureUpsertWithWhereUniqueWithoutUserInput = {
    where: CaptureWhereUniqueInput
    update: XOR<CaptureUpdateWithoutUserInput, CaptureUncheckedUpdateWithoutUserInput>
    create: XOR<CaptureCreateWithoutUserInput, CaptureUncheckedCreateWithoutUserInput>
  }

  export type CaptureUpdateWithWhereUniqueWithoutUserInput = {
    where: CaptureWhereUniqueInput
    data: XOR<CaptureUpdateWithoutUserInput, CaptureUncheckedUpdateWithoutUserInput>
  }

  export type CaptureUpdateManyWithWhereWithoutUserInput = {
    where: CaptureScalarWhereInput
    data: XOR<CaptureUpdateManyMutationInput, CaptureUncheckedUpdateManyWithoutUserInput>
  }

  export type CaptureScalarWhereInput = {
    AND?: CaptureScalarWhereInput | CaptureScalarWhereInput[]
    OR?: CaptureScalarWhereInput[]
    NOT?: CaptureScalarWhereInput | CaptureScalarWhereInput[]
    id?: StringFilter<"Capture"> | string
    userId?: StringFilter<"Capture"> | string
    type?: StringFilter<"Capture"> | string
    content?: StringFilter<"Capture"> | string
    transcription?: StringNullableFilter<"Capture"> | string | null
    status?: StringFilter<"Capture"> | string
    convertedToTaskId?: StringNullableFilter<"Capture"> | string | null
    convertedToNoteId?: StringNullableFilter<"Capture"> | string | null
    suggestedProject?: StringNullableFilter<"Capture"> | string | null
    suggestedDueDate?: DateTimeNullableFilter<"Capture"> | Date | string | null
    suggestedPriority?: StringNullableFilter<"Capture"> | string | null
    tags?: StringNullableListFilter<"Capture">
    createdAt?: DateTimeFilter<"Capture"> | Date | string
    processedAt?: DateTimeNullableFilter<"Capture"> | Date | string | null
  }

  export type ClientUpsertWithWhereUniqueWithoutUserInput = {
    where: ClientWhereUniqueInput
    update: XOR<ClientUpdateWithoutUserInput, ClientUncheckedUpdateWithoutUserInput>
    create: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
  }

  export type ClientUpdateWithWhereUniqueWithoutUserInput = {
    where: ClientWhereUniqueInput
    data: XOR<ClientUpdateWithoutUserInput, ClientUncheckedUpdateWithoutUserInput>
  }

  export type ClientUpdateManyWithWhereWithoutUserInput = {
    where: ClientScalarWhereInput
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyWithoutUserInput>
  }

  export type ClientScalarWhereInput = {
    AND?: ClientScalarWhereInput | ClientScalarWhereInput[]
    OR?: ClientScalarWhereInput[]
    NOT?: ClientScalarWhereInput | ClientScalarWhereInput[]
    id?: StringFilter<"Client"> | string
    userId?: StringFilter<"Client"> | string
    name?: StringFilter<"Client"> | string
    companyName?: StringNullableFilter<"Client"> | string | null
    email?: StringFilter<"Client"> | string
    phone?: StringNullableFilter<"Client"> | string | null
    primaryContact?: JsonNullableFilter<"Client">
    additionalContacts?: JsonNullableListFilter<"Client">
    industry?: StringNullableFilter<"Client"> | string | null
    website?: StringNullableFilter<"Client"> | string | null
    timezone?: StringNullableFilter<"Client"> | string | null
    relationshipHealth?: FloatNullableFilter<"Client"> | number | null
    lastContactedAt?: DateTimeNullableFilter<"Client"> | Date | string | null
    preferredCommunication?: StringNullableFilter<"Client"> | string | null
    defaultHourlyRate?: FloatNullableFilter<"Client"> | number | null
    paymentTerms?: StringNullableFilter<"Client"> | string | null
    outstandingBalance?: FloatFilter<"Client"> | number
    notes?: StringNullableFilter<"Client"> | string | null
    tags?: StringNullableListFilter<"Client">
    status?: StringFilter<"Client"> | string
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    lastInteractionAt?: DateTimeNullableFilter<"Client"> | Date | string | null
  }

  export type DayPlanUpsertWithWhereUniqueWithoutUserInput = {
    where: DayPlanWhereUniqueInput
    update: XOR<DayPlanUpdateWithoutUserInput, DayPlanUncheckedUpdateWithoutUserInput>
    create: XOR<DayPlanCreateWithoutUserInput, DayPlanUncheckedCreateWithoutUserInput>
  }

  export type DayPlanUpdateWithWhereUniqueWithoutUserInput = {
    where: DayPlanWhereUniqueInput
    data: XOR<DayPlanUpdateWithoutUserInput, DayPlanUncheckedUpdateWithoutUserInput>
  }

  export type DayPlanUpdateManyWithWhereWithoutUserInput = {
    where: DayPlanScalarWhereInput
    data: XOR<DayPlanUpdateManyMutationInput, DayPlanUncheckedUpdateManyWithoutUserInput>
  }

  export type DayPlanScalarWhereInput = {
    AND?: DayPlanScalarWhereInput | DayPlanScalarWhereInput[]
    OR?: DayPlanScalarWhereInput[]
    NOT?: DayPlanScalarWhereInput | DayPlanScalarWhereInput[]
    id?: StringFilter<"DayPlan"> | string
    weekPlanId?: StringFilter<"DayPlan"> | string
    date?: DateTimeFilter<"DayPlan"> | Date | string
    topPriorities?: StringNullableListFilter<"DayPlan">
    morningEnergy?: FloatNullableFilter<"DayPlan"> | number | null
    afternoonEnergy?: FloatNullableFilter<"DayPlan"> | number | null
    eveningEnergy?: FloatNullableFilter<"DayPlan"> | number | null
    dailyWin?: StringNullableFilter<"DayPlan"> | string | null
    gratitude?: StringNullableListFilter<"DayPlan">
    tomorrowPrep?: StringNullableListFilter<"DayPlan">
    completionRate?: FloatFilter<"DayPlan"> | number
    userId?: StringFilter<"DayPlan"> | string
  }

  export type MeetingUpsertWithWhereUniqueWithoutUserInput = {
    where: MeetingWhereUniqueInput
    update: XOR<MeetingUpdateWithoutUserInput, MeetingUncheckedUpdateWithoutUserInput>
    create: XOR<MeetingCreateWithoutUserInput, MeetingUncheckedCreateWithoutUserInput>
  }

  export type MeetingUpdateWithWhereUniqueWithoutUserInput = {
    where: MeetingWhereUniqueInput
    data: XOR<MeetingUpdateWithoutUserInput, MeetingUncheckedUpdateWithoutUserInput>
  }

  export type MeetingUpdateManyWithWhereWithoutUserInput = {
    where: MeetingScalarWhereInput
    data: XOR<MeetingUpdateManyMutationInput, MeetingUncheckedUpdateManyWithoutUserInput>
  }

  export type MeetingScalarWhereInput = {
    AND?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
    OR?: MeetingScalarWhereInput[]
    NOT?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
    id?: StringFilter<"Meeting"> | string
    clientId?: StringNullableFilter<"Meeting"> | string | null
    projectId?: StringNullableFilter<"Meeting"> | string | null
    title?: StringFilter<"Meeting"> | string
    description?: StringNullableFilter<"Meeting"> | string | null
    type?: StringFilter<"Meeting"> | string
    scheduledAt?: DateTimeFilter<"Meeting"> | Date | string
    duration?: IntFilter<"Meeting"> | number
    timezone?: StringFilter<"Meeting"> | string
    organizer?: StringFilter<"Meeting"> | string
    requiredAttendees?: StringNullableListFilter<"Meeting">
    optionalAttendees?: StringNullableListFilter<"Meeting">
    location?: StringNullableFilter<"Meeting"> | string | null
    meetingLink?: StringNullableFilter<"Meeting"> | string | null
    agenda?: StringNullableFilter<"Meeting"> | string | null
    meetingNotes?: StringNullableFilter<"Meeting"> | string | null
    actionItems?: JsonNullableListFilter<"Meeting">
    decisions?: StringNullableListFilter<"Meeting">
    status?: StringFilter<"Meeting"> | string
    createdAt?: DateTimeFilter<"Meeting"> | Date | string
    updatedAt?: DateTimeFilter<"Meeting"> | Date | string
    userId?: StringFilter<"Meeting"> | string
  }

  export type NoteUpsertWithWhereUniqueWithoutUserInput = {
    where: NoteWhereUniqueInput
    update: XOR<NoteUpdateWithoutUserInput, NoteUncheckedUpdateWithoutUserInput>
    create: XOR<NoteCreateWithoutUserInput, NoteUncheckedCreateWithoutUserInput>
  }

  export type NoteUpdateWithWhereUniqueWithoutUserInput = {
    where: NoteWhereUniqueInput
    data: XOR<NoteUpdateWithoutUserInput, NoteUncheckedUpdateWithoutUserInput>
  }

  export type NoteUpdateManyWithWhereWithoutUserInput = {
    where: NoteScalarWhereInput
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyWithoutUserInput>
  }

  export type NoteScalarWhereInput = {
    AND?: NoteScalarWhereInput | NoteScalarWhereInput[]
    OR?: NoteScalarWhereInput[]
    NOT?: NoteScalarWhereInput | NoteScalarWhereInput[]
    id?: StringFilter<"Note"> | string
    userId?: StringFilter<"Note"> | string
    content?: StringFilter<"Note"> | string
    goalId?: StringNullableFilter<"Note"> | string | null
    keyStepId?: StringNullableFilter<"Note"> | string | null
    dayPlanId?: StringNullableFilter<"Note"> | string | null
    createdAt?: DateTimeFilter<"Note"> | Date | string
    updatedAt?: DateTimeFilter<"Note"> | Date | string
  }

  export type ProjectUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutUserInput, ProjectUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutUserInput, ProjectUncheckedUpdateWithoutUserInput>
  }

  export type ProjectUpdateManyWithWhereWithoutUserInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: StringFilter<"Project"> | string
    userId?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    type?: StringFilter<"Project"> | string
    status?: StringFilter<"Project"> | string
    clientId?: StringNullableFilter<"Project"> | string | null
    billable?: BoolFilter<"Project"> | boolean
    hourlyRate?: FloatNullableFilter<"Project"> | number | null
    budgetHours?: FloatNullableFilter<"Project"> | number | null
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    deadline?: DateTimeNullableFilter<"Project"> | Date | string | null
    estimatedHours?: FloatNullableFilter<"Project"> | number | null
    actualHoursSpent?: FloatFilter<"Project"> | number
    completionPercentage?: FloatFilter<"Project"> | number
    goalId?: StringNullableFilter<"Project"> | string | null
    parentProjectId?: StringNullableFilter<"Project"> | string | null
    priority?: StringFilter<"Project"> | string
    tags?: StringNullableListFilter<"Project">
    color?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    completedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    archivedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    icon?: StringNullableFilter<"Project"> | string | null
  }

  export type ResearchUpsertWithWhereUniqueWithoutUserInput = {
    where: ResearchWhereUniqueInput
    update: XOR<ResearchUpdateWithoutUserInput, ResearchUncheckedUpdateWithoutUserInput>
    create: XOR<ResearchCreateWithoutUserInput, ResearchUncheckedCreateWithoutUserInput>
  }

  export type ResearchUpdateWithWhereUniqueWithoutUserInput = {
    where: ResearchWhereUniqueInput
    data: XOR<ResearchUpdateWithoutUserInput, ResearchUncheckedUpdateWithoutUserInput>
  }

  export type ResearchUpdateManyWithWhereWithoutUserInput = {
    where: ResearchScalarWhereInput
    data: XOR<ResearchUpdateManyMutationInput, ResearchUncheckedUpdateManyWithoutUserInput>
  }

  export type ResearchScalarWhereInput = {
    AND?: ResearchScalarWhereInput | ResearchScalarWhereInput[]
    OR?: ResearchScalarWhereInput[]
    NOT?: ResearchScalarWhereInput | ResearchScalarWhereInput[]
    id?: StringFilter<"Research"> | string
    userId?: StringFilter<"Research"> | string
    title?: StringFilter<"Research"> | string
    scope?: EnumResearchScopeFilter<"Research"> | $Enums.ResearchScope
    searchMethod?: EnumSearchMethodFilter<"Research"> | $Enums.SearchMethod
    status?: EnumResearchStatusFilter<"Research"> | $Enums.ResearchStatus
    originalPrompt?: StringFilter<"Research"> | string
    refinedPrompt?: StringFilter<"Research"> | string
    rawData?: JsonNullableFilter<"Research">
    progress?: IntFilter<"Research"> | number
    errorMessage?: StringNullableFilter<"Research"> | string | null
    goalId?: StringNullableFilter<"Research"> | string | null
    isFavorited?: BoolFilter<"Research"> | boolean
    createdAt?: DateTimeFilter<"Research"> | Date | string
    updatedAt?: DateTimeFilter<"Research"> | Date | string
    completedAt?: DateTimeNullableFilter<"Research"> | Date | string | null
  }

  export type TaskUpsertWithWhereUniqueWithoutUserInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutUserInput, TaskUncheckedUpdateWithoutUserInput>
    create: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutUserInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutUserInput, TaskUncheckedUpdateWithoutUserInput>
  }

  export type TaskUpdateManyWithWhereWithoutUserInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutUserInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: StringFilter<"Task"> | string
    userId?: StringFilter<"Task"> | string
    projectId?: StringNullableFilter<"Task"> | string | null
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: StringFilter<"Task"> | string
    startedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    estimatedMinutes?: IntNullableFilter<"Task"> | number | null
    actualMinutes?: IntFilter<"Task"> | number
    timerRunning?: BoolFilter<"Task"> | boolean
    currentTimerStart?: DateTimeNullableFilter<"Task"> | Date | string | null
    scheduledDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    priority?: StringFilter<"Task"> | string
    type?: StringFilter<"Task"> | string
    tags?: StringNullableListFilter<"Task">
    parentTaskId?: StringNullableFilter<"Task"> | string | null
    dependsOn?: StringNullableListFilter<"Task">
    blocks?: StringNullableListFilter<"Task">
    energyRequired?: FloatNullableFilter<"Task"> | number | null
    isAdHoc?: BoolFilter<"Task"> | boolean
    isRecurring?: BoolFilter<"Task"> | boolean
    recurringPattern?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    meetingId?: StringNullableFilter<"Task"> | string | null
    goalId?: StringNullableFilter<"Task"> | string | null
    keyStepId?: StringNullableFilter<"Task"> | string | null
  }

  export type TimeEntryUpsertWithWhereUniqueWithoutUserInput = {
    where: TimeEntryWhereUniqueInput
    update: XOR<TimeEntryUpdateWithoutUserInput, TimeEntryUncheckedUpdateWithoutUserInput>
    create: XOR<TimeEntryCreateWithoutUserInput, TimeEntryUncheckedCreateWithoutUserInput>
  }

  export type TimeEntryUpdateWithWhereUniqueWithoutUserInput = {
    where: TimeEntryWhereUniqueInput
    data: XOR<TimeEntryUpdateWithoutUserInput, TimeEntryUncheckedUpdateWithoutUserInput>
  }

  export type TimeEntryUpdateManyWithWhereWithoutUserInput = {
    where: TimeEntryScalarWhereInput
    data: XOR<TimeEntryUpdateManyMutationInput, TimeEntryUncheckedUpdateManyWithoutUserInput>
  }

  export type TimeEntryScalarWhereInput = {
    AND?: TimeEntryScalarWhereInput | TimeEntryScalarWhereInput[]
    OR?: TimeEntryScalarWhereInput[]
    NOT?: TimeEntryScalarWhereInput | TimeEntryScalarWhereInput[]
    id?: StringFilter<"TimeEntry"> | string
    userId?: StringFilter<"TimeEntry"> | string
    taskId?: StringNullableFilter<"TimeEntry"> | string | null
    projectId?: StringNullableFilter<"TimeEntry"> | string | null
    clientId?: StringNullableFilter<"TimeEntry"> | string | null
    startTime?: DateTimeFilter<"TimeEntry"> | Date | string
    endTime?: DateTimeNullableFilter<"TimeEntry"> | Date | string | null
    duration?: IntFilter<"TimeEntry"> | number
    type?: StringFilter<"TimeEntry"> | string
    description?: StringNullableFilter<"TimeEntry"> | string | null
    tags?: StringNullableListFilter<"TimeEntry">
    focusQuality?: FloatNullableFilter<"TimeEntry"> | number | null
    energyBefore?: FloatNullableFilter<"TimeEntry"> | number | null
    energyAfter?: FloatNullableFilter<"TimeEntry"> | number | null
    distractions?: IntFilter<"TimeEntry"> | number
    billable?: BoolFilter<"TimeEntry"> | boolean
    hourlyRate?: FloatNullableFilter<"TimeEntry"> | number | null
    amount?: FloatFilter<"TimeEntry"> | number
    invoiced?: BoolFilter<"TimeEntry"> | boolean
    createdAt?: DateTimeFilter<"TimeEntry"> | Date | string
    updatedAt?: DateTimeFilter<"TimeEntry"> | Date | string
  }

  export type VoiceSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: VoiceSessionWhereUniqueInput
    update: XOR<VoiceSessionUpdateWithoutUserInput, VoiceSessionUncheckedUpdateWithoutUserInput>
    create: XOR<VoiceSessionCreateWithoutUserInput, VoiceSessionUncheckedCreateWithoutUserInput>
  }

  export type VoiceSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: VoiceSessionWhereUniqueInput
    data: XOR<VoiceSessionUpdateWithoutUserInput, VoiceSessionUncheckedUpdateWithoutUserInput>
  }

  export type VoiceSessionUpdateManyWithWhereWithoutUserInput = {
    where: VoiceSessionScalarWhereInput
    data: XOR<VoiceSessionUpdateManyMutationInput, VoiceSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type VoiceSessionScalarWhereInput = {
    AND?: VoiceSessionScalarWhereInput | VoiceSessionScalarWhereInput[]
    OR?: VoiceSessionScalarWhereInput[]
    NOT?: VoiceSessionScalarWhereInput | VoiceSessionScalarWhereInput[]
    id?: StringFilter<"VoiceSession"> | string
    userId?: StringFilter<"VoiceSession"> | string
    title?: StringFilter<"VoiceSession"> | string
    duration?: IntFilter<"VoiceSession"> | number
    recordedAt?: DateTimeFilter<"VoiceSession"> | Date | string
    audioFileUrl?: StringFilter<"VoiceSession"> | string
    waveformData?: JsonNullableFilter<"VoiceSession">
    transcription?: StringNullableFilter<"VoiceSession"> | string | null
    speakers?: JsonNullableListFilter<"VoiceSession">
    timestamps?: JsonNullableListFilter<"VoiceSession">
    summary?: StringNullableFilter<"VoiceSession"> | string | null
    keyPoints?: StringNullableListFilter<"VoiceSession">
    actionItems?: JsonNullableListFilter<"VoiceSession">
    projectId?: StringNullableFilter<"VoiceSession"> | string | null
    tags?: StringNullableListFilter<"VoiceSession">
    processed?: BoolFilter<"VoiceSession"> | boolean
    archivedAt?: DateTimeNullableFilter<"VoiceSession"> | Date | string | null
    createdAt?: DateTimeFilter<"VoiceSession"> | Date | string
  }

  export type WeekPlanUpsertWithWhereUniqueWithoutUserInput = {
    where: WeekPlanWhereUniqueInput
    update: XOR<WeekPlanUpdateWithoutUserInput, WeekPlanUncheckedUpdateWithoutUserInput>
    create: XOR<WeekPlanCreateWithoutUserInput, WeekPlanUncheckedCreateWithoutUserInput>
  }

  export type WeekPlanUpdateWithWhereUniqueWithoutUserInput = {
    where: WeekPlanWhereUniqueInput
    data: XOR<WeekPlanUpdateWithoutUserInput, WeekPlanUncheckedUpdateWithoutUserInput>
  }

  export type WeekPlanUpdateManyWithWhereWithoutUserInput = {
    where: WeekPlanScalarWhereInput
    data: XOR<WeekPlanUpdateManyMutationInput, WeekPlanUncheckedUpdateManyWithoutUserInput>
  }

  export type WeekPlanScalarWhereInput = {
    AND?: WeekPlanScalarWhereInput | WeekPlanScalarWhereInput[]
    OR?: WeekPlanScalarWhereInput[]
    NOT?: WeekPlanScalarWhereInput | WeekPlanScalarWhereInput[]
    id?: StringFilter<"WeekPlan"> | string
    monthPlanId?: StringFilter<"WeekPlan"> | string
    weekNumber?: IntFilter<"WeekPlan"> | number
    year?: IntFilter<"WeekPlan"> | number
    startDate?: DateTimeFilter<"WeekPlan"> | Date | string
    endDate?: DateTimeFilter<"WeekPlan"> | Date | string
    topOutcomes?: StringNullableListFilter<"WeekPlan">
    plannedClientHours?: FloatNullableFilter<"WeekPlan"> | number | null
    plannedPersonalHours?: FloatNullableFilter<"WeekPlan"> | number | null
    userId?: StringFilter<"WeekPlan"> | string
    challenges?: StringNullableListFilter<"WeekPlan">
    keyWins?: StringNullableListFilter<"WeekPlan">
    lessonsLearned?: StringNullableListFilter<"WeekPlan">
    rating?: IntNullableFilter<"WeekPlan"> | number | null
    reviewNotes?: StringNullableFilter<"WeekPlan"> | string | null
  }

  export type WellBeingEntryUpsertWithWhereUniqueWithoutUserInput = {
    where: WellBeingEntryWhereUniqueInput
    update: XOR<WellBeingEntryUpdateWithoutUserInput, WellBeingEntryUncheckedUpdateWithoutUserInput>
    create: XOR<WellBeingEntryCreateWithoutUserInput, WellBeingEntryUncheckedCreateWithoutUserInput>
  }

  export type WellBeingEntryUpdateWithWhereUniqueWithoutUserInput = {
    where: WellBeingEntryWhereUniqueInput
    data: XOR<WellBeingEntryUpdateWithoutUserInput, WellBeingEntryUncheckedUpdateWithoutUserInput>
  }

  export type WellBeingEntryUpdateManyWithWhereWithoutUserInput = {
    where: WellBeingEntryScalarWhereInput
    data: XOR<WellBeingEntryUpdateManyMutationInput, WellBeingEntryUncheckedUpdateManyWithoutUserInput>
  }

  export type WellBeingEntryScalarWhereInput = {
    AND?: WellBeingEntryScalarWhereInput | WellBeingEntryScalarWhereInput[]
    OR?: WellBeingEntryScalarWhereInput[]
    NOT?: WellBeingEntryScalarWhereInput | WellBeingEntryScalarWhereInput[]
    id?: StringFilter<"WellBeingEntry"> | string
    userId?: StringFilter<"WellBeingEntry"> | string
    date?: DateTimeFilter<"WellBeingEntry"> | Date | string
    morningEnergy?: FloatNullableFilter<"WellBeingEntry"> | number | null
    afternoonEnergy?: FloatNullableFilter<"WellBeingEntry"> | number | null
    eveningEnergy?: FloatNullableFilter<"WellBeingEntry"> | number | null
    averageEnergy?: FloatNullableFilter<"WellBeingEntry"> | number | null
    exerciseMinutes?: IntFilter<"WellBeingEntry"> | number
    exerciseType?: StringNullableFilter<"WellBeingEntry"> | string | null
    readingMinutes?: IntFilter<"WellBeingEntry"> | number
    learningMinutes?: IntFilter<"WellBeingEntry"> | number
    meditationMinutes?: IntFilter<"WellBeingEntry"> | number
    sleepHours?: FloatNullableFilter<"WellBeingEntry"> | number | null
    sleepQuality?: FloatNullableFilter<"WellBeingEntry"> | number | null
    morningJournal?: StringNullableFilter<"WellBeingEntry"> | string | null
    eveningReflection?: StringNullableFilter<"WellBeingEntry"> | string | null
    gratitude?: StringNullableListFilter<"WellBeingEntry">
    dailyWin?: StringNullableFilter<"WellBeingEntry"> | string | null
    mood?: FloatNullableFilter<"WellBeingEntry"> | number | null
    stressLevel?: FloatNullableFilter<"WellBeingEntry"> | number | null
    focusQuality?: FloatNullableFilter<"WellBeingEntry"> | number | null
    notes?: StringNullableFilter<"WellBeingEntry"> | string | null
    createdAt?: DateTimeFilter<"WellBeingEntry"> | Date | string
  }

  export type YearPlanUpsertWithWhereUniqueWithoutUserInput = {
    where: YearPlanWhereUniqueInput
    update: XOR<YearPlanUpdateWithoutUserInput, YearPlanUncheckedUpdateWithoutUserInput>
    create: XOR<YearPlanCreateWithoutUserInput, YearPlanUncheckedCreateWithoutUserInput>
  }

  export type YearPlanUpdateWithWhereUniqueWithoutUserInput = {
    where: YearPlanWhereUniqueInput
    data: XOR<YearPlanUpdateWithoutUserInput, YearPlanUncheckedUpdateWithoutUserInput>
  }

  export type YearPlanUpdateManyWithWhereWithoutUserInput = {
    where: YearPlanScalarWhereInput
    data: XOR<YearPlanUpdateManyMutationInput, YearPlanUncheckedUpdateManyWithoutUserInput>
  }

  export type YearPlanScalarWhereInput = {
    AND?: YearPlanScalarWhereInput | YearPlanScalarWhereInput[]
    OR?: YearPlanScalarWhereInput[]
    NOT?: YearPlanScalarWhereInput | YearPlanScalarWhereInput[]
    id?: StringFilter<"YearPlan"> | string
    userId?: StringFilter<"YearPlan"> | string
    year?: IntFilter<"YearPlan"> | number
    theme?: StringFilter<"YearPlan"> | string
    vision?: StringFilter<"YearPlan"> | string
    focusAreas?: StringNullableListFilter<"YearPlan">
    createdAt?: DateTimeFilter<"YearPlan"> | Date | string
    updatedAt?: DateTimeFilter<"YearPlan"> | Date | string
    status?: StringFilter<"YearPlan"> | string
  }

  export type GoalCreateWithoutYearPlanInput = {
    id?: string
    title: string
    description?: string | null
    category: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    kpis?: GoalCreatekpisInput | string[]
    priority?: string
    progress?: number
    risks?: GoalCreaterisksInput | string[]
    strategies?: GoalCreatestrategiesInput | string[]
    targetDate?: Date | string | null
    keySteps?: KeyStepCreateNestedManyWithoutGoalInput
    milestones?: MilestoneCreateNestedManyWithoutGoalInput
    notes?: NoteCreateNestedManyWithoutGoalInput
    quarterFocuses?: QuarterFocusCreateNestedManyWithoutGoalInput
    researches?: ResearchCreateNestedManyWithoutGoalInput
    tasks?: TaskCreateNestedManyWithoutGoalInput
  }

  export type GoalUncheckedCreateWithoutYearPlanInput = {
    id?: string
    title: string
    description?: string | null
    category: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    kpis?: GoalCreatekpisInput | string[]
    priority?: string
    progress?: number
    risks?: GoalCreaterisksInput | string[]
    strategies?: GoalCreatestrategiesInput | string[]
    targetDate?: Date | string | null
    keySteps?: KeyStepUncheckedCreateNestedManyWithoutGoalInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutGoalInput
    notes?: NoteUncheckedCreateNestedManyWithoutGoalInput
    quarterFocuses?: QuarterFocusUncheckedCreateNestedManyWithoutGoalInput
    researches?: ResearchUncheckedCreateNestedManyWithoutGoalInput
    tasks?: TaskUncheckedCreateNestedManyWithoutGoalInput
  }

  export type GoalCreateOrConnectWithoutYearPlanInput = {
    where: GoalWhereUniqueInput
    create: XOR<GoalCreateWithoutYearPlanInput, GoalUncheckedCreateWithoutYearPlanInput>
  }

  export type GoalCreateManyYearPlanInputEnvelope = {
    data: GoalCreateManyYearPlanInput | GoalCreateManyYearPlanInput[]
    skipDuplicates?: boolean
  }

  export type QuarterPlanCreateWithoutYearPlanInput = {
    id?: string
    quarter: number
    theme: string
    startDate: Date | string
    endDate: Date | string
    monthPlans?: MonthPlanCreateNestedManyWithoutQuarterPlanInput
    quarterFocuses?: QuarterFocusCreateNestedManyWithoutQuarterPlanInput
    objectives?: QuarterObjectiveCreateNestedManyWithoutQuarterPlanInput
  }

  export type QuarterPlanUncheckedCreateWithoutYearPlanInput = {
    id?: string
    quarter: number
    theme: string
    startDate: Date | string
    endDate: Date | string
    monthPlans?: MonthPlanUncheckedCreateNestedManyWithoutQuarterPlanInput
    quarterFocuses?: QuarterFocusUncheckedCreateNestedManyWithoutQuarterPlanInput
    objectives?: QuarterObjectiveUncheckedCreateNestedManyWithoutQuarterPlanInput
  }

  export type QuarterPlanCreateOrConnectWithoutYearPlanInput = {
    where: QuarterPlanWhereUniqueInput
    create: XOR<QuarterPlanCreateWithoutYearPlanInput, QuarterPlanUncheckedCreateWithoutYearPlanInput>
  }

  export type QuarterPlanCreateManyYearPlanInputEnvelope = {
    data: QuarterPlanCreateManyYearPlanInput | QuarterPlanCreateManyYearPlanInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutYearPlansInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    geminiApiKey?: string | null
    geminiModel?: string
    groqApiKey?: string | null
    llmProvider?: string
    serperApiKey?: string | null
    researchLimit?: number
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    captures?: CaptureCreateNestedManyWithoutUserInput
    clients?: ClientCreateNestedManyWithoutUserInput
    dayPlans?: DayPlanCreateNestedManyWithoutUserInput
    meetings?: MeetingCreateNestedManyWithoutUserInput
    notes?: NoteCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    researches?: ResearchCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    voiceSessions?: VoiceSessionCreateNestedManyWithoutUserInput
    weekPlans?: WeekPlanCreateNestedManyWithoutUserInput
    wellBeingEntries?: WellBeingEntryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutYearPlansInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    geminiApiKey?: string | null
    geminiModel?: string
    groqApiKey?: string | null
    llmProvider?: string
    serperApiKey?: string | null
    researchLimit?: number
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    captures?: CaptureUncheckedCreateNestedManyWithoutUserInput
    clients?: ClientUncheckedCreateNestedManyWithoutUserInput
    dayPlans?: DayPlanUncheckedCreateNestedManyWithoutUserInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutUserInput
    notes?: NoteUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    researches?: ResearchUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    voiceSessions?: VoiceSessionUncheckedCreateNestedManyWithoutUserInput
    weekPlans?: WeekPlanUncheckedCreateNestedManyWithoutUserInput
    wellBeingEntries?: WellBeingEntryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutYearPlansInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutYearPlansInput, UserUncheckedCreateWithoutYearPlansInput>
  }

  export type GoalUpsertWithWhereUniqueWithoutYearPlanInput = {
    where: GoalWhereUniqueInput
    update: XOR<GoalUpdateWithoutYearPlanInput, GoalUncheckedUpdateWithoutYearPlanInput>
    create: XOR<GoalCreateWithoutYearPlanInput, GoalUncheckedCreateWithoutYearPlanInput>
  }

  export type GoalUpdateWithWhereUniqueWithoutYearPlanInput = {
    where: GoalWhereUniqueInput
    data: XOR<GoalUpdateWithoutYearPlanInput, GoalUncheckedUpdateWithoutYearPlanInput>
  }

  export type GoalUpdateManyWithWhereWithoutYearPlanInput = {
    where: GoalScalarWhereInput
    data: XOR<GoalUpdateManyMutationInput, GoalUncheckedUpdateManyWithoutYearPlanInput>
  }

  export type GoalScalarWhereInput = {
    AND?: GoalScalarWhereInput | GoalScalarWhereInput[]
    OR?: GoalScalarWhereInput[]
    NOT?: GoalScalarWhereInput | GoalScalarWhereInput[]
    id?: StringFilter<"Goal"> | string
    yearPlanId?: StringFilter<"Goal"> | string
    title?: StringFilter<"Goal"> | string
    description?: StringNullableFilter<"Goal"> | string | null
    category?: StringFilter<"Goal"> | string
    status?: StringFilter<"Goal"> | string
    createdAt?: DateTimeFilter<"Goal"> | Date | string
    updatedAt?: DateTimeFilter<"Goal"> | Date | string
    kpis?: StringNullableListFilter<"Goal">
    priority?: StringFilter<"Goal"> | string
    progress?: FloatFilter<"Goal"> | number
    risks?: StringNullableListFilter<"Goal">
    strategies?: StringNullableListFilter<"Goal">
    targetDate?: DateTimeNullableFilter<"Goal"> | Date | string | null
  }

  export type QuarterPlanUpsertWithWhereUniqueWithoutYearPlanInput = {
    where: QuarterPlanWhereUniqueInput
    update: XOR<QuarterPlanUpdateWithoutYearPlanInput, QuarterPlanUncheckedUpdateWithoutYearPlanInput>
    create: XOR<QuarterPlanCreateWithoutYearPlanInput, QuarterPlanUncheckedCreateWithoutYearPlanInput>
  }

  export type QuarterPlanUpdateWithWhereUniqueWithoutYearPlanInput = {
    where: QuarterPlanWhereUniqueInput
    data: XOR<QuarterPlanUpdateWithoutYearPlanInput, QuarterPlanUncheckedUpdateWithoutYearPlanInput>
  }

  export type QuarterPlanUpdateManyWithWhereWithoutYearPlanInput = {
    where: QuarterPlanScalarWhereInput
    data: XOR<QuarterPlanUpdateManyMutationInput, QuarterPlanUncheckedUpdateManyWithoutYearPlanInput>
  }

  export type QuarterPlanScalarWhereInput = {
    AND?: QuarterPlanScalarWhereInput | QuarterPlanScalarWhereInput[]
    OR?: QuarterPlanScalarWhereInput[]
    NOT?: QuarterPlanScalarWhereInput | QuarterPlanScalarWhereInput[]
    id?: StringFilter<"QuarterPlan"> | string
    yearPlanId?: StringFilter<"QuarterPlan"> | string
    quarter?: IntFilter<"QuarterPlan"> | number
    theme?: StringFilter<"QuarterPlan"> | string
    startDate?: DateTimeFilter<"QuarterPlan"> | Date | string
    endDate?: DateTimeFilter<"QuarterPlan"> | Date | string
  }

  export type UserUpsertWithoutYearPlansInput = {
    update: XOR<UserUpdateWithoutYearPlansInput, UserUncheckedUpdateWithoutYearPlansInput>
    create: XOR<UserCreateWithoutYearPlansInput, UserUncheckedCreateWithoutYearPlansInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutYearPlansInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutYearPlansInput, UserUncheckedUpdateWithoutYearPlansInput>
  }

  export type UserUpdateWithoutYearPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    geminiModel?: StringFieldUpdateOperationsInput | string
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    llmProvider?: StringFieldUpdateOperationsInput | string
    serperApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    researchLimit?: IntFieldUpdateOperationsInput | number
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    captures?: CaptureUpdateManyWithoutUserNestedInput
    clients?: ClientUpdateManyWithoutUserNestedInput
    dayPlans?: DayPlanUpdateManyWithoutUserNestedInput
    meetings?: MeetingUpdateManyWithoutUserNestedInput
    notes?: NoteUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    researches?: ResearchUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    voiceSessions?: VoiceSessionUpdateManyWithoutUserNestedInput
    weekPlans?: WeekPlanUpdateManyWithoutUserNestedInput
    wellBeingEntries?: WellBeingEntryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutYearPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    geminiModel?: StringFieldUpdateOperationsInput | string
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    llmProvider?: StringFieldUpdateOperationsInput | string
    serperApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    researchLimit?: IntFieldUpdateOperationsInput | number
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    captures?: CaptureUncheckedUpdateManyWithoutUserNestedInput
    clients?: ClientUncheckedUpdateManyWithoutUserNestedInput
    dayPlans?: DayPlanUncheckedUpdateManyWithoutUserNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutUserNestedInput
    notes?: NoteUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    researches?: ResearchUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    voiceSessions?: VoiceSessionUncheckedUpdateManyWithoutUserNestedInput
    weekPlans?: WeekPlanUncheckedUpdateManyWithoutUserNestedInput
    wellBeingEntries?: WellBeingEntryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type YearPlanCreateWithoutGoalsInput = {
    id?: string
    year: number
    theme: string
    vision: string
    focusAreas?: YearPlanCreatefocusAreasInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    quarterPlans?: QuarterPlanCreateNestedManyWithoutYearPlanInput
    user: UserCreateNestedOneWithoutYearPlansInput
  }

  export type YearPlanUncheckedCreateWithoutGoalsInput = {
    id?: string
    userId: string
    year: number
    theme: string
    vision: string
    focusAreas?: YearPlanCreatefocusAreasInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    quarterPlans?: QuarterPlanUncheckedCreateNestedManyWithoutYearPlanInput
  }

  export type YearPlanCreateOrConnectWithoutGoalsInput = {
    where: YearPlanWhereUniqueInput
    create: XOR<YearPlanCreateWithoutGoalsInput, YearPlanUncheckedCreateWithoutGoalsInput>
  }

  export type KeyStepCreateWithoutGoalInput = {
    id?: string
    title: string
    description?: string | null
    order?: number
    completed?: boolean
    completedAt?: Date | string | null
    progress?: number
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: NoteCreateNestedManyWithoutKeyStepInput
    tasks?: TaskCreateNestedManyWithoutKeyStepInput
  }

  export type KeyStepUncheckedCreateWithoutGoalInput = {
    id?: string
    title: string
    description?: string | null
    order?: number
    completed?: boolean
    completedAt?: Date | string | null
    progress?: number
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: NoteUncheckedCreateNestedManyWithoutKeyStepInput
    tasks?: TaskUncheckedCreateNestedManyWithoutKeyStepInput
  }

  export type KeyStepCreateOrConnectWithoutGoalInput = {
    where: KeyStepWhereUniqueInput
    create: XOR<KeyStepCreateWithoutGoalInput, KeyStepUncheckedCreateWithoutGoalInput>
  }

  export type KeyStepCreateManyGoalInputEnvelope = {
    data: KeyStepCreateManyGoalInput | KeyStepCreateManyGoalInput[]
    skipDuplicates?: boolean
  }

  export type MilestoneCreateWithoutGoalInput = {
    id?: string
    title: string
    targetDate?: Date | string | null
    completed?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MilestoneUncheckedCreateWithoutGoalInput = {
    id?: string
    title: string
    targetDate?: Date | string | null
    completed?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MilestoneCreateOrConnectWithoutGoalInput = {
    where: MilestoneWhereUniqueInput
    create: XOR<MilestoneCreateWithoutGoalInput, MilestoneUncheckedCreateWithoutGoalInput>
  }

  export type MilestoneCreateManyGoalInputEnvelope = {
    data: MilestoneCreateManyGoalInput | MilestoneCreateManyGoalInput[]
    skipDuplicates?: boolean
  }

  export type NoteCreateWithoutGoalInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dayPlan?: DayPlanCreateNestedOneWithoutNotesInput
    keyStep?: KeyStepCreateNestedOneWithoutNotesInput
    user: UserCreateNestedOneWithoutNotesInput
  }

  export type NoteUncheckedCreateWithoutGoalInput = {
    id?: string
    userId: string
    content: string
    keyStepId?: string | null
    dayPlanId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoteCreateOrConnectWithoutGoalInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutGoalInput, NoteUncheckedCreateWithoutGoalInput>
  }

  export type NoteCreateManyGoalInputEnvelope = {
    data: NoteCreateManyGoalInput | NoteCreateManyGoalInput[]
    skipDuplicates?: boolean
  }

  export type QuarterFocusCreateWithoutGoalInput = {
    id?: string
    priority?: number
    progress?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    monthFocuses?: MonthFocusCreateNestedManyWithoutQuarterFocusInput
    quarterPlan: QuarterPlanCreateNestedOneWithoutQuarterFocusesInput
  }

  export type QuarterFocusUncheckedCreateWithoutGoalInput = {
    id?: string
    quarterPlanId: string
    priority?: number
    progress?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    monthFocuses?: MonthFocusUncheckedCreateNestedManyWithoutQuarterFocusInput
  }

  export type QuarterFocusCreateOrConnectWithoutGoalInput = {
    where: QuarterFocusWhereUniqueInput
    create: XOR<QuarterFocusCreateWithoutGoalInput, QuarterFocusUncheckedCreateWithoutGoalInput>
  }

  export type QuarterFocusCreateManyGoalInputEnvelope = {
    data: QuarterFocusCreateManyGoalInput | QuarterFocusCreateManyGoalInput[]
    skipDuplicates?: boolean
  }

  export type ResearchCreateWithoutGoalInput = {
    id?: string
    title: string
    scope: $Enums.ResearchScope
    searchMethod?: $Enums.SearchMethod
    status?: $Enums.ResearchStatus
    originalPrompt: string
    refinedPrompt: string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    errorMessage?: string | null
    isFavorited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    actionItems?: ActionItemCreateNestedManyWithoutResearchInput
    leadData?: LeadDataCreateNestedOneWithoutResearchInput
    user: UserCreateNestedOneWithoutResearchesInput
    insights?: ResearchInsightCreateNestedManyWithoutResearchInput
    sources?: ResearchSourceCreateNestedManyWithoutResearchInput
  }

  export type ResearchUncheckedCreateWithoutGoalInput = {
    id?: string
    userId: string
    title: string
    scope: $Enums.ResearchScope
    searchMethod?: $Enums.SearchMethod
    status?: $Enums.ResearchStatus
    originalPrompt: string
    refinedPrompt: string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    errorMessage?: string | null
    isFavorited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutResearchInput
    leadData?: LeadDataUncheckedCreateNestedOneWithoutResearchInput
    insights?: ResearchInsightUncheckedCreateNestedManyWithoutResearchInput
    sources?: ResearchSourceUncheckedCreateNestedManyWithoutResearchInput
  }

  export type ResearchCreateOrConnectWithoutGoalInput = {
    where: ResearchWhereUniqueInput
    create: XOR<ResearchCreateWithoutGoalInput, ResearchUncheckedCreateWithoutGoalInput>
  }

  export type ResearchCreateManyGoalInputEnvelope = {
    data: ResearchCreateManyGoalInput | ResearchCreateManyGoalInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutGoalInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    estimatedMinutes?: number | null
    actualMinutes?: number
    timerRunning?: boolean
    currentTimerStart?: Date | string | null
    scheduledDate?: Date | string | null
    dueDate?: Date | string | null
    priority: string
    type: string
    tags?: TaskCreatetagsInput | string[]
    parentTaskId?: string | null
    dependsOn?: TaskCreatedependsOnInput | string[]
    blocks?: TaskCreateblocksInput | string[]
    energyRequired?: number | null
    isAdHoc?: boolean
    isRecurring?: boolean
    recurringPattern?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actionItem?: ActionItemCreateNestedOneWithoutConvertedToTaskInput
    keyStep?: KeyStepCreateNestedOneWithoutTasksInput
    meeting?: MeetingCreateNestedOneWithoutTasksInput
    project?: ProjectCreateNestedOneWithoutTasksInput
    user: UserCreateNestedOneWithoutTasksInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutTaskInput
    timeEntries?: TimeEntryCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutGoalInput = {
    id?: string
    userId: string
    projectId?: string | null
    title: string
    description?: string | null
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    estimatedMinutes?: number | null
    actualMinutes?: number
    timerRunning?: boolean
    currentTimerStart?: Date | string | null
    scheduledDate?: Date | string | null
    dueDate?: Date | string | null
    priority: string
    type: string
    tags?: TaskCreatetagsInput | string[]
    parentTaskId?: string | null
    dependsOn?: TaskCreatedependsOnInput | string[]
    blocks?: TaskCreateblocksInput | string[]
    energyRequired?: number | null
    isAdHoc?: boolean
    isRecurring?: boolean
    recurringPattern?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meetingId?: string | null
    keyStepId?: string | null
    actionItem?: ActionItemUncheckedCreateNestedOneWithoutConvertedToTaskInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutTaskInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutGoalInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutGoalInput, TaskUncheckedCreateWithoutGoalInput>
  }

  export type TaskCreateManyGoalInputEnvelope = {
    data: TaskCreateManyGoalInput | TaskCreateManyGoalInput[]
    skipDuplicates?: boolean
  }

  export type YearPlanUpsertWithoutGoalsInput = {
    update: XOR<YearPlanUpdateWithoutGoalsInput, YearPlanUncheckedUpdateWithoutGoalsInput>
    create: XOR<YearPlanCreateWithoutGoalsInput, YearPlanUncheckedCreateWithoutGoalsInput>
    where?: YearPlanWhereInput
  }

  export type YearPlanUpdateToOneWithWhereWithoutGoalsInput = {
    where?: YearPlanWhereInput
    data: XOR<YearPlanUpdateWithoutGoalsInput, YearPlanUncheckedUpdateWithoutGoalsInput>
  }

  export type YearPlanUpdateWithoutGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    theme?: StringFieldUpdateOperationsInput | string
    vision?: StringFieldUpdateOperationsInput | string
    focusAreas?: YearPlanUpdatefocusAreasInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    quarterPlans?: QuarterPlanUpdateManyWithoutYearPlanNestedInput
    user?: UserUpdateOneRequiredWithoutYearPlansNestedInput
  }

  export type YearPlanUncheckedUpdateWithoutGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    theme?: StringFieldUpdateOperationsInput | string
    vision?: StringFieldUpdateOperationsInput | string
    focusAreas?: YearPlanUpdatefocusAreasInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    quarterPlans?: QuarterPlanUncheckedUpdateManyWithoutYearPlanNestedInput
  }

  export type KeyStepUpsertWithWhereUniqueWithoutGoalInput = {
    where: KeyStepWhereUniqueInput
    update: XOR<KeyStepUpdateWithoutGoalInput, KeyStepUncheckedUpdateWithoutGoalInput>
    create: XOR<KeyStepCreateWithoutGoalInput, KeyStepUncheckedCreateWithoutGoalInput>
  }

  export type KeyStepUpdateWithWhereUniqueWithoutGoalInput = {
    where: KeyStepWhereUniqueInput
    data: XOR<KeyStepUpdateWithoutGoalInput, KeyStepUncheckedUpdateWithoutGoalInput>
  }

  export type KeyStepUpdateManyWithWhereWithoutGoalInput = {
    where: KeyStepScalarWhereInput
    data: XOR<KeyStepUpdateManyMutationInput, KeyStepUncheckedUpdateManyWithoutGoalInput>
  }

  export type KeyStepScalarWhereInput = {
    AND?: KeyStepScalarWhereInput | KeyStepScalarWhereInput[]
    OR?: KeyStepScalarWhereInput[]
    NOT?: KeyStepScalarWhereInput | KeyStepScalarWhereInput[]
    id?: StringFilter<"KeyStep"> | string
    goalId?: StringFilter<"KeyStep"> | string
    title?: StringFilter<"KeyStep"> | string
    description?: StringNullableFilter<"KeyStep"> | string | null
    order?: IntFilter<"KeyStep"> | number
    completed?: BoolFilter<"KeyStep"> | boolean
    completedAt?: DateTimeNullableFilter<"KeyStep"> | Date | string | null
    progress?: FloatFilter<"KeyStep"> | number
    targetDate?: DateTimeNullableFilter<"KeyStep"> | Date | string | null
    createdAt?: DateTimeFilter<"KeyStep"> | Date | string
    updatedAt?: DateTimeFilter<"KeyStep"> | Date | string
  }

  export type MilestoneUpsertWithWhereUniqueWithoutGoalInput = {
    where: MilestoneWhereUniqueInput
    update: XOR<MilestoneUpdateWithoutGoalInput, MilestoneUncheckedUpdateWithoutGoalInput>
    create: XOR<MilestoneCreateWithoutGoalInput, MilestoneUncheckedCreateWithoutGoalInput>
  }

  export type MilestoneUpdateWithWhereUniqueWithoutGoalInput = {
    where: MilestoneWhereUniqueInput
    data: XOR<MilestoneUpdateWithoutGoalInput, MilestoneUncheckedUpdateWithoutGoalInput>
  }

  export type MilestoneUpdateManyWithWhereWithoutGoalInput = {
    where: MilestoneScalarWhereInput
    data: XOR<MilestoneUpdateManyMutationInput, MilestoneUncheckedUpdateManyWithoutGoalInput>
  }

  export type MilestoneScalarWhereInput = {
    AND?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
    OR?: MilestoneScalarWhereInput[]
    NOT?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
    id?: StringFilter<"Milestone"> | string
    goalId?: StringFilter<"Milestone"> | string
    title?: StringFilter<"Milestone"> | string
    targetDate?: DateTimeNullableFilter<"Milestone"> | Date | string | null
    completed?: BoolFilter<"Milestone"> | boolean
    completedAt?: DateTimeNullableFilter<"Milestone"> | Date | string | null
    createdAt?: DateTimeFilter<"Milestone"> | Date | string
  }

  export type NoteUpsertWithWhereUniqueWithoutGoalInput = {
    where: NoteWhereUniqueInput
    update: XOR<NoteUpdateWithoutGoalInput, NoteUncheckedUpdateWithoutGoalInput>
    create: XOR<NoteCreateWithoutGoalInput, NoteUncheckedCreateWithoutGoalInput>
  }

  export type NoteUpdateWithWhereUniqueWithoutGoalInput = {
    where: NoteWhereUniqueInput
    data: XOR<NoteUpdateWithoutGoalInput, NoteUncheckedUpdateWithoutGoalInput>
  }

  export type NoteUpdateManyWithWhereWithoutGoalInput = {
    where: NoteScalarWhereInput
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyWithoutGoalInput>
  }

  export type QuarterFocusUpsertWithWhereUniqueWithoutGoalInput = {
    where: QuarterFocusWhereUniqueInput
    update: XOR<QuarterFocusUpdateWithoutGoalInput, QuarterFocusUncheckedUpdateWithoutGoalInput>
    create: XOR<QuarterFocusCreateWithoutGoalInput, QuarterFocusUncheckedCreateWithoutGoalInput>
  }

  export type QuarterFocusUpdateWithWhereUniqueWithoutGoalInput = {
    where: QuarterFocusWhereUniqueInput
    data: XOR<QuarterFocusUpdateWithoutGoalInput, QuarterFocusUncheckedUpdateWithoutGoalInput>
  }

  export type QuarterFocusUpdateManyWithWhereWithoutGoalInput = {
    where: QuarterFocusScalarWhereInput
    data: XOR<QuarterFocusUpdateManyMutationInput, QuarterFocusUncheckedUpdateManyWithoutGoalInput>
  }

  export type QuarterFocusScalarWhereInput = {
    AND?: QuarterFocusScalarWhereInput | QuarterFocusScalarWhereInput[]
    OR?: QuarterFocusScalarWhereInput[]
    NOT?: QuarterFocusScalarWhereInput | QuarterFocusScalarWhereInput[]
    id?: StringFilter<"QuarterFocus"> | string
    quarterPlanId?: StringFilter<"QuarterFocus"> | string
    goalId?: StringFilter<"QuarterFocus"> | string
    priority?: IntFilter<"QuarterFocus"> | number
    progress?: FloatFilter<"QuarterFocus"> | number
    notes?: StringNullableFilter<"QuarterFocus"> | string | null
    createdAt?: DateTimeFilter<"QuarterFocus"> | Date | string
    updatedAt?: DateTimeFilter<"QuarterFocus"> | Date | string
  }

  export type ResearchUpsertWithWhereUniqueWithoutGoalInput = {
    where: ResearchWhereUniqueInput
    update: XOR<ResearchUpdateWithoutGoalInput, ResearchUncheckedUpdateWithoutGoalInput>
    create: XOR<ResearchCreateWithoutGoalInput, ResearchUncheckedCreateWithoutGoalInput>
  }

  export type ResearchUpdateWithWhereUniqueWithoutGoalInput = {
    where: ResearchWhereUniqueInput
    data: XOR<ResearchUpdateWithoutGoalInput, ResearchUncheckedUpdateWithoutGoalInput>
  }

  export type ResearchUpdateManyWithWhereWithoutGoalInput = {
    where: ResearchScalarWhereInput
    data: XOR<ResearchUpdateManyMutationInput, ResearchUncheckedUpdateManyWithoutGoalInput>
  }

  export type TaskUpsertWithWhereUniqueWithoutGoalInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutGoalInput, TaskUncheckedUpdateWithoutGoalInput>
    create: XOR<TaskCreateWithoutGoalInput, TaskUncheckedCreateWithoutGoalInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutGoalInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutGoalInput, TaskUncheckedUpdateWithoutGoalInput>
  }

  export type TaskUpdateManyWithWhereWithoutGoalInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutGoalInput>
  }

  export type GoalCreateWithoutMilestonesInput = {
    id?: string
    title: string
    description?: string | null
    category: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    kpis?: GoalCreatekpisInput | string[]
    priority?: string
    progress?: number
    risks?: GoalCreaterisksInput | string[]
    strategies?: GoalCreatestrategiesInput | string[]
    targetDate?: Date | string | null
    yearPlan: YearPlanCreateNestedOneWithoutGoalsInput
    keySteps?: KeyStepCreateNestedManyWithoutGoalInput
    notes?: NoteCreateNestedManyWithoutGoalInput
    quarterFocuses?: QuarterFocusCreateNestedManyWithoutGoalInput
    researches?: ResearchCreateNestedManyWithoutGoalInput
    tasks?: TaskCreateNestedManyWithoutGoalInput
  }

  export type GoalUncheckedCreateWithoutMilestonesInput = {
    id?: string
    yearPlanId: string
    title: string
    description?: string | null
    category: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    kpis?: GoalCreatekpisInput | string[]
    priority?: string
    progress?: number
    risks?: GoalCreaterisksInput | string[]
    strategies?: GoalCreatestrategiesInput | string[]
    targetDate?: Date | string | null
    keySteps?: KeyStepUncheckedCreateNestedManyWithoutGoalInput
    notes?: NoteUncheckedCreateNestedManyWithoutGoalInput
    quarterFocuses?: QuarterFocusUncheckedCreateNestedManyWithoutGoalInput
    researches?: ResearchUncheckedCreateNestedManyWithoutGoalInput
    tasks?: TaskUncheckedCreateNestedManyWithoutGoalInput
  }

  export type GoalCreateOrConnectWithoutMilestonesInput = {
    where: GoalWhereUniqueInput
    create: XOR<GoalCreateWithoutMilestonesInput, GoalUncheckedCreateWithoutMilestonesInput>
  }

  export type GoalUpsertWithoutMilestonesInput = {
    update: XOR<GoalUpdateWithoutMilestonesInput, GoalUncheckedUpdateWithoutMilestonesInput>
    create: XOR<GoalCreateWithoutMilestonesInput, GoalUncheckedCreateWithoutMilestonesInput>
    where?: GoalWhereInput
  }

  export type GoalUpdateToOneWithWhereWithoutMilestonesInput = {
    where?: GoalWhereInput
    data: XOR<GoalUpdateWithoutMilestonesInput, GoalUncheckedUpdateWithoutMilestonesInput>
  }

  export type GoalUpdateWithoutMilestonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kpis?: GoalUpdatekpisInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    risks?: GoalUpdaterisksInput | string[]
    strategies?: GoalUpdatestrategiesInput | string[]
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    yearPlan?: YearPlanUpdateOneRequiredWithoutGoalsNestedInput
    keySteps?: KeyStepUpdateManyWithoutGoalNestedInput
    notes?: NoteUpdateManyWithoutGoalNestedInput
    quarterFocuses?: QuarterFocusUpdateManyWithoutGoalNestedInput
    researches?: ResearchUpdateManyWithoutGoalNestedInput
    tasks?: TaskUpdateManyWithoutGoalNestedInput
  }

  export type GoalUncheckedUpdateWithoutMilestonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    yearPlanId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kpis?: GoalUpdatekpisInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    risks?: GoalUpdaterisksInput | string[]
    strategies?: GoalUpdatestrategiesInput | string[]
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    keySteps?: KeyStepUncheckedUpdateManyWithoutGoalNestedInput
    notes?: NoteUncheckedUpdateManyWithoutGoalNestedInput
    quarterFocuses?: QuarterFocusUncheckedUpdateManyWithoutGoalNestedInput
    researches?: ResearchUncheckedUpdateManyWithoutGoalNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutGoalNestedInput
  }

  export type GoalCreateWithoutKeyStepsInput = {
    id?: string
    title: string
    description?: string | null
    category: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    kpis?: GoalCreatekpisInput | string[]
    priority?: string
    progress?: number
    risks?: GoalCreaterisksInput | string[]
    strategies?: GoalCreatestrategiesInput | string[]
    targetDate?: Date | string | null
    yearPlan: YearPlanCreateNestedOneWithoutGoalsInput
    milestones?: MilestoneCreateNestedManyWithoutGoalInput
    notes?: NoteCreateNestedManyWithoutGoalInput
    quarterFocuses?: QuarterFocusCreateNestedManyWithoutGoalInput
    researches?: ResearchCreateNestedManyWithoutGoalInput
    tasks?: TaskCreateNestedManyWithoutGoalInput
  }

  export type GoalUncheckedCreateWithoutKeyStepsInput = {
    id?: string
    yearPlanId: string
    title: string
    description?: string | null
    category: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    kpis?: GoalCreatekpisInput | string[]
    priority?: string
    progress?: number
    risks?: GoalCreaterisksInput | string[]
    strategies?: GoalCreatestrategiesInput | string[]
    targetDate?: Date | string | null
    milestones?: MilestoneUncheckedCreateNestedManyWithoutGoalInput
    notes?: NoteUncheckedCreateNestedManyWithoutGoalInput
    quarterFocuses?: QuarterFocusUncheckedCreateNestedManyWithoutGoalInput
    researches?: ResearchUncheckedCreateNestedManyWithoutGoalInput
    tasks?: TaskUncheckedCreateNestedManyWithoutGoalInput
  }

  export type GoalCreateOrConnectWithoutKeyStepsInput = {
    where: GoalWhereUniqueInput
    create: XOR<GoalCreateWithoutKeyStepsInput, GoalUncheckedCreateWithoutKeyStepsInput>
  }

  export type NoteCreateWithoutKeyStepInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dayPlan?: DayPlanCreateNestedOneWithoutNotesInput
    goal?: GoalCreateNestedOneWithoutNotesInput
    user: UserCreateNestedOneWithoutNotesInput
  }

  export type NoteUncheckedCreateWithoutKeyStepInput = {
    id?: string
    userId: string
    content: string
    goalId?: string | null
    dayPlanId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoteCreateOrConnectWithoutKeyStepInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutKeyStepInput, NoteUncheckedCreateWithoutKeyStepInput>
  }

  export type NoteCreateManyKeyStepInputEnvelope = {
    data: NoteCreateManyKeyStepInput | NoteCreateManyKeyStepInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutKeyStepInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    estimatedMinutes?: number | null
    actualMinutes?: number
    timerRunning?: boolean
    currentTimerStart?: Date | string | null
    scheduledDate?: Date | string | null
    dueDate?: Date | string | null
    priority: string
    type: string
    tags?: TaskCreatetagsInput | string[]
    parentTaskId?: string | null
    dependsOn?: TaskCreatedependsOnInput | string[]
    blocks?: TaskCreateblocksInput | string[]
    energyRequired?: number | null
    isAdHoc?: boolean
    isRecurring?: boolean
    recurringPattern?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actionItem?: ActionItemCreateNestedOneWithoutConvertedToTaskInput
    goal?: GoalCreateNestedOneWithoutTasksInput
    meeting?: MeetingCreateNestedOneWithoutTasksInput
    project?: ProjectCreateNestedOneWithoutTasksInput
    user: UserCreateNestedOneWithoutTasksInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutTaskInput
    timeEntries?: TimeEntryCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutKeyStepInput = {
    id?: string
    userId: string
    projectId?: string | null
    title: string
    description?: string | null
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    estimatedMinutes?: number | null
    actualMinutes?: number
    timerRunning?: boolean
    currentTimerStart?: Date | string | null
    scheduledDate?: Date | string | null
    dueDate?: Date | string | null
    priority: string
    type: string
    tags?: TaskCreatetagsInput | string[]
    parentTaskId?: string | null
    dependsOn?: TaskCreatedependsOnInput | string[]
    blocks?: TaskCreateblocksInput | string[]
    energyRequired?: number | null
    isAdHoc?: boolean
    isRecurring?: boolean
    recurringPattern?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meetingId?: string | null
    goalId?: string | null
    actionItem?: ActionItemUncheckedCreateNestedOneWithoutConvertedToTaskInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutTaskInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutKeyStepInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutKeyStepInput, TaskUncheckedCreateWithoutKeyStepInput>
  }

  export type TaskCreateManyKeyStepInputEnvelope = {
    data: TaskCreateManyKeyStepInput | TaskCreateManyKeyStepInput[]
    skipDuplicates?: boolean
  }

  export type GoalUpsertWithoutKeyStepsInput = {
    update: XOR<GoalUpdateWithoutKeyStepsInput, GoalUncheckedUpdateWithoutKeyStepsInput>
    create: XOR<GoalCreateWithoutKeyStepsInput, GoalUncheckedCreateWithoutKeyStepsInput>
    where?: GoalWhereInput
  }

  export type GoalUpdateToOneWithWhereWithoutKeyStepsInput = {
    where?: GoalWhereInput
    data: XOR<GoalUpdateWithoutKeyStepsInput, GoalUncheckedUpdateWithoutKeyStepsInput>
  }

  export type GoalUpdateWithoutKeyStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kpis?: GoalUpdatekpisInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    risks?: GoalUpdaterisksInput | string[]
    strategies?: GoalUpdatestrategiesInput | string[]
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    yearPlan?: YearPlanUpdateOneRequiredWithoutGoalsNestedInput
    milestones?: MilestoneUpdateManyWithoutGoalNestedInput
    notes?: NoteUpdateManyWithoutGoalNestedInput
    quarterFocuses?: QuarterFocusUpdateManyWithoutGoalNestedInput
    researches?: ResearchUpdateManyWithoutGoalNestedInput
    tasks?: TaskUpdateManyWithoutGoalNestedInput
  }

  export type GoalUncheckedUpdateWithoutKeyStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    yearPlanId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kpis?: GoalUpdatekpisInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    risks?: GoalUpdaterisksInput | string[]
    strategies?: GoalUpdatestrategiesInput | string[]
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    milestones?: MilestoneUncheckedUpdateManyWithoutGoalNestedInput
    notes?: NoteUncheckedUpdateManyWithoutGoalNestedInput
    quarterFocuses?: QuarterFocusUncheckedUpdateManyWithoutGoalNestedInput
    researches?: ResearchUncheckedUpdateManyWithoutGoalNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutGoalNestedInput
  }

  export type NoteUpsertWithWhereUniqueWithoutKeyStepInput = {
    where: NoteWhereUniqueInput
    update: XOR<NoteUpdateWithoutKeyStepInput, NoteUncheckedUpdateWithoutKeyStepInput>
    create: XOR<NoteCreateWithoutKeyStepInput, NoteUncheckedCreateWithoutKeyStepInput>
  }

  export type NoteUpdateWithWhereUniqueWithoutKeyStepInput = {
    where: NoteWhereUniqueInput
    data: XOR<NoteUpdateWithoutKeyStepInput, NoteUncheckedUpdateWithoutKeyStepInput>
  }

  export type NoteUpdateManyWithWhereWithoutKeyStepInput = {
    where: NoteScalarWhereInput
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyWithoutKeyStepInput>
  }

  export type TaskUpsertWithWhereUniqueWithoutKeyStepInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutKeyStepInput, TaskUncheckedUpdateWithoutKeyStepInput>
    create: XOR<TaskCreateWithoutKeyStepInput, TaskUncheckedCreateWithoutKeyStepInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutKeyStepInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutKeyStepInput, TaskUncheckedUpdateWithoutKeyStepInput>
  }

  export type TaskUpdateManyWithWhereWithoutKeyStepInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutKeyStepInput>
  }

  export type DayPlanCreateWithoutNotesInput = {
    id?: string
    date: Date | string
    topPriorities?: DayPlanCreatetopPrioritiesInput | string[]
    morningEnergy?: number | null
    afternoonEnergy?: number | null
    eveningEnergy?: number | null
    dailyWin?: string | null
    gratitude?: DayPlanCreategratitudeInput | string[]
    tomorrowPrep?: DayPlanCreatetomorrowPrepInput | string[]
    completionRate?: number
    dayFocuses?: DayFocusCreateNestedManyWithoutDayPlanInput
    user: UserCreateNestedOneWithoutDayPlansInput
    weekPlan: WeekPlanCreateNestedOneWithoutDayPlansInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutDayPlanInput
  }

  export type DayPlanUncheckedCreateWithoutNotesInput = {
    id?: string
    weekPlanId: string
    date: Date | string
    topPriorities?: DayPlanCreatetopPrioritiesInput | string[]
    morningEnergy?: number | null
    afternoonEnergy?: number | null
    eveningEnergy?: number | null
    dailyWin?: string | null
    gratitude?: DayPlanCreategratitudeInput | string[]
    tomorrowPrep?: DayPlanCreatetomorrowPrepInput | string[]
    completionRate?: number
    userId: string
    dayFocuses?: DayFocusUncheckedCreateNestedManyWithoutDayPlanInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutDayPlanInput
  }

  export type DayPlanCreateOrConnectWithoutNotesInput = {
    where: DayPlanWhereUniqueInput
    create: XOR<DayPlanCreateWithoutNotesInput, DayPlanUncheckedCreateWithoutNotesInput>
  }

  export type GoalCreateWithoutNotesInput = {
    id?: string
    title: string
    description?: string | null
    category: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    kpis?: GoalCreatekpisInput | string[]
    priority?: string
    progress?: number
    risks?: GoalCreaterisksInput | string[]
    strategies?: GoalCreatestrategiesInput | string[]
    targetDate?: Date | string | null
    yearPlan: YearPlanCreateNestedOneWithoutGoalsInput
    keySteps?: KeyStepCreateNestedManyWithoutGoalInput
    milestones?: MilestoneCreateNestedManyWithoutGoalInput
    quarterFocuses?: QuarterFocusCreateNestedManyWithoutGoalInput
    researches?: ResearchCreateNestedManyWithoutGoalInput
    tasks?: TaskCreateNestedManyWithoutGoalInput
  }

  export type GoalUncheckedCreateWithoutNotesInput = {
    id?: string
    yearPlanId: string
    title: string
    description?: string | null
    category: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    kpis?: GoalCreatekpisInput | string[]
    priority?: string
    progress?: number
    risks?: GoalCreaterisksInput | string[]
    strategies?: GoalCreatestrategiesInput | string[]
    targetDate?: Date | string | null
    keySteps?: KeyStepUncheckedCreateNestedManyWithoutGoalInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutGoalInput
    quarterFocuses?: QuarterFocusUncheckedCreateNestedManyWithoutGoalInput
    researches?: ResearchUncheckedCreateNestedManyWithoutGoalInput
    tasks?: TaskUncheckedCreateNestedManyWithoutGoalInput
  }

  export type GoalCreateOrConnectWithoutNotesInput = {
    where: GoalWhereUniqueInput
    create: XOR<GoalCreateWithoutNotesInput, GoalUncheckedCreateWithoutNotesInput>
  }

  export type KeyStepCreateWithoutNotesInput = {
    id?: string
    title: string
    description?: string | null
    order?: number
    completed?: boolean
    completedAt?: Date | string | null
    progress?: number
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goal: GoalCreateNestedOneWithoutKeyStepsInput
    tasks?: TaskCreateNestedManyWithoutKeyStepInput
  }

  export type KeyStepUncheckedCreateWithoutNotesInput = {
    id?: string
    goalId: string
    title: string
    description?: string | null
    order?: number
    completed?: boolean
    completedAt?: Date | string | null
    progress?: number
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutKeyStepInput
  }

  export type KeyStepCreateOrConnectWithoutNotesInput = {
    where: KeyStepWhereUniqueInput
    create: XOR<KeyStepCreateWithoutNotesInput, KeyStepUncheckedCreateWithoutNotesInput>
  }

  export type UserCreateWithoutNotesInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    geminiApiKey?: string | null
    geminiModel?: string
    groqApiKey?: string | null
    llmProvider?: string
    serperApiKey?: string | null
    researchLimit?: number
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    captures?: CaptureCreateNestedManyWithoutUserInput
    clients?: ClientCreateNestedManyWithoutUserInput
    dayPlans?: DayPlanCreateNestedManyWithoutUserInput
    meetings?: MeetingCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    researches?: ResearchCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    voiceSessions?: VoiceSessionCreateNestedManyWithoutUserInput
    weekPlans?: WeekPlanCreateNestedManyWithoutUserInput
    wellBeingEntries?: WellBeingEntryCreateNestedManyWithoutUserInput
    yearPlans?: YearPlanCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotesInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    geminiApiKey?: string | null
    geminiModel?: string
    groqApiKey?: string | null
    llmProvider?: string
    serperApiKey?: string | null
    researchLimit?: number
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    captures?: CaptureUncheckedCreateNestedManyWithoutUserInput
    clients?: ClientUncheckedCreateNestedManyWithoutUserInput
    dayPlans?: DayPlanUncheckedCreateNestedManyWithoutUserInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    researches?: ResearchUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    voiceSessions?: VoiceSessionUncheckedCreateNestedManyWithoutUserInput
    weekPlans?: WeekPlanUncheckedCreateNestedManyWithoutUserInput
    wellBeingEntries?: WellBeingEntryUncheckedCreateNestedManyWithoutUserInput
    yearPlans?: YearPlanUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
  }

  export type DayPlanUpsertWithoutNotesInput = {
    update: XOR<DayPlanUpdateWithoutNotesInput, DayPlanUncheckedUpdateWithoutNotesInput>
    create: XOR<DayPlanCreateWithoutNotesInput, DayPlanUncheckedCreateWithoutNotesInput>
    where?: DayPlanWhereInput
  }

  export type DayPlanUpdateToOneWithWhereWithoutNotesInput = {
    where?: DayPlanWhereInput
    data: XOR<DayPlanUpdateWithoutNotesInput, DayPlanUncheckedUpdateWithoutNotesInput>
  }

  export type DayPlanUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topPriorities?: DayPlanUpdatetopPrioritiesInput | string[]
    morningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    afternoonEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    eveningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyWin?: NullableStringFieldUpdateOperationsInput | string | null
    gratitude?: DayPlanUpdategratitudeInput | string[]
    tomorrowPrep?: DayPlanUpdatetomorrowPrepInput | string[]
    completionRate?: FloatFieldUpdateOperationsInput | number
    dayFocuses?: DayFocusUpdateManyWithoutDayPlanNestedInput
    user?: UserUpdateOneRequiredWithoutDayPlansNestedInput
    weekPlan?: WeekPlanUpdateOneRequiredWithoutDayPlansNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutDayPlanNestedInput
  }

  export type DayPlanUncheckedUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekPlanId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topPriorities?: DayPlanUpdatetopPrioritiesInput | string[]
    morningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    afternoonEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    eveningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyWin?: NullableStringFieldUpdateOperationsInput | string | null
    gratitude?: DayPlanUpdategratitudeInput | string[]
    tomorrowPrep?: DayPlanUpdatetomorrowPrepInput | string[]
    completionRate?: FloatFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    dayFocuses?: DayFocusUncheckedUpdateManyWithoutDayPlanNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutDayPlanNestedInput
  }

  export type GoalUpsertWithoutNotesInput = {
    update: XOR<GoalUpdateWithoutNotesInput, GoalUncheckedUpdateWithoutNotesInput>
    create: XOR<GoalCreateWithoutNotesInput, GoalUncheckedCreateWithoutNotesInput>
    where?: GoalWhereInput
  }

  export type GoalUpdateToOneWithWhereWithoutNotesInput = {
    where?: GoalWhereInput
    data: XOR<GoalUpdateWithoutNotesInput, GoalUncheckedUpdateWithoutNotesInput>
  }

  export type GoalUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kpis?: GoalUpdatekpisInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    risks?: GoalUpdaterisksInput | string[]
    strategies?: GoalUpdatestrategiesInput | string[]
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    yearPlan?: YearPlanUpdateOneRequiredWithoutGoalsNestedInput
    keySteps?: KeyStepUpdateManyWithoutGoalNestedInput
    milestones?: MilestoneUpdateManyWithoutGoalNestedInput
    quarterFocuses?: QuarterFocusUpdateManyWithoutGoalNestedInput
    researches?: ResearchUpdateManyWithoutGoalNestedInput
    tasks?: TaskUpdateManyWithoutGoalNestedInput
  }

  export type GoalUncheckedUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    yearPlanId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kpis?: GoalUpdatekpisInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    risks?: GoalUpdaterisksInput | string[]
    strategies?: GoalUpdatestrategiesInput | string[]
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    keySteps?: KeyStepUncheckedUpdateManyWithoutGoalNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutGoalNestedInput
    quarterFocuses?: QuarterFocusUncheckedUpdateManyWithoutGoalNestedInput
    researches?: ResearchUncheckedUpdateManyWithoutGoalNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutGoalNestedInput
  }

  export type KeyStepUpsertWithoutNotesInput = {
    update: XOR<KeyStepUpdateWithoutNotesInput, KeyStepUncheckedUpdateWithoutNotesInput>
    create: XOR<KeyStepCreateWithoutNotesInput, KeyStepUncheckedCreateWithoutNotesInput>
    where?: KeyStepWhereInput
  }

  export type KeyStepUpdateToOneWithWhereWithoutNotesInput = {
    where?: KeyStepWhereInput
    data: XOR<KeyStepUpdateWithoutNotesInput, KeyStepUncheckedUpdateWithoutNotesInput>
  }

  export type KeyStepUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goal?: GoalUpdateOneRequiredWithoutKeyStepsNestedInput
    tasks?: TaskUpdateManyWithoutKeyStepNestedInput
  }

  export type KeyStepUncheckedUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutKeyStepNestedInput
  }

  export type UserUpsertWithoutNotesInput = {
    update: XOR<UserUpdateWithoutNotesInput, UserUncheckedUpdateWithoutNotesInput>
    create: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotesInput, UserUncheckedUpdateWithoutNotesInput>
  }

  export type UserUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    geminiModel?: StringFieldUpdateOperationsInput | string
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    llmProvider?: StringFieldUpdateOperationsInput | string
    serperApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    researchLimit?: IntFieldUpdateOperationsInput | number
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    captures?: CaptureUpdateManyWithoutUserNestedInput
    clients?: ClientUpdateManyWithoutUserNestedInput
    dayPlans?: DayPlanUpdateManyWithoutUserNestedInput
    meetings?: MeetingUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    researches?: ResearchUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    voiceSessions?: VoiceSessionUpdateManyWithoutUserNestedInput
    weekPlans?: WeekPlanUpdateManyWithoutUserNestedInput
    wellBeingEntries?: WellBeingEntryUpdateManyWithoutUserNestedInput
    yearPlans?: YearPlanUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    geminiModel?: StringFieldUpdateOperationsInput | string
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    llmProvider?: StringFieldUpdateOperationsInput | string
    serperApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    researchLimit?: IntFieldUpdateOperationsInput | number
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    captures?: CaptureUncheckedUpdateManyWithoutUserNestedInput
    clients?: ClientUncheckedUpdateManyWithoutUserNestedInput
    dayPlans?: DayPlanUncheckedUpdateManyWithoutUserNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    researches?: ResearchUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    voiceSessions?: VoiceSessionUncheckedUpdateManyWithoutUserNestedInput
    weekPlans?: WeekPlanUncheckedUpdateManyWithoutUserNestedInput
    wellBeingEntries?: WellBeingEntryUncheckedUpdateManyWithoutUserNestedInput
    yearPlans?: YearPlanUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MonthPlanCreateWithoutQuarterPlanInput = {
    id?: string
    month: number
    year: number
    objectives?: MonthPlanCreateobjectivesInput | string[]
    completionRate?: number
    energyRating?: number | null
    rating?: number | null
    reviewNotes?: string | null
    theme?: string | null
    monthFocuses?: MonthFocusCreateNestedManyWithoutMonthPlanInput
    weekPlans?: WeekPlanCreateNestedManyWithoutMonthPlanInput
  }

  export type MonthPlanUncheckedCreateWithoutQuarterPlanInput = {
    id?: string
    month: number
    year: number
    objectives?: MonthPlanCreateobjectivesInput | string[]
    completionRate?: number
    energyRating?: number | null
    rating?: number | null
    reviewNotes?: string | null
    theme?: string | null
    monthFocuses?: MonthFocusUncheckedCreateNestedManyWithoutMonthPlanInput
    weekPlans?: WeekPlanUncheckedCreateNestedManyWithoutMonthPlanInput
  }

  export type MonthPlanCreateOrConnectWithoutQuarterPlanInput = {
    where: MonthPlanWhereUniqueInput
    create: XOR<MonthPlanCreateWithoutQuarterPlanInput, MonthPlanUncheckedCreateWithoutQuarterPlanInput>
  }

  export type MonthPlanCreateManyQuarterPlanInputEnvelope = {
    data: MonthPlanCreateManyQuarterPlanInput | MonthPlanCreateManyQuarterPlanInput[]
    skipDuplicates?: boolean
  }

  export type QuarterFocusCreateWithoutQuarterPlanInput = {
    id?: string
    priority?: number
    progress?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    monthFocuses?: MonthFocusCreateNestedManyWithoutQuarterFocusInput
    goal: GoalCreateNestedOneWithoutQuarterFocusesInput
  }

  export type QuarterFocusUncheckedCreateWithoutQuarterPlanInput = {
    id?: string
    goalId: string
    priority?: number
    progress?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    monthFocuses?: MonthFocusUncheckedCreateNestedManyWithoutQuarterFocusInput
  }

  export type QuarterFocusCreateOrConnectWithoutQuarterPlanInput = {
    where: QuarterFocusWhereUniqueInput
    create: XOR<QuarterFocusCreateWithoutQuarterPlanInput, QuarterFocusUncheckedCreateWithoutQuarterPlanInput>
  }

  export type QuarterFocusCreateManyQuarterPlanInputEnvelope = {
    data: QuarterFocusCreateManyQuarterPlanInput | QuarterFocusCreateManyQuarterPlanInput[]
    skipDuplicates?: boolean
  }

  export type QuarterObjectiveCreateWithoutQuarterPlanInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuarterObjectiveUncheckedCreateWithoutQuarterPlanInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuarterObjectiveCreateOrConnectWithoutQuarterPlanInput = {
    where: QuarterObjectiveWhereUniqueInput
    create: XOR<QuarterObjectiveCreateWithoutQuarterPlanInput, QuarterObjectiveUncheckedCreateWithoutQuarterPlanInput>
  }

  export type QuarterObjectiveCreateManyQuarterPlanInputEnvelope = {
    data: QuarterObjectiveCreateManyQuarterPlanInput | QuarterObjectiveCreateManyQuarterPlanInput[]
    skipDuplicates?: boolean
  }

  export type YearPlanCreateWithoutQuarterPlansInput = {
    id?: string
    year: number
    theme: string
    vision: string
    focusAreas?: YearPlanCreatefocusAreasInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    goals?: GoalCreateNestedManyWithoutYearPlanInput
    user: UserCreateNestedOneWithoutYearPlansInput
  }

  export type YearPlanUncheckedCreateWithoutQuarterPlansInput = {
    id?: string
    userId: string
    year: number
    theme: string
    vision: string
    focusAreas?: YearPlanCreatefocusAreasInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    goals?: GoalUncheckedCreateNestedManyWithoutYearPlanInput
  }

  export type YearPlanCreateOrConnectWithoutQuarterPlansInput = {
    where: YearPlanWhereUniqueInput
    create: XOR<YearPlanCreateWithoutQuarterPlansInput, YearPlanUncheckedCreateWithoutQuarterPlansInput>
  }

  export type MonthPlanUpsertWithWhereUniqueWithoutQuarterPlanInput = {
    where: MonthPlanWhereUniqueInput
    update: XOR<MonthPlanUpdateWithoutQuarterPlanInput, MonthPlanUncheckedUpdateWithoutQuarterPlanInput>
    create: XOR<MonthPlanCreateWithoutQuarterPlanInput, MonthPlanUncheckedCreateWithoutQuarterPlanInput>
  }

  export type MonthPlanUpdateWithWhereUniqueWithoutQuarterPlanInput = {
    where: MonthPlanWhereUniqueInput
    data: XOR<MonthPlanUpdateWithoutQuarterPlanInput, MonthPlanUncheckedUpdateWithoutQuarterPlanInput>
  }

  export type MonthPlanUpdateManyWithWhereWithoutQuarterPlanInput = {
    where: MonthPlanScalarWhereInput
    data: XOR<MonthPlanUpdateManyMutationInput, MonthPlanUncheckedUpdateManyWithoutQuarterPlanInput>
  }

  export type MonthPlanScalarWhereInput = {
    AND?: MonthPlanScalarWhereInput | MonthPlanScalarWhereInput[]
    OR?: MonthPlanScalarWhereInput[]
    NOT?: MonthPlanScalarWhereInput | MonthPlanScalarWhereInput[]
    id?: StringFilter<"MonthPlan"> | string
    quarterPlanId?: StringFilter<"MonthPlan"> | string
    month?: IntFilter<"MonthPlan"> | number
    year?: IntFilter<"MonthPlan"> | number
    objectives?: StringNullableListFilter<"MonthPlan">
    completionRate?: FloatFilter<"MonthPlan"> | number
    energyRating?: FloatNullableFilter<"MonthPlan"> | number | null
    rating?: IntNullableFilter<"MonthPlan"> | number | null
    reviewNotes?: StringNullableFilter<"MonthPlan"> | string | null
    theme?: StringNullableFilter<"MonthPlan"> | string | null
  }

  export type QuarterFocusUpsertWithWhereUniqueWithoutQuarterPlanInput = {
    where: QuarterFocusWhereUniqueInput
    update: XOR<QuarterFocusUpdateWithoutQuarterPlanInput, QuarterFocusUncheckedUpdateWithoutQuarterPlanInput>
    create: XOR<QuarterFocusCreateWithoutQuarterPlanInput, QuarterFocusUncheckedCreateWithoutQuarterPlanInput>
  }

  export type QuarterFocusUpdateWithWhereUniqueWithoutQuarterPlanInput = {
    where: QuarterFocusWhereUniqueInput
    data: XOR<QuarterFocusUpdateWithoutQuarterPlanInput, QuarterFocusUncheckedUpdateWithoutQuarterPlanInput>
  }

  export type QuarterFocusUpdateManyWithWhereWithoutQuarterPlanInput = {
    where: QuarterFocusScalarWhereInput
    data: XOR<QuarterFocusUpdateManyMutationInput, QuarterFocusUncheckedUpdateManyWithoutQuarterPlanInput>
  }

  export type QuarterObjectiveUpsertWithWhereUniqueWithoutQuarterPlanInput = {
    where: QuarterObjectiveWhereUniqueInput
    update: XOR<QuarterObjectiveUpdateWithoutQuarterPlanInput, QuarterObjectiveUncheckedUpdateWithoutQuarterPlanInput>
    create: XOR<QuarterObjectiveCreateWithoutQuarterPlanInput, QuarterObjectiveUncheckedCreateWithoutQuarterPlanInput>
  }

  export type QuarterObjectiveUpdateWithWhereUniqueWithoutQuarterPlanInput = {
    where: QuarterObjectiveWhereUniqueInput
    data: XOR<QuarterObjectiveUpdateWithoutQuarterPlanInput, QuarterObjectiveUncheckedUpdateWithoutQuarterPlanInput>
  }

  export type QuarterObjectiveUpdateManyWithWhereWithoutQuarterPlanInput = {
    where: QuarterObjectiveScalarWhereInput
    data: XOR<QuarterObjectiveUpdateManyMutationInput, QuarterObjectiveUncheckedUpdateManyWithoutQuarterPlanInput>
  }

  export type QuarterObjectiveScalarWhereInput = {
    AND?: QuarterObjectiveScalarWhereInput | QuarterObjectiveScalarWhereInput[]
    OR?: QuarterObjectiveScalarWhereInput[]
    NOT?: QuarterObjectiveScalarWhereInput | QuarterObjectiveScalarWhereInput[]
    id?: StringFilter<"QuarterObjective"> | string
    quarterPlanId?: StringFilter<"QuarterObjective"> | string
    title?: StringFilter<"QuarterObjective"> | string
    description?: StringNullableFilter<"QuarterObjective"> | string | null
    status?: StringFilter<"QuarterObjective"> | string
    createdAt?: DateTimeFilter<"QuarterObjective"> | Date | string
    updatedAt?: DateTimeFilter<"QuarterObjective"> | Date | string
  }

  export type YearPlanUpsertWithoutQuarterPlansInput = {
    update: XOR<YearPlanUpdateWithoutQuarterPlansInput, YearPlanUncheckedUpdateWithoutQuarterPlansInput>
    create: XOR<YearPlanCreateWithoutQuarterPlansInput, YearPlanUncheckedCreateWithoutQuarterPlansInput>
    where?: YearPlanWhereInput
  }

  export type YearPlanUpdateToOneWithWhereWithoutQuarterPlansInput = {
    where?: YearPlanWhereInput
    data: XOR<YearPlanUpdateWithoutQuarterPlansInput, YearPlanUncheckedUpdateWithoutQuarterPlansInput>
  }

  export type YearPlanUpdateWithoutQuarterPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    theme?: StringFieldUpdateOperationsInput | string
    vision?: StringFieldUpdateOperationsInput | string
    focusAreas?: YearPlanUpdatefocusAreasInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    goals?: GoalUpdateManyWithoutYearPlanNestedInput
    user?: UserUpdateOneRequiredWithoutYearPlansNestedInput
  }

  export type YearPlanUncheckedUpdateWithoutQuarterPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    theme?: StringFieldUpdateOperationsInput | string
    vision?: StringFieldUpdateOperationsInput | string
    focusAreas?: YearPlanUpdatefocusAreasInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    goals?: GoalUncheckedUpdateManyWithoutYearPlanNestedInput
  }

  export type QuarterPlanCreateWithoutObjectivesInput = {
    id?: string
    quarter: number
    theme: string
    startDate: Date | string
    endDate: Date | string
    monthPlans?: MonthPlanCreateNestedManyWithoutQuarterPlanInput
    quarterFocuses?: QuarterFocusCreateNestedManyWithoutQuarterPlanInput
    yearPlan: YearPlanCreateNestedOneWithoutQuarterPlansInput
  }

  export type QuarterPlanUncheckedCreateWithoutObjectivesInput = {
    id?: string
    yearPlanId: string
    quarter: number
    theme: string
    startDate: Date | string
    endDate: Date | string
    monthPlans?: MonthPlanUncheckedCreateNestedManyWithoutQuarterPlanInput
    quarterFocuses?: QuarterFocusUncheckedCreateNestedManyWithoutQuarterPlanInput
  }

  export type QuarterPlanCreateOrConnectWithoutObjectivesInput = {
    where: QuarterPlanWhereUniqueInput
    create: XOR<QuarterPlanCreateWithoutObjectivesInput, QuarterPlanUncheckedCreateWithoutObjectivesInput>
  }

  export type QuarterPlanUpsertWithoutObjectivesInput = {
    update: XOR<QuarterPlanUpdateWithoutObjectivesInput, QuarterPlanUncheckedUpdateWithoutObjectivesInput>
    create: XOR<QuarterPlanCreateWithoutObjectivesInput, QuarterPlanUncheckedCreateWithoutObjectivesInput>
    where?: QuarterPlanWhereInput
  }

  export type QuarterPlanUpdateToOneWithWhereWithoutObjectivesInput = {
    where?: QuarterPlanWhereInput
    data: XOR<QuarterPlanUpdateWithoutObjectivesInput, QuarterPlanUncheckedUpdateWithoutObjectivesInput>
  }

  export type QuarterPlanUpdateWithoutObjectivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    quarter?: IntFieldUpdateOperationsInput | number
    theme?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    monthPlans?: MonthPlanUpdateManyWithoutQuarterPlanNestedInput
    quarterFocuses?: QuarterFocusUpdateManyWithoutQuarterPlanNestedInput
    yearPlan?: YearPlanUpdateOneRequiredWithoutQuarterPlansNestedInput
  }

  export type QuarterPlanUncheckedUpdateWithoutObjectivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    yearPlanId?: StringFieldUpdateOperationsInput | string
    quarter?: IntFieldUpdateOperationsInput | number
    theme?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    monthPlans?: MonthPlanUncheckedUpdateManyWithoutQuarterPlanNestedInput
    quarterFocuses?: QuarterFocusUncheckedUpdateManyWithoutQuarterPlanNestedInput
  }

  export type MonthFocusCreateWithoutQuarterFocusInput = {
    id?: string
    priority?: number
    progress?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    monthPlan: MonthPlanCreateNestedOneWithoutMonthFocusesInput
    weekFocuses?: WeekFocusCreateNestedManyWithoutMonthFocusInput
  }

  export type MonthFocusUncheckedCreateWithoutQuarterFocusInput = {
    id?: string
    monthPlanId: string
    priority?: number
    progress?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    weekFocuses?: WeekFocusUncheckedCreateNestedManyWithoutMonthFocusInput
  }

  export type MonthFocusCreateOrConnectWithoutQuarterFocusInput = {
    where: MonthFocusWhereUniqueInput
    create: XOR<MonthFocusCreateWithoutQuarterFocusInput, MonthFocusUncheckedCreateWithoutQuarterFocusInput>
  }

  export type MonthFocusCreateManyQuarterFocusInputEnvelope = {
    data: MonthFocusCreateManyQuarterFocusInput | MonthFocusCreateManyQuarterFocusInput[]
    skipDuplicates?: boolean
  }

  export type GoalCreateWithoutQuarterFocusesInput = {
    id?: string
    title: string
    description?: string | null
    category: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    kpis?: GoalCreatekpisInput | string[]
    priority?: string
    progress?: number
    risks?: GoalCreaterisksInput | string[]
    strategies?: GoalCreatestrategiesInput | string[]
    targetDate?: Date | string | null
    yearPlan: YearPlanCreateNestedOneWithoutGoalsInput
    keySteps?: KeyStepCreateNestedManyWithoutGoalInput
    milestones?: MilestoneCreateNestedManyWithoutGoalInput
    notes?: NoteCreateNestedManyWithoutGoalInput
    researches?: ResearchCreateNestedManyWithoutGoalInput
    tasks?: TaskCreateNestedManyWithoutGoalInput
  }

  export type GoalUncheckedCreateWithoutQuarterFocusesInput = {
    id?: string
    yearPlanId: string
    title: string
    description?: string | null
    category: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    kpis?: GoalCreatekpisInput | string[]
    priority?: string
    progress?: number
    risks?: GoalCreaterisksInput | string[]
    strategies?: GoalCreatestrategiesInput | string[]
    targetDate?: Date | string | null
    keySteps?: KeyStepUncheckedCreateNestedManyWithoutGoalInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutGoalInput
    notes?: NoteUncheckedCreateNestedManyWithoutGoalInput
    researches?: ResearchUncheckedCreateNestedManyWithoutGoalInput
    tasks?: TaskUncheckedCreateNestedManyWithoutGoalInput
  }

  export type GoalCreateOrConnectWithoutQuarterFocusesInput = {
    where: GoalWhereUniqueInput
    create: XOR<GoalCreateWithoutQuarterFocusesInput, GoalUncheckedCreateWithoutQuarterFocusesInput>
  }

  export type QuarterPlanCreateWithoutQuarterFocusesInput = {
    id?: string
    quarter: number
    theme: string
    startDate: Date | string
    endDate: Date | string
    monthPlans?: MonthPlanCreateNestedManyWithoutQuarterPlanInput
    objectives?: QuarterObjectiveCreateNestedManyWithoutQuarterPlanInput
    yearPlan: YearPlanCreateNestedOneWithoutQuarterPlansInput
  }

  export type QuarterPlanUncheckedCreateWithoutQuarterFocusesInput = {
    id?: string
    yearPlanId: string
    quarter: number
    theme: string
    startDate: Date | string
    endDate: Date | string
    monthPlans?: MonthPlanUncheckedCreateNestedManyWithoutQuarterPlanInput
    objectives?: QuarterObjectiveUncheckedCreateNestedManyWithoutQuarterPlanInput
  }

  export type QuarterPlanCreateOrConnectWithoutQuarterFocusesInput = {
    where: QuarterPlanWhereUniqueInput
    create: XOR<QuarterPlanCreateWithoutQuarterFocusesInput, QuarterPlanUncheckedCreateWithoutQuarterFocusesInput>
  }

  export type MonthFocusUpsertWithWhereUniqueWithoutQuarterFocusInput = {
    where: MonthFocusWhereUniqueInput
    update: XOR<MonthFocusUpdateWithoutQuarterFocusInput, MonthFocusUncheckedUpdateWithoutQuarterFocusInput>
    create: XOR<MonthFocusCreateWithoutQuarterFocusInput, MonthFocusUncheckedCreateWithoutQuarterFocusInput>
  }

  export type MonthFocusUpdateWithWhereUniqueWithoutQuarterFocusInput = {
    where: MonthFocusWhereUniqueInput
    data: XOR<MonthFocusUpdateWithoutQuarterFocusInput, MonthFocusUncheckedUpdateWithoutQuarterFocusInput>
  }

  export type MonthFocusUpdateManyWithWhereWithoutQuarterFocusInput = {
    where: MonthFocusScalarWhereInput
    data: XOR<MonthFocusUpdateManyMutationInput, MonthFocusUncheckedUpdateManyWithoutQuarterFocusInput>
  }

  export type MonthFocusScalarWhereInput = {
    AND?: MonthFocusScalarWhereInput | MonthFocusScalarWhereInput[]
    OR?: MonthFocusScalarWhereInput[]
    NOT?: MonthFocusScalarWhereInput | MonthFocusScalarWhereInput[]
    id?: StringFilter<"MonthFocus"> | string
    monthPlanId?: StringFilter<"MonthFocus"> | string
    quarterFocusId?: StringFilter<"MonthFocus"> | string
    priority?: IntFilter<"MonthFocus"> | number
    progress?: FloatFilter<"MonthFocus"> | number
    notes?: StringNullableFilter<"MonthFocus"> | string | null
    createdAt?: DateTimeFilter<"MonthFocus"> | Date | string
    updatedAt?: DateTimeFilter<"MonthFocus"> | Date | string
  }

  export type GoalUpsertWithoutQuarterFocusesInput = {
    update: XOR<GoalUpdateWithoutQuarterFocusesInput, GoalUncheckedUpdateWithoutQuarterFocusesInput>
    create: XOR<GoalCreateWithoutQuarterFocusesInput, GoalUncheckedCreateWithoutQuarterFocusesInput>
    where?: GoalWhereInput
  }

  export type GoalUpdateToOneWithWhereWithoutQuarterFocusesInput = {
    where?: GoalWhereInput
    data: XOR<GoalUpdateWithoutQuarterFocusesInput, GoalUncheckedUpdateWithoutQuarterFocusesInput>
  }

  export type GoalUpdateWithoutQuarterFocusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kpis?: GoalUpdatekpisInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    risks?: GoalUpdaterisksInput | string[]
    strategies?: GoalUpdatestrategiesInput | string[]
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    yearPlan?: YearPlanUpdateOneRequiredWithoutGoalsNestedInput
    keySteps?: KeyStepUpdateManyWithoutGoalNestedInput
    milestones?: MilestoneUpdateManyWithoutGoalNestedInput
    notes?: NoteUpdateManyWithoutGoalNestedInput
    researches?: ResearchUpdateManyWithoutGoalNestedInput
    tasks?: TaskUpdateManyWithoutGoalNestedInput
  }

  export type GoalUncheckedUpdateWithoutQuarterFocusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    yearPlanId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kpis?: GoalUpdatekpisInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    risks?: GoalUpdaterisksInput | string[]
    strategies?: GoalUpdatestrategiesInput | string[]
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    keySteps?: KeyStepUncheckedUpdateManyWithoutGoalNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutGoalNestedInput
    notes?: NoteUncheckedUpdateManyWithoutGoalNestedInput
    researches?: ResearchUncheckedUpdateManyWithoutGoalNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutGoalNestedInput
  }

  export type QuarterPlanUpsertWithoutQuarterFocusesInput = {
    update: XOR<QuarterPlanUpdateWithoutQuarterFocusesInput, QuarterPlanUncheckedUpdateWithoutQuarterFocusesInput>
    create: XOR<QuarterPlanCreateWithoutQuarterFocusesInput, QuarterPlanUncheckedCreateWithoutQuarterFocusesInput>
    where?: QuarterPlanWhereInput
  }

  export type QuarterPlanUpdateToOneWithWhereWithoutQuarterFocusesInput = {
    where?: QuarterPlanWhereInput
    data: XOR<QuarterPlanUpdateWithoutQuarterFocusesInput, QuarterPlanUncheckedUpdateWithoutQuarterFocusesInput>
  }

  export type QuarterPlanUpdateWithoutQuarterFocusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    quarter?: IntFieldUpdateOperationsInput | number
    theme?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    monthPlans?: MonthPlanUpdateManyWithoutQuarterPlanNestedInput
    objectives?: QuarterObjectiveUpdateManyWithoutQuarterPlanNestedInput
    yearPlan?: YearPlanUpdateOneRequiredWithoutQuarterPlansNestedInput
  }

  export type QuarterPlanUncheckedUpdateWithoutQuarterFocusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    yearPlanId?: StringFieldUpdateOperationsInput | string
    quarter?: IntFieldUpdateOperationsInput | number
    theme?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    monthPlans?: MonthPlanUncheckedUpdateManyWithoutQuarterPlanNestedInput
    objectives?: QuarterObjectiveUncheckedUpdateManyWithoutQuarterPlanNestedInput
  }

  export type MonthFocusCreateWithoutMonthPlanInput = {
    id?: string
    priority?: number
    progress?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quarterFocus: QuarterFocusCreateNestedOneWithoutMonthFocusesInput
    weekFocuses?: WeekFocusCreateNestedManyWithoutMonthFocusInput
  }

  export type MonthFocusUncheckedCreateWithoutMonthPlanInput = {
    id?: string
    quarterFocusId: string
    priority?: number
    progress?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    weekFocuses?: WeekFocusUncheckedCreateNestedManyWithoutMonthFocusInput
  }

  export type MonthFocusCreateOrConnectWithoutMonthPlanInput = {
    where: MonthFocusWhereUniqueInput
    create: XOR<MonthFocusCreateWithoutMonthPlanInput, MonthFocusUncheckedCreateWithoutMonthPlanInput>
  }

  export type MonthFocusCreateManyMonthPlanInputEnvelope = {
    data: MonthFocusCreateManyMonthPlanInput | MonthFocusCreateManyMonthPlanInput[]
    skipDuplicates?: boolean
  }

  export type QuarterPlanCreateWithoutMonthPlansInput = {
    id?: string
    quarter: number
    theme: string
    startDate: Date | string
    endDate: Date | string
    quarterFocuses?: QuarterFocusCreateNestedManyWithoutQuarterPlanInput
    objectives?: QuarterObjectiveCreateNestedManyWithoutQuarterPlanInput
    yearPlan: YearPlanCreateNestedOneWithoutQuarterPlansInput
  }

  export type QuarterPlanUncheckedCreateWithoutMonthPlansInput = {
    id?: string
    yearPlanId: string
    quarter: number
    theme: string
    startDate: Date | string
    endDate: Date | string
    quarterFocuses?: QuarterFocusUncheckedCreateNestedManyWithoutQuarterPlanInput
    objectives?: QuarterObjectiveUncheckedCreateNestedManyWithoutQuarterPlanInput
  }

  export type QuarterPlanCreateOrConnectWithoutMonthPlansInput = {
    where: QuarterPlanWhereUniqueInput
    create: XOR<QuarterPlanCreateWithoutMonthPlansInput, QuarterPlanUncheckedCreateWithoutMonthPlansInput>
  }

  export type WeekPlanCreateWithoutMonthPlanInput = {
    id?: string
    weekNumber: number
    year: number
    startDate: Date | string
    endDate: Date | string
    topOutcomes?: WeekPlanCreatetopOutcomesInput | string[]
    plannedClientHours?: number | null
    plannedPersonalHours?: number | null
    challenges?: WeekPlanCreatechallengesInput | string[]
    keyWins?: WeekPlanCreatekeyWinsInput | string[]
    lessonsLearned?: WeekPlanCreatelessonsLearnedInput | string[]
    rating?: number | null
    reviewNotes?: string | null
    dayPlans?: DayPlanCreateNestedManyWithoutWeekPlanInput
    weekFocuses?: WeekFocusCreateNestedManyWithoutWeekPlanInput
    user: UserCreateNestedOneWithoutWeekPlansInput
  }

  export type WeekPlanUncheckedCreateWithoutMonthPlanInput = {
    id?: string
    weekNumber: number
    year: number
    startDate: Date | string
    endDate: Date | string
    topOutcomes?: WeekPlanCreatetopOutcomesInput | string[]
    plannedClientHours?: number | null
    plannedPersonalHours?: number | null
    userId: string
    challenges?: WeekPlanCreatechallengesInput | string[]
    keyWins?: WeekPlanCreatekeyWinsInput | string[]
    lessonsLearned?: WeekPlanCreatelessonsLearnedInput | string[]
    rating?: number | null
    reviewNotes?: string | null
    dayPlans?: DayPlanUncheckedCreateNestedManyWithoutWeekPlanInput
    weekFocuses?: WeekFocusUncheckedCreateNestedManyWithoutWeekPlanInput
  }

  export type WeekPlanCreateOrConnectWithoutMonthPlanInput = {
    where: WeekPlanWhereUniqueInput
    create: XOR<WeekPlanCreateWithoutMonthPlanInput, WeekPlanUncheckedCreateWithoutMonthPlanInput>
  }

  export type WeekPlanCreateManyMonthPlanInputEnvelope = {
    data: WeekPlanCreateManyMonthPlanInput | WeekPlanCreateManyMonthPlanInput[]
    skipDuplicates?: boolean
  }

  export type MonthFocusUpsertWithWhereUniqueWithoutMonthPlanInput = {
    where: MonthFocusWhereUniqueInput
    update: XOR<MonthFocusUpdateWithoutMonthPlanInput, MonthFocusUncheckedUpdateWithoutMonthPlanInput>
    create: XOR<MonthFocusCreateWithoutMonthPlanInput, MonthFocusUncheckedCreateWithoutMonthPlanInput>
  }

  export type MonthFocusUpdateWithWhereUniqueWithoutMonthPlanInput = {
    where: MonthFocusWhereUniqueInput
    data: XOR<MonthFocusUpdateWithoutMonthPlanInput, MonthFocusUncheckedUpdateWithoutMonthPlanInput>
  }

  export type MonthFocusUpdateManyWithWhereWithoutMonthPlanInput = {
    where: MonthFocusScalarWhereInput
    data: XOR<MonthFocusUpdateManyMutationInput, MonthFocusUncheckedUpdateManyWithoutMonthPlanInput>
  }

  export type QuarterPlanUpsertWithoutMonthPlansInput = {
    update: XOR<QuarterPlanUpdateWithoutMonthPlansInput, QuarterPlanUncheckedUpdateWithoutMonthPlansInput>
    create: XOR<QuarterPlanCreateWithoutMonthPlansInput, QuarterPlanUncheckedCreateWithoutMonthPlansInput>
    where?: QuarterPlanWhereInput
  }

  export type QuarterPlanUpdateToOneWithWhereWithoutMonthPlansInput = {
    where?: QuarterPlanWhereInput
    data: XOR<QuarterPlanUpdateWithoutMonthPlansInput, QuarterPlanUncheckedUpdateWithoutMonthPlansInput>
  }

  export type QuarterPlanUpdateWithoutMonthPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    quarter?: IntFieldUpdateOperationsInput | number
    theme?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quarterFocuses?: QuarterFocusUpdateManyWithoutQuarterPlanNestedInput
    objectives?: QuarterObjectiveUpdateManyWithoutQuarterPlanNestedInput
    yearPlan?: YearPlanUpdateOneRequiredWithoutQuarterPlansNestedInput
  }

  export type QuarterPlanUncheckedUpdateWithoutMonthPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    yearPlanId?: StringFieldUpdateOperationsInput | string
    quarter?: IntFieldUpdateOperationsInput | number
    theme?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quarterFocuses?: QuarterFocusUncheckedUpdateManyWithoutQuarterPlanNestedInput
    objectives?: QuarterObjectiveUncheckedUpdateManyWithoutQuarterPlanNestedInput
  }

  export type WeekPlanUpsertWithWhereUniqueWithoutMonthPlanInput = {
    where: WeekPlanWhereUniqueInput
    update: XOR<WeekPlanUpdateWithoutMonthPlanInput, WeekPlanUncheckedUpdateWithoutMonthPlanInput>
    create: XOR<WeekPlanCreateWithoutMonthPlanInput, WeekPlanUncheckedCreateWithoutMonthPlanInput>
  }

  export type WeekPlanUpdateWithWhereUniqueWithoutMonthPlanInput = {
    where: WeekPlanWhereUniqueInput
    data: XOR<WeekPlanUpdateWithoutMonthPlanInput, WeekPlanUncheckedUpdateWithoutMonthPlanInput>
  }

  export type WeekPlanUpdateManyWithWhereWithoutMonthPlanInput = {
    where: WeekPlanScalarWhereInput
    data: XOR<WeekPlanUpdateManyMutationInput, WeekPlanUncheckedUpdateManyWithoutMonthPlanInput>
  }

  export type MonthPlanCreateWithoutMonthFocusesInput = {
    id?: string
    month: number
    year: number
    objectives?: MonthPlanCreateobjectivesInput | string[]
    completionRate?: number
    energyRating?: number | null
    rating?: number | null
    reviewNotes?: string | null
    theme?: string | null
    quarterPlan: QuarterPlanCreateNestedOneWithoutMonthPlansInput
    weekPlans?: WeekPlanCreateNestedManyWithoutMonthPlanInput
  }

  export type MonthPlanUncheckedCreateWithoutMonthFocusesInput = {
    id?: string
    quarterPlanId: string
    month: number
    year: number
    objectives?: MonthPlanCreateobjectivesInput | string[]
    completionRate?: number
    energyRating?: number | null
    rating?: number | null
    reviewNotes?: string | null
    theme?: string | null
    weekPlans?: WeekPlanUncheckedCreateNestedManyWithoutMonthPlanInput
  }

  export type MonthPlanCreateOrConnectWithoutMonthFocusesInput = {
    where: MonthPlanWhereUniqueInput
    create: XOR<MonthPlanCreateWithoutMonthFocusesInput, MonthPlanUncheckedCreateWithoutMonthFocusesInput>
  }

  export type QuarterFocusCreateWithoutMonthFocusesInput = {
    id?: string
    priority?: number
    progress?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goal: GoalCreateNestedOneWithoutQuarterFocusesInput
    quarterPlan: QuarterPlanCreateNestedOneWithoutQuarterFocusesInput
  }

  export type QuarterFocusUncheckedCreateWithoutMonthFocusesInput = {
    id?: string
    quarterPlanId: string
    goalId: string
    priority?: number
    progress?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuarterFocusCreateOrConnectWithoutMonthFocusesInput = {
    where: QuarterFocusWhereUniqueInput
    create: XOR<QuarterFocusCreateWithoutMonthFocusesInput, QuarterFocusUncheckedCreateWithoutMonthFocusesInput>
  }

  export type WeekFocusCreateWithoutMonthFocusInput = {
    id?: string
    priority?: number
    progress?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dayFocuses?: DayFocusCreateNestedManyWithoutWeekFocusInput
    weekPlan: WeekPlanCreateNestedOneWithoutWeekFocusesInput
  }

  export type WeekFocusUncheckedCreateWithoutMonthFocusInput = {
    id?: string
    weekPlanId: string
    priority?: number
    progress?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dayFocuses?: DayFocusUncheckedCreateNestedManyWithoutWeekFocusInput
  }

  export type WeekFocusCreateOrConnectWithoutMonthFocusInput = {
    where: WeekFocusWhereUniqueInput
    create: XOR<WeekFocusCreateWithoutMonthFocusInput, WeekFocusUncheckedCreateWithoutMonthFocusInput>
  }

  export type WeekFocusCreateManyMonthFocusInputEnvelope = {
    data: WeekFocusCreateManyMonthFocusInput | WeekFocusCreateManyMonthFocusInput[]
    skipDuplicates?: boolean
  }

  export type MonthPlanUpsertWithoutMonthFocusesInput = {
    update: XOR<MonthPlanUpdateWithoutMonthFocusesInput, MonthPlanUncheckedUpdateWithoutMonthFocusesInput>
    create: XOR<MonthPlanCreateWithoutMonthFocusesInput, MonthPlanUncheckedCreateWithoutMonthFocusesInput>
    where?: MonthPlanWhereInput
  }

  export type MonthPlanUpdateToOneWithWhereWithoutMonthFocusesInput = {
    where?: MonthPlanWhereInput
    data: XOR<MonthPlanUpdateWithoutMonthFocusesInput, MonthPlanUncheckedUpdateWithoutMonthFocusesInput>
  }

  export type MonthPlanUpdateWithoutMonthFocusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    objectives?: MonthPlanUpdateobjectivesInput | string[]
    completionRate?: FloatFieldUpdateOperationsInput | number
    energyRating?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    quarterPlan?: QuarterPlanUpdateOneRequiredWithoutMonthPlansNestedInput
    weekPlans?: WeekPlanUpdateManyWithoutMonthPlanNestedInput
  }

  export type MonthPlanUncheckedUpdateWithoutMonthFocusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    quarterPlanId?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    objectives?: MonthPlanUpdateobjectivesInput | string[]
    completionRate?: FloatFieldUpdateOperationsInput | number
    energyRating?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    weekPlans?: WeekPlanUncheckedUpdateManyWithoutMonthPlanNestedInput
  }

  export type QuarterFocusUpsertWithoutMonthFocusesInput = {
    update: XOR<QuarterFocusUpdateWithoutMonthFocusesInput, QuarterFocusUncheckedUpdateWithoutMonthFocusesInput>
    create: XOR<QuarterFocusCreateWithoutMonthFocusesInput, QuarterFocusUncheckedCreateWithoutMonthFocusesInput>
    where?: QuarterFocusWhereInput
  }

  export type QuarterFocusUpdateToOneWithWhereWithoutMonthFocusesInput = {
    where?: QuarterFocusWhereInput
    data: XOR<QuarterFocusUpdateWithoutMonthFocusesInput, QuarterFocusUncheckedUpdateWithoutMonthFocusesInput>
  }

  export type QuarterFocusUpdateWithoutMonthFocusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goal?: GoalUpdateOneRequiredWithoutQuarterFocusesNestedInput
    quarterPlan?: QuarterPlanUpdateOneRequiredWithoutQuarterFocusesNestedInput
  }

  export type QuarterFocusUncheckedUpdateWithoutMonthFocusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    quarterPlanId?: StringFieldUpdateOperationsInput | string
    goalId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeekFocusUpsertWithWhereUniqueWithoutMonthFocusInput = {
    where: WeekFocusWhereUniqueInput
    update: XOR<WeekFocusUpdateWithoutMonthFocusInput, WeekFocusUncheckedUpdateWithoutMonthFocusInput>
    create: XOR<WeekFocusCreateWithoutMonthFocusInput, WeekFocusUncheckedCreateWithoutMonthFocusInput>
  }

  export type WeekFocusUpdateWithWhereUniqueWithoutMonthFocusInput = {
    where: WeekFocusWhereUniqueInput
    data: XOR<WeekFocusUpdateWithoutMonthFocusInput, WeekFocusUncheckedUpdateWithoutMonthFocusInput>
  }

  export type WeekFocusUpdateManyWithWhereWithoutMonthFocusInput = {
    where: WeekFocusScalarWhereInput
    data: XOR<WeekFocusUpdateManyMutationInput, WeekFocusUncheckedUpdateManyWithoutMonthFocusInput>
  }

  export type WeekFocusScalarWhereInput = {
    AND?: WeekFocusScalarWhereInput | WeekFocusScalarWhereInput[]
    OR?: WeekFocusScalarWhereInput[]
    NOT?: WeekFocusScalarWhereInput | WeekFocusScalarWhereInput[]
    id?: StringFilter<"WeekFocus"> | string
    weekPlanId?: StringFilter<"WeekFocus"> | string
    monthFocusId?: StringFilter<"WeekFocus"> | string
    priority?: IntFilter<"WeekFocus"> | number
    progress?: FloatFilter<"WeekFocus"> | number
    notes?: StringNullableFilter<"WeekFocus"> | string | null
    createdAt?: DateTimeFilter<"WeekFocus"> | Date | string
    updatedAt?: DateTimeFilter<"WeekFocus"> | Date | string
  }

  export type DayPlanCreateWithoutWeekPlanInput = {
    id?: string
    date: Date | string
    topPriorities?: DayPlanCreatetopPrioritiesInput | string[]
    morningEnergy?: number | null
    afternoonEnergy?: number | null
    eveningEnergy?: number | null
    dailyWin?: string | null
    gratitude?: DayPlanCreategratitudeInput | string[]
    tomorrowPrep?: DayPlanCreatetomorrowPrepInput | string[]
    completionRate?: number
    dayFocuses?: DayFocusCreateNestedManyWithoutDayPlanInput
    user: UserCreateNestedOneWithoutDayPlansInput
    notes?: NoteCreateNestedManyWithoutDayPlanInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutDayPlanInput
  }

  export type DayPlanUncheckedCreateWithoutWeekPlanInput = {
    id?: string
    date: Date | string
    topPriorities?: DayPlanCreatetopPrioritiesInput | string[]
    morningEnergy?: number | null
    afternoonEnergy?: number | null
    eveningEnergy?: number | null
    dailyWin?: string | null
    gratitude?: DayPlanCreategratitudeInput | string[]
    tomorrowPrep?: DayPlanCreatetomorrowPrepInput | string[]
    completionRate?: number
    userId: string
    dayFocuses?: DayFocusUncheckedCreateNestedManyWithoutDayPlanInput
    notes?: NoteUncheckedCreateNestedManyWithoutDayPlanInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutDayPlanInput
  }

  export type DayPlanCreateOrConnectWithoutWeekPlanInput = {
    where: DayPlanWhereUniqueInput
    create: XOR<DayPlanCreateWithoutWeekPlanInput, DayPlanUncheckedCreateWithoutWeekPlanInput>
  }

  export type DayPlanCreateManyWeekPlanInputEnvelope = {
    data: DayPlanCreateManyWeekPlanInput | DayPlanCreateManyWeekPlanInput[]
    skipDuplicates?: boolean
  }

  export type WeekFocusCreateWithoutWeekPlanInput = {
    id?: string
    priority?: number
    progress?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dayFocuses?: DayFocusCreateNestedManyWithoutWeekFocusInput
    monthFocus: MonthFocusCreateNestedOneWithoutWeekFocusesInput
  }

  export type WeekFocusUncheckedCreateWithoutWeekPlanInput = {
    id?: string
    monthFocusId: string
    priority?: number
    progress?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dayFocuses?: DayFocusUncheckedCreateNestedManyWithoutWeekFocusInput
  }

  export type WeekFocusCreateOrConnectWithoutWeekPlanInput = {
    where: WeekFocusWhereUniqueInput
    create: XOR<WeekFocusCreateWithoutWeekPlanInput, WeekFocusUncheckedCreateWithoutWeekPlanInput>
  }

  export type WeekFocusCreateManyWeekPlanInputEnvelope = {
    data: WeekFocusCreateManyWeekPlanInput | WeekFocusCreateManyWeekPlanInput[]
    skipDuplicates?: boolean
  }

  export type MonthPlanCreateWithoutWeekPlansInput = {
    id?: string
    month: number
    year: number
    objectives?: MonthPlanCreateobjectivesInput | string[]
    completionRate?: number
    energyRating?: number | null
    rating?: number | null
    reviewNotes?: string | null
    theme?: string | null
    monthFocuses?: MonthFocusCreateNestedManyWithoutMonthPlanInput
    quarterPlan: QuarterPlanCreateNestedOneWithoutMonthPlansInput
  }

  export type MonthPlanUncheckedCreateWithoutWeekPlansInput = {
    id?: string
    quarterPlanId: string
    month: number
    year: number
    objectives?: MonthPlanCreateobjectivesInput | string[]
    completionRate?: number
    energyRating?: number | null
    rating?: number | null
    reviewNotes?: string | null
    theme?: string | null
    monthFocuses?: MonthFocusUncheckedCreateNestedManyWithoutMonthPlanInput
  }

  export type MonthPlanCreateOrConnectWithoutWeekPlansInput = {
    where: MonthPlanWhereUniqueInput
    create: XOR<MonthPlanCreateWithoutWeekPlansInput, MonthPlanUncheckedCreateWithoutWeekPlansInput>
  }

  export type UserCreateWithoutWeekPlansInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    geminiApiKey?: string | null
    geminiModel?: string
    groqApiKey?: string | null
    llmProvider?: string
    serperApiKey?: string | null
    researchLimit?: number
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    captures?: CaptureCreateNestedManyWithoutUserInput
    clients?: ClientCreateNestedManyWithoutUserInput
    dayPlans?: DayPlanCreateNestedManyWithoutUserInput
    meetings?: MeetingCreateNestedManyWithoutUserInput
    notes?: NoteCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    researches?: ResearchCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    voiceSessions?: VoiceSessionCreateNestedManyWithoutUserInput
    wellBeingEntries?: WellBeingEntryCreateNestedManyWithoutUserInput
    yearPlans?: YearPlanCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWeekPlansInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    geminiApiKey?: string | null
    geminiModel?: string
    groqApiKey?: string | null
    llmProvider?: string
    serperApiKey?: string | null
    researchLimit?: number
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    captures?: CaptureUncheckedCreateNestedManyWithoutUserInput
    clients?: ClientUncheckedCreateNestedManyWithoutUserInput
    dayPlans?: DayPlanUncheckedCreateNestedManyWithoutUserInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutUserInput
    notes?: NoteUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    researches?: ResearchUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    voiceSessions?: VoiceSessionUncheckedCreateNestedManyWithoutUserInput
    wellBeingEntries?: WellBeingEntryUncheckedCreateNestedManyWithoutUserInput
    yearPlans?: YearPlanUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWeekPlansInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWeekPlansInput, UserUncheckedCreateWithoutWeekPlansInput>
  }

  export type DayPlanUpsertWithWhereUniqueWithoutWeekPlanInput = {
    where: DayPlanWhereUniqueInput
    update: XOR<DayPlanUpdateWithoutWeekPlanInput, DayPlanUncheckedUpdateWithoutWeekPlanInput>
    create: XOR<DayPlanCreateWithoutWeekPlanInput, DayPlanUncheckedCreateWithoutWeekPlanInput>
  }

  export type DayPlanUpdateWithWhereUniqueWithoutWeekPlanInput = {
    where: DayPlanWhereUniqueInput
    data: XOR<DayPlanUpdateWithoutWeekPlanInput, DayPlanUncheckedUpdateWithoutWeekPlanInput>
  }

  export type DayPlanUpdateManyWithWhereWithoutWeekPlanInput = {
    where: DayPlanScalarWhereInput
    data: XOR<DayPlanUpdateManyMutationInput, DayPlanUncheckedUpdateManyWithoutWeekPlanInput>
  }

  export type WeekFocusUpsertWithWhereUniqueWithoutWeekPlanInput = {
    where: WeekFocusWhereUniqueInput
    update: XOR<WeekFocusUpdateWithoutWeekPlanInput, WeekFocusUncheckedUpdateWithoutWeekPlanInput>
    create: XOR<WeekFocusCreateWithoutWeekPlanInput, WeekFocusUncheckedCreateWithoutWeekPlanInput>
  }

  export type WeekFocusUpdateWithWhereUniqueWithoutWeekPlanInput = {
    where: WeekFocusWhereUniqueInput
    data: XOR<WeekFocusUpdateWithoutWeekPlanInput, WeekFocusUncheckedUpdateWithoutWeekPlanInput>
  }

  export type WeekFocusUpdateManyWithWhereWithoutWeekPlanInput = {
    where: WeekFocusScalarWhereInput
    data: XOR<WeekFocusUpdateManyMutationInput, WeekFocusUncheckedUpdateManyWithoutWeekPlanInput>
  }

  export type MonthPlanUpsertWithoutWeekPlansInput = {
    update: XOR<MonthPlanUpdateWithoutWeekPlansInput, MonthPlanUncheckedUpdateWithoutWeekPlansInput>
    create: XOR<MonthPlanCreateWithoutWeekPlansInput, MonthPlanUncheckedCreateWithoutWeekPlansInput>
    where?: MonthPlanWhereInput
  }

  export type MonthPlanUpdateToOneWithWhereWithoutWeekPlansInput = {
    where?: MonthPlanWhereInput
    data: XOR<MonthPlanUpdateWithoutWeekPlansInput, MonthPlanUncheckedUpdateWithoutWeekPlansInput>
  }

  export type MonthPlanUpdateWithoutWeekPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    objectives?: MonthPlanUpdateobjectivesInput | string[]
    completionRate?: FloatFieldUpdateOperationsInput | number
    energyRating?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    monthFocuses?: MonthFocusUpdateManyWithoutMonthPlanNestedInput
    quarterPlan?: QuarterPlanUpdateOneRequiredWithoutMonthPlansNestedInput
  }

  export type MonthPlanUncheckedUpdateWithoutWeekPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    quarterPlanId?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    objectives?: MonthPlanUpdateobjectivesInput | string[]
    completionRate?: FloatFieldUpdateOperationsInput | number
    energyRating?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    monthFocuses?: MonthFocusUncheckedUpdateManyWithoutMonthPlanNestedInput
  }

  export type UserUpsertWithoutWeekPlansInput = {
    update: XOR<UserUpdateWithoutWeekPlansInput, UserUncheckedUpdateWithoutWeekPlansInput>
    create: XOR<UserCreateWithoutWeekPlansInput, UserUncheckedCreateWithoutWeekPlansInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWeekPlansInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWeekPlansInput, UserUncheckedUpdateWithoutWeekPlansInput>
  }

  export type UserUpdateWithoutWeekPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    geminiModel?: StringFieldUpdateOperationsInput | string
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    llmProvider?: StringFieldUpdateOperationsInput | string
    serperApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    researchLimit?: IntFieldUpdateOperationsInput | number
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    captures?: CaptureUpdateManyWithoutUserNestedInput
    clients?: ClientUpdateManyWithoutUserNestedInput
    dayPlans?: DayPlanUpdateManyWithoutUserNestedInput
    meetings?: MeetingUpdateManyWithoutUserNestedInput
    notes?: NoteUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    researches?: ResearchUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    voiceSessions?: VoiceSessionUpdateManyWithoutUserNestedInput
    wellBeingEntries?: WellBeingEntryUpdateManyWithoutUserNestedInput
    yearPlans?: YearPlanUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWeekPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    geminiModel?: StringFieldUpdateOperationsInput | string
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    llmProvider?: StringFieldUpdateOperationsInput | string
    serperApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    researchLimit?: IntFieldUpdateOperationsInput | number
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    captures?: CaptureUncheckedUpdateManyWithoutUserNestedInput
    clients?: ClientUncheckedUpdateManyWithoutUserNestedInput
    dayPlans?: DayPlanUncheckedUpdateManyWithoutUserNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutUserNestedInput
    notes?: NoteUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    researches?: ResearchUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    voiceSessions?: VoiceSessionUncheckedUpdateManyWithoutUserNestedInput
    wellBeingEntries?: WellBeingEntryUncheckedUpdateManyWithoutUserNestedInput
    yearPlans?: YearPlanUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DayFocusCreateWithoutWeekFocusInput = {
    id?: string
    priority?: number
    completed?: boolean
    completedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dayPlan: DayPlanCreateNestedOneWithoutDayFocusesInput
  }

  export type DayFocusUncheckedCreateWithoutWeekFocusInput = {
    id?: string
    dayPlanId: string
    priority?: number
    completed?: boolean
    completedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DayFocusCreateOrConnectWithoutWeekFocusInput = {
    where: DayFocusWhereUniqueInput
    create: XOR<DayFocusCreateWithoutWeekFocusInput, DayFocusUncheckedCreateWithoutWeekFocusInput>
  }

  export type DayFocusCreateManyWeekFocusInputEnvelope = {
    data: DayFocusCreateManyWeekFocusInput | DayFocusCreateManyWeekFocusInput[]
    skipDuplicates?: boolean
  }

  export type MonthFocusCreateWithoutWeekFocusesInput = {
    id?: string
    priority?: number
    progress?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    monthPlan: MonthPlanCreateNestedOneWithoutMonthFocusesInput
    quarterFocus: QuarterFocusCreateNestedOneWithoutMonthFocusesInput
  }

  export type MonthFocusUncheckedCreateWithoutWeekFocusesInput = {
    id?: string
    monthPlanId: string
    quarterFocusId: string
    priority?: number
    progress?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MonthFocusCreateOrConnectWithoutWeekFocusesInput = {
    where: MonthFocusWhereUniqueInput
    create: XOR<MonthFocusCreateWithoutWeekFocusesInput, MonthFocusUncheckedCreateWithoutWeekFocusesInput>
  }

  export type WeekPlanCreateWithoutWeekFocusesInput = {
    id?: string
    weekNumber: number
    year: number
    startDate: Date | string
    endDate: Date | string
    topOutcomes?: WeekPlanCreatetopOutcomesInput | string[]
    plannedClientHours?: number | null
    plannedPersonalHours?: number | null
    challenges?: WeekPlanCreatechallengesInput | string[]
    keyWins?: WeekPlanCreatekeyWinsInput | string[]
    lessonsLearned?: WeekPlanCreatelessonsLearnedInput | string[]
    rating?: number | null
    reviewNotes?: string | null
    dayPlans?: DayPlanCreateNestedManyWithoutWeekPlanInput
    monthPlan: MonthPlanCreateNestedOneWithoutWeekPlansInput
    user: UserCreateNestedOneWithoutWeekPlansInput
  }

  export type WeekPlanUncheckedCreateWithoutWeekFocusesInput = {
    id?: string
    monthPlanId: string
    weekNumber: number
    year: number
    startDate: Date | string
    endDate: Date | string
    topOutcomes?: WeekPlanCreatetopOutcomesInput | string[]
    plannedClientHours?: number | null
    plannedPersonalHours?: number | null
    userId: string
    challenges?: WeekPlanCreatechallengesInput | string[]
    keyWins?: WeekPlanCreatekeyWinsInput | string[]
    lessonsLearned?: WeekPlanCreatelessonsLearnedInput | string[]
    rating?: number | null
    reviewNotes?: string | null
    dayPlans?: DayPlanUncheckedCreateNestedManyWithoutWeekPlanInput
  }

  export type WeekPlanCreateOrConnectWithoutWeekFocusesInput = {
    where: WeekPlanWhereUniqueInput
    create: XOR<WeekPlanCreateWithoutWeekFocusesInput, WeekPlanUncheckedCreateWithoutWeekFocusesInput>
  }

  export type DayFocusUpsertWithWhereUniqueWithoutWeekFocusInput = {
    where: DayFocusWhereUniqueInput
    update: XOR<DayFocusUpdateWithoutWeekFocusInput, DayFocusUncheckedUpdateWithoutWeekFocusInput>
    create: XOR<DayFocusCreateWithoutWeekFocusInput, DayFocusUncheckedCreateWithoutWeekFocusInput>
  }

  export type DayFocusUpdateWithWhereUniqueWithoutWeekFocusInput = {
    where: DayFocusWhereUniqueInput
    data: XOR<DayFocusUpdateWithoutWeekFocusInput, DayFocusUncheckedUpdateWithoutWeekFocusInput>
  }

  export type DayFocusUpdateManyWithWhereWithoutWeekFocusInput = {
    where: DayFocusScalarWhereInput
    data: XOR<DayFocusUpdateManyMutationInput, DayFocusUncheckedUpdateManyWithoutWeekFocusInput>
  }

  export type DayFocusScalarWhereInput = {
    AND?: DayFocusScalarWhereInput | DayFocusScalarWhereInput[]
    OR?: DayFocusScalarWhereInput[]
    NOT?: DayFocusScalarWhereInput | DayFocusScalarWhereInput[]
    id?: StringFilter<"DayFocus"> | string
    dayPlanId?: StringFilter<"DayFocus"> | string
    weekFocusId?: StringFilter<"DayFocus"> | string
    priority?: IntFilter<"DayFocus"> | number
    completed?: BoolFilter<"DayFocus"> | boolean
    completedAt?: DateTimeNullableFilter<"DayFocus"> | Date | string | null
    notes?: StringNullableFilter<"DayFocus"> | string | null
    createdAt?: DateTimeFilter<"DayFocus"> | Date | string
    updatedAt?: DateTimeFilter<"DayFocus"> | Date | string
  }

  export type MonthFocusUpsertWithoutWeekFocusesInput = {
    update: XOR<MonthFocusUpdateWithoutWeekFocusesInput, MonthFocusUncheckedUpdateWithoutWeekFocusesInput>
    create: XOR<MonthFocusCreateWithoutWeekFocusesInput, MonthFocusUncheckedCreateWithoutWeekFocusesInput>
    where?: MonthFocusWhereInput
  }

  export type MonthFocusUpdateToOneWithWhereWithoutWeekFocusesInput = {
    where?: MonthFocusWhereInput
    data: XOR<MonthFocusUpdateWithoutWeekFocusesInput, MonthFocusUncheckedUpdateWithoutWeekFocusesInput>
  }

  export type MonthFocusUpdateWithoutWeekFocusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monthPlan?: MonthPlanUpdateOneRequiredWithoutMonthFocusesNestedInput
    quarterFocus?: QuarterFocusUpdateOneRequiredWithoutMonthFocusesNestedInput
  }

  export type MonthFocusUncheckedUpdateWithoutWeekFocusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthPlanId?: StringFieldUpdateOperationsInput | string
    quarterFocusId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeekPlanUpsertWithoutWeekFocusesInput = {
    update: XOR<WeekPlanUpdateWithoutWeekFocusesInput, WeekPlanUncheckedUpdateWithoutWeekFocusesInput>
    create: XOR<WeekPlanCreateWithoutWeekFocusesInput, WeekPlanUncheckedCreateWithoutWeekFocusesInput>
    where?: WeekPlanWhereInput
  }

  export type WeekPlanUpdateToOneWithWhereWithoutWeekFocusesInput = {
    where?: WeekPlanWhereInput
    data: XOR<WeekPlanUpdateWithoutWeekFocusesInput, WeekPlanUncheckedUpdateWithoutWeekFocusesInput>
  }

  export type WeekPlanUpdateWithoutWeekFocusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    topOutcomes?: WeekPlanUpdatetopOutcomesInput | string[]
    plannedClientHours?: NullableFloatFieldUpdateOperationsInput | number | null
    plannedPersonalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    challenges?: WeekPlanUpdatechallengesInput | string[]
    keyWins?: WeekPlanUpdatekeyWinsInput | string[]
    lessonsLearned?: WeekPlanUpdatelessonsLearnedInput | string[]
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dayPlans?: DayPlanUpdateManyWithoutWeekPlanNestedInput
    monthPlan?: MonthPlanUpdateOneRequiredWithoutWeekPlansNestedInput
    user?: UserUpdateOneRequiredWithoutWeekPlansNestedInput
  }

  export type WeekPlanUncheckedUpdateWithoutWeekFocusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthPlanId?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    topOutcomes?: WeekPlanUpdatetopOutcomesInput | string[]
    plannedClientHours?: NullableFloatFieldUpdateOperationsInput | number | null
    plannedPersonalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    challenges?: WeekPlanUpdatechallengesInput | string[]
    keyWins?: WeekPlanUpdatekeyWinsInput | string[]
    lessonsLearned?: WeekPlanUpdatelessonsLearnedInput | string[]
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dayPlans?: DayPlanUncheckedUpdateManyWithoutWeekPlanNestedInput
  }

  export type DayFocusCreateWithoutDayPlanInput = {
    id?: string
    priority?: number
    completed?: boolean
    completedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    weekFocus: WeekFocusCreateNestedOneWithoutDayFocusesInput
  }

  export type DayFocusUncheckedCreateWithoutDayPlanInput = {
    id?: string
    weekFocusId: string
    priority?: number
    completed?: boolean
    completedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DayFocusCreateOrConnectWithoutDayPlanInput = {
    where: DayFocusWhereUniqueInput
    create: XOR<DayFocusCreateWithoutDayPlanInput, DayFocusUncheckedCreateWithoutDayPlanInput>
  }

  export type DayFocusCreateManyDayPlanInputEnvelope = {
    data: DayFocusCreateManyDayPlanInput | DayFocusCreateManyDayPlanInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutDayPlansInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    geminiApiKey?: string | null
    geminiModel?: string
    groqApiKey?: string | null
    llmProvider?: string
    serperApiKey?: string | null
    researchLimit?: number
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    captures?: CaptureCreateNestedManyWithoutUserInput
    clients?: ClientCreateNestedManyWithoutUserInput
    meetings?: MeetingCreateNestedManyWithoutUserInput
    notes?: NoteCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    researches?: ResearchCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    voiceSessions?: VoiceSessionCreateNestedManyWithoutUserInput
    weekPlans?: WeekPlanCreateNestedManyWithoutUserInput
    wellBeingEntries?: WellBeingEntryCreateNestedManyWithoutUserInput
    yearPlans?: YearPlanCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDayPlansInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    geminiApiKey?: string | null
    geminiModel?: string
    groqApiKey?: string | null
    llmProvider?: string
    serperApiKey?: string | null
    researchLimit?: number
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    captures?: CaptureUncheckedCreateNestedManyWithoutUserInput
    clients?: ClientUncheckedCreateNestedManyWithoutUserInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutUserInput
    notes?: NoteUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    researches?: ResearchUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    voiceSessions?: VoiceSessionUncheckedCreateNestedManyWithoutUserInput
    weekPlans?: WeekPlanUncheckedCreateNestedManyWithoutUserInput
    wellBeingEntries?: WellBeingEntryUncheckedCreateNestedManyWithoutUserInput
    yearPlans?: YearPlanUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDayPlansInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDayPlansInput, UserUncheckedCreateWithoutDayPlansInput>
  }

  export type WeekPlanCreateWithoutDayPlansInput = {
    id?: string
    weekNumber: number
    year: number
    startDate: Date | string
    endDate: Date | string
    topOutcomes?: WeekPlanCreatetopOutcomesInput | string[]
    plannedClientHours?: number | null
    plannedPersonalHours?: number | null
    challenges?: WeekPlanCreatechallengesInput | string[]
    keyWins?: WeekPlanCreatekeyWinsInput | string[]
    lessonsLearned?: WeekPlanCreatelessonsLearnedInput | string[]
    rating?: number | null
    reviewNotes?: string | null
    weekFocuses?: WeekFocusCreateNestedManyWithoutWeekPlanInput
    monthPlan: MonthPlanCreateNestedOneWithoutWeekPlansInput
    user: UserCreateNestedOneWithoutWeekPlansInput
  }

  export type WeekPlanUncheckedCreateWithoutDayPlansInput = {
    id?: string
    monthPlanId: string
    weekNumber: number
    year: number
    startDate: Date | string
    endDate: Date | string
    topOutcomes?: WeekPlanCreatetopOutcomesInput | string[]
    plannedClientHours?: number | null
    plannedPersonalHours?: number | null
    userId: string
    challenges?: WeekPlanCreatechallengesInput | string[]
    keyWins?: WeekPlanCreatekeyWinsInput | string[]
    lessonsLearned?: WeekPlanCreatelessonsLearnedInput | string[]
    rating?: number | null
    reviewNotes?: string | null
    weekFocuses?: WeekFocusUncheckedCreateNestedManyWithoutWeekPlanInput
  }

  export type WeekPlanCreateOrConnectWithoutDayPlansInput = {
    where: WeekPlanWhereUniqueInput
    create: XOR<WeekPlanCreateWithoutDayPlansInput, WeekPlanUncheckedCreateWithoutDayPlansInput>
  }

  export type NoteCreateWithoutDayPlanInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    goal?: GoalCreateNestedOneWithoutNotesInput
    keyStep?: KeyStepCreateNestedOneWithoutNotesInput
    user: UserCreateNestedOneWithoutNotesInput
  }

  export type NoteUncheckedCreateWithoutDayPlanInput = {
    id?: string
    userId: string
    content: string
    goalId?: string | null
    keyStepId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoteCreateOrConnectWithoutDayPlanInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutDayPlanInput, NoteUncheckedCreateWithoutDayPlanInput>
  }

  export type NoteCreateManyDayPlanInputEnvelope = {
    data: NoteCreateManyDayPlanInput | NoteCreateManyDayPlanInput[]
    skipDuplicates?: boolean
  }

  export type TimeBlockCreateWithoutDayPlanInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    duration: number
    type: string
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    actualDuration?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    focusQuality?: number | null
    notes?: string | null
    client?: ClientCreateNestedOneWithoutTimeBlocksInput
    project?: ProjectCreateNestedOneWithoutTimeBlocksInput
    task?: TaskCreateNestedOneWithoutTimeBlocksInput
  }

  export type TimeBlockUncheckedCreateWithoutDayPlanInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    duration: number
    type: string
    taskId?: string | null
    projectId?: string | null
    clientId?: string | null
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    actualDuration?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    focusQuality?: number | null
    notes?: string | null
  }

  export type TimeBlockCreateOrConnectWithoutDayPlanInput = {
    where: TimeBlockWhereUniqueInput
    create: XOR<TimeBlockCreateWithoutDayPlanInput, TimeBlockUncheckedCreateWithoutDayPlanInput>
  }

  export type TimeBlockCreateManyDayPlanInputEnvelope = {
    data: TimeBlockCreateManyDayPlanInput | TimeBlockCreateManyDayPlanInput[]
    skipDuplicates?: boolean
  }

  export type DayFocusUpsertWithWhereUniqueWithoutDayPlanInput = {
    where: DayFocusWhereUniqueInput
    update: XOR<DayFocusUpdateWithoutDayPlanInput, DayFocusUncheckedUpdateWithoutDayPlanInput>
    create: XOR<DayFocusCreateWithoutDayPlanInput, DayFocusUncheckedCreateWithoutDayPlanInput>
  }

  export type DayFocusUpdateWithWhereUniqueWithoutDayPlanInput = {
    where: DayFocusWhereUniqueInput
    data: XOR<DayFocusUpdateWithoutDayPlanInput, DayFocusUncheckedUpdateWithoutDayPlanInput>
  }

  export type DayFocusUpdateManyWithWhereWithoutDayPlanInput = {
    where: DayFocusScalarWhereInput
    data: XOR<DayFocusUpdateManyMutationInput, DayFocusUncheckedUpdateManyWithoutDayPlanInput>
  }

  export type UserUpsertWithoutDayPlansInput = {
    update: XOR<UserUpdateWithoutDayPlansInput, UserUncheckedUpdateWithoutDayPlansInput>
    create: XOR<UserCreateWithoutDayPlansInput, UserUncheckedCreateWithoutDayPlansInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDayPlansInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDayPlansInput, UserUncheckedUpdateWithoutDayPlansInput>
  }

  export type UserUpdateWithoutDayPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    geminiModel?: StringFieldUpdateOperationsInput | string
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    llmProvider?: StringFieldUpdateOperationsInput | string
    serperApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    researchLimit?: IntFieldUpdateOperationsInput | number
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    captures?: CaptureUpdateManyWithoutUserNestedInput
    clients?: ClientUpdateManyWithoutUserNestedInput
    meetings?: MeetingUpdateManyWithoutUserNestedInput
    notes?: NoteUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    researches?: ResearchUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    voiceSessions?: VoiceSessionUpdateManyWithoutUserNestedInput
    weekPlans?: WeekPlanUpdateManyWithoutUserNestedInput
    wellBeingEntries?: WellBeingEntryUpdateManyWithoutUserNestedInput
    yearPlans?: YearPlanUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDayPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    geminiModel?: StringFieldUpdateOperationsInput | string
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    llmProvider?: StringFieldUpdateOperationsInput | string
    serperApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    researchLimit?: IntFieldUpdateOperationsInput | number
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    captures?: CaptureUncheckedUpdateManyWithoutUserNestedInput
    clients?: ClientUncheckedUpdateManyWithoutUserNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutUserNestedInput
    notes?: NoteUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    researches?: ResearchUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    voiceSessions?: VoiceSessionUncheckedUpdateManyWithoutUserNestedInput
    weekPlans?: WeekPlanUncheckedUpdateManyWithoutUserNestedInput
    wellBeingEntries?: WellBeingEntryUncheckedUpdateManyWithoutUserNestedInput
    yearPlans?: YearPlanUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WeekPlanUpsertWithoutDayPlansInput = {
    update: XOR<WeekPlanUpdateWithoutDayPlansInput, WeekPlanUncheckedUpdateWithoutDayPlansInput>
    create: XOR<WeekPlanCreateWithoutDayPlansInput, WeekPlanUncheckedCreateWithoutDayPlansInput>
    where?: WeekPlanWhereInput
  }

  export type WeekPlanUpdateToOneWithWhereWithoutDayPlansInput = {
    where?: WeekPlanWhereInput
    data: XOR<WeekPlanUpdateWithoutDayPlansInput, WeekPlanUncheckedUpdateWithoutDayPlansInput>
  }

  export type WeekPlanUpdateWithoutDayPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    topOutcomes?: WeekPlanUpdatetopOutcomesInput | string[]
    plannedClientHours?: NullableFloatFieldUpdateOperationsInput | number | null
    plannedPersonalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    challenges?: WeekPlanUpdatechallengesInput | string[]
    keyWins?: WeekPlanUpdatekeyWinsInput | string[]
    lessonsLearned?: WeekPlanUpdatelessonsLearnedInput | string[]
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    weekFocuses?: WeekFocusUpdateManyWithoutWeekPlanNestedInput
    monthPlan?: MonthPlanUpdateOneRequiredWithoutWeekPlansNestedInput
    user?: UserUpdateOneRequiredWithoutWeekPlansNestedInput
  }

  export type WeekPlanUncheckedUpdateWithoutDayPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthPlanId?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    topOutcomes?: WeekPlanUpdatetopOutcomesInput | string[]
    plannedClientHours?: NullableFloatFieldUpdateOperationsInput | number | null
    plannedPersonalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    challenges?: WeekPlanUpdatechallengesInput | string[]
    keyWins?: WeekPlanUpdatekeyWinsInput | string[]
    lessonsLearned?: WeekPlanUpdatelessonsLearnedInput | string[]
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    weekFocuses?: WeekFocusUncheckedUpdateManyWithoutWeekPlanNestedInput
  }

  export type NoteUpsertWithWhereUniqueWithoutDayPlanInput = {
    where: NoteWhereUniqueInput
    update: XOR<NoteUpdateWithoutDayPlanInput, NoteUncheckedUpdateWithoutDayPlanInput>
    create: XOR<NoteCreateWithoutDayPlanInput, NoteUncheckedCreateWithoutDayPlanInput>
  }

  export type NoteUpdateWithWhereUniqueWithoutDayPlanInput = {
    where: NoteWhereUniqueInput
    data: XOR<NoteUpdateWithoutDayPlanInput, NoteUncheckedUpdateWithoutDayPlanInput>
  }

  export type NoteUpdateManyWithWhereWithoutDayPlanInput = {
    where: NoteScalarWhereInput
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyWithoutDayPlanInput>
  }

  export type TimeBlockUpsertWithWhereUniqueWithoutDayPlanInput = {
    where: TimeBlockWhereUniqueInput
    update: XOR<TimeBlockUpdateWithoutDayPlanInput, TimeBlockUncheckedUpdateWithoutDayPlanInput>
    create: XOR<TimeBlockCreateWithoutDayPlanInput, TimeBlockUncheckedCreateWithoutDayPlanInput>
  }

  export type TimeBlockUpdateWithWhereUniqueWithoutDayPlanInput = {
    where: TimeBlockWhereUniqueInput
    data: XOR<TimeBlockUpdateWithoutDayPlanInput, TimeBlockUncheckedUpdateWithoutDayPlanInput>
  }

  export type TimeBlockUpdateManyWithWhereWithoutDayPlanInput = {
    where: TimeBlockScalarWhereInput
    data: XOR<TimeBlockUpdateManyMutationInput, TimeBlockUncheckedUpdateManyWithoutDayPlanInput>
  }

  export type TimeBlockScalarWhereInput = {
    AND?: TimeBlockScalarWhereInput | TimeBlockScalarWhereInput[]
    OR?: TimeBlockScalarWhereInput[]
    NOT?: TimeBlockScalarWhereInput | TimeBlockScalarWhereInput[]
    id?: StringFilter<"TimeBlock"> | string
    dayPlanId?: StringFilter<"TimeBlock"> | string
    startTime?: DateTimeFilter<"TimeBlock"> | Date | string
    endTime?: DateTimeFilter<"TimeBlock"> | Date | string
    duration?: IntFilter<"TimeBlock"> | number
    type?: StringFilter<"TimeBlock"> | string
    taskId?: StringNullableFilter<"TimeBlock"> | string | null
    projectId?: StringNullableFilter<"TimeBlock"> | string | null
    clientId?: StringNullableFilter<"TimeBlock"> | string | null
    actualStartTime?: DateTimeNullableFilter<"TimeBlock"> | Date | string | null
    actualEndTime?: DateTimeNullableFilter<"TimeBlock"> | Date | string | null
    actualDuration?: IntNullableFilter<"TimeBlock"> | number | null
    energyBefore?: FloatNullableFilter<"TimeBlock"> | number | null
    energyAfter?: FloatNullableFilter<"TimeBlock"> | number | null
    focusQuality?: FloatNullableFilter<"TimeBlock"> | number | null
    notes?: StringNullableFilter<"TimeBlock"> | string | null
  }

  export type DayPlanCreateWithoutDayFocusesInput = {
    id?: string
    date: Date | string
    topPriorities?: DayPlanCreatetopPrioritiesInput | string[]
    morningEnergy?: number | null
    afternoonEnergy?: number | null
    eveningEnergy?: number | null
    dailyWin?: string | null
    gratitude?: DayPlanCreategratitudeInput | string[]
    tomorrowPrep?: DayPlanCreatetomorrowPrepInput | string[]
    completionRate?: number
    user: UserCreateNestedOneWithoutDayPlansInput
    weekPlan: WeekPlanCreateNestedOneWithoutDayPlansInput
    notes?: NoteCreateNestedManyWithoutDayPlanInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutDayPlanInput
  }

  export type DayPlanUncheckedCreateWithoutDayFocusesInput = {
    id?: string
    weekPlanId: string
    date: Date | string
    topPriorities?: DayPlanCreatetopPrioritiesInput | string[]
    morningEnergy?: number | null
    afternoonEnergy?: number | null
    eveningEnergy?: number | null
    dailyWin?: string | null
    gratitude?: DayPlanCreategratitudeInput | string[]
    tomorrowPrep?: DayPlanCreatetomorrowPrepInput | string[]
    completionRate?: number
    userId: string
    notes?: NoteUncheckedCreateNestedManyWithoutDayPlanInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutDayPlanInput
  }

  export type DayPlanCreateOrConnectWithoutDayFocusesInput = {
    where: DayPlanWhereUniqueInput
    create: XOR<DayPlanCreateWithoutDayFocusesInput, DayPlanUncheckedCreateWithoutDayFocusesInput>
  }

  export type WeekFocusCreateWithoutDayFocusesInput = {
    id?: string
    priority?: number
    progress?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    monthFocus: MonthFocusCreateNestedOneWithoutWeekFocusesInput
    weekPlan: WeekPlanCreateNestedOneWithoutWeekFocusesInput
  }

  export type WeekFocusUncheckedCreateWithoutDayFocusesInput = {
    id?: string
    weekPlanId: string
    monthFocusId: string
    priority?: number
    progress?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeekFocusCreateOrConnectWithoutDayFocusesInput = {
    where: WeekFocusWhereUniqueInput
    create: XOR<WeekFocusCreateWithoutDayFocusesInput, WeekFocusUncheckedCreateWithoutDayFocusesInput>
  }

  export type DayPlanUpsertWithoutDayFocusesInput = {
    update: XOR<DayPlanUpdateWithoutDayFocusesInput, DayPlanUncheckedUpdateWithoutDayFocusesInput>
    create: XOR<DayPlanCreateWithoutDayFocusesInput, DayPlanUncheckedCreateWithoutDayFocusesInput>
    where?: DayPlanWhereInput
  }

  export type DayPlanUpdateToOneWithWhereWithoutDayFocusesInput = {
    where?: DayPlanWhereInput
    data: XOR<DayPlanUpdateWithoutDayFocusesInput, DayPlanUncheckedUpdateWithoutDayFocusesInput>
  }

  export type DayPlanUpdateWithoutDayFocusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topPriorities?: DayPlanUpdatetopPrioritiesInput | string[]
    morningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    afternoonEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    eveningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyWin?: NullableStringFieldUpdateOperationsInput | string | null
    gratitude?: DayPlanUpdategratitudeInput | string[]
    tomorrowPrep?: DayPlanUpdatetomorrowPrepInput | string[]
    completionRate?: FloatFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutDayPlansNestedInput
    weekPlan?: WeekPlanUpdateOneRequiredWithoutDayPlansNestedInput
    notes?: NoteUpdateManyWithoutDayPlanNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutDayPlanNestedInput
  }

  export type DayPlanUncheckedUpdateWithoutDayFocusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekPlanId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topPriorities?: DayPlanUpdatetopPrioritiesInput | string[]
    morningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    afternoonEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    eveningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyWin?: NullableStringFieldUpdateOperationsInput | string | null
    gratitude?: DayPlanUpdategratitudeInput | string[]
    tomorrowPrep?: DayPlanUpdatetomorrowPrepInput | string[]
    completionRate?: FloatFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    notes?: NoteUncheckedUpdateManyWithoutDayPlanNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutDayPlanNestedInput
  }

  export type WeekFocusUpsertWithoutDayFocusesInput = {
    update: XOR<WeekFocusUpdateWithoutDayFocusesInput, WeekFocusUncheckedUpdateWithoutDayFocusesInput>
    create: XOR<WeekFocusCreateWithoutDayFocusesInput, WeekFocusUncheckedCreateWithoutDayFocusesInput>
    where?: WeekFocusWhereInput
  }

  export type WeekFocusUpdateToOneWithWhereWithoutDayFocusesInput = {
    where?: WeekFocusWhereInput
    data: XOR<WeekFocusUpdateWithoutDayFocusesInput, WeekFocusUncheckedUpdateWithoutDayFocusesInput>
  }

  export type WeekFocusUpdateWithoutDayFocusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monthFocus?: MonthFocusUpdateOneRequiredWithoutWeekFocusesNestedInput
    weekPlan?: WeekPlanUpdateOneRequiredWithoutWeekFocusesNestedInput
  }

  export type WeekFocusUncheckedUpdateWithoutDayFocusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekPlanId?: StringFieldUpdateOperationsInput | string
    monthFocusId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateWithoutTimeBlocksInput = {
    id?: string
    name: string
    companyName?: string | null
    email: string
    phone?: string | null
    primaryContact?: NullableJsonNullValueInput | InputJsonValue
    additionalContacts?: ClientCreateadditionalContactsInput | InputJsonValue[]
    industry?: string | null
    website?: string | null
    timezone?: string | null
    relationshipHealth?: number | null
    lastContactedAt?: Date | string | null
    preferredCommunication?: string | null
    defaultHourlyRate?: number | null
    paymentTerms?: string | null
    outstandingBalance?: number
    notes?: string | null
    tags?: ClientCreatetagsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastInteractionAt?: Date | string | null
    user: UserCreateNestedOneWithoutClientsInput
    communications?: CommunicationCreateNestedManyWithoutClientInput
    meetings?: MeetingCreateNestedManyWithoutClientInput
    projects?: ProjectCreateNestedManyWithoutClientInput
    timeEntries?: TimeEntryCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutTimeBlocksInput = {
    id?: string
    userId: string
    name: string
    companyName?: string | null
    email: string
    phone?: string | null
    primaryContact?: NullableJsonNullValueInput | InputJsonValue
    additionalContacts?: ClientCreateadditionalContactsInput | InputJsonValue[]
    industry?: string | null
    website?: string | null
    timezone?: string | null
    relationshipHealth?: number | null
    lastContactedAt?: Date | string | null
    preferredCommunication?: string | null
    defaultHourlyRate?: number | null
    paymentTerms?: string | null
    outstandingBalance?: number
    notes?: string | null
    tags?: ClientCreatetagsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastInteractionAt?: Date | string | null
    communications?: CommunicationUncheckedCreateNestedManyWithoutClientInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutClientInput
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutTimeBlocksInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutTimeBlocksInput, ClientUncheckedCreateWithoutTimeBlocksInput>
  }

  export type DayPlanCreateWithoutTimeBlocksInput = {
    id?: string
    date: Date | string
    topPriorities?: DayPlanCreatetopPrioritiesInput | string[]
    morningEnergy?: number | null
    afternoonEnergy?: number | null
    eveningEnergy?: number | null
    dailyWin?: string | null
    gratitude?: DayPlanCreategratitudeInput | string[]
    tomorrowPrep?: DayPlanCreatetomorrowPrepInput | string[]
    completionRate?: number
    dayFocuses?: DayFocusCreateNestedManyWithoutDayPlanInput
    user: UserCreateNestedOneWithoutDayPlansInput
    weekPlan: WeekPlanCreateNestedOneWithoutDayPlansInput
    notes?: NoteCreateNestedManyWithoutDayPlanInput
  }

  export type DayPlanUncheckedCreateWithoutTimeBlocksInput = {
    id?: string
    weekPlanId: string
    date: Date | string
    topPriorities?: DayPlanCreatetopPrioritiesInput | string[]
    morningEnergy?: number | null
    afternoonEnergy?: number | null
    eveningEnergy?: number | null
    dailyWin?: string | null
    gratitude?: DayPlanCreategratitudeInput | string[]
    tomorrowPrep?: DayPlanCreatetomorrowPrepInput | string[]
    completionRate?: number
    userId: string
    dayFocuses?: DayFocusUncheckedCreateNestedManyWithoutDayPlanInput
    notes?: NoteUncheckedCreateNestedManyWithoutDayPlanInput
  }

  export type DayPlanCreateOrConnectWithoutTimeBlocksInput = {
    where: DayPlanWhereUniqueInput
    create: XOR<DayPlanCreateWithoutTimeBlocksInput, DayPlanUncheckedCreateWithoutTimeBlocksInput>
  }

  export type ProjectCreateWithoutTimeBlocksInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    status: string
    billable?: boolean
    hourlyRate?: number | null
    budgetHours?: number | null
    startDate?: Date | string | null
    deadline?: Date | string | null
    estimatedHours?: number | null
    actualHoursSpent?: number
    completionPercentage?: number
    goalId?: string | null
    parentProjectId?: string | null
    priority: string
    tags?: ProjectCreatetagsInput | string[]
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    archivedAt?: Date | string | null
    icon?: string | null
    client?: ClientCreateNestedOneWithoutProjectsInput
    user: UserCreateNestedOneWithoutProjectsInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    timeEntries?: TimeEntryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutTimeBlocksInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    type: string
    status: string
    clientId?: string | null
    billable?: boolean
    hourlyRate?: number | null
    budgetHours?: number | null
    startDate?: Date | string | null
    deadline?: Date | string | null
    estimatedHours?: number | null
    actualHoursSpent?: number
    completionPercentage?: number
    goalId?: string | null
    parentProjectId?: string | null
    priority: string
    tags?: ProjectCreatetagsInput | string[]
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    archivedAt?: Date | string | null
    icon?: string | null
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTimeBlocksInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTimeBlocksInput, ProjectUncheckedCreateWithoutTimeBlocksInput>
  }

  export type TaskCreateWithoutTimeBlocksInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    estimatedMinutes?: number | null
    actualMinutes?: number
    timerRunning?: boolean
    currentTimerStart?: Date | string | null
    scheduledDate?: Date | string | null
    dueDate?: Date | string | null
    priority: string
    type: string
    tags?: TaskCreatetagsInput | string[]
    parentTaskId?: string | null
    dependsOn?: TaskCreatedependsOnInput | string[]
    blocks?: TaskCreateblocksInput | string[]
    energyRequired?: number | null
    isAdHoc?: boolean
    isRecurring?: boolean
    recurringPattern?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actionItem?: ActionItemCreateNestedOneWithoutConvertedToTaskInput
    goal?: GoalCreateNestedOneWithoutTasksInput
    keyStep?: KeyStepCreateNestedOneWithoutTasksInput
    meeting?: MeetingCreateNestedOneWithoutTasksInput
    project?: ProjectCreateNestedOneWithoutTasksInput
    user: UserCreateNestedOneWithoutTasksInput
    timeEntries?: TimeEntryCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutTimeBlocksInput = {
    id?: string
    userId: string
    projectId?: string | null
    title: string
    description?: string | null
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    estimatedMinutes?: number | null
    actualMinutes?: number
    timerRunning?: boolean
    currentTimerStart?: Date | string | null
    scheduledDate?: Date | string | null
    dueDate?: Date | string | null
    priority: string
    type: string
    tags?: TaskCreatetagsInput | string[]
    parentTaskId?: string | null
    dependsOn?: TaskCreatedependsOnInput | string[]
    blocks?: TaskCreateblocksInput | string[]
    energyRequired?: number | null
    isAdHoc?: boolean
    isRecurring?: boolean
    recurringPattern?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meetingId?: string | null
    goalId?: string | null
    keyStepId?: string | null
    actionItem?: ActionItemUncheckedCreateNestedOneWithoutConvertedToTaskInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutTimeBlocksInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutTimeBlocksInput, TaskUncheckedCreateWithoutTimeBlocksInput>
  }

  export type ClientUpsertWithoutTimeBlocksInput = {
    update: XOR<ClientUpdateWithoutTimeBlocksInput, ClientUncheckedUpdateWithoutTimeBlocksInput>
    create: XOR<ClientCreateWithoutTimeBlocksInput, ClientUncheckedCreateWithoutTimeBlocksInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutTimeBlocksInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutTimeBlocksInput, ClientUncheckedUpdateWithoutTimeBlocksInput>
  }

  export type ClientUpdateWithoutTimeBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContact?: NullableJsonNullValueInput | InputJsonValue
    additionalContacts?: ClientUpdateadditionalContactsInput | InputJsonValue[]
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipHealth?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredCommunication?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    outstandingBalance?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ClientUpdatetagsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastInteractionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutClientsNestedInput
    communications?: CommunicationUpdateManyWithoutClientNestedInput
    meetings?: MeetingUpdateManyWithoutClientNestedInput
    projects?: ProjectUpdateManyWithoutClientNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutTimeBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContact?: NullableJsonNullValueInput | InputJsonValue
    additionalContacts?: ClientUpdateadditionalContactsInput | InputJsonValue[]
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipHealth?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredCommunication?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    outstandingBalance?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ClientUpdatetagsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastInteractionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communications?: CommunicationUncheckedUpdateManyWithoutClientNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutClientNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutClientNestedInput
  }

  export type DayPlanUpsertWithoutTimeBlocksInput = {
    update: XOR<DayPlanUpdateWithoutTimeBlocksInput, DayPlanUncheckedUpdateWithoutTimeBlocksInput>
    create: XOR<DayPlanCreateWithoutTimeBlocksInput, DayPlanUncheckedCreateWithoutTimeBlocksInput>
    where?: DayPlanWhereInput
  }

  export type DayPlanUpdateToOneWithWhereWithoutTimeBlocksInput = {
    where?: DayPlanWhereInput
    data: XOR<DayPlanUpdateWithoutTimeBlocksInput, DayPlanUncheckedUpdateWithoutTimeBlocksInput>
  }

  export type DayPlanUpdateWithoutTimeBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topPriorities?: DayPlanUpdatetopPrioritiesInput | string[]
    morningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    afternoonEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    eveningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyWin?: NullableStringFieldUpdateOperationsInput | string | null
    gratitude?: DayPlanUpdategratitudeInput | string[]
    tomorrowPrep?: DayPlanUpdatetomorrowPrepInput | string[]
    completionRate?: FloatFieldUpdateOperationsInput | number
    dayFocuses?: DayFocusUpdateManyWithoutDayPlanNestedInput
    user?: UserUpdateOneRequiredWithoutDayPlansNestedInput
    weekPlan?: WeekPlanUpdateOneRequiredWithoutDayPlansNestedInput
    notes?: NoteUpdateManyWithoutDayPlanNestedInput
  }

  export type DayPlanUncheckedUpdateWithoutTimeBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekPlanId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topPriorities?: DayPlanUpdatetopPrioritiesInput | string[]
    morningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    afternoonEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    eveningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyWin?: NullableStringFieldUpdateOperationsInput | string | null
    gratitude?: DayPlanUpdategratitudeInput | string[]
    tomorrowPrep?: DayPlanUpdatetomorrowPrepInput | string[]
    completionRate?: FloatFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    dayFocuses?: DayFocusUncheckedUpdateManyWithoutDayPlanNestedInput
    notes?: NoteUncheckedUpdateManyWithoutDayPlanNestedInput
  }

  export type ProjectUpsertWithoutTimeBlocksInput = {
    update: XOR<ProjectUpdateWithoutTimeBlocksInput, ProjectUncheckedUpdateWithoutTimeBlocksInput>
    create: XOR<ProjectCreateWithoutTimeBlocksInput, ProjectUncheckedCreateWithoutTimeBlocksInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTimeBlocksInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTimeBlocksInput, ProjectUncheckedUpdateWithoutTimeBlocksInput>
  }

  export type ProjectUpdateWithoutTimeBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    billable?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetHours?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHoursSpent?: FloatFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    parentProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    tags?: ProjectUpdatetagsInput | string[]
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneWithoutProjectsNestedInput
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTimeBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    billable?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetHours?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHoursSpent?: FloatFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    parentProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    tags?: ProjectUpdatetagsInput | string[]
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TaskUpsertWithoutTimeBlocksInput = {
    update: XOR<TaskUpdateWithoutTimeBlocksInput, TaskUncheckedUpdateWithoutTimeBlocksInput>
    create: XOR<TaskCreateWithoutTimeBlocksInput, TaskUncheckedCreateWithoutTimeBlocksInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutTimeBlocksInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutTimeBlocksInput, TaskUncheckedUpdateWithoutTimeBlocksInput>
  }

  export type TaskUpdateWithoutTimeBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    actualMinutes?: IntFieldUpdateOperationsInput | number
    timerRunning?: BoolFieldUpdateOperationsInput | boolean
    currentTimerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tags?: TaskUpdatetagsInput | string[]
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOn?: TaskUpdatedependsOnInput | string[]
    blocks?: TaskUpdateblocksInput | string[]
    energyRequired?: NullableFloatFieldUpdateOperationsInput | number | null
    isAdHoc?: BoolFieldUpdateOperationsInput | boolean
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionItem?: ActionItemUpdateOneWithoutConvertedToTaskNestedInput
    goal?: GoalUpdateOneWithoutTasksNestedInput
    keyStep?: KeyStepUpdateOneWithoutTasksNestedInput
    meeting?: MeetingUpdateOneWithoutTasksNestedInput
    project?: ProjectUpdateOneWithoutTasksNestedInput
    user?: UserUpdateOneRequiredWithoutTasksNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutTimeBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    actualMinutes?: IntFieldUpdateOperationsInput | number
    timerRunning?: BoolFieldUpdateOperationsInput | boolean
    currentTimerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tags?: TaskUpdatetagsInput | string[]
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOn?: TaskUpdatedependsOnInput | string[]
    blocks?: TaskUpdateblocksInput | string[]
    energyRequired?: NullableFloatFieldUpdateOperationsInput | number | null
    isAdHoc?: BoolFieldUpdateOperationsInput | boolean
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    keyStepId?: NullableStringFieldUpdateOperationsInput | string | null
    actionItem?: ActionItemUncheckedUpdateOneWithoutConvertedToTaskNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type ClientCreateWithoutProjectsInput = {
    id?: string
    name: string
    companyName?: string | null
    email: string
    phone?: string | null
    primaryContact?: NullableJsonNullValueInput | InputJsonValue
    additionalContacts?: ClientCreateadditionalContactsInput | InputJsonValue[]
    industry?: string | null
    website?: string | null
    timezone?: string | null
    relationshipHealth?: number | null
    lastContactedAt?: Date | string | null
    preferredCommunication?: string | null
    defaultHourlyRate?: number | null
    paymentTerms?: string | null
    outstandingBalance?: number
    notes?: string | null
    tags?: ClientCreatetagsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastInteractionAt?: Date | string | null
    user: UserCreateNestedOneWithoutClientsInput
    communications?: CommunicationCreateNestedManyWithoutClientInput
    meetings?: MeetingCreateNestedManyWithoutClientInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutClientInput
    timeEntries?: TimeEntryCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutProjectsInput = {
    id?: string
    userId: string
    name: string
    companyName?: string | null
    email: string
    phone?: string | null
    primaryContact?: NullableJsonNullValueInput | InputJsonValue
    additionalContacts?: ClientCreateadditionalContactsInput | InputJsonValue[]
    industry?: string | null
    website?: string | null
    timezone?: string | null
    relationshipHealth?: number | null
    lastContactedAt?: Date | string | null
    preferredCommunication?: string | null
    defaultHourlyRate?: number | null
    paymentTerms?: string | null
    outstandingBalance?: number
    notes?: string | null
    tags?: ClientCreatetagsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastInteractionAt?: Date | string | null
    communications?: CommunicationUncheckedCreateNestedManyWithoutClientInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutClientInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutClientInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutProjectsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutProjectsInput, ClientUncheckedCreateWithoutProjectsInput>
  }

  export type UserCreateWithoutProjectsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    geminiApiKey?: string | null
    geminiModel?: string
    groqApiKey?: string | null
    llmProvider?: string
    serperApiKey?: string | null
    researchLimit?: number
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    captures?: CaptureCreateNestedManyWithoutUserInput
    clients?: ClientCreateNestedManyWithoutUserInput
    dayPlans?: DayPlanCreateNestedManyWithoutUserInput
    meetings?: MeetingCreateNestedManyWithoutUserInput
    notes?: NoteCreateNestedManyWithoutUserInput
    researches?: ResearchCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    voiceSessions?: VoiceSessionCreateNestedManyWithoutUserInput
    weekPlans?: WeekPlanCreateNestedManyWithoutUserInput
    wellBeingEntries?: WellBeingEntryCreateNestedManyWithoutUserInput
    yearPlans?: YearPlanCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjectsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    geminiApiKey?: string | null
    geminiModel?: string
    groqApiKey?: string | null
    llmProvider?: string
    serperApiKey?: string | null
    researchLimit?: number
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    captures?: CaptureUncheckedCreateNestedManyWithoutUserInput
    clients?: ClientUncheckedCreateNestedManyWithoutUserInput
    dayPlans?: DayPlanUncheckedCreateNestedManyWithoutUserInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutUserInput
    notes?: NoteUncheckedCreateNestedManyWithoutUserInput
    researches?: ResearchUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    voiceSessions?: VoiceSessionUncheckedCreateNestedManyWithoutUserInput
    weekPlans?: WeekPlanUncheckedCreateNestedManyWithoutUserInput
    wellBeingEntries?: WellBeingEntryUncheckedCreateNestedManyWithoutUserInput
    yearPlans?: YearPlanUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
  }

  export type TaskCreateWithoutProjectInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    estimatedMinutes?: number | null
    actualMinutes?: number
    timerRunning?: boolean
    currentTimerStart?: Date | string | null
    scheduledDate?: Date | string | null
    dueDate?: Date | string | null
    priority: string
    type: string
    tags?: TaskCreatetagsInput | string[]
    parentTaskId?: string | null
    dependsOn?: TaskCreatedependsOnInput | string[]
    blocks?: TaskCreateblocksInput | string[]
    energyRequired?: number | null
    isAdHoc?: boolean
    isRecurring?: boolean
    recurringPattern?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actionItem?: ActionItemCreateNestedOneWithoutConvertedToTaskInput
    goal?: GoalCreateNestedOneWithoutTasksInput
    keyStep?: KeyStepCreateNestedOneWithoutTasksInput
    meeting?: MeetingCreateNestedOneWithoutTasksInput
    user: UserCreateNestedOneWithoutTasksInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutTaskInput
    timeEntries?: TimeEntryCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutProjectInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    estimatedMinutes?: number | null
    actualMinutes?: number
    timerRunning?: boolean
    currentTimerStart?: Date | string | null
    scheduledDate?: Date | string | null
    dueDate?: Date | string | null
    priority: string
    type: string
    tags?: TaskCreatetagsInput | string[]
    parentTaskId?: string | null
    dependsOn?: TaskCreatedependsOnInput | string[]
    blocks?: TaskCreateblocksInput | string[]
    energyRequired?: number | null
    isAdHoc?: boolean
    isRecurring?: boolean
    recurringPattern?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meetingId?: string | null
    goalId?: string | null
    keyStepId?: string | null
    actionItem?: ActionItemUncheckedCreateNestedOneWithoutConvertedToTaskInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutTaskInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutProjectInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>
  }

  export type TaskCreateManyProjectInputEnvelope = {
    data: TaskCreateManyProjectInput | TaskCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type TimeBlockCreateWithoutProjectInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    duration: number
    type: string
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    actualDuration?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    focusQuality?: number | null
    notes?: string | null
    client?: ClientCreateNestedOneWithoutTimeBlocksInput
    dayPlan: DayPlanCreateNestedOneWithoutTimeBlocksInput
    task?: TaskCreateNestedOneWithoutTimeBlocksInput
  }

  export type TimeBlockUncheckedCreateWithoutProjectInput = {
    id?: string
    dayPlanId: string
    startTime: Date | string
    endTime: Date | string
    duration: number
    type: string
    taskId?: string | null
    clientId?: string | null
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    actualDuration?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    focusQuality?: number | null
    notes?: string | null
  }

  export type TimeBlockCreateOrConnectWithoutProjectInput = {
    where: TimeBlockWhereUniqueInput
    create: XOR<TimeBlockCreateWithoutProjectInput, TimeBlockUncheckedCreateWithoutProjectInput>
  }

  export type TimeBlockCreateManyProjectInputEnvelope = {
    data: TimeBlockCreateManyProjectInput | TimeBlockCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type TimeEntryCreateWithoutProjectInput = {
    id?: string
    startTime: Date | string
    endTime?: Date | string | null
    duration: number
    type: string
    description?: string | null
    tags?: TimeEntryCreatetagsInput | string[]
    focusQuality?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    distractions?: number
    billable?: boolean
    hourlyRate?: number | null
    amount?: number
    invoiced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutTimeEntriesInput
    task?: TaskCreateNestedOneWithoutTimeEntriesInput
    user: UserCreateNestedOneWithoutTimeEntriesInput
  }

  export type TimeEntryUncheckedCreateWithoutProjectInput = {
    id?: string
    userId: string
    taskId?: string | null
    clientId?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    duration: number
    type: string
    description?: string | null
    tags?: TimeEntryCreatetagsInput | string[]
    focusQuality?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    distractions?: number
    billable?: boolean
    hourlyRate?: number | null
    amount?: number
    invoiced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeEntryCreateOrConnectWithoutProjectInput = {
    where: TimeEntryWhereUniqueInput
    create: XOR<TimeEntryCreateWithoutProjectInput, TimeEntryUncheckedCreateWithoutProjectInput>
  }

  export type TimeEntryCreateManyProjectInputEnvelope = {
    data: TimeEntryCreateManyProjectInput | TimeEntryCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutProjectsInput = {
    update: XOR<ClientUpdateWithoutProjectsInput, ClientUncheckedUpdateWithoutProjectsInput>
    create: XOR<ClientCreateWithoutProjectsInput, ClientUncheckedCreateWithoutProjectsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutProjectsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutProjectsInput, ClientUncheckedUpdateWithoutProjectsInput>
  }

  export type ClientUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContact?: NullableJsonNullValueInput | InputJsonValue
    additionalContacts?: ClientUpdateadditionalContactsInput | InputJsonValue[]
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipHealth?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredCommunication?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    outstandingBalance?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ClientUpdatetagsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastInteractionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutClientsNestedInput
    communications?: CommunicationUpdateManyWithoutClientNestedInput
    meetings?: MeetingUpdateManyWithoutClientNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutClientNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContact?: NullableJsonNullValueInput | InputJsonValue
    additionalContacts?: ClientUpdateadditionalContactsInput | InputJsonValue[]
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipHealth?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredCommunication?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    outstandingBalance?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ClientUpdatetagsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastInteractionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communications?: CommunicationUncheckedUpdateManyWithoutClientNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutClientNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutClientNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutClientNestedInput
  }

  export type UserUpsertWithoutProjectsInput = {
    update: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type UserUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    geminiModel?: StringFieldUpdateOperationsInput | string
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    llmProvider?: StringFieldUpdateOperationsInput | string
    serperApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    researchLimit?: IntFieldUpdateOperationsInput | number
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    captures?: CaptureUpdateManyWithoutUserNestedInput
    clients?: ClientUpdateManyWithoutUserNestedInput
    dayPlans?: DayPlanUpdateManyWithoutUserNestedInput
    meetings?: MeetingUpdateManyWithoutUserNestedInput
    notes?: NoteUpdateManyWithoutUserNestedInput
    researches?: ResearchUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    voiceSessions?: VoiceSessionUpdateManyWithoutUserNestedInput
    weekPlans?: WeekPlanUpdateManyWithoutUserNestedInput
    wellBeingEntries?: WellBeingEntryUpdateManyWithoutUserNestedInput
    yearPlans?: YearPlanUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    geminiModel?: StringFieldUpdateOperationsInput | string
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    llmProvider?: StringFieldUpdateOperationsInput | string
    serperApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    researchLimit?: IntFieldUpdateOperationsInput | number
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    captures?: CaptureUncheckedUpdateManyWithoutUserNestedInput
    clients?: ClientUncheckedUpdateManyWithoutUserNestedInput
    dayPlans?: DayPlanUncheckedUpdateManyWithoutUserNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutUserNestedInput
    notes?: NoteUncheckedUpdateManyWithoutUserNestedInput
    researches?: ResearchUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    voiceSessions?: VoiceSessionUncheckedUpdateManyWithoutUserNestedInput
    weekPlans?: WeekPlanUncheckedUpdateManyWithoutUserNestedInput
    wellBeingEntries?: WellBeingEntryUncheckedUpdateManyWithoutUserNestedInput
    yearPlans?: YearPlanUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TaskUpsertWithWhereUniqueWithoutProjectInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutProjectInput, TaskUncheckedUpdateWithoutProjectInput>
    create: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutProjectInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutProjectInput, TaskUncheckedUpdateWithoutProjectInput>
  }

  export type TaskUpdateManyWithWhereWithoutProjectInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutProjectInput>
  }

  export type TimeBlockUpsertWithWhereUniqueWithoutProjectInput = {
    where: TimeBlockWhereUniqueInput
    update: XOR<TimeBlockUpdateWithoutProjectInput, TimeBlockUncheckedUpdateWithoutProjectInput>
    create: XOR<TimeBlockCreateWithoutProjectInput, TimeBlockUncheckedCreateWithoutProjectInput>
  }

  export type TimeBlockUpdateWithWhereUniqueWithoutProjectInput = {
    where: TimeBlockWhereUniqueInput
    data: XOR<TimeBlockUpdateWithoutProjectInput, TimeBlockUncheckedUpdateWithoutProjectInput>
  }

  export type TimeBlockUpdateManyWithWhereWithoutProjectInput = {
    where: TimeBlockScalarWhereInput
    data: XOR<TimeBlockUpdateManyMutationInput, TimeBlockUncheckedUpdateManyWithoutProjectInput>
  }

  export type TimeEntryUpsertWithWhereUniqueWithoutProjectInput = {
    where: TimeEntryWhereUniqueInput
    update: XOR<TimeEntryUpdateWithoutProjectInput, TimeEntryUncheckedUpdateWithoutProjectInput>
    create: XOR<TimeEntryCreateWithoutProjectInput, TimeEntryUncheckedCreateWithoutProjectInput>
  }

  export type TimeEntryUpdateWithWhereUniqueWithoutProjectInput = {
    where: TimeEntryWhereUniqueInput
    data: XOR<TimeEntryUpdateWithoutProjectInput, TimeEntryUncheckedUpdateWithoutProjectInput>
  }

  export type TimeEntryUpdateManyWithWhereWithoutProjectInput = {
    where: TimeEntryScalarWhereInput
    data: XOR<TimeEntryUpdateManyMutationInput, TimeEntryUncheckedUpdateManyWithoutProjectInput>
  }

  export type ActionItemCreateWithoutConvertedToTaskInput = {
    id?: string
    description: string
    priority?: $Enums.ActionPriority
    effort?: number
    convertedAt?: Date | string | null
    createdAt?: Date | string
    research: ResearchCreateNestedOneWithoutActionItemsInput
  }

  export type ActionItemUncheckedCreateWithoutConvertedToTaskInput = {
    id?: string
    researchId: string
    description: string
    priority?: $Enums.ActionPriority
    effort?: number
    convertedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ActionItemCreateOrConnectWithoutConvertedToTaskInput = {
    where: ActionItemWhereUniqueInput
    create: XOR<ActionItemCreateWithoutConvertedToTaskInput, ActionItemUncheckedCreateWithoutConvertedToTaskInput>
  }

  export type GoalCreateWithoutTasksInput = {
    id?: string
    title: string
    description?: string | null
    category: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    kpis?: GoalCreatekpisInput | string[]
    priority?: string
    progress?: number
    risks?: GoalCreaterisksInput | string[]
    strategies?: GoalCreatestrategiesInput | string[]
    targetDate?: Date | string | null
    yearPlan: YearPlanCreateNestedOneWithoutGoalsInput
    keySteps?: KeyStepCreateNestedManyWithoutGoalInput
    milestones?: MilestoneCreateNestedManyWithoutGoalInput
    notes?: NoteCreateNestedManyWithoutGoalInput
    quarterFocuses?: QuarterFocusCreateNestedManyWithoutGoalInput
    researches?: ResearchCreateNestedManyWithoutGoalInput
  }

  export type GoalUncheckedCreateWithoutTasksInput = {
    id?: string
    yearPlanId: string
    title: string
    description?: string | null
    category: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    kpis?: GoalCreatekpisInput | string[]
    priority?: string
    progress?: number
    risks?: GoalCreaterisksInput | string[]
    strategies?: GoalCreatestrategiesInput | string[]
    targetDate?: Date | string | null
    keySteps?: KeyStepUncheckedCreateNestedManyWithoutGoalInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutGoalInput
    notes?: NoteUncheckedCreateNestedManyWithoutGoalInput
    quarterFocuses?: QuarterFocusUncheckedCreateNestedManyWithoutGoalInput
    researches?: ResearchUncheckedCreateNestedManyWithoutGoalInput
  }

  export type GoalCreateOrConnectWithoutTasksInput = {
    where: GoalWhereUniqueInput
    create: XOR<GoalCreateWithoutTasksInput, GoalUncheckedCreateWithoutTasksInput>
  }

  export type KeyStepCreateWithoutTasksInput = {
    id?: string
    title: string
    description?: string | null
    order?: number
    completed?: boolean
    completedAt?: Date | string | null
    progress?: number
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goal: GoalCreateNestedOneWithoutKeyStepsInput
    notes?: NoteCreateNestedManyWithoutKeyStepInput
  }

  export type KeyStepUncheckedCreateWithoutTasksInput = {
    id?: string
    goalId: string
    title: string
    description?: string | null
    order?: number
    completed?: boolean
    completedAt?: Date | string | null
    progress?: number
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: NoteUncheckedCreateNestedManyWithoutKeyStepInput
  }

  export type KeyStepCreateOrConnectWithoutTasksInput = {
    where: KeyStepWhereUniqueInput
    create: XOR<KeyStepCreateWithoutTasksInput, KeyStepUncheckedCreateWithoutTasksInput>
  }

  export type MeetingCreateWithoutTasksInput = {
    id?: string
    projectId?: string | null
    title: string
    description?: string | null
    type?: string
    scheduledAt: Date | string
    duration: number
    timezone?: string
    organizer?: string
    requiredAttendees?: MeetingCreaterequiredAttendeesInput | string[]
    optionalAttendees?: MeetingCreateoptionalAttendeesInput | string[]
    location?: string | null
    meetingLink?: string | null
    agenda?: string | null
    meetingNotes?: string | null
    actionItems?: MeetingCreateactionItemsInput | InputJsonValue[]
    decisions?: MeetingCreatedecisionsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutMeetingsInput
    user: UserCreateNestedOneWithoutMeetingsInput
  }

  export type MeetingUncheckedCreateWithoutTasksInput = {
    id?: string
    clientId?: string | null
    projectId?: string | null
    title: string
    description?: string | null
    type?: string
    scheduledAt: Date | string
    duration: number
    timezone?: string
    organizer?: string
    requiredAttendees?: MeetingCreaterequiredAttendeesInput | string[]
    optionalAttendees?: MeetingCreateoptionalAttendeesInput | string[]
    location?: string | null
    meetingLink?: string | null
    agenda?: string | null
    meetingNotes?: string | null
    actionItems?: MeetingCreateactionItemsInput | InputJsonValue[]
    decisions?: MeetingCreatedecisionsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type MeetingCreateOrConnectWithoutTasksInput = {
    where: MeetingWhereUniqueInput
    create: XOR<MeetingCreateWithoutTasksInput, MeetingUncheckedCreateWithoutTasksInput>
  }

  export type ProjectCreateWithoutTasksInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    status: string
    billable?: boolean
    hourlyRate?: number | null
    budgetHours?: number | null
    startDate?: Date | string | null
    deadline?: Date | string | null
    estimatedHours?: number | null
    actualHoursSpent?: number
    completionPercentage?: number
    goalId?: string | null
    parentProjectId?: string | null
    priority: string
    tags?: ProjectCreatetagsInput | string[]
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    archivedAt?: Date | string | null
    icon?: string | null
    client?: ClientCreateNestedOneWithoutProjectsInput
    user: UserCreateNestedOneWithoutProjectsInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutProjectInput
    timeEntries?: TimeEntryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutTasksInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    type: string
    status: string
    clientId?: string | null
    billable?: boolean
    hourlyRate?: number | null
    budgetHours?: number | null
    startDate?: Date | string | null
    deadline?: Date | string | null
    estimatedHours?: number | null
    actualHoursSpent?: number
    completionPercentage?: number
    goalId?: string | null
    parentProjectId?: string | null
    priority: string
    tags?: ProjectCreatetagsInput | string[]
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    archivedAt?: Date | string | null
    icon?: string | null
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutProjectInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTasksInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
  }

  export type UserCreateWithoutTasksInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    geminiApiKey?: string | null
    geminiModel?: string
    groqApiKey?: string | null
    llmProvider?: string
    serperApiKey?: string | null
    researchLimit?: number
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    captures?: CaptureCreateNestedManyWithoutUserInput
    clients?: ClientCreateNestedManyWithoutUserInput
    dayPlans?: DayPlanCreateNestedManyWithoutUserInput
    meetings?: MeetingCreateNestedManyWithoutUserInput
    notes?: NoteCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    researches?: ResearchCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    voiceSessions?: VoiceSessionCreateNestedManyWithoutUserInput
    weekPlans?: WeekPlanCreateNestedManyWithoutUserInput
    wellBeingEntries?: WellBeingEntryCreateNestedManyWithoutUserInput
    yearPlans?: YearPlanCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTasksInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    geminiApiKey?: string | null
    geminiModel?: string
    groqApiKey?: string | null
    llmProvider?: string
    serperApiKey?: string | null
    researchLimit?: number
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    captures?: CaptureUncheckedCreateNestedManyWithoutUserInput
    clients?: ClientUncheckedCreateNestedManyWithoutUserInput
    dayPlans?: DayPlanUncheckedCreateNestedManyWithoutUserInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutUserInput
    notes?: NoteUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    researches?: ResearchUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    voiceSessions?: VoiceSessionUncheckedCreateNestedManyWithoutUserInput
    weekPlans?: WeekPlanUncheckedCreateNestedManyWithoutUserInput
    wellBeingEntries?: WellBeingEntryUncheckedCreateNestedManyWithoutUserInput
    yearPlans?: YearPlanUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
  }

  export type TimeBlockCreateWithoutTaskInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    duration: number
    type: string
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    actualDuration?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    focusQuality?: number | null
    notes?: string | null
    client?: ClientCreateNestedOneWithoutTimeBlocksInput
    dayPlan: DayPlanCreateNestedOneWithoutTimeBlocksInput
    project?: ProjectCreateNestedOneWithoutTimeBlocksInput
  }

  export type TimeBlockUncheckedCreateWithoutTaskInput = {
    id?: string
    dayPlanId: string
    startTime: Date | string
    endTime: Date | string
    duration: number
    type: string
    projectId?: string | null
    clientId?: string | null
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    actualDuration?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    focusQuality?: number | null
    notes?: string | null
  }

  export type TimeBlockCreateOrConnectWithoutTaskInput = {
    where: TimeBlockWhereUniqueInput
    create: XOR<TimeBlockCreateWithoutTaskInput, TimeBlockUncheckedCreateWithoutTaskInput>
  }

  export type TimeBlockCreateManyTaskInputEnvelope = {
    data: TimeBlockCreateManyTaskInput | TimeBlockCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type TimeEntryCreateWithoutTaskInput = {
    id?: string
    startTime: Date | string
    endTime?: Date | string | null
    duration: number
    type: string
    description?: string | null
    tags?: TimeEntryCreatetagsInput | string[]
    focusQuality?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    distractions?: number
    billable?: boolean
    hourlyRate?: number | null
    amount?: number
    invoiced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutTimeEntriesInput
    project?: ProjectCreateNestedOneWithoutTimeEntriesInput
    user: UserCreateNestedOneWithoutTimeEntriesInput
  }

  export type TimeEntryUncheckedCreateWithoutTaskInput = {
    id?: string
    userId: string
    projectId?: string | null
    clientId?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    duration: number
    type: string
    description?: string | null
    tags?: TimeEntryCreatetagsInput | string[]
    focusQuality?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    distractions?: number
    billable?: boolean
    hourlyRate?: number | null
    amount?: number
    invoiced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeEntryCreateOrConnectWithoutTaskInput = {
    where: TimeEntryWhereUniqueInput
    create: XOR<TimeEntryCreateWithoutTaskInput, TimeEntryUncheckedCreateWithoutTaskInput>
  }

  export type TimeEntryCreateManyTaskInputEnvelope = {
    data: TimeEntryCreateManyTaskInput | TimeEntryCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type ActionItemUpsertWithoutConvertedToTaskInput = {
    update: XOR<ActionItemUpdateWithoutConvertedToTaskInput, ActionItemUncheckedUpdateWithoutConvertedToTaskInput>
    create: XOR<ActionItemCreateWithoutConvertedToTaskInput, ActionItemUncheckedCreateWithoutConvertedToTaskInput>
    where?: ActionItemWhereInput
  }

  export type ActionItemUpdateToOneWithWhereWithoutConvertedToTaskInput = {
    where?: ActionItemWhereInput
    data: XOR<ActionItemUpdateWithoutConvertedToTaskInput, ActionItemUncheckedUpdateWithoutConvertedToTaskInput>
  }

  export type ActionItemUpdateWithoutConvertedToTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumActionPriorityFieldUpdateOperationsInput | $Enums.ActionPriority
    effort?: IntFieldUpdateOperationsInput | number
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    research?: ResearchUpdateOneRequiredWithoutActionItemsNestedInput
  }

  export type ActionItemUncheckedUpdateWithoutConvertedToTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    researchId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumActionPriorityFieldUpdateOperationsInput | $Enums.ActionPriority
    effort?: IntFieldUpdateOperationsInput | number
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalUpsertWithoutTasksInput = {
    update: XOR<GoalUpdateWithoutTasksInput, GoalUncheckedUpdateWithoutTasksInput>
    create: XOR<GoalCreateWithoutTasksInput, GoalUncheckedCreateWithoutTasksInput>
    where?: GoalWhereInput
  }

  export type GoalUpdateToOneWithWhereWithoutTasksInput = {
    where?: GoalWhereInput
    data: XOR<GoalUpdateWithoutTasksInput, GoalUncheckedUpdateWithoutTasksInput>
  }

  export type GoalUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kpis?: GoalUpdatekpisInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    risks?: GoalUpdaterisksInput | string[]
    strategies?: GoalUpdatestrategiesInput | string[]
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    yearPlan?: YearPlanUpdateOneRequiredWithoutGoalsNestedInput
    keySteps?: KeyStepUpdateManyWithoutGoalNestedInput
    milestones?: MilestoneUpdateManyWithoutGoalNestedInput
    notes?: NoteUpdateManyWithoutGoalNestedInput
    quarterFocuses?: QuarterFocusUpdateManyWithoutGoalNestedInput
    researches?: ResearchUpdateManyWithoutGoalNestedInput
  }

  export type GoalUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    yearPlanId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kpis?: GoalUpdatekpisInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    risks?: GoalUpdaterisksInput | string[]
    strategies?: GoalUpdatestrategiesInput | string[]
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    keySteps?: KeyStepUncheckedUpdateManyWithoutGoalNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutGoalNestedInput
    notes?: NoteUncheckedUpdateManyWithoutGoalNestedInput
    quarterFocuses?: QuarterFocusUncheckedUpdateManyWithoutGoalNestedInput
    researches?: ResearchUncheckedUpdateManyWithoutGoalNestedInput
  }

  export type KeyStepUpsertWithoutTasksInput = {
    update: XOR<KeyStepUpdateWithoutTasksInput, KeyStepUncheckedUpdateWithoutTasksInput>
    create: XOR<KeyStepCreateWithoutTasksInput, KeyStepUncheckedCreateWithoutTasksInput>
    where?: KeyStepWhereInput
  }

  export type KeyStepUpdateToOneWithWhereWithoutTasksInput = {
    where?: KeyStepWhereInput
    data: XOR<KeyStepUpdateWithoutTasksInput, KeyStepUncheckedUpdateWithoutTasksInput>
  }

  export type KeyStepUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goal?: GoalUpdateOneRequiredWithoutKeyStepsNestedInput
    notes?: NoteUpdateManyWithoutKeyStepNestedInput
  }

  export type KeyStepUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NoteUncheckedUpdateManyWithoutKeyStepNestedInput
  }

  export type MeetingUpsertWithoutTasksInput = {
    update: XOR<MeetingUpdateWithoutTasksInput, MeetingUncheckedUpdateWithoutTasksInput>
    create: XOR<MeetingCreateWithoutTasksInput, MeetingUncheckedCreateWithoutTasksInput>
    where?: MeetingWhereInput
  }

  export type MeetingUpdateToOneWithWhereWithoutTasksInput = {
    where?: MeetingWhereInput
    data: XOR<MeetingUpdateWithoutTasksInput, MeetingUncheckedUpdateWithoutTasksInput>
  }

  export type MeetingUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    organizer?: StringFieldUpdateOperationsInput | string
    requiredAttendees?: MeetingUpdaterequiredAttendeesInput | string[]
    optionalAttendees?: MeetingUpdateoptionalAttendeesInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    meetingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    actionItems?: MeetingUpdateactionItemsInput | InputJsonValue[]
    decisions?: MeetingUpdatedecisionsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutMeetingsNestedInput
    user?: UserUpdateOneRequiredWithoutMeetingsNestedInput
  }

  export type MeetingUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    organizer?: StringFieldUpdateOperationsInput | string
    requiredAttendees?: MeetingUpdaterequiredAttendeesInput | string[]
    optionalAttendees?: MeetingUpdateoptionalAttendeesInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    meetingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    actionItems?: MeetingUpdateactionItemsInput | InputJsonValue[]
    decisions?: MeetingUpdatedecisionsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectUpsertWithoutTasksInput = {
    update: XOR<ProjectUpdateWithoutTasksInput, ProjectUncheckedUpdateWithoutTasksInput>
    create: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTasksInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTasksInput, ProjectUncheckedUpdateWithoutTasksInput>
  }

  export type ProjectUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    billable?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetHours?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHoursSpent?: FloatFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    parentProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    tags?: ProjectUpdatetagsInput | string[]
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneWithoutProjectsNestedInput
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutProjectNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    billable?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetHours?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHoursSpent?: FloatFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    parentProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    tags?: ProjectUpdatetagsInput | string[]
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutProjectNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutTasksInput = {
    update: XOR<UserUpdateWithoutTasksInput, UserUncheckedUpdateWithoutTasksInput>
    create: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTasksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTasksInput, UserUncheckedUpdateWithoutTasksInput>
  }

  export type UserUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    geminiModel?: StringFieldUpdateOperationsInput | string
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    llmProvider?: StringFieldUpdateOperationsInput | string
    serperApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    researchLimit?: IntFieldUpdateOperationsInput | number
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    captures?: CaptureUpdateManyWithoutUserNestedInput
    clients?: ClientUpdateManyWithoutUserNestedInput
    dayPlans?: DayPlanUpdateManyWithoutUserNestedInput
    meetings?: MeetingUpdateManyWithoutUserNestedInput
    notes?: NoteUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    researches?: ResearchUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    voiceSessions?: VoiceSessionUpdateManyWithoutUserNestedInput
    weekPlans?: WeekPlanUpdateManyWithoutUserNestedInput
    wellBeingEntries?: WellBeingEntryUpdateManyWithoutUserNestedInput
    yearPlans?: YearPlanUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    geminiModel?: StringFieldUpdateOperationsInput | string
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    llmProvider?: StringFieldUpdateOperationsInput | string
    serperApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    researchLimit?: IntFieldUpdateOperationsInput | number
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    captures?: CaptureUncheckedUpdateManyWithoutUserNestedInput
    clients?: ClientUncheckedUpdateManyWithoutUserNestedInput
    dayPlans?: DayPlanUncheckedUpdateManyWithoutUserNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutUserNestedInput
    notes?: NoteUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    researches?: ResearchUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    voiceSessions?: VoiceSessionUncheckedUpdateManyWithoutUserNestedInput
    weekPlans?: WeekPlanUncheckedUpdateManyWithoutUserNestedInput
    wellBeingEntries?: WellBeingEntryUncheckedUpdateManyWithoutUserNestedInput
    yearPlans?: YearPlanUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TimeBlockUpsertWithWhereUniqueWithoutTaskInput = {
    where: TimeBlockWhereUniqueInput
    update: XOR<TimeBlockUpdateWithoutTaskInput, TimeBlockUncheckedUpdateWithoutTaskInput>
    create: XOR<TimeBlockCreateWithoutTaskInput, TimeBlockUncheckedCreateWithoutTaskInput>
  }

  export type TimeBlockUpdateWithWhereUniqueWithoutTaskInput = {
    where: TimeBlockWhereUniqueInput
    data: XOR<TimeBlockUpdateWithoutTaskInput, TimeBlockUncheckedUpdateWithoutTaskInput>
  }

  export type TimeBlockUpdateManyWithWhereWithoutTaskInput = {
    where: TimeBlockScalarWhereInput
    data: XOR<TimeBlockUpdateManyMutationInput, TimeBlockUncheckedUpdateManyWithoutTaskInput>
  }

  export type TimeEntryUpsertWithWhereUniqueWithoutTaskInput = {
    where: TimeEntryWhereUniqueInput
    update: XOR<TimeEntryUpdateWithoutTaskInput, TimeEntryUncheckedUpdateWithoutTaskInput>
    create: XOR<TimeEntryCreateWithoutTaskInput, TimeEntryUncheckedCreateWithoutTaskInput>
  }

  export type TimeEntryUpdateWithWhereUniqueWithoutTaskInput = {
    where: TimeEntryWhereUniqueInput
    data: XOR<TimeEntryUpdateWithoutTaskInput, TimeEntryUncheckedUpdateWithoutTaskInput>
  }

  export type TimeEntryUpdateManyWithWhereWithoutTaskInput = {
    where: TimeEntryScalarWhereInput
    data: XOR<TimeEntryUpdateManyMutationInput, TimeEntryUncheckedUpdateManyWithoutTaskInput>
  }

  export type ClientCreateWithoutTimeEntriesInput = {
    id?: string
    name: string
    companyName?: string | null
    email: string
    phone?: string | null
    primaryContact?: NullableJsonNullValueInput | InputJsonValue
    additionalContacts?: ClientCreateadditionalContactsInput | InputJsonValue[]
    industry?: string | null
    website?: string | null
    timezone?: string | null
    relationshipHealth?: number | null
    lastContactedAt?: Date | string | null
    preferredCommunication?: string | null
    defaultHourlyRate?: number | null
    paymentTerms?: string | null
    outstandingBalance?: number
    notes?: string | null
    tags?: ClientCreatetagsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastInteractionAt?: Date | string | null
    user: UserCreateNestedOneWithoutClientsInput
    communications?: CommunicationCreateNestedManyWithoutClientInput
    meetings?: MeetingCreateNestedManyWithoutClientInput
    projects?: ProjectCreateNestedManyWithoutClientInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutTimeEntriesInput = {
    id?: string
    userId: string
    name: string
    companyName?: string | null
    email: string
    phone?: string | null
    primaryContact?: NullableJsonNullValueInput | InputJsonValue
    additionalContacts?: ClientCreateadditionalContactsInput | InputJsonValue[]
    industry?: string | null
    website?: string | null
    timezone?: string | null
    relationshipHealth?: number | null
    lastContactedAt?: Date | string | null
    preferredCommunication?: string | null
    defaultHourlyRate?: number | null
    paymentTerms?: string | null
    outstandingBalance?: number
    notes?: string | null
    tags?: ClientCreatetagsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastInteractionAt?: Date | string | null
    communications?: CommunicationUncheckedCreateNestedManyWithoutClientInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutClientInput
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutTimeEntriesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutTimeEntriesInput, ClientUncheckedCreateWithoutTimeEntriesInput>
  }

  export type ProjectCreateWithoutTimeEntriesInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    status: string
    billable?: boolean
    hourlyRate?: number | null
    budgetHours?: number | null
    startDate?: Date | string | null
    deadline?: Date | string | null
    estimatedHours?: number | null
    actualHoursSpent?: number
    completionPercentage?: number
    goalId?: string | null
    parentProjectId?: string | null
    priority: string
    tags?: ProjectCreatetagsInput | string[]
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    archivedAt?: Date | string | null
    icon?: string | null
    client?: ClientCreateNestedOneWithoutProjectsInput
    user: UserCreateNestedOneWithoutProjectsInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutTimeEntriesInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    type: string
    status: string
    clientId?: string | null
    billable?: boolean
    hourlyRate?: number | null
    budgetHours?: number | null
    startDate?: Date | string | null
    deadline?: Date | string | null
    estimatedHours?: number | null
    actualHoursSpent?: number
    completionPercentage?: number
    goalId?: string | null
    parentProjectId?: string | null
    priority: string
    tags?: ProjectCreatetagsInput | string[]
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    archivedAt?: Date | string | null
    icon?: string | null
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTimeEntriesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTimeEntriesInput, ProjectUncheckedCreateWithoutTimeEntriesInput>
  }

  export type TaskCreateWithoutTimeEntriesInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    estimatedMinutes?: number | null
    actualMinutes?: number
    timerRunning?: boolean
    currentTimerStart?: Date | string | null
    scheduledDate?: Date | string | null
    dueDate?: Date | string | null
    priority: string
    type: string
    tags?: TaskCreatetagsInput | string[]
    parentTaskId?: string | null
    dependsOn?: TaskCreatedependsOnInput | string[]
    blocks?: TaskCreateblocksInput | string[]
    energyRequired?: number | null
    isAdHoc?: boolean
    isRecurring?: boolean
    recurringPattern?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actionItem?: ActionItemCreateNestedOneWithoutConvertedToTaskInput
    goal?: GoalCreateNestedOneWithoutTasksInput
    keyStep?: KeyStepCreateNestedOneWithoutTasksInput
    meeting?: MeetingCreateNestedOneWithoutTasksInput
    project?: ProjectCreateNestedOneWithoutTasksInput
    user: UserCreateNestedOneWithoutTasksInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutTimeEntriesInput = {
    id?: string
    userId: string
    projectId?: string | null
    title: string
    description?: string | null
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    estimatedMinutes?: number | null
    actualMinutes?: number
    timerRunning?: boolean
    currentTimerStart?: Date | string | null
    scheduledDate?: Date | string | null
    dueDate?: Date | string | null
    priority: string
    type: string
    tags?: TaskCreatetagsInput | string[]
    parentTaskId?: string | null
    dependsOn?: TaskCreatedependsOnInput | string[]
    blocks?: TaskCreateblocksInput | string[]
    energyRequired?: number | null
    isAdHoc?: boolean
    isRecurring?: boolean
    recurringPattern?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meetingId?: string | null
    goalId?: string | null
    keyStepId?: string | null
    actionItem?: ActionItemUncheckedCreateNestedOneWithoutConvertedToTaskInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutTimeEntriesInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutTimeEntriesInput, TaskUncheckedCreateWithoutTimeEntriesInput>
  }

  export type UserCreateWithoutTimeEntriesInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    geminiApiKey?: string | null
    geminiModel?: string
    groqApiKey?: string | null
    llmProvider?: string
    serperApiKey?: string | null
    researchLimit?: number
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    captures?: CaptureCreateNestedManyWithoutUserInput
    clients?: ClientCreateNestedManyWithoutUserInput
    dayPlans?: DayPlanCreateNestedManyWithoutUserInput
    meetings?: MeetingCreateNestedManyWithoutUserInput
    notes?: NoteCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    researches?: ResearchCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    voiceSessions?: VoiceSessionCreateNestedManyWithoutUserInput
    weekPlans?: WeekPlanCreateNestedManyWithoutUserInput
    wellBeingEntries?: WellBeingEntryCreateNestedManyWithoutUserInput
    yearPlans?: YearPlanCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTimeEntriesInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    geminiApiKey?: string | null
    geminiModel?: string
    groqApiKey?: string | null
    llmProvider?: string
    serperApiKey?: string | null
    researchLimit?: number
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    captures?: CaptureUncheckedCreateNestedManyWithoutUserInput
    clients?: ClientUncheckedCreateNestedManyWithoutUserInput
    dayPlans?: DayPlanUncheckedCreateNestedManyWithoutUserInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutUserInput
    notes?: NoteUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    researches?: ResearchUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    voiceSessions?: VoiceSessionUncheckedCreateNestedManyWithoutUserInput
    weekPlans?: WeekPlanUncheckedCreateNestedManyWithoutUserInput
    wellBeingEntries?: WellBeingEntryUncheckedCreateNestedManyWithoutUserInput
    yearPlans?: YearPlanUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTimeEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTimeEntriesInput, UserUncheckedCreateWithoutTimeEntriesInput>
  }

  export type ClientUpsertWithoutTimeEntriesInput = {
    update: XOR<ClientUpdateWithoutTimeEntriesInput, ClientUncheckedUpdateWithoutTimeEntriesInput>
    create: XOR<ClientCreateWithoutTimeEntriesInput, ClientUncheckedCreateWithoutTimeEntriesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutTimeEntriesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutTimeEntriesInput, ClientUncheckedUpdateWithoutTimeEntriesInput>
  }

  export type ClientUpdateWithoutTimeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContact?: NullableJsonNullValueInput | InputJsonValue
    additionalContacts?: ClientUpdateadditionalContactsInput | InputJsonValue[]
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipHealth?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredCommunication?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    outstandingBalance?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ClientUpdatetagsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastInteractionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutClientsNestedInput
    communications?: CommunicationUpdateManyWithoutClientNestedInput
    meetings?: MeetingUpdateManyWithoutClientNestedInput
    projects?: ProjectUpdateManyWithoutClientNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutTimeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContact?: NullableJsonNullValueInput | InputJsonValue
    additionalContacts?: ClientUpdateadditionalContactsInput | InputJsonValue[]
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipHealth?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredCommunication?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    outstandingBalance?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ClientUpdatetagsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastInteractionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communications?: CommunicationUncheckedUpdateManyWithoutClientNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutClientNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ProjectUpsertWithoutTimeEntriesInput = {
    update: XOR<ProjectUpdateWithoutTimeEntriesInput, ProjectUncheckedUpdateWithoutTimeEntriesInput>
    create: XOR<ProjectCreateWithoutTimeEntriesInput, ProjectUncheckedCreateWithoutTimeEntriesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTimeEntriesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTimeEntriesInput, ProjectUncheckedUpdateWithoutTimeEntriesInput>
  }

  export type ProjectUpdateWithoutTimeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    billable?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetHours?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHoursSpent?: FloatFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    parentProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    tags?: ProjectUpdatetagsInput | string[]
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneWithoutProjectsNestedInput
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTimeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    billable?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetHours?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHoursSpent?: FloatFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    parentProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    tags?: ProjectUpdatetagsInput | string[]
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TaskUpsertWithoutTimeEntriesInput = {
    update: XOR<TaskUpdateWithoutTimeEntriesInput, TaskUncheckedUpdateWithoutTimeEntriesInput>
    create: XOR<TaskCreateWithoutTimeEntriesInput, TaskUncheckedCreateWithoutTimeEntriesInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutTimeEntriesInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutTimeEntriesInput, TaskUncheckedUpdateWithoutTimeEntriesInput>
  }

  export type TaskUpdateWithoutTimeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    actualMinutes?: IntFieldUpdateOperationsInput | number
    timerRunning?: BoolFieldUpdateOperationsInput | boolean
    currentTimerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tags?: TaskUpdatetagsInput | string[]
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOn?: TaskUpdatedependsOnInput | string[]
    blocks?: TaskUpdateblocksInput | string[]
    energyRequired?: NullableFloatFieldUpdateOperationsInput | number | null
    isAdHoc?: BoolFieldUpdateOperationsInput | boolean
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionItem?: ActionItemUpdateOneWithoutConvertedToTaskNestedInput
    goal?: GoalUpdateOneWithoutTasksNestedInput
    keyStep?: KeyStepUpdateOneWithoutTasksNestedInput
    meeting?: MeetingUpdateOneWithoutTasksNestedInput
    project?: ProjectUpdateOneWithoutTasksNestedInput
    user?: UserUpdateOneRequiredWithoutTasksNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutTimeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    actualMinutes?: IntFieldUpdateOperationsInput | number
    timerRunning?: BoolFieldUpdateOperationsInput | boolean
    currentTimerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tags?: TaskUpdatetagsInput | string[]
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOn?: TaskUpdatedependsOnInput | string[]
    blocks?: TaskUpdateblocksInput | string[]
    energyRequired?: NullableFloatFieldUpdateOperationsInput | number | null
    isAdHoc?: BoolFieldUpdateOperationsInput | boolean
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    keyStepId?: NullableStringFieldUpdateOperationsInput | string | null
    actionItem?: ActionItemUncheckedUpdateOneWithoutConvertedToTaskNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type UserUpsertWithoutTimeEntriesInput = {
    update: XOR<UserUpdateWithoutTimeEntriesInput, UserUncheckedUpdateWithoutTimeEntriesInput>
    create: XOR<UserCreateWithoutTimeEntriesInput, UserUncheckedCreateWithoutTimeEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTimeEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTimeEntriesInput, UserUncheckedUpdateWithoutTimeEntriesInput>
  }

  export type UserUpdateWithoutTimeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    geminiModel?: StringFieldUpdateOperationsInput | string
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    llmProvider?: StringFieldUpdateOperationsInput | string
    serperApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    researchLimit?: IntFieldUpdateOperationsInput | number
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    captures?: CaptureUpdateManyWithoutUserNestedInput
    clients?: ClientUpdateManyWithoutUserNestedInput
    dayPlans?: DayPlanUpdateManyWithoutUserNestedInput
    meetings?: MeetingUpdateManyWithoutUserNestedInput
    notes?: NoteUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    researches?: ResearchUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    voiceSessions?: VoiceSessionUpdateManyWithoutUserNestedInput
    weekPlans?: WeekPlanUpdateManyWithoutUserNestedInput
    wellBeingEntries?: WellBeingEntryUpdateManyWithoutUserNestedInput
    yearPlans?: YearPlanUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTimeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    geminiModel?: StringFieldUpdateOperationsInput | string
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    llmProvider?: StringFieldUpdateOperationsInput | string
    serperApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    researchLimit?: IntFieldUpdateOperationsInput | number
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    captures?: CaptureUncheckedUpdateManyWithoutUserNestedInput
    clients?: ClientUncheckedUpdateManyWithoutUserNestedInput
    dayPlans?: DayPlanUncheckedUpdateManyWithoutUserNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutUserNestedInput
    notes?: NoteUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    researches?: ResearchUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    voiceSessions?: VoiceSessionUncheckedUpdateManyWithoutUserNestedInput
    weekPlans?: WeekPlanUncheckedUpdateManyWithoutUserNestedInput
    wellBeingEntries?: WellBeingEntryUncheckedUpdateManyWithoutUserNestedInput
    yearPlans?: YearPlanUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutClientsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    geminiApiKey?: string | null
    geminiModel?: string
    groqApiKey?: string | null
    llmProvider?: string
    serperApiKey?: string | null
    researchLimit?: number
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    captures?: CaptureCreateNestedManyWithoutUserInput
    dayPlans?: DayPlanCreateNestedManyWithoutUserInput
    meetings?: MeetingCreateNestedManyWithoutUserInput
    notes?: NoteCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    researches?: ResearchCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    voiceSessions?: VoiceSessionCreateNestedManyWithoutUserInput
    weekPlans?: WeekPlanCreateNestedManyWithoutUserInput
    wellBeingEntries?: WellBeingEntryCreateNestedManyWithoutUserInput
    yearPlans?: YearPlanCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClientsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    geminiApiKey?: string | null
    geminiModel?: string
    groqApiKey?: string | null
    llmProvider?: string
    serperApiKey?: string | null
    researchLimit?: number
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    captures?: CaptureUncheckedCreateNestedManyWithoutUserInput
    dayPlans?: DayPlanUncheckedCreateNestedManyWithoutUserInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutUserInput
    notes?: NoteUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    researches?: ResearchUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    voiceSessions?: VoiceSessionUncheckedCreateNestedManyWithoutUserInput
    weekPlans?: WeekPlanUncheckedCreateNestedManyWithoutUserInput
    wellBeingEntries?: WellBeingEntryUncheckedCreateNestedManyWithoutUserInput
    yearPlans?: YearPlanUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClientsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientsInput, UserUncheckedCreateWithoutClientsInput>
  }

  export type CommunicationCreateWithoutClientInput = {
    id?: string
    projectId?: string | null
    type: string
    direction: string
    subject: string
    content: string
    summary?: string | null
    from?: string | null
    to?: CommunicationCreatetoInput | string[]
    cc?: CommunicationCreateccInput | string[]
    attachments?: CommunicationCreateattachmentsInput | InputJsonValue[]
    meetingDate?: Date | string | null
    meetingDuration?: number | null
    attendees?: CommunicationCreateattendeesInput | string[]
    meetingNotes?: string | null
    sentiment?: string | null
    requiresFollowUp?: boolean
    followUpDate?: Date | string | null
    createdAt?: Date | string
    responseTime?: number | null
  }

  export type CommunicationUncheckedCreateWithoutClientInput = {
    id?: string
    projectId?: string | null
    type: string
    direction: string
    subject: string
    content: string
    summary?: string | null
    from?: string | null
    to?: CommunicationCreatetoInput | string[]
    cc?: CommunicationCreateccInput | string[]
    attachments?: CommunicationCreateattachmentsInput | InputJsonValue[]
    meetingDate?: Date | string | null
    meetingDuration?: number | null
    attendees?: CommunicationCreateattendeesInput | string[]
    meetingNotes?: string | null
    sentiment?: string | null
    requiresFollowUp?: boolean
    followUpDate?: Date | string | null
    createdAt?: Date | string
    responseTime?: number | null
  }

  export type CommunicationCreateOrConnectWithoutClientInput = {
    where: CommunicationWhereUniqueInput
    create: XOR<CommunicationCreateWithoutClientInput, CommunicationUncheckedCreateWithoutClientInput>
  }

  export type CommunicationCreateManyClientInputEnvelope = {
    data: CommunicationCreateManyClientInput | CommunicationCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type MeetingCreateWithoutClientInput = {
    id?: string
    projectId?: string | null
    title: string
    description?: string | null
    type?: string
    scheduledAt: Date | string
    duration: number
    timezone?: string
    organizer?: string
    requiredAttendees?: MeetingCreaterequiredAttendeesInput | string[]
    optionalAttendees?: MeetingCreateoptionalAttendeesInput | string[]
    location?: string | null
    meetingLink?: string | null
    agenda?: string | null
    meetingNotes?: string | null
    actionItems?: MeetingCreateactionItemsInput | InputJsonValue[]
    decisions?: MeetingCreatedecisionsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMeetingsInput
    tasks?: TaskCreateNestedManyWithoutMeetingInput
  }

  export type MeetingUncheckedCreateWithoutClientInput = {
    id?: string
    projectId?: string | null
    title: string
    description?: string | null
    type?: string
    scheduledAt: Date | string
    duration: number
    timezone?: string
    organizer?: string
    requiredAttendees?: MeetingCreaterequiredAttendeesInput | string[]
    optionalAttendees?: MeetingCreateoptionalAttendeesInput | string[]
    location?: string | null
    meetingLink?: string | null
    agenda?: string | null
    meetingNotes?: string | null
    actionItems?: MeetingCreateactionItemsInput | InputJsonValue[]
    decisions?: MeetingCreatedecisionsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    tasks?: TaskUncheckedCreateNestedManyWithoutMeetingInput
  }

  export type MeetingCreateOrConnectWithoutClientInput = {
    where: MeetingWhereUniqueInput
    create: XOR<MeetingCreateWithoutClientInput, MeetingUncheckedCreateWithoutClientInput>
  }

  export type MeetingCreateManyClientInputEnvelope = {
    data: MeetingCreateManyClientInput | MeetingCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutClientInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    status: string
    billable?: boolean
    hourlyRate?: number | null
    budgetHours?: number | null
    startDate?: Date | string | null
    deadline?: Date | string | null
    estimatedHours?: number | null
    actualHoursSpent?: number
    completionPercentage?: number
    goalId?: string | null
    parentProjectId?: string | null
    priority: string
    tags?: ProjectCreatetagsInput | string[]
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    archivedAt?: Date | string | null
    icon?: string | null
    user: UserCreateNestedOneWithoutProjectsInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutProjectInput
    timeEntries?: TimeEntryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutClientInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    type: string
    status: string
    billable?: boolean
    hourlyRate?: number | null
    budgetHours?: number | null
    startDate?: Date | string | null
    deadline?: Date | string | null
    estimatedHours?: number | null
    actualHoursSpent?: number
    completionPercentage?: number
    goalId?: string | null
    parentProjectId?: string | null
    priority: string
    tags?: ProjectCreatetagsInput | string[]
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    archivedAt?: Date | string | null
    icon?: string | null
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutProjectInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutClientInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput>
  }

  export type ProjectCreateManyClientInputEnvelope = {
    data: ProjectCreateManyClientInput | ProjectCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type TimeBlockCreateWithoutClientInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    duration: number
    type: string
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    actualDuration?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    focusQuality?: number | null
    notes?: string | null
    dayPlan: DayPlanCreateNestedOneWithoutTimeBlocksInput
    project?: ProjectCreateNestedOneWithoutTimeBlocksInput
    task?: TaskCreateNestedOneWithoutTimeBlocksInput
  }

  export type TimeBlockUncheckedCreateWithoutClientInput = {
    id?: string
    dayPlanId: string
    startTime: Date | string
    endTime: Date | string
    duration: number
    type: string
    taskId?: string | null
    projectId?: string | null
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    actualDuration?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    focusQuality?: number | null
    notes?: string | null
  }

  export type TimeBlockCreateOrConnectWithoutClientInput = {
    where: TimeBlockWhereUniqueInput
    create: XOR<TimeBlockCreateWithoutClientInput, TimeBlockUncheckedCreateWithoutClientInput>
  }

  export type TimeBlockCreateManyClientInputEnvelope = {
    data: TimeBlockCreateManyClientInput | TimeBlockCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type TimeEntryCreateWithoutClientInput = {
    id?: string
    startTime: Date | string
    endTime?: Date | string | null
    duration: number
    type: string
    description?: string | null
    tags?: TimeEntryCreatetagsInput | string[]
    focusQuality?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    distractions?: number
    billable?: boolean
    hourlyRate?: number | null
    amount?: number
    invoiced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectCreateNestedOneWithoutTimeEntriesInput
    task?: TaskCreateNestedOneWithoutTimeEntriesInput
    user: UserCreateNestedOneWithoutTimeEntriesInput
  }

  export type TimeEntryUncheckedCreateWithoutClientInput = {
    id?: string
    userId: string
    taskId?: string | null
    projectId?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    duration: number
    type: string
    description?: string | null
    tags?: TimeEntryCreatetagsInput | string[]
    focusQuality?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    distractions?: number
    billable?: boolean
    hourlyRate?: number | null
    amount?: number
    invoiced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeEntryCreateOrConnectWithoutClientInput = {
    where: TimeEntryWhereUniqueInput
    create: XOR<TimeEntryCreateWithoutClientInput, TimeEntryUncheckedCreateWithoutClientInput>
  }

  export type TimeEntryCreateManyClientInputEnvelope = {
    data: TimeEntryCreateManyClientInput | TimeEntryCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutClientsInput = {
    update: XOR<UserUpdateWithoutClientsInput, UserUncheckedUpdateWithoutClientsInput>
    create: XOR<UserCreateWithoutClientsInput, UserUncheckedCreateWithoutClientsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClientsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClientsInput, UserUncheckedUpdateWithoutClientsInput>
  }

  export type UserUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    geminiModel?: StringFieldUpdateOperationsInput | string
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    llmProvider?: StringFieldUpdateOperationsInput | string
    serperApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    researchLimit?: IntFieldUpdateOperationsInput | number
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    captures?: CaptureUpdateManyWithoutUserNestedInput
    dayPlans?: DayPlanUpdateManyWithoutUserNestedInput
    meetings?: MeetingUpdateManyWithoutUserNestedInput
    notes?: NoteUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    researches?: ResearchUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    voiceSessions?: VoiceSessionUpdateManyWithoutUserNestedInput
    weekPlans?: WeekPlanUpdateManyWithoutUserNestedInput
    wellBeingEntries?: WellBeingEntryUpdateManyWithoutUserNestedInput
    yearPlans?: YearPlanUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    geminiModel?: StringFieldUpdateOperationsInput | string
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    llmProvider?: StringFieldUpdateOperationsInput | string
    serperApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    researchLimit?: IntFieldUpdateOperationsInput | number
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    captures?: CaptureUncheckedUpdateManyWithoutUserNestedInput
    dayPlans?: DayPlanUncheckedUpdateManyWithoutUserNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutUserNestedInput
    notes?: NoteUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    researches?: ResearchUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    voiceSessions?: VoiceSessionUncheckedUpdateManyWithoutUserNestedInput
    weekPlans?: WeekPlanUncheckedUpdateManyWithoutUserNestedInput
    wellBeingEntries?: WellBeingEntryUncheckedUpdateManyWithoutUserNestedInput
    yearPlans?: YearPlanUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommunicationUpsertWithWhereUniqueWithoutClientInput = {
    where: CommunicationWhereUniqueInput
    update: XOR<CommunicationUpdateWithoutClientInput, CommunicationUncheckedUpdateWithoutClientInput>
    create: XOR<CommunicationCreateWithoutClientInput, CommunicationUncheckedCreateWithoutClientInput>
  }

  export type CommunicationUpdateWithWhereUniqueWithoutClientInput = {
    where: CommunicationWhereUniqueInput
    data: XOR<CommunicationUpdateWithoutClientInput, CommunicationUncheckedUpdateWithoutClientInput>
  }

  export type CommunicationUpdateManyWithWhereWithoutClientInput = {
    where: CommunicationScalarWhereInput
    data: XOR<CommunicationUpdateManyMutationInput, CommunicationUncheckedUpdateManyWithoutClientInput>
  }

  export type CommunicationScalarWhereInput = {
    AND?: CommunicationScalarWhereInput | CommunicationScalarWhereInput[]
    OR?: CommunicationScalarWhereInput[]
    NOT?: CommunicationScalarWhereInput | CommunicationScalarWhereInput[]
    id?: StringFilter<"Communication"> | string
    clientId?: StringFilter<"Communication"> | string
    projectId?: StringNullableFilter<"Communication"> | string | null
    type?: StringFilter<"Communication"> | string
    direction?: StringFilter<"Communication"> | string
    subject?: StringFilter<"Communication"> | string
    content?: StringFilter<"Communication"> | string
    summary?: StringNullableFilter<"Communication"> | string | null
    from?: StringNullableFilter<"Communication"> | string | null
    to?: StringNullableListFilter<"Communication">
    cc?: StringNullableListFilter<"Communication">
    attachments?: JsonNullableListFilter<"Communication">
    meetingDate?: DateTimeNullableFilter<"Communication"> | Date | string | null
    meetingDuration?: IntNullableFilter<"Communication"> | number | null
    attendees?: StringNullableListFilter<"Communication">
    meetingNotes?: StringNullableFilter<"Communication"> | string | null
    sentiment?: StringNullableFilter<"Communication"> | string | null
    requiresFollowUp?: BoolFilter<"Communication"> | boolean
    followUpDate?: DateTimeNullableFilter<"Communication"> | Date | string | null
    createdAt?: DateTimeFilter<"Communication"> | Date | string
    responseTime?: IntNullableFilter<"Communication"> | number | null
  }

  export type MeetingUpsertWithWhereUniqueWithoutClientInput = {
    where: MeetingWhereUniqueInput
    update: XOR<MeetingUpdateWithoutClientInput, MeetingUncheckedUpdateWithoutClientInput>
    create: XOR<MeetingCreateWithoutClientInput, MeetingUncheckedCreateWithoutClientInput>
  }

  export type MeetingUpdateWithWhereUniqueWithoutClientInput = {
    where: MeetingWhereUniqueInput
    data: XOR<MeetingUpdateWithoutClientInput, MeetingUncheckedUpdateWithoutClientInput>
  }

  export type MeetingUpdateManyWithWhereWithoutClientInput = {
    where: MeetingScalarWhereInput
    data: XOR<MeetingUpdateManyMutationInput, MeetingUncheckedUpdateManyWithoutClientInput>
  }

  export type ProjectUpsertWithWhereUniqueWithoutClientInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutClientInput, ProjectUncheckedUpdateWithoutClientInput>
    create: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutClientInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutClientInput, ProjectUncheckedUpdateWithoutClientInput>
  }

  export type ProjectUpdateManyWithWhereWithoutClientInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutClientInput>
  }

  export type TimeBlockUpsertWithWhereUniqueWithoutClientInput = {
    where: TimeBlockWhereUniqueInput
    update: XOR<TimeBlockUpdateWithoutClientInput, TimeBlockUncheckedUpdateWithoutClientInput>
    create: XOR<TimeBlockCreateWithoutClientInput, TimeBlockUncheckedCreateWithoutClientInput>
  }

  export type TimeBlockUpdateWithWhereUniqueWithoutClientInput = {
    where: TimeBlockWhereUniqueInput
    data: XOR<TimeBlockUpdateWithoutClientInput, TimeBlockUncheckedUpdateWithoutClientInput>
  }

  export type TimeBlockUpdateManyWithWhereWithoutClientInput = {
    where: TimeBlockScalarWhereInput
    data: XOR<TimeBlockUpdateManyMutationInput, TimeBlockUncheckedUpdateManyWithoutClientInput>
  }

  export type TimeEntryUpsertWithWhereUniqueWithoutClientInput = {
    where: TimeEntryWhereUniqueInput
    update: XOR<TimeEntryUpdateWithoutClientInput, TimeEntryUncheckedUpdateWithoutClientInput>
    create: XOR<TimeEntryCreateWithoutClientInput, TimeEntryUncheckedCreateWithoutClientInput>
  }

  export type TimeEntryUpdateWithWhereUniqueWithoutClientInput = {
    where: TimeEntryWhereUniqueInput
    data: XOR<TimeEntryUpdateWithoutClientInput, TimeEntryUncheckedUpdateWithoutClientInput>
  }

  export type TimeEntryUpdateManyWithWhereWithoutClientInput = {
    where: TimeEntryScalarWhereInput
    data: XOR<TimeEntryUpdateManyMutationInput, TimeEntryUncheckedUpdateManyWithoutClientInput>
  }

  export type ClientCreateWithoutCommunicationsInput = {
    id?: string
    name: string
    companyName?: string | null
    email: string
    phone?: string | null
    primaryContact?: NullableJsonNullValueInput | InputJsonValue
    additionalContacts?: ClientCreateadditionalContactsInput | InputJsonValue[]
    industry?: string | null
    website?: string | null
    timezone?: string | null
    relationshipHealth?: number | null
    lastContactedAt?: Date | string | null
    preferredCommunication?: string | null
    defaultHourlyRate?: number | null
    paymentTerms?: string | null
    outstandingBalance?: number
    notes?: string | null
    tags?: ClientCreatetagsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastInteractionAt?: Date | string | null
    user: UserCreateNestedOneWithoutClientsInput
    meetings?: MeetingCreateNestedManyWithoutClientInput
    projects?: ProjectCreateNestedManyWithoutClientInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutClientInput
    timeEntries?: TimeEntryCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutCommunicationsInput = {
    id?: string
    userId: string
    name: string
    companyName?: string | null
    email: string
    phone?: string | null
    primaryContact?: NullableJsonNullValueInput | InputJsonValue
    additionalContacts?: ClientCreateadditionalContactsInput | InputJsonValue[]
    industry?: string | null
    website?: string | null
    timezone?: string | null
    relationshipHealth?: number | null
    lastContactedAt?: Date | string | null
    preferredCommunication?: string | null
    defaultHourlyRate?: number | null
    paymentTerms?: string | null
    outstandingBalance?: number
    notes?: string | null
    tags?: ClientCreatetagsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastInteractionAt?: Date | string | null
    meetings?: MeetingUncheckedCreateNestedManyWithoutClientInput
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutClientInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutCommunicationsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutCommunicationsInput, ClientUncheckedCreateWithoutCommunicationsInput>
  }

  export type ClientUpsertWithoutCommunicationsInput = {
    update: XOR<ClientUpdateWithoutCommunicationsInput, ClientUncheckedUpdateWithoutCommunicationsInput>
    create: XOR<ClientCreateWithoutCommunicationsInput, ClientUncheckedCreateWithoutCommunicationsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutCommunicationsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutCommunicationsInput, ClientUncheckedUpdateWithoutCommunicationsInput>
  }

  export type ClientUpdateWithoutCommunicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContact?: NullableJsonNullValueInput | InputJsonValue
    additionalContacts?: ClientUpdateadditionalContactsInput | InputJsonValue[]
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipHealth?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredCommunication?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    outstandingBalance?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ClientUpdatetagsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastInteractionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutClientsNestedInput
    meetings?: MeetingUpdateManyWithoutClientNestedInput
    projects?: ProjectUpdateManyWithoutClientNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutClientNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutCommunicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContact?: NullableJsonNullValueInput | InputJsonValue
    additionalContacts?: ClientUpdateadditionalContactsInput | InputJsonValue[]
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipHealth?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredCommunication?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    outstandingBalance?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ClientUpdatetagsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastInteractionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meetings?: MeetingUncheckedUpdateManyWithoutClientNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutClientNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateWithoutMeetingsInput = {
    id?: string
    name: string
    companyName?: string | null
    email: string
    phone?: string | null
    primaryContact?: NullableJsonNullValueInput | InputJsonValue
    additionalContacts?: ClientCreateadditionalContactsInput | InputJsonValue[]
    industry?: string | null
    website?: string | null
    timezone?: string | null
    relationshipHealth?: number | null
    lastContactedAt?: Date | string | null
    preferredCommunication?: string | null
    defaultHourlyRate?: number | null
    paymentTerms?: string | null
    outstandingBalance?: number
    notes?: string | null
    tags?: ClientCreatetagsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastInteractionAt?: Date | string | null
    user: UserCreateNestedOneWithoutClientsInput
    communications?: CommunicationCreateNestedManyWithoutClientInput
    projects?: ProjectCreateNestedManyWithoutClientInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutClientInput
    timeEntries?: TimeEntryCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutMeetingsInput = {
    id?: string
    userId: string
    name: string
    companyName?: string | null
    email: string
    phone?: string | null
    primaryContact?: NullableJsonNullValueInput | InputJsonValue
    additionalContacts?: ClientCreateadditionalContactsInput | InputJsonValue[]
    industry?: string | null
    website?: string | null
    timezone?: string | null
    relationshipHealth?: number | null
    lastContactedAt?: Date | string | null
    preferredCommunication?: string | null
    defaultHourlyRate?: number | null
    paymentTerms?: string | null
    outstandingBalance?: number
    notes?: string | null
    tags?: ClientCreatetagsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastInteractionAt?: Date | string | null
    communications?: CommunicationUncheckedCreateNestedManyWithoutClientInput
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutClientInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutMeetingsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutMeetingsInput, ClientUncheckedCreateWithoutMeetingsInput>
  }

  export type UserCreateWithoutMeetingsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    geminiApiKey?: string | null
    geminiModel?: string
    groqApiKey?: string | null
    llmProvider?: string
    serperApiKey?: string | null
    researchLimit?: number
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    captures?: CaptureCreateNestedManyWithoutUserInput
    clients?: ClientCreateNestedManyWithoutUserInput
    dayPlans?: DayPlanCreateNestedManyWithoutUserInput
    notes?: NoteCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    researches?: ResearchCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    voiceSessions?: VoiceSessionCreateNestedManyWithoutUserInput
    weekPlans?: WeekPlanCreateNestedManyWithoutUserInput
    wellBeingEntries?: WellBeingEntryCreateNestedManyWithoutUserInput
    yearPlans?: YearPlanCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMeetingsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    geminiApiKey?: string | null
    geminiModel?: string
    groqApiKey?: string | null
    llmProvider?: string
    serperApiKey?: string | null
    researchLimit?: number
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    captures?: CaptureUncheckedCreateNestedManyWithoutUserInput
    clients?: ClientUncheckedCreateNestedManyWithoutUserInput
    dayPlans?: DayPlanUncheckedCreateNestedManyWithoutUserInput
    notes?: NoteUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    researches?: ResearchUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    voiceSessions?: VoiceSessionUncheckedCreateNestedManyWithoutUserInput
    weekPlans?: WeekPlanUncheckedCreateNestedManyWithoutUserInput
    wellBeingEntries?: WellBeingEntryUncheckedCreateNestedManyWithoutUserInput
    yearPlans?: YearPlanUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMeetingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMeetingsInput, UserUncheckedCreateWithoutMeetingsInput>
  }

  export type TaskCreateWithoutMeetingInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    estimatedMinutes?: number | null
    actualMinutes?: number
    timerRunning?: boolean
    currentTimerStart?: Date | string | null
    scheduledDate?: Date | string | null
    dueDate?: Date | string | null
    priority: string
    type: string
    tags?: TaskCreatetagsInput | string[]
    parentTaskId?: string | null
    dependsOn?: TaskCreatedependsOnInput | string[]
    blocks?: TaskCreateblocksInput | string[]
    energyRequired?: number | null
    isAdHoc?: boolean
    isRecurring?: boolean
    recurringPattern?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actionItem?: ActionItemCreateNestedOneWithoutConvertedToTaskInput
    goal?: GoalCreateNestedOneWithoutTasksInput
    keyStep?: KeyStepCreateNestedOneWithoutTasksInput
    project?: ProjectCreateNestedOneWithoutTasksInput
    user: UserCreateNestedOneWithoutTasksInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutTaskInput
    timeEntries?: TimeEntryCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutMeetingInput = {
    id?: string
    userId: string
    projectId?: string | null
    title: string
    description?: string | null
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    estimatedMinutes?: number | null
    actualMinutes?: number
    timerRunning?: boolean
    currentTimerStart?: Date | string | null
    scheduledDate?: Date | string | null
    dueDate?: Date | string | null
    priority: string
    type: string
    tags?: TaskCreatetagsInput | string[]
    parentTaskId?: string | null
    dependsOn?: TaskCreatedependsOnInput | string[]
    blocks?: TaskCreateblocksInput | string[]
    energyRequired?: number | null
    isAdHoc?: boolean
    isRecurring?: boolean
    recurringPattern?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goalId?: string | null
    keyStepId?: string | null
    actionItem?: ActionItemUncheckedCreateNestedOneWithoutConvertedToTaskInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutTaskInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutMeetingInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutMeetingInput, TaskUncheckedCreateWithoutMeetingInput>
  }

  export type TaskCreateManyMeetingInputEnvelope = {
    data: TaskCreateManyMeetingInput | TaskCreateManyMeetingInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutMeetingsInput = {
    update: XOR<ClientUpdateWithoutMeetingsInput, ClientUncheckedUpdateWithoutMeetingsInput>
    create: XOR<ClientCreateWithoutMeetingsInput, ClientUncheckedCreateWithoutMeetingsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutMeetingsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutMeetingsInput, ClientUncheckedUpdateWithoutMeetingsInput>
  }

  export type ClientUpdateWithoutMeetingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContact?: NullableJsonNullValueInput | InputJsonValue
    additionalContacts?: ClientUpdateadditionalContactsInput | InputJsonValue[]
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipHealth?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredCommunication?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    outstandingBalance?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ClientUpdatetagsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastInteractionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutClientsNestedInput
    communications?: CommunicationUpdateManyWithoutClientNestedInput
    projects?: ProjectUpdateManyWithoutClientNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutClientNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutMeetingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContact?: NullableJsonNullValueInput | InputJsonValue
    additionalContacts?: ClientUpdateadditionalContactsInput | InputJsonValue[]
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipHealth?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredCommunication?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    outstandingBalance?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ClientUpdatetagsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastInteractionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communications?: CommunicationUncheckedUpdateManyWithoutClientNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutClientNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutClientNestedInput
  }

  export type UserUpsertWithoutMeetingsInput = {
    update: XOR<UserUpdateWithoutMeetingsInput, UserUncheckedUpdateWithoutMeetingsInput>
    create: XOR<UserCreateWithoutMeetingsInput, UserUncheckedCreateWithoutMeetingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMeetingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMeetingsInput, UserUncheckedUpdateWithoutMeetingsInput>
  }

  export type UserUpdateWithoutMeetingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    geminiModel?: StringFieldUpdateOperationsInput | string
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    llmProvider?: StringFieldUpdateOperationsInput | string
    serperApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    researchLimit?: IntFieldUpdateOperationsInput | number
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    captures?: CaptureUpdateManyWithoutUserNestedInput
    clients?: ClientUpdateManyWithoutUserNestedInput
    dayPlans?: DayPlanUpdateManyWithoutUserNestedInput
    notes?: NoteUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    researches?: ResearchUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    voiceSessions?: VoiceSessionUpdateManyWithoutUserNestedInput
    weekPlans?: WeekPlanUpdateManyWithoutUserNestedInput
    wellBeingEntries?: WellBeingEntryUpdateManyWithoutUserNestedInput
    yearPlans?: YearPlanUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMeetingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    geminiModel?: StringFieldUpdateOperationsInput | string
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    llmProvider?: StringFieldUpdateOperationsInput | string
    serperApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    researchLimit?: IntFieldUpdateOperationsInput | number
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    captures?: CaptureUncheckedUpdateManyWithoutUserNestedInput
    clients?: ClientUncheckedUpdateManyWithoutUserNestedInput
    dayPlans?: DayPlanUncheckedUpdateManyWithoutUserNestedInput
    notes?: NoteUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    researches?: ResearchUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    voiceSessions?: VoiceSessionUncheckedUpdateManyWithoutUserNestedInput
    weekPlans?: WeekPlanUncheckedUpdateManyWithoutUserNestedInput
    wellBeingEntries?: WellBeingEntryUncheckedUpdateManyWithoutUserNestedInput
    yearPlans?: YearPlanUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TaskUpsertWithWhereUniqueWithoutMeetingInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutMeetingInput, TaskUncheckedUpdateWithoutMeetingInput>
    create: XOR<TaskCreateWithoutMeetingInput, TaskUncheckedCreateWithoutMeetingInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutMeetingInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutMeetingInput, TaskUncheckedUpdateWithoutMeetingInput>
  }

  export type TaskUpdateManyWithWhereWithoutMeetingInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutMeetingInput>
  }

  export type UserCreateWithoutWellBeingEntriesInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    geminiApiKey?: string | null
    geminiModel?: string
    groqApiKey?: string | null
    llmProvider?: string
    serperApiKey?: string | null
    researchLimit?: number
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    captures?: CaptureCreateNestedManyWithoutUserInput
    clients?: ClientCreateNestedManyWithoutUserInput
    dayPlans?: DayPlanCreateNestedManyWithoutUserInput
    meetings?: MeetingCreateNestedManyWithoutUserInput
    notes?: NoteCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    researches?: ResearchCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    voiceSessions?: VoiceSessionCreateNestedManyWithoutUserInput
    weekPlans?: WeekPlanCreateNestedManyWithoutUserInput
    yearPlans?: YearPlanCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWellBeingEntriesInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    geminiApiKey?: string | null
    geminiModel?: string
    groqApiKey?: string | null
    llmProvider?: string
    serperApiKey?: string | null
    researchLimit?: number
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    captures?: CaptureUncheckedCreateNestedManyWithoutUserInput
    clients?: ClientUncheckedCreateNestedManyWithoutUserInput
    dayPlans?: DayPlanUncheckedCreateNestedManyWithoutUserInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutUserInput
    notes?: NoteUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    researches?: ResearchUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    voiceSessions?: VoiceSessionUncheckedCreateNestedManyWithoutUserInput
    weekPlans?: WeekPlanUncheckedCreateNestedManyWithoutUserInput
    yearPlans?: YearPlanUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWellBeingEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWellBeingEntriesInput, UserUncheckedCreateWithoutWellBeingEntriesInput>
  }

  export type UserUpsertWithoutWellBeingEntriesInput = {
    update: XOR<UserUpdateWithoutWellBeingEntriesInput, UserUncheckedUpdateWithoutWellBeingEntriesInput>
    create: XOR<UserCreateWithoutWellBeingEntriesInput, UserUncheckedCreateWithoutWellBeingEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWellBeingEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWellBeingEntriesInput, UserUncheckedUpdateWithoutWellBeingEntriesInput>
  }

  export type UserUpdateWithoutWellBeingEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    geminiModel?: StringFieldUpdateOperationsInput | string
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    llmProvider?: StringFieldUpdateOperationsInput | string
    serperApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    researchLimit?: IntFieldUpdateOperationsInput | number
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    captures?: CaptureUpdateManyWithoutUserNestedInput
    clients?: ClientUpdateManyWithoutUserNestedInput
    dayPlans?: DayPlanUpdateManyWithoutUserNestedInput
    meetings?: MeetingUpdateManyWithoutUserNestedInput
    notes?: NoteUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    researches?: ResearchUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    voiceSessions?: VoiceSessionUpdateManyWithoutUserNestedInput
    weekPlans?: WeekPlanUpdateManyWithoutUserNestedInput
    yearPlans?: YearPlanUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWellBeingEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    geminiModel?: StringFieldUpdateOperationsInput | string
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    llmProvider?: StringFieldUpdateOperationsInput | string
    serperApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    researchLimit?: IntFieldUpdateOperationsInput | number
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    captures?: CaptureUncheckedUpdateManyWithoutUserNestedInput
    clients?: ClientUncheckedUpdateManyWithoutUserNestedInput
    dayPlans?: DayPlanUncheckedUpdateManyWithoutUserNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutUserNestedInput
    notes?: NoteUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    researches?: ResearchUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    voiceSessions?: VoiceSessionUncheckedUpdateManyWithoutUserNestedInput
    weekPlans?: WeekPlanUncheckedUpdateManyWithoutUserNestedInput
    yearPlans?: YearPlanUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCapturesInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    geminiApiKey?: string | null
    geminiModel?: string
    groqApiKey?: string | null
    llmProvider?: string
    serperApiKey?: string | null
    researchLimit?: number
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    clients?: ClientCreateNestedManyWithoutUserInput
    dayPlans?: DayPlanCreateNestedManyWithoutUserInput
    meetings?: MeetingCreateNestedManyWithoutUserInput
    notes?: NoteCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    researches?: ResearchCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    voiceSessions?: VoiceSessionCreateNestedManyWithoutUserInput
    weekPlans?: WeekPlanCreateNestedManyWithoutUserInput
    wellBeingEntries?: WellBeingEntryCreateNestedManyWithoutUserInput
    yearPlans?: YearPlanCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCapturesInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    geminiApiKey?: string | null
    geminiModel?: string
    groqApiKey?: string | null
    llmProvider?: string
    serperApiKey?: string | null
    researchLimit?: number
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    clients?: ClientUncheckedCreateNestedManyWithoutUserInput
    dayPlans?: DayPlanUncheckedCreateNestedManyWithoutUserInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutUserInput
    notes?: NoteUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    researches?: ResearchUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    voiceSessions?: VoiceSessionUncheckedCreateNestedManyWithoutUserInput
    weekPlans?: WeekPlanUncheckedCreateNestedManyWithoutUserInput
    wellBeingEntries?: WellBeingEntryUncheckedCreateNestedManyWithoutUserInput
    yearPlans?: YearPlanUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCapturesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCapturesInput, UserUncheckedCreateWithoutCapturesInput>
  }

  export type UserUpsertWithoutCapturesInput = {
    update: XOR<UserUpdateWithoutCapturesInput, UserUncheckedUpdateWithoutCapturesInput>
    create: XOR<UserCreateWithoutCapturesInput, UserUncheckedCreateWithoutCapturesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCapturesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCapturesInput, UserUncheckedUpdateWithoutCapturesInput>
  }

  export type UserUpdateWithoutCapturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    geminiModel?: StringFieldUpdateOperationsInput | string
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    llmProvider?: StringFieldUpdateOperationsInput | string
    serperApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    researchLimit?: IntFieldUpdateOperationsInput | number
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    clients?: ClientUpdateManyWithoutUserNestedInput
    dayPlans?: DayPlanUpdateManyWithoutUserNestedInput
    meetings?: MeetingUpdateManyWithoutUserNestedInput
    notes?: NoteUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    researches?: ResearchUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    voiceSessions?: VoiceSessionUpdateManyWithoutUserNestedInput
    weekPlans?: WeekPlanUpdateManyWithoutUserNestedInput
    wellBeingEntries?: WellBeingEntryUpdateManyWithoutUserNestedInput
    yearPlans?: YearPlanUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCapturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    geminiModel?: StringFieldUpdateOperationsInput | string
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    llmProvider?: StringFieldUpdateOperationsInput | string
    serperApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    researchLimit?: IntFieldUpdateOperationsInput | number
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    clients?: ClientUncheckedUpdateManyWithoutUserNestedInput
    dayPlans?: DayPlanUncheckedUpdateManyWithoutUserNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutUserNestedInput
    notes?: NoteUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    researches?: ResearchUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    voiceSessions?: VoiceSessionUncheckedUpdateManyWithoutUserNestedInput
    weekPlans?: WeekPlanUncheckedUpdateManyWithoutUserNestedInput
    wellBeingEntries?: WellBeingEntryUncheckedUpdateManyWithoutUserNestedInput
    yearPlans?: YearPlanUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutVoiceSessionsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    geminiApiKey?: string | null
    geminiModel?: string
    groqApiKey?: string | null
    llmProvider?: string
    serperApiKey?: string | null
    researchLimit?: number
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    captures?: CaptureCreateNestedManyWithoutUserInput
    clients?: ClientCreateNestedManyWithoutUserInput
    dayPlans?: DayPlanCreateNestedManyWithoutUserInput
    meetings?: MeetingCreateNestedManyWithoutUserInput
    notes?: NoteCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    researches?: ResearchCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    weekPlans?: WeekPlanCreateNestedManyWithoutUserInput
    wellBeingEntries?: WellBeingEntryCreateNestedManyWithoutUserInput
    yearPlans?: YearPlanCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVoiceSessionsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    geminiApiKey?: string | null
    geminiModel?: string
    groqApiKey?: string | null
    llmProvider?: string
    serperApiKey?: string | null
    researchLimit?: number
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    captures?: CaptureUncheckedCreateNestedManyWithoutUserInput
    clients?: ClientUncheckedCreateNestedManyWithoutUserInput
    dayPlans?: DayPlanUncheckedCreateNestedManyWithoutUserInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutUserInput
    notes?: NoteUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    researches?: ResearchUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    weekPlans?: WeekPlanUncheckedCreateNestedManyWithoutUserInput
    wellBeingEntries?: WellBeingEntryUncheckedCreateNestedManyWithoutUserInput
    yearPlans?: YearPlanUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVoiceSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVoiceSessionsInput, UserUncheckedCreateWithoutVoiceSessionsInput>
  }

  export type UserUpsertWithoutVoiceSessionsInput = {
    update: XOR<UserUpdateWithoutVoiceSessionsInput, UserUncheckedUpdateWithoutVoiceSessionsInput>
    create: XOR<UserCreateWithoutVoiceSessionsInput, UserUncheckedCreateWithoutVoiceSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVoiceSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVoiceSessionsInput, UserUncheckedUpdateWithoutVoiceSessionsInput>
  }

  export type UserUpdateWithoutVoiceSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    geminiModel?: StringFieldUpdateOperationsInput | string
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    llmProvider?: StringFieldUpdateOperationsInput | string
    serperApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    researchLimit?: IntFieldUpdateOperationsInput | number
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    captures?: CaptureUpdateManyWithoutUserNestedInput
    clients?: ClientUpdateManyWithoutUserNestedInput
    dayPlans?: DayPlanUpdateManyWithoutUserNestedInput
    meetings?: MeetingUpdateManyWithoutUserNestedInput
    notes?: NoteUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    researches?: ResearchUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    weekPlans?: WeekPlanUpdateManyWithoutUserNestedInput
    wellBeingEntries?: WellBeingEntryUpdateManyWithoutUserNestedInput
    yearPlans?: YearPlanUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVoiceSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    geminiModel?: StringFieldUpdateOperationsInput | string
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    llmProvider?: StringFieldUpdateOperationsInput | string
    serperApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    researchLimit?: IntFieldUpdateOperationsInput | number
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    captures?: CaptureUncheckedUpdateManyWithoutUserNestedInput
    clients?: ClientUncheckedUpdateManyWithoutUserNestedInput
    dayPlans?: DayPlanUncheckedUpdateManyWithoutUserNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutUserNestedInput
    notes?: NoteUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    researches?: ResearchUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    weekPlans?: WeekPlanUncheckedUpdateManyWithoutUserNestedInput
    wellBeingEntries?: WellBeingEntryUncheckedUpdateManyWithoutUserNestedInput
    yearPlans?: YearPlanUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCalendarEventsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    geminiApiKey?: string | null
    geminiModel?: string
    groqApiKey?: string | null
    llmProvider?: string
    serperApiKey?: string | null
    researchLimit?: number
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    captures?: CaptureCreateNestedManyWithoutUserInput
    clients?: ClientCreateNestedManyWithoutUserInput
    dayPlans?: DayPlanCreateNestedManyWithoutUserInput
    meetings?: MeetingCreateNestedManyWithoutUserInput
    notes?: NoteCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    researches?: ResearchCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    voiceSessions?: VoiceSessionCreateNestedManyWithoutUserInput
    weekPlans?: WeekPlanCreateNestedManyWithoutUserInput
    wellBeingEntries?: WellBeingEntryCreateNestedManyWithoutUserInput
    yearPlans?: YearPlanCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCalendarEventsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    geminiApiKey?: string | null
    geminiModel?: string
    groqApiKey?: string | null
    llmProvider?: string
    serperApiKey?: string | null
    researchLimit?: number
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    captures?: CaptureUncheckedCreateNestedManyWithoutUserInput
    clients?: ClientUncheckedCreateNestedManyWithoutUserInput
    dayPlans?: DayPlanUncheckedCreateNestedManyWithoutUserInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutUserInput
    notes?: NoteUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    researches?: ResearchUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    voiceSessions?: VoiceSessionUncheckedCreateNestedManyWithoutUserInput
    weekPlans?: WeekPlanUncheckedCreateNestedManyWithoutUserInput
    wellBeingEntries?: WellBeingEntryUncheckedCreateNestedManyWithoutUserInput
    yearPlans?: YearPlanUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCalendarEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCalendarEventsInput, UserUncheckedCreateWithoutCalendarEventsInput>
  }

  export type UserUpsertWithoutCalendarEventsInput = {
    update: XOR<UserUpdateWithoutCalendarEventsInput, UserUncheckedUpdateWithoutCalendarEventsInput>
    create: XOR<UserCreateWithoutCalendarEventsInput, UserUncheckedCreateWithoutCalendarEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCalendarEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCalendarEventsInput, UserUncheckedUpdateWithoutCalendarEventsInput>
  }

  export type UserUpdateWithoutCalendarEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    geminiModel?: StringFieldUpdateOperationsInput | string
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    llmProvider?: StringFieldUpdateOperationsInput | string
    serperApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    researchLimit?: IntFieldUpdateOperationsInput | number
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    captures?: CaptureUpdateManyWithoutUserNestedInput
    clients?: ClientUpdateManyWithoutUserNestedInput
    dayPlans?: DayPlanUpdateManyWithoutUserNestedInput
    meetings?: MeetingUpdateManyWithoutUserNestedInput
    notes?: NoteUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    researches?: ResearchUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    voiceSessions?: VoiceSessionUpdateManyWithoutUserNestedInput
    weekPlans?: WeekPlanUpdateManyWithoutUserNestedInput
    wellBeingEntries?: WellBeingEntryUpdateManyWithoutUserNestedInput
    yearPlans?: YearPlanUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCalendarEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    geminiModel?: StringFieldUpdateOperationsInput | string
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    llmProvider?: StringFieldUpdateOperationsInput | string
    serperApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    researchLimit?: IntFieldUpdateOperationsInput | number
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    captures?: CaptureUncheckedUpdateManyWithoutUserNestedInput
    clients?: ClientUncheckedUpdateManyWithoutUserNestedInput
    dayPlans?: DayPlanUncheckedUpdateManyWithoutUserNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutUserNestedInput
    notes?: NoteUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    researches?: ResearchUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    voiceSessions?: VoiceSessionUncheckedUpdateManyWithoutUserNestedInput
    weekPlans?: WeekPlanUncheckedUpdateManyWithoutUserNestedInput
    wellBeingEntries?: WellBeingEntryUncheckedUpdateManyWithoutUserNestedInput
    yearPlans?: YearPlanUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAnalyticsEventsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    geminiApiKey?: string | null
    geminiModel?: string
    groqApiKey?: string | null
    llmProvider?: string
    serperApiKey?: string | null
    researchLimit?: number
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    captures?: CaptureCreateNestedManyWithoutUserInput
    clients?: ClientCreateNestedManyWithoutUserInput
    dayPlans?: DayPlanCreateNestedManyWithoutUserInput
    meetings?: MeetingCreateNestedManyWithoutUserInput
    notes?: NoteCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    researches?: ResearchCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    voiceSessions?: VoiceSessionCreateNestedManyWithoutUserInput
    weekPlans?: WeekPlanCreateNestedManyWithoutUserInput
    wellBeingEntries?: WellBeingEntryCreateNestedManyWithoutUserInput
    yearPlans?: YearPlanCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAnalyticsEventsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    geminiApiKey?: string | null
    geminiModel?: string
    groqApiKey?: string | null
    llmProvider?: string
    serperApiKey?: string | null
    researchLimit?: number
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    captures?: CaptureUncheckedCreateNestedManyWithoutUserInput
    clients?: ClientUncheckedCreateNestedManyWithoutUserInput
    dayPlans?: DayPlanUncheckedCreateNestedManyWithoutUserInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutUserInput
    notes?: NoteUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    researches?: ResearchUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    voiceSessions?: VoiceSessionUncheckedCreateNestedManyWithoutUserInput
    weekPlans?: WeekPlanUncheckedCreateNestedManyWithoutUserInput
    wellBeingEntries?: WellBeingEntryUncheckedCreateNestedManyWithoutUserInput
    yearPlans?: YearPlanUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAnalyticsEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnalyticsEventsInput, UserUncheckedCreateWithoutAnalyticsEventsInput>
  }

  export type UserUpsertWithoutAnalyticsEventsInput = {
    update: XOR<UserUpdateWithoutAnalyticsEventsInput, UserUncheckedUpdateWithoutAnalyticsEventsInput>
    create: XOR<UserCreateWithoutAnalyticsEventsInput, UserUncheckedCreateWithoutAnalyticsEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAnalyticsEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAnalyticsEventsInput, UserUncheckedUpdateWithoutAnalyticsEventsInput>
  }

  export type UserUpdateWithoutAnalyticsEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    geminiModel?: StringFieldUpdateOperationsInput | string
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    llmProvider?: StringFieldUpdateOperationsInput | string
    serperApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    researchLimit?: IntFieldUpdateOperationsInput | number
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    captures?: CaptureUpdateManyWithoutUserNestedInput
    clients?: ClientUpdateManyWithoutUserNestedInput
    dayPlans?: DayPlanUpdateManyWithoutUserNestedInput
    meetings?: MeetingUpdateManyWithoutUserNestedInput
    notes?: NoteUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    researches?: ResearchUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    voiceSessions?: VoiceSessionUpdateManyWithoutUserNestedInput
    weekPlans?: WeekPlanUpdateManyWithoutUserNestedInput
    wellBeingEntries?: WellBeingEntryUpdateManyWithoutUserNestedInput
    yearPlans?: YearPlanUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAnalyticsEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    geminiModel?: StringFieldUpdateOperationsInput | string
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    llmProvider?: StringFieldUpdateOperationsInput | string
    serperApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    researchLimit?: IntFieldUpdateOperationsInput | number
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    captures?: CaptureUncheckedUpdateManyWithoutUserNestedInput
    clients?: ClientUncheckedUpdateManyWithoutUserNestedInput
    dayPlans?: DayPlanUncheckedUpdateManyWithoutUserNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutUserNestedInput
    notes?: NoteUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    researches?: ResearchUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    voiceSessions?: VoiceSessionUncheckedUpdateManyWithoutUserNestedInput
    weekPlans?: WeekPlanUncheckedUpdateManyWithoutUserNestedInput
    wellBeingEntries?: WellBeingEntryUncheckedUpdateManyWithoutUserNestedInput
    yearPlans?: YearPlanUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ActionItemCreateWithoutResearchInput = {
    id?: string
    description: string
    priority?: $Enums.ActionPriority
    effort?: number
    convertedAt?: Date | string | null
    createdAt?: Date | string
    convertedToTask?: TaskCreateNestedOneWithoutActionItemInput
  }

  export type ActionItemUncheckedCreateWithoutResearchInput = {
    id?: string
    description: string
    priority?: $Enums.ActionPriority
    effort?: number
    convertedToTaskId?: string | null
    convertedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ActionItemCreateOrConnectWithoutResearchInput = {
    where: ActionItemWhereUniqueInput
    create: XOR<ActionItemCreateWithoutResearchInput, ActionItemUncheckedCreateWithoutResearchInput>
  }

  export type ActionItemCreateManyResearchInputEnvelope = {
    data: ActionItemCreateManyResearchInput | ActionItemCreateManyResearchInput[]
    skipDuplicates?: boolean
  }

  export type LeadDataCreateWithoutResearchInput = {
    id?: string
    totalFound?: number
    exportedAt?: Date | string | null
    leads?: LeadCreateNestedManyWithoutLeadDataInput
  }

  export type LeadDataUncheckedCreateWithoutResearchInput = {
    id?: string
    totalFound?: number
    exportedAt?: Date | string | null
    leads?: LeadUncheckedCreateNestedManyWithoutLeadDataInput
  }

  export type LeadDataCreateOrConnectWithoutResearchInput = {
    where: LeadDataWhereUniqueInput
    create: XOR<LeadDataCreateWithoutResearchInput, LeadDataUncheckedCreateWithoutResearchInput>
  }

  export type GoalCreateWithoutResearchesInput = {
    id?: string
    title: string
    description?: string | null
    category: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    kpis?: GoalCreatekpisInput | string[]
    priority?: string
    progress?: number
    risks?: GoalCreaterisksInput | string[]
    strategies?: GoalCreatestrategiesInput | string[]
    targetDate?: Date | string | null
    yearPlan: YearPlanCreateNestedOneWithoutGoalsInput
    keySteps?: KeyStepCreateNestedManyWithoutGoalInput
    milestones?: MilestoneCreateNestedManyWithoutGoalInput
    notes?: NoteCreateNestedManyWithoutGoalInput
    quarterFocuses?: QuarterFocusCreateNestedManyWithoutGoalInput
    tasks?: TaskCreateNestedManyWithoutGoalInput
  }

  export type GoalUncheckedCreateWithoutResearchesInput = {
    id?: string
    yearPlanId: string
    title: string
    description?: string | null
    category: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    kpis?: GoalCreatekpisInput | string[]
    priority?: string
    progress?: number
    risks?: GoalCreaterisksInput | string[]
    strategies?: GoalCreatestrategiesInput | string[]
    targetDate?: Date | string | null
    keySteps?: KeyStepUncheckedCreateNestedManyWithoutGoalInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutGoalInput
    notes?: NoteUncheckedCreateNestedManyWithoutGoalInput
    quarterFocuses?: QuarterFocusUncheckedCreateNestedManyWithoutGoalInput
    tasks?: TaskUncheckedCreateNestedManyWithoutGoalInput
  }

  export type GoalCreateOrConnectWithoutResearchesInput = {
    where: GoalWhereUniqueInput
    create: XOR<GoalCreateWithoutResearchesInput, GoalUncheckedCreateWithoutResearchesInput>
  }

  export type UserCreateWithoutResearchesInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    geminiApiKey?: string | null
    geminiModel?: string
    groqApiKey?: string | null
    llmProvider?: string
    serperApiKey?: string | null
    researchLimit?: number
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    captures?: CaptureCreateNestedManyWithoutUserInput
    clients?: ClientCreateNestedManyWithoutUserInput
    dayPlans?: DayPlanCreateNestedManyWithoutUserInput
    meetings?: MeetingCreateNestedManyWithoutUserInput
    notes?: NoteCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    voiceSessions?: VoiceSessionCreateNestedManyWithoutUserInput
    weekPlans?: WeekPlanCreateNestedManyWithoutUserInput
    wellBeingEntries?: WellBeingEntryCreateNestedManyWithoutUserInput
    yearPlans?: YearPlanCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutResearchesInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    geminiApiKey?: string | null
    geminiModel?: string
    groqApiKey?: string | null
    llmProvider?: string
    serperApiKey?: string | null
    researchLimit?: number
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    captures?: CaptureUncheckedCreateNestedManyWithoutUserInput
    clients?: ClientUncheckedCreateNestedManyWithoutUserInput
    dayPlans?: DayPlanUncheckedCreateNestedManyWithoutUserInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutUserInput
    notes?: NoteUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    voiceSessions?: VoiceSessionUncheckedCreateNestedManyWithoutUserInput
    weekPlans?: WeekPlanUncheckedCreateNestedManyWithoutUserInput
    wellBeingEntries?: WellBeingEntryUncheckedCreateNestedManyWithoutUserInput
    yearPlans?: YearPlanUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutResearchesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResearchesInput, UserUncheckedCreateWithoutResearchesInput>
  }

  export type ResearchInsightCreateWithoutResearchInput = {
    id?: string
    title: string
    content: string
    category: string
    visualData?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number
    order?: number
    createdAt?: Date | string
  }

  export type ResearchInsightUncheckedCreateWithoutResearchInput = {
    id?: string
    title: string
    content: string
    category: string
    visualData?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number
    order?: number
    createdAt?: Date | string
  }

  export type ResearchInsightCreateOrConnectWithoutResearchInput = {
    where: ResearchInsightWhereUniqueInput
    create: XOR<ResearchInsightCreateWithoutResearchInput, ResearchInsightUncheckedCreateWithoutResearchInput>
  }

  export type ResearchInsightCreateManyResearchInputEnvelope = {
    data: ResearchInsightCreateManyResearchInput | ResearchInsightCreateManyResearchInput[]
    skipDuplicates?: boolean
  }

  export type ResearchSourceCreateWithoutResearchInput = {
    id?: string
    url: string
    title: string
    content?: string
    excerpt: string
    credibility?: number
    citedInSections?: ResearchSourceCreatecitedInSectionsInput | string[]
    scrapedAt?: Date | string
  }

  export type ResearchSourceUncheckedCreateWithoutResearchInput = {
    id?: string
    url: string
    title: string
    content?: string
    excerpt: string
    credibility?: number
    citedInSections?: ResearchSourceCreatecitedInSectionsInput | string[]
    scrapedAt?: Date | string
  }

  export type ResearchSourceCreateOrConnectWithoutResearchInput = {
    where: ResearchSourceWhereUniqueInput
    create: XOR<ResearchSourceCreateWithoutResearchInput, ResearchSourceUncheckedCreateWithoutResearchInput>
  }

  export type ResearchSourceCreateManyResearchInputEnvelope = {
    data: ResearchSourceCreateManyResearchInput | ResearchSourceCreateManyResearchInput[]
    skipDuplicates?: boolean
  }

  export type ActionItemUpsertWithWhereUniqueWithoutResearchInput = {
    where: ActionItemWhereUniqueInput
    update: XOR<ActionItemUpdateWithoutResearchInput, ActionItemUncheckedUpdateWithoutResearchInput>
    create: XOR<ActionItemCreateWithoutResearchInput, ActionItemUncheckedCreateWithoutResearchInput>
  }

  export type ActionItemUpdateWithWhereUniqueWithoutResearchInput = {
    where: ActionItemWhereUniqueInput
    data: XOR<ActionItemUpdateWithoutResearchInput, ActionItemUncheckedUpdateWithoutResearchInput>
  }

  export type ActionItemUpdateManyWithWhereWithoutResearchInput = {
    where: ActionItemScalarWhereInput
    data: XOR<ActionItemUpdateManyMutationInput, ActionItemUncheckedUpdateManyWithoutResearchInput>
  }

  export type ActionItemScalarWhereInput = {
    AND?: ActionItemScalarWhereInput | ActionItemScalarWhereInput[]
    OR?: ActionItemScalarWhereInput[]
    NOT?: ActionItemScalarWhereInput | ActionItemScalarWhereInput[]
    id?: StringFilter<"ActionItem"> | string
    researchId?: StringFilter<"ActionItem"> | string
    description?: StringFilter<"ActionItem"> | string
    priority?: EnumActionPriorityFilter<"ActionItem"> | $Enums.ActionPriority
    effort?: IntFilter<"ActionItem"> | number
    convertedToTaskId?: StringNullableFilter<"ActionItem"> | string | null
    convertedAt?: DateTimeNullableFilter<"ActionItem"> | Date | string | null
    createdAt?: DateTimeFilter<"ActionItem"> | Date | string
  }

  export type LeadDataUpsertWithoutResearchInput = {
    update: XOR<LeadDataUpdateWithoutResearchInput, LeadDataUncheckedUpdateWithoutResearchInput>
    create: XOR<LeadDataCreateWithoutResearchInput, LeadDataUncheckedCreateWithoutResearchInput>
    where?: LeadDataWhereInput
  }

  export type LeadDataUpdateToOneWithWhereWithoutResearchInput = {
    where?: LeadDataWhereInput
    data: XOR<LeadDataUpdateWithoutResearchInput, LeadDataUncheckedUpdateWithoutResearchInput>
  }

  export type LeadDataUpdateWithoutResearchInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalFound?: IntFieldUpdateOperationsInput | number
    exportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leads?: LeadUpdateManyWithoutLeadDataNestedInput
  }

  export type LeadDataUncheckedUpdateWithoutResearchInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalFound?: IntFieldUpdateOperationsInput | number
    exportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leads?: LeadUncheckedUpdateManyWithoutLeadDataNestedInput
  }

  export type GoalUpsertWithoutResearchesInput = {
    update: XOR<GoalUpdateWithoutResearchesInput, GoalUncheckedUpdateWithoutResearchesInput>
    create: XOR<GoalCreateWithoutResearchesInput, GoalUncheckedCreateWithoutResearchesInput>
    where?: GoalWhereInput
  }

  export type GoalUpdateToOneWithWhereWithoutResearchesInput = {
    where?: GoalWhereInput
    data: XOR<GoalUpdateWithoutResearchesInput, GoalUncheckedUpdateWithoutResearchesInput>
  }

  export type GoalUpdateWithoutResearchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kpis?: GoalUpdatekpisInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    risks?: GoalUpdaterisksInput | string[]
    strategies?: GoalUpdatestrategiesInput | string[]
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    yearPlan?: YearPlanUpdateOneRequiredWithoutGoalsNestedInput
    keySteps?: KeyStepUpdateManyWithoutGoalNestedInput
    milestones?: MilestoneUpdateManyWithoutGoalNestedInput
    notes?: NoteUpdateManyWithoutGoalNestedInput
    quarterFocuses?: QuarterFocusUpdateManyWithoutGoalNestedInput
    tasks?: TaskUpdateManyWithoutGoalNestedInput
  }

  export type GoalUncheckedUpdateWithoutResearchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    yearPlanId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kpis?: GoalUpdatekpisInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    risks?: GoalUpdaterisksInput | string[]
    strategies?: GoalUpdatestrategiesInput | string[]
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    keySteps?: KeyStepUncheckedUpdateManyWithoutGoalNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutGoalNestedInput
    notes?: NoteUncheckedUpdateManyWithoutGoalNestedInput
    quarterFocuses?: QuarterFocusUncheckedUpdateManyWithoutGoalNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutGoalNestedInput
  }

  export type UserUpsertWithoutResearchesInput = {
    update: XOR<UserUpdateWithoutResearchesInput, UserUncheckedUpdateWithoutResearchesInput>
    create: XOR<UserCreateWithoutResearchesInput, UserUncheckedCreateWithoutResearchesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResearchesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResearchesInput, UserUncheckedUpdateWithoutResearchesInput>
  }

  export type UserUpdateWithoutResearchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    geminiModel?: StringFieldUpdateOperationsInput | string
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    llmProvider?: StringFieldUpdateOperationsInput | string
    serperApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    researchLimit?: IntFieldUpdateOperationsInput | number
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    captures?: CaptureUpdateManyWithoutUserNestedInput
    clients?: ClientUpdateManyWithoutUserNestedInput
    dayPlans?: DayPlanUpdateManyWithoutUserNestedInput
    meetings?: MeetingUpdateManyWithoutUserNestedInput
    notes?: NoteUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    voiceSessions?: VoiceSessionUpdateManyWithoutUserNestedInput
    weekPlans?: WeekPlanUpdateManyWithoutUserNestedInput
    wellBeingEntries?: WellBeingEntryUpdateManyWithoutUserNestedInput
    yearPlans?: YearPlanUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutResearchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    geminiModel?: StringFieldUpdateOperationsInput | string
    groqApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    llmProvider?: StringFieldUpdateOperationsInput | string
    serperApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    researchLimit?: IntFieldUpdateOperationsInput | number
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    captures?: CaptureUncheckedUpdateManyWithoutUserNestedInput
    clients?: ClientUncheckedUpdateManyWithoutUserNestedInput
    dayPlans?: DayPlanUncheckedUpdateManyWithoutUserNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutUserNestedInput
    notes?: NoteUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    voiceSessions?: VoiceSessionUncheckedUpdateManyWithoutUserNestedInput
    weekPlans?: WeekPlanUncheckedUpdateManyWithoutUserNestedInput
    wellBeingEntries?: WellBeingEntryUncheckedUpdateManyWithoutUserNestedInput
    yearPlans?: YearPlanUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ResearchInsightUpsertWithWhereUniqueWithoutResearchInput = {
    where: ResearchInsightWhereUniqueInput
    update: XOR<ResearchInsightUpdateWithoutResearchInput, ResearchInsightUncheckedUpdateWithoutResearchInput>
    create: XOR<ResearchInsightCreateWithoutResearchInput, ResearchInsightUncheckedCreateWithoutResearchInput>
  }

  export type ResearchInsightUpdateWithWhereUniqueWithoutResearchInput = {
    where: ResearchInsightWhereUniqueInput
    data: XOR<ResearchInsightUpdateWithoutResearchInput, ResearchInsightUncheckedUpdateWithoutResearchInput>
  }

  export type ResearchInsightUpdateManyWithWhereWithoutResearchInput = {
    where: ResearchInsightScalarWhereInput
    data: XOR<ResearchInsightUpdateManyMutationInput, ResearchInsightUncheckedUpdateManyWithoutResearchInput>
  }

  export type ResearchInsightScalarWhereInput = {
    AND?: ResearchInsightScalarWhereInput | ResearchInsightScalarWhereInput[]
    OR?: ResearchInsightScalarWhereInput[]
    NOT?: ResearchInsightScalarWhereInput | ResearchInsightScalarWhereInput[]
    id?: StringFilter<"ResearchInsight"> | string
    researchId?: StringFilter<"ResearchInsight"> | string
    title?: StringFilter<"ResearchInsight"> | string
    content?: StringFilter<"ResearchInsight"> | string
    category?: StringFilter<"ResearchInsight"> | string
    visualData?: JsonNullableFilter<"ResearchInsight">
    confidence?: FloatFilter<"ResearchInsight"> | number
    order?: IntFilter<"ResearchInsight"> | number
    createdAt?: DateTimeFilter<"ResearchInsight"> | Date | string
  }

  export type ResearchSourceUpsertWithWhereUniqueWithoutResearchInput = {
    where: ResearchSourceWhereUniqueInput
    update: XOR<ResearchSourceUpdateWithoutResearchInput, ResearchSourceUncheckedUpdateWithoutResearchInput>
    create: XOR<ResearchSourceCreateWithoutResearchInput, ResearchSourceUncheckedCreateWithoutResearchInput>
  }

  export type ResearchSourceUpdateWithWhereUniqueWithoutResearchInput = {
    where: ResearchSourceWhereUniqueInput
    data: XOR<ResearchSourceUpdateWithoutResearchInput, ResearchSourceUncheckedUpdateWithoutResearchInput>
  }

  export type ResearchSourceUpdateManyWithWhereWithoutResearchInput = {
    where: ResearchSourceScalarWhereInput
    data: XOR<ResearchSourceUpdateManyMutationInput, ResearchSourceUncheckedUpdateManyWithoutResearchInput>
  }

  export type ResearchSourceScalarWhereInput = {
    AND?: ResearchSourceScalarWhereInput | ResearchSourceScalarWhereInput[]
    OR?: ResearchSourceScalarWhereInput[]
    NOT?: ResearchSourceScalarWhereInput | ResearchSourceScalarWhereInput[]
    id?: StringFilter<"ResearchSource"> | string
    researchId?: StringFilter<"ResearchSource"> | string
    url?: StringFilter<"ResearchSource"> | string
    title?: StringFilter<"ResearchSource"> | string
    content?: StringFilter<"ResearchSource"> | string
    excerpt?: StringFilter<"ResearchSource"> | string
    credibility?: FloatFilter<"ResearchSource"> | number
    citedInSections?: StringNullableListFilter<"ResearchSource">
    scrapedAt?: DateTimeFilter<"ResearchSource"> | Date | string
  }

  export type ResearchCreateWithoutSourcesInput = {
    id?: string
    title: string
    scope: $Enums.ResearchScope
    searchMethod?: $Enums.SearchMethod
    status?: $Enums.ResearchStatus
    originalPrompt: string
    refinedPrompt: string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    errorMessage?: string | null
    isFavorited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    actionItems?: ActionItemCreateNestedManyWithoutResearchInput
    leadData?: LeadDataCreateNestedOneWithoutResearchInput
    goal?: GoalCreateNestedOneWithoutResearchesInput
    user: UserCreateNestedOneWithoutResearchesInput
    insights?: ResearchInsightCreateNestedManyWithoutResearchInput
  }

  export type ResearchUncheckedCreateWithoutSourcesInput = {
    id?: string
    userId: string
    title: string
    scope: $Enums.ResearchScope
    searchMethod?: $Enums.SearchMethod
    status?: $Enums.ResearchStatus
    originalPrompt: string
    refinedPrompt: string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    errorMessage?: string | null
    goalId?: string | null
    isFavorited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutResearchInput
    leadData?: LeadDataUncheckedCreateNestedOneWithoutResearchInput
    insights?: ResearchInsightUncheckedCreateNestedManyWithoutResearchInput
  }

  export type ResearchCreateOrConnectWithoutSourcesInput = {
    where: ResearchWhereUniqueInput
    create: XOR<ResearchCreateWithoutSourcesInput, ResearchUncheckedCreateWithoutSourcesInput>
  }

  export type ResearchUpsertWithoutSourcesInput = {
    update: XOR<ResearchUpdateWithoutSourcesInput, ResearchUncheckedUpdateWithoutSourcesInput>
    create: XOR<ResearchCreateWithoutSourcesInput, ResearchUncheckedCreateWithoutSourcesInput>
    where?: ResearchWhereInput
  }

  export type ResearchUpdateToOneWithWhereWithoutSourcesInput = {
    where?: ResearchWhereInput
    data: XOR<ResearchUpdateWithoutSourcesInput, ResearchUncheckedUpdateWithoutSourcesInput>
  }

  export type ResearchUpdateWithoutSourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    scope?: EnumResearchScopeFieldUpdateOperationsInput | $Enums.ResearchScope
    searchMethod?: EnumSearchMethodFieldUpdateOperationsInput | $Enums.SearchMethod
    status?: EnumResearchStatusFieldUpdateOperationsInput | $Enums.ResearchStatus
    originalPrompt?: StringFieldUpdateOperationsInput | string
    refinedPrompt?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isFavorited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionItems?: ActionItemUpdateManyWithoutResearchNestedInput
    leadData?: LeadDataUpdateOneWithoutResearchNestedInput
    goal?: GoalUpdateOneWithoutResearchesNestedInput
    user?: UserUpdateOneRequiredWithoutResearchesNestedInput
    insights?: ResearchInsightUpdateManyWithoutResearchNestedInput
  }

  export type ResearchUncheckedUpdateWithoutSourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    scope?: EnumResearchScopeFieldUpdateOperationsInput | $Enums.ResearchScope
    searchMethod?: EnumSearchMethodFieldUpdateOperationsInput | $Enums.SearchMethod
    status?: EnumResearchStatusFieldUpdateOperationsInput | $Enums.ResearchStatus
    originalPrompt?: StringFieldUpdateOperationsInput | string
    refinedPrompt?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    isFavorited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionItems?: ActionItemUncheckedUpdateManyWithoutResearchNestedInput
    leadData?: LeadDataUncheckedUpdateOneWithoutResearchNestedInput
    insights?: ResearchInsightUncheckedUpdateManyWithoutResearchNestedInput
  }

  export type ResearchCreateWithoutInsightsInput = {
    id?: string
    title: string
    scope: $Enums.ResearchScope
    searchMethod?: $Enums.SearchMethod
    status?: $Enums.ResearchStatus
    originalPrompt: string
    refinedPrompt: string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    errorMessage?: string | null
    isFavorited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    actionItems?: ActionItemCreateNestedManyWithoutResearchInput
    leadData?: LeadDataCreateNestedOneWithoutResearchInput
    goal?: GoalCreateNestedOneWithoutResearchesInput
    user: UserCreateNestedOneWithoutResearchesInput
    sources?: ResearchSourceCreateNestedManyWithoutResearchInput
  }

  export type ResearchUncheckedCreateWithoutInsightsInput = {
    id?: string
    userId: string
    title: string
    scope: $Enums.ResearchScope
    searchMethod?: $Enums.SearchMethod
    status?: $Enums.ResearchStatus
    originalPrompt: string
    refinedPrompt: string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    errorMessage?: string | null
    goalId?: string | null
    isFavorited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutResearchInput
    leadData?: LeadDataUncheckedCreateNestedOneWithoutResearchInput
    sources?: ResearchSourceUncheckedCreateNestedManyWithoutResearchInput
  }

  export type ResearchCreateOrConnectWithoutInsightsInput = {
    where: ResearchWhereUniqueInput
    create: XOR<ResearchCreateWithoutInsightsInput, ResearchUncheckedCreateWithoutInsightsInput>
  }

  export type ResearchUpsertWithoutInsightsInput = {
    update: XOR<ResearchUpdateWithoutInsightsInput, ResearchUncheckedUpdateWithoutInsightsInput>
    create: XOR<ResearchCreateWithoutInsightsInput, ResearchUncheckedCreateWithoutInsightsInput>
    where?: ResearchWhereInput
  }

  export type ResearchUpdateToOneWithWhereWithoutInsightsInput = {
    where?: ResearchWhereInput
    data: XOR<ResearchUpdateWithoutInsightsInput, ResearchUncheckedUpdateWithoutInsightsInput>
  }

  export type ResearchUpdateWithoutInsightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    scope?: EnumResearchScopeFieldUpdateOperationsInput | $Enums.ResearchScope
    searchMethod?: EnumSearchMethodFieldUpdateOperationsInput | $Enums.SearchMethod
    status?: EnumResearchStatusFieldUpdateOperationsInput | $Enums.ResearchStatus
    originalPrompt?: StringFieldUpdateOperationsInput | string
    refinedPrompt?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isFavorited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionItems?: ActionItemUpdateManyWithoutResearchNestedInput
    leadData?: LeadDataUpdateOneWithoutResearchNestedInput
    goal?: GoalUpdateOneWithoutResearchesNestedInput
    user?: UserUpdateOneRequiredWithoutResearchesNestedInput
    sources?: ResearchSourceUpdateManyWithoutResearchNestedInput
  }

  export type ResearchUncheckedUpdateWithoutInsightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    scope?: EnumResearchScopeFieldUpdateOperationsInput | $Enums.ResearchScope
    searchMethod?: EnumSearchMethodFieldUpdateOperationsInput | $Enums.SearchMethod
    status?: EnumResearchStatusFieldUpdateOperationsInput | $Enums.ResearchStatus
    originalPrompt?: StringFieldUpdateOperationsInput | string
    refinedPrompt?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    isFavorited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionItems?: ActionItemUncheckedUpdateManyWithoutResearchNestedInput
    leadData?: LeadDataUncheckedUpdateOneWithoutResearchNestedInput
    sources?: ResearchSourceUncheckedUpdateManyWithoutResearchNestedInput
  }

  export type TaskCreateWithoutActionItemInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    estimatedMinutes?: number | null
    actualMinutes?: number
    timerRunning?: boolean
    currentTimerStart?: Date | string | null
    scheduledDate?: Date | string | null
    dueDate?: Date | string | null
    priority: string
    type: string
    tags?: TaskCreatetagsInput | string[]
    parentTaskId?: string | null
    dependsOn?: TaskCreatedependsOnInput | string[]
    blocks?: TaskCreateblocksInput | string[]
    energyRequired?: number | null
    isAdHoc?: boolean
    isRecurring?: boolean
    recurringPattern?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goal?: GoalCreateNestedOneWithoutTasksInput
    keyStep?: KeyStepCreateNestedOneWithoutTasksInput
    meeting?: MeetingCreateNestedOneWithoutTasksInput
    project?: ProjectCreateNestedOneWithoutTasksInput
    user: UserCreateNestedOneWithoutTasksInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutTaskInput
    timeEntries?: TimeEntryCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutActionItemInput = {
    id?: string
    userId: string
    projectId?: string | null
    title: string
    description?: string | null
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    estimatedMinutes?: number | null
    actualMinutes?: number
    timerRunning?: boolean
    currentTimerStart?: Date | string | null
    scheduledDate?: Date | string | null
    dueDate?: Date | string | null
    priority: string
    type: string
    tags?: TaskCreatetagsInput | string[]
    parentTaskId?: string | null
    dependsOn?: TaskCreatedependsOnInput | string[]
    blocks?: TaskCreateblocksInput | string[]
    energyRequired?: number | null
    isAdHoc?: boolean
    isRecurring?: boolean
    recurringPattern?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meetingId?: string | null
    goalId?: string | null
    keyStepId?: string | null
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutTaskInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutActionItemInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutActionItemInput, TaskUncheckedCreateWithoutActionItemInput>
  }

  export type ResearchCreateWithoutActionItemsInput = {
    id?: string
    title: string
    scope: $Enums.ResearchScope
    searchMethod?: $Enums.SearchMethod
    status?: $Enums.ResearchStatus
    originalPrompt: string
    refinedPrompt: string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    errorMessage?: string | null
    isFavorited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    leadData?: LeadDataCreateNestedOneWithoutResearchInput
    goal?: GoalCreateNestedOneWithoutResearchesInput
    user: UserCreateNestedOneWithoutResearchesInput
    insights?: ResearchInsightCreateNestedManyWithoutResearchInput
    sources?: ResearchSourceCreateNestedManyWithoutResearchInput
  }

  export type ResearchUncheckedCreateWithoutActionItemsInput = {
    id?: string
    userId: string
    title: string
    scope: $Enums.ResearchScope
    searchMethod?: $Enums.SearchMethod
    status?: $Enums.ResearchStatus
    originalPrompt: string
    refinedPrompt: string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    errorMessage?: string | null
    goalId?: string | null
    isFavorited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    leadData?: LeadDataUncheckedCreateNestedOneWithoutResearchInput
    insights?: ResearchInsightUncheckedCreateNestedManyWithoutResearchInput
    sources?: ResearchSourceUncheckedCreateNestedManyWithoutResearchInput
  }

  export type ResearchCreateOrConnectWithoutActionItemsInput = {
    where: ResearchWhereUniqueInput
    create: XOR<ResearchCreateWithoutActionItemsInput, ResearchUncheckedCreateWithoutActionItemsInput>
  }

  export type TaskUpsertWithoutActionItemInput = {
    update: XOR<TaskUpdateWithoutActionItemInput, TaskUncheckedUpdateWithoutActionItemInput>
    create: XOR<TaskCreateWithoutActionItemInput, TaskUncheckedCreateWithoutActionItemInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutActionItemInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutActionItemInput, TaskUncheckedUpdateWithoutActionItemInput>
  }

  export type TaskUpdateWithoutActionItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    actualMinutes?: IntFieldUpdateOperationsInput | number
    timerRunning?: BoolFieldUpdateOperationsInput | boolean
    currentTimerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tags?: TaskUpdatetagsInput | string[]
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOn?: TaskUpdatedependsOnInput | string[]
    blocks?: TaskUpdateblocksInput | string[]
    energyRequired?: NullableFloatFieldUpdateOperationsInput | number | null
    isAdHoc?: BoolFieldUpdateOperationsInput | boolean
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goal?: GoalUpdateOneWithoutTasksNestedInput
    keyStep?: KeyStepUpdateOneWithoutTasksNestedInput
    meeting?: MeetingUpdateOneWithoutTasksNestedInput
    project?: ProjectUpdateOneWithoutTasksNestedInput
    user?: UserUpdateOneRequiredWithoutTasksNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutTaskNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutActionItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    actualMinutes?: IntFieldUpdateOperationsInput | number
    timerRunning?: BoolFieldUpdateOperationsInput | boolean
    currentTimerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tags?: TaskUpdatetagsInput | string[]
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOn?: TaskUpdatedependsOnInput | string[]
    blocks?: TaskUpdateblocksInput | string[]
    energyRequired?: NullableFloatFieldUpdateOperationsInput | number | null
    isAdHoc?: BoolFieldUpdateOperationsInput | boolean
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    keyStepId?: NullableStringFieldUpdateOperationsInput | string | null
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutTaskNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type ResearchUpsertWithoutActionItemsInput = {
    update: XOR<ResearchUpdateWithoutActionItemsInput, ResearchUncheckedUpdateWithoutActionItemsInput>
    create: XOR<ResearchCreateWithoutActionItemsInput, ResearchUncheckedCreateWithoutActionItemsInput>
    where?: ResearchWhereInput
  }

  export type ResearchUpdateToOneWithWhereWithoutActionItemsInput = {
    where?: ResearchWhereInput
    data: XOR<ResearchUpdateWithoutActionItemsInput, ResearchUncheckedUpdateWithoutActionItemsInput>
  }

  export type ResearchUpdateWithoutActionItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    scope?: EnumResearchScopeFieldUpdateOperationsInput | $Enums.ResearchScope
    searchMethod?: EnumSearchMethodFieldUpdateOperationsInput | $Enums.SearchMethod
    status?: EnumResearchStatusFieldUpdateOperationsInput | $Enums.ResearchStatus
    originalPrompt?: StringFieldUpdateOperationsInput | string
    refinedPrompt?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isFavorited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leadData?: LeadDataUpdateOneWithoutResearchNestedInput
    goal?: GoalUpdateOneWithoutResearchesNestedInput
    user?: UserUpdateOneRequiredWithoutResearchesNestedInput
    insights?: ResearchInsightUpdateManyWithoutResearchNestedInput
    sources?: ResearchSourceUpdateManyWithoutResearchNestedInput
  }

  export type ResearchUncheckedUpdateWithoutActionItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    scope?: EnumResearchScopeFieldUpdateOperationsInput | $Enums.ResearchScope
    searchMethod?: EnumSearchMethodFieldUpdateOperationsInput | $Enums.SearchMethod
    status?: EnumResearchStatusFieldUpdateOperationsInput | $Enums.ResearchStatus
    originalPrompt?: StringFieldUpdateOperationsInput | string
    refinedPrompt?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    isFavorited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leadData?: LeadDataUncheckedUpdateOneWithoutResearchNestedInput
    insights?: ResearchInsightUncheckedUpdateManyWithoutResearchNestedInput
    sources?: ResearchSourceUncheckedUpdateManyWithoutResearchNestedInput
  }

  export type LeadCreateWithoutLeadDataInput = {
    id?: string
    name: string
    company?: string | null
    email?: string | null
    phone?: string | null
    website?: string | null
    industry?: string | null
    location?: string | null
    painPoints?: LeadCreatepainPointsInput | string[]
    suggestedDM: string
    suggestedEmail: string
    personalization?: NullableJsonNullValueInput | InputJsonValue
    contacted?: boolean
    contactedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type LeadUncheckedCreateWithoutLeadDataInput = {
    id?: string
    name: string
    company?: string | null
    email?: string | null
    phone?: string | null
    website?: string | null
    industry?: string | null
    location?: string | null
    painPoints?: LeadCreatepainPointsInput | string[]
    suggestedDM: string
    suggestedEmail: string
    personalization?: NullableJsonNullValueInput | InputJsonValue
    contacted?: boolean
    contactedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type LeadCreateOrConnectWithoutLeadDataInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutLeadDataInput, LeadUncheckedCreateWithoutLeadDataInput>
  }

  export type LeadCreateManyLeadDataInputEnvelope = {
    data: LeadCreateManyLeadDataInput | LeadCreateManyLeadDataInput[]
    skipDuplicates?: boolean
  }

  export type ResearchCreateWithoutLeadDataInput = {
    id?: string
    title: string
    scope: $Enums.ResearchScope
    searchMethod?: $Enums.SearchMethod
    status?: $Enums.ResearchStatus
    originalPrompt: string
    refinedPrompt: string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    errorMessage?: string | null
    isFavorited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    actionItems?: ActionItemCreateNestedManyWithoutResearchInput
    goal?: GoalCreateNestedOneWithoutResearchesInput
    user: UserCreateNestedOneWithoutResearchesInput
    insights?: ResearchInsightCreateNestedManyWithoutResearchInput
    sources?: ResearchSourceCreateNestedManyWithoutResearchInput
  }

  export type ResearchUncheckedCreateWithoutLeadDataInput = {
    id?: string
    userId: string
    title: string
    scope: $Enums.ResearchScope
    searchMethod?: $Enums.SearchMethod
    status?: $Enums.ResearchStatus
    originalPrompt: string
    refinedPrompt: string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    errorMessage?: string | null
    goalId?: string | null
    isFavorited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutResearchInput
    insights?: ResearchInsightUncheckedCreateNestedManyWithoutResearchInput
    sources?: ResearchSourceUncheckedCreateNestedManyWithoutResearchInput
  }

  export type ResearchCreateOrConnectWithoutLeadDataInput = {
    where: ResearchWhereUniqueInput
    create: XOR<ResearchCreateWithoutLeadDataInput, ResearchUncheckedCreateWithoutLeadDataInput>
  }

  export type LeadUpsertWithWhereUniqueWithoutLeadDataInput = {
    where: LeadWhereUniqueInput
    update: XOR<LeadUpdateWithoutLeadDataInput, LeadUncheckedUpdateWithoutLeadDataInput>
    create: XOR<LeadCreateWithoutLeadDataInput, LeadUncheckedCreateWithoutLeadDataInput>
  }

  export type LeadUpdateWithWhereUniqueWithoutLeadDataInput = {
    where: LeadWhereUniqueInput
    data: XOR<LeadUpdateWithoutLeadDataInput, LeadUncheckedUpdateWithoutLeadDataInput>
  }

  export type LeadUpdateManyWithWhereWithoutLeadDataInput = {
    where: LeadScalarWhereInput
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyWithoutLeadDataInput>
  }

  export type LeadScalarWhereInput = {
    AND?: LeadScalarWhereInput | LeadScalarWhereInput[]
    OR?: LeadScalarWhereInput[]
    NOT?: LeadScalarWhereInput | LeadScalarWhereInput[]
    id?: StringFilter<"Lead"> | string
    leadDataId?: StringFilter<"Lead"> | string
    name?: StringFilter<"Lead"> | string
    company?: StringNullableFilter<"Lead"> | string | null
    email?: StringNullableFilter<"Lead"> | string | null
    phone?: StringNullableFilter<"Lead"> | string | null
    website?: StringNullableFilter<"Lead"> | string | null
    industry?: StringNullableFilter<"Lead"> | string | null
    location?: StringNullableFilter<"Lead"> | string | null
    painPoints?: StringNullableListFilter<"Lead">
    suggestedDM?: StringFilter<"Lead"> | string
    suggestedEmail?: StringFilter<"Lead"> | string
    personalization?: JsonNullableFilter<"Lead">
    contacted?: BoolFilter<"Lead"> | boolean
    contactedAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    createdAt?: DateTimeFilter<"Lead"> | Date | string
  }

  export type ResearchUpsertWithoutLeadDataInput = {
    update: XOR<ResearchUpdateWithoutLeadDataInput, ResearchUncheckedUpdateWithoutLeadDataInput>
    create: XOR<ResearchCreateWithoutLeadDataInput, ResearchUncheckedCreateWithoutLeadDataInput>
    where?: ResearchWhereInput
  }

  export type ResearchUpdateToOneWithWhereWithoutLeadDataInput = {
    where?: ResearchWhereInput
    data: XOR<ResearchUpdateWithoutLeadDataInput, ResearchUncheckedUpdateWithoutLeadDataInput>
  }

  export type ResearchUpdateWithoutLeadDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    scope?: EnumResearchScopeFieldUpdateOperationsInput | $Enums.ResearchScope
    searchMethod?: EnumSearchMethodFieldUpdateOperationsInput | $Enums.SearchMethod
    status?: EnumResearchStatusFieldUpdateOperationsInput | $Enums.ResearchStatus
    originalPrompt?: StringFieldUpdateOperationsInput | string
    refinedPrompt?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isFavorited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionItems?: ActionItemUpdateManyWithoutResearchNestedInput
    goal?: GoalUpdateOneWithoutResearchesNestedInput
    user?: UserUpdateOneRequiredWithoutResearchesNestedInput
    insights?: ResearchInsightUpdateManyWithoutResearchNestedInput
    sources?: ResearchSourceUpdateManyWithoutResearchNestedInput
  }

  export type ResearchUncheckedUpdateWithoutLeadDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    scope?: EnumResearchScopeFieldUpdateOperationsInput | $Enums.ResearchScope
    searchMethod?: EnumSearchMethodFieldUpdateOperationsInput | $Enums.SearchMethod
    status?: EnumResearchStatusFieldUpdateOperationsInput | $Enums.ResearchStatus
    originalPrompt?: StringFieldUpdateOperationsInput | string
    refinedPrompt?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    isFavorited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionItems?: ActionItemUncheckedUpdateManyWithoutResearchNestedInput
    insights?: ResearchInsightUncheckedUpdateManyWithoutResearchNestedInput
    sources?: ResearchSourceUncheckedUpdateManyWithoutResearchNestedInput
  }

  export type LeadDataCreateWithoutLeadsInput = {
    id?: string
    totalFound?: number
    exportedAt?: Date | string | null
    research: ResearchCreateNestedOneWithoutLeadDataInput
  }

  export type LeadDataUncheckedCreateWithoutLeadsInput = {
    id?: string
    researchId: string
    totalFound?: number
    exportedAt?: Date | string | null
  }

  export type LeadDataCreateOrConnectWithoutLeadsInput = {
    where: LeadDataWhereUniqueInput
    create: XOR<LeadDataCreateWithoutLeadsInput, LeadDataUncheckedCreateWithoutLeadsInput>
  }

  export type LeadDataUpsertWithoutLeadsInput = {
    update: XOR<LeadDataUpdateWithoutLeadsInput, LeadDataUncheckedUpdateWithoutLeadsInput>
    create: XOR<LeadDataCreateWithoutLeadsInput, LeadDataUncheckedCreateWithoutLeadsInput>
    where?: LeadDataWhereInput
  }

  export type LeadDataUpdateToOneWithWhereWithoutLeadsInput = {
    where?: LeadDataWhereInput
    data: XOR<LeadDataUpdateWithoutLeadsInput, LeadDataUncheckedUpdateWithoutLeadsInput>
  }

  export type LeadDataUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalFound?: IntFieldUpdateOperationsInput | number
    exportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    research?: ResearchUpdateOneRequiredWithoutLeadDataNestedInput
  }

  export type LeadDataUncheckedUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    researchId?: StringFieldUpdateOperationsInput | string
    totalFound?: IntFieldUpdateOperationsInput | number
    exportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnalyticsEventCreateManyUserInput = {
    id?: string
    eventType: string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: string | null
    createdAt?: Date | string
  }

  export type CalendarEventCreateManyUserInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    allDay?: boolean
    timezone: string
    isRecurring?: boolean
    recurrenceRule?: string | null
    projectId?: string | null
    taskId?: string | null
    clientId?: string | null
    meetingId?: string | null
    type: string
    reminders?: CalendarEventCreateremindersInput | InputJsonValue[]
    color?: string | null
    location?: string | null
    attendees?: CalendarEventCreateattendeesInput | string[]
    externalCalendarId?: string | null
    externalEventId?: string | null
    syncStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CaptureCreateManyUserInput = {
    id?: string
    type: string
    content: string
    transcription?: string | null
    status?: string
    convertedToTaskId?: string | null
    convertedToNoteId?: string | null
    suggestedProject?: string | null
    suggestedDueDate?: Date | string | null
    suggestedPriority?: string | null
    tags?: CaptureCreatetagsInput | string[]
    createdAt?: Date | string
    processedAt?: Date | string | null
  }

  export type ClientCreateManyUserInput = {
    id?: string
    name: string
    companyName?: string | null
    email: string
    phone?: string | null
    primaryContact?: NullableJsonNullValueInput | InputJsonValue
    additionalContacts?: ClientCreateadditionalContactsInput | InputJsonValue[]
    industry?: string | null
    website?: string | null
    timezone?: string | null
    relationshipHealth?: number | null
    lastContactedAt?: Date | string | null
    preferredCommunication?: string | null
    defaultHourlyRate?: number | null
    paymentTerms?: string | null
    outstandingBalance?: number
    notes?: string | null
    tags?: ClientCreatetagsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastInteractionAt?: Date | string | null
  }

  export type DayPlanCreateManyUserInput = {
    id?: string
    weekPlanId: string
    date: Date | string
    topPriorities?: DayPlanCreatetopPrioritiesInput | string[]
    morningEnergy?: number | null
    afternoonEnergy?: number | null
    eveningEnergy?: number | null
    dailyWin?: string | null
    gratitude?: DayPlanCreategratitudeInput | string[]
    tomorrowPrep?: DayPlanCreatetomorrowPrepInput | string[]
    completionRate?: number
  }

  export type MeetingCreateManyUserInput = {
    id?: string
    clientId?: string | null
    projectId?: string | null
    title: string
    description?: string | null
    type?: string
    scheduledAt: Date | string
    duration: number
    timezone?: string
    organizer?: string
    requiredAttendees?: MeetingCreaterequiredAttendeesInput | string[]
    optionalAttendees?: MeetingCreateoptionalAttendeesInput | string[]
    location?: string | null
    meetingLink?: string | null
    agenda?: string | null
    meetingNotes?: string | null
    actionItems?: MeetingCreateactionItemsInput | InputJsonValue[]
    decisions?: MeetingCreatedecisionsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoteCreateManyUserInput = {
    id?: string
    content: string
    goalId?: string | null
    keyStepId?: string | null
    dayPlanId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectCreateManyUserInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    status: string
    clientId?: string | null
    billable?: boolean
    hourlyRate?: number | null
    budgetHours?: number | null
    startDate?: Date | string | null
    deadline?: Date | string | null
    estimatedHours?: number | null
    actualHoursSpent?: number
    completionPercentage?: number
    goalId?: string | null
    parentProjectId?: string | null
    priority: string
    tags?: ProjectCreatetagsInput | string[]
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    archivedAt?: Date | string | null
    icon?: string | null
  }

  export type ResearchCreateManyUserInput = {
    id?: string
    title: string
    scope: $Enums.ResearchScope
    searchMethod?: $Enums.SearchMethod
    status?: $Enums.ResearchStatus
    originalPrompt: string
    refinedPrompt: string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    errorMessage?: string | null
    goalId?: string | null
    isFavorited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type TaskCreateManyUserInput = {
    id?: string
    projectId?: string | null
    title: string
    description?: string | null
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    estimatedMinutes?: number | null
    actualMinutes?: number
    timerRunning?: boolean
    currentTimerStart?: Date | string | null
    scheduledDate?: Date | string | null
    dueDate?: Date | string | null
    priority: string
    type: string
    tags?: TaskCreatetagsInput | string[]
    parentTaskId?: string | null
    dependsOn?: TaskCreatedependsOnInput | string[]
    blocks?: TaskCreateblocksInput | string[]
    energyRequired?: number | null
    isAdHoc?: boolean
    isRecurring?: boolean
    recurringPattern?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meetingId?: string | null
    goalId?: string | null
    keyStepId?: string | null
  }

  export type TimeEntryCreateManyUserInput = {
    id?: string
    taskId?: string | null
    projectId?: string | null
    clientId?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    duration: number
    type: string
    description?: string | null
    tags?: TimeEntryCreatetagsInput | string[]
    focusQuality?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    distractions?: number
    billable?: boolean
    hourlyRate?: number | null
    amount?: number
    invoiced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoiceSessionCreateManyUserInput = {
    id?: string
    title: string
    duration: number
    recordedAt: Date | string
    audioFileUrl: string
    waveformData?: NullableJsonNullValueInput | InputJsonValue
    transcription?: string | null
    speakers?: VoiceSessionCreatespeakersInput | InputJsonValue[]
    timestamps?: VoiceSessionCreatetimestampsInput | InputJsonValue[]
    summary?: string | null
    keyPoints?: VoiceSessionCreatekeyPointsInput | string[]
    actionItems?: VoiceSessionCreateactionItemsInput | InputJsonValue[]
    projectId?: string | null
    tags?: VoiceSessionCreatetagsInput | string[]
    processed?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type WeekPlanCreateManyUserInput = {
    id?: string
    monthPlanId: string
    weekNumber: number
    year: number
    startDate: Date | string
    endDate: Date | string
    topOutcomes?: WeekPlanCreatetopOutcomesInput | string[]
    plannedClientHours?: number | null
    plannedPersonalHours?: number | null
    challenges?: WeekPlanCreatechallengesInput | string[]
    keyWins?: WeekPlanCreatekeyWinsInput | string[]
    lessonsLearned?: WeekPlanCreatelessonsLearnedInput | string[]
    rating?: number | null
    reviewNotes?: string | null
  }

  export type WellBeingEntryCreateManyUserInput = {
    id?: string
    date: Date | string
    morningEnergy?: number | null
    afternoonEnergy?: number | null
    eveningEnergy?: number | null
    averageEnergy?: number | null
    exerciseMinutes?: number
    exerciseType?: string | null
    readingMinutes?: number
    learningMinutes?: number
    meditationMinutes?: number
    sleepHours?: number | null
    sleepQuality?: number | null
    morningJournal?: string | null
    eveningReflection?: string | null
    gratitude?: WellBeingEntryCreategratitudeInput | string[]
    dailyWin?: string | null
    mood?: number | null
    stressLevel?: number | null
    focusQuality?: number | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type YearPlanCreateManyUserInput = {
    id?: string
    year: number
    theme: string
    vision: string
    focusAreas?: YearPlanCreatefocusAreasInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
  }

  export type AnalyticsEventUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    allDay?: BoolFieldUpdateOperationsInput | boolean
    timezone?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    reminders?: CalendarEventUpdateremindersInput | InputJsonValue[]
    color?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attendees?: CalendarEventUpdateattendeesInput | string[]
    externalCalendarId?: NullableStringFieldUpdateOperationsInput | string | null
    externalEventId?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    allDay?: BoolFieldUpdateOperationsInput | boolean
    timezone?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    reminders?: CalendarEventUpdateremindersInput | InputJsonValue[]
    color?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attendees?: CalendarEventUpdateattendeesInput | string[]
    externalCalendarId?: NullableStringFieldUpdateOperationsInput | string | null
    externalEventId?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    allDay?: BoolFieldUpdateOperationsInput | boolean
    timezone?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    reminders?: CalendarEventUpdateremindersInput | InputJsonValue[]
    color?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attendees?: CalendarEventUpdateattendeesInput | string[]
    externalCalendarId?: NullableStringFieldUpdateOperationsInput | string | null
    externalEventId?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaptureUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    convertedToTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    convertedToNoteId?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedProject?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suggestedPriority?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CaptureUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CaptureUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    convertedToTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    convertedToNoteId?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedProject?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suggestedPriority?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CaptureUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CaptureUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    convertedToTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    convertedToNoteId?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedProject?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suggestedPriority?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CaptureUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClientUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContact?: NullableJsonNullValueInput | InputJsonValue
    additionalContacts?: ClientUpdateadditionalContactsInput | InputJsonValue[]
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipHealth?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredCommunication?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    outstandingBalance?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ClientUpdatetagsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastInteractionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communications?: CommunicationUpdateManyWithoutClientNestedInput
    meetings?: MeetingUpdateManyWithoutClientNestedInput
    projects?: ProjectUpdateManyWithoutClientNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutClientNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContact?: NullableJsonNullValueInput | InputJsonValue
    additionalContacts?: ClientUpdateadditionalContactsInput | InputJsonValue[]
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipHealth?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredCommunication?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    outstandingBalance?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ClientUpdatetagsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastInteractionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communications?: CommunicationUncheckedUpdateManyWithoutClientNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutClientNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutClientNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContact?: NullableJsonNullValueInput | InputJsonValue
    additionalContacts?: ClientUpdateadditionalContactsInput | InputJsonValue[]
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipHealth?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredCommunication?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    outstandingBalance?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ClientUpdatetagsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastInteractionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DayPlanUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topPriorities?: DayPlanUpdatetopPrioritiesInput | string[]
    morningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    afternoonEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    eveningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyWin?: NullableStringFieldUpdateOperationsInput | string | null
    gratitude?: DayPlanUpdategratitudeInput | string[]
    tomorrowPrep?: DayPlanUpdatetomorrowPrepInput | string[]
    completionRate?: FloatFieldUpdateOperationsInput | number
    dayFocuses?: DayFocusUpdateManyWithoutDayPlanNestedInput
    weekPlan?: WeekPlanUpdateOneRequiredWithoutDayPlansNestedInput
    notes?: NoteUpdateManyWithoutDayPlanNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutDayPlanNestedInput
  }

  export type DayPlanUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekPlanId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topPriorities?: DayPlanUpdatetopPrioritiesInput | string[]
    morningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    afternoonEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    eveningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyWin?: NullableStringFieldUpdateOperationsInput | string | null
    gratitude?: DayPlanUpdategratitudeInput | string[]
    tomorrowPrep?: DayPlanUpdatetomorrowPrepInput | string[]
    completionRate?: FloatFieldUpdateOperationsInput | number
    dayFocuses?: DayFocusUncheckedUpdateManyWithoutDayPlanNestedInput
    notes?: NoteUncheckedUpdateManyWithoutDayPlanNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutDayPlanNestedInput
  }

  export type DayPlanUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekPlanId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topPriorities?: DayPlanUpdatetopPrioritiesInput | string[]
    morningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    afternoonEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    eveningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyWin?: NullableStringFieldUpdateOperationsInput | string | null
    gratitude?: DayPlanUpdategratitudeInput | string[]
    tomorrowPrep?: DayPlanUpdatetomorrowPrepInput | string[]
    completionRate?: FloatFieldUpdateOperationsInput | number
  }

  export type MeetingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    organizer?: StringFieldUpdateOperationsInput | string
    requiredAttendees?: MeetingUpdaterequiredAttendeesInput | string[]
    optionalAttendees?: MeetingUpdateoptionalAttendeesInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    meetingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    actionItems?: MeetingUpdateactionItemsInput | InputJsonValue[]
    decisions?: MeetingUpdatedecisionsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutMeetingsNestedInput
    tasks?: TaskUpdateManyWithoutMeetingNestedInput
  }

  export type MeetingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    organizer?: StringFieldUpdateOperationsInput | string
    requiredAttendees?: MeetingUpdaterequiredAttendeesInput | string[]
    optionalAttendees?: MeetingUpdateoptionalAttendeesInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    meetingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    actionItems?: MeetingUpdateactionItemsInput | InputJsonValue[]
    decisions?: MeetingUpdatedecisionsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutMeetingNestedInput
  }

  export type MeetingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    organizer?: StringFieldUpdateOperationsInput | string
    requiredAttendees?: MeetingUpdaterequiredAttendeesInput | string[]
    optionalAttendees?: MeetingUpdateoptionalAttendeesInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    meetingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    actionItems?: MeetingUpdateactionItemsInput | InputJsonValue[]
    decisions?: MeetingUpdatedecisionsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayPlan?: DayPlanUpdateOneWithoutNotesNestedInput
    goal?: GoalUpdateOneWithoutNotesNestedInput
    keyStep?: KeyStepUpdateOneWithoutNotesNestedInput
  }

  export type NoteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    keyStepId?: NullableStringFieldUpdateOperationsInput | string | null
    dayPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    keyStepId?: NullableStringFieldUpdateOperationsInput | string | null
    dayPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    billable?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetHours?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHoursSpent?: FloatFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    parentProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    tags?: ProjectUpdatetagsInput | string[]
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneWithoutProjectsNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutProjectNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    billable?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetHours?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHoursSpent?: FloatFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    parentProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    tags?: ProjectUpdatetagsInput | string[]
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutProjectNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    billable?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetHours?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHoursSpent?: FloatFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    parentProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    tags?: ProjectUpdatetagsInput | string[]
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResearchUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    scope?: EnumResearchScopeFieldUpdateOperationsInput | $Enums.ResearchScope
    searchMethod?: EnumSearchMethodFieldUpdateOperationsInput | $Enums.SearchMethod
    status?: EnumResearchStatusFieldUpdateOperationsInput | $Enums.ResearchStatus
    originalPrompt?: StringFieldUpdateOperationsInput | string
    refinedPrompt?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isFavorited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionItems?: ActionItemUpdateManyWithoutResearchNestedInput
    leadData?: LeadDataUpdateOneWithoutResearchNestedInput
    goal?: GoalUpdateOneWithoutResearchesNestedInput
    insights?: ResearchInsightUpdateManyWithoutResearchNestedInput
    sources?: ResearchSourceUpdateManyWithoutResearchNestedInput
  }

  export type ResearchUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    scope?: EnumResearchScopeFieldUpdateOperationsInput | $Enums.ResearchScope
    searchMethod?: EnumSearchMethodFieldUpdateOperationsInput | $Enums.SearchMethod
    status?: EnumResearchStatusFieldUpdateOperationsInput | $Enums.ResearchStatus
    originalPrompt?: StringFieldUpdateOperationsInput | string
    refinedPrompt?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    isFavorited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionItems?: ActionItemUncheckedUpdateManyWithoutResearchNestedInput
    leadData?: LeadDataUncheckedUpdateOneWithoutResearchNestedInput
    insights?: ResearchInsightUncheckedUpdateManyWithoutResearchNestedInput
    sources?: ResearchSourceUncheckedUpdateManyWithoutResearchNestedInput
  }

  export type ResearchUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    scope?: EnumResearchScopeFieldUpdateOperationsInput | $Enums.ResearchScope
    searchMethod?: EnumSearchMethodFieldUpdateOperationsInput | $Enums.SearchMethod
    status?: EnumResearchStatusFieldUpdateOperationsInput | $Enums.ResearchStatus
    originalPrompt?: StringFieldUpdateOperationsInput | string
    refinedPrompt?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    isFavorited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    actualMinutes?: IntFieldUpdateOperationsInput | number
    timerRunning?: BoolFieldUpdateOperationsInput | boolean
    currentTimerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tags?: TaskUpdatetagsInput | string[]
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOn?: TaskUpdatedependsOnInput | string[]
    blocks?: TaskUpdateblocksInput | string[]
    energyRequired?: NullableFloatFieldUpdateOperationsInput | number | null
    isAdHoc?: BoolFieldUpdateOperationsInput | boolean
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionItem?: ActionItemUpdateOneWithoutConvertedToTaskNestedInput
    goal?: GoalUpdateOneWithoutTasksNestedInput
    keyStep?: KeyStepUpdateOneWithoutTasksNestedInput
    meeting?: MeetingUpdateOneWithoutTasksNestedInput
    project?: ProjectUpdateOneWithoutTasksNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutTaskNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    actualMinutes?: IntFieldUpdateOperationsInput | number
    timerRunning?: BoolFieldUpdateOperationsInput | boolean
    currentTimerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tags?: TaskUpdatetagsInput | string[]
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOn?: TaskUpdatedependsOnInput | string[]
    blocks?: TaskUpdateblocksInput | string[]
    energyRequired?: NullableFloatFieldUpdateOperationsInput | number | null
    isAdHoc?: BoolFieldUpdateOperationsInput | boolean
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    keyStepId?: NullableStringFieldUpdateOperationsInput | string | null
    actionItem?: ActionItemUncheckedUpdateOneWithoutConvertedToTaskNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutTaskNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    actualMinutes?: IntFieldUpdateOperationsInput | number
    timerRunning?: BoolFieldUpdateOperationsInput | boolean
    currentTimerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tags?: TaskUpdatetagsInput | string[]
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOn?: TaskUpdatedependsOnInput | string[]
    blocks?: TaskUpdateblocksInput | string[]
    energyRequired?: NullableFloatFieldUpdateOperationsInput | number | null
    isAdHoc?: BoolFieldUpdateOperationsInput | boolean
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    keyStepId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimeEntryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TimeEntryUpdatetagsInput | string[]
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    energyBefore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    distractions?: IntFieldUpdateOperationsInput | number
    billable?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    invoiced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutTimeEntriesNestedInput
    project?: ProjectUpdateOneWithoutTimeEntriesNestedInput
    task?: TaskUpdateOneWithoutTimeEntriesNestedInput
  }

  export type TimeEntryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TimeEntryUpdatetagsInput | string[]
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    energyBefore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    distractions?: IntFieldUpdateOperationsInput | number
    billable?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    invoiced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeEntryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TimeEntryUpdatetagsInput | string[]
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    energyBefore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    distractions?: IntFieldUpdateOperationsInput | number
    billable?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    invoiced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoiceSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audioFileUrl?: StringFieldUpdateOperationsInput | string
    waveformData?: NullableJsonNullValueInput | InputJsonValue
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    speakers?: VoiceSessionUpdatespeakersInput | InputJsonValue[]
    timestamps?: VoiceSessionUpdatetimestampsInput | InputJsonValue[]
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyPoints?: VoiceSessionUpdatekeyPointsInput | string[]
    actionItems?: VoiceSessionUpdateactionItemsInput | InputJsonValue[]
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: VoiceSessionUpdatetagsInput | string[]
    processed?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoiceSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audioFileUrl?: StringFieldUpdateOperationsInput | string
    waveformData?: NullableJsonNullValueInput | InputJsonValue
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    speakers?: VoiceSessionUpdatespeakersInput | InputJsonValue[]
    timestamps?: VoiceSessionUpdatetimestampsInput | InputJsonValue[]
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyPoints?: VoiceSessionUpdatekeyPointsInput | string[]
    actionItems?: VoiceSessionUpdateactionItemsInput | InputJsonValue[]
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: VoiceSessionUpdatetagsInput | string[]
    processed?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoiceSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audioFileUrl?: StringFieldUpdateOperationsInput | string
    waveformData?: NullableJsonNullValueInput | InputJsonValue
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    speakers?: VoiceSessionUpdatespeakersInput | InputJsonValue[]
    timestamps?: VoiceSessionUpdatetimestampsInput | InputJsonValue[]
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyPoints?: VoiceSessionUpdatekeyPointsInput | string[]
    actionItems?: VoiceSessionUpdateactionItemsInput | InputJsonValue[]
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: VoiceSessionUpdatetagsInput | string[]
    processed?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeekPlanUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    topOutcomes?: WeekPlanUpdatetopOutcomesInput | string[]
    plannedClientHours?: NullableFloatFieldUpdateOperationsInput | number | null
    plannedPersonalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    challenges?: WeekPlanUpdatechallengesInput | string[]
    keyWins?: WeekPlanUpdatekeyWinsInput | string[]
    lessonsLearned?: WeekPlanUpdatelessonsLearnedInput | string[]
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dayPlans?: DayPlanUpdateManyWithoutWeekPlanNestedInput
    weekFocuses?: WeekFocusUpdateManyWithoutWeekPlanNestedInput
    monthPlan?: MonthPlanUpdateOneRequiredWithoutWeekPlansNestedInput
  }

  export type WeekPlanUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthPlanId?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    topOutcomes?: WeekPlanUpdatetopOutcomesInput | string[]
    plannedClientHours?: NullableFloatFieldUpdateOperationsInput | number | null
    plannedPersonalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    challenges?: WeekPlanUpdatechallengesInput | string[]
    keyWins?: WeekPlanUpdatekeyWinsInput | string[]
    lessonsLearned?: WeekPlanUpdatelessonsLearnedInput | string[]
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dayPlans?: DayPlanUncheckedUpdateManyWithoutWeekPlanNestedInput
    weekFocuses?: WeekFocusUncheckedUpdateManyWithoutWeekPlanNestedInput
  }

  export type WeekPlanUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthPlanId?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    topOutcomes?: WeekPlanUpdatetopOutcomesInput | string[]
    plannedClientHours?: NullableFloatFieldUpdateOperationsInput | number | null
    plannedPersonalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    challenges?: WeekPlanUpdatechallengesInput | string[]
    keyWins?: WeekPlanUpdatekeyWinsInput | string[]
    lessonsLearned?: WeekPlanUpdatelessonsLearnedInput | string[]
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WellBeingEntryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    morningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    afternoonEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    eveningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    averageEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    exerciseMinutes?: IntFieldUpdateOperationsInput | number
    exerciseType?: NullableStringFieldUpdateOperationsInput | string | null
    readingMinutes?: IntFieldUpdateOperationsInput | number
    learningMinutes?: IntFieldUpdateOperationsInput | number
    meditationMinutes?: IntFieldUpdateOperationsInput | number
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    sleepQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    morningJournal?: NullableStringFieldUpdateOperationsInput | string | null
    eveningReflection?: NullableStringFieldUpdateOperationsInput | string | null
    gratitude?: WellBeingEntryUpdategratitudeInput | string[]
    dailyWin?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: NullableFloatFieldUpdateOperationsInput | number | null
    stressLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WellBeingEntryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    morningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    afternoonEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    eveningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    averageEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    exerciseMinutes?: IntFieldUpdateOperationsInput | number
    exerciseType?: NullableStringFieldUpdateOperationsInput | string | null
    readingMinutes?: IntFieldUpdateOperationsInput | number
    learningMinutes?: IntFieldUpdateOperationsInput | number
    meditationMinutes?: IntFieldUpdateOperationsInput | number
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    sleepQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    morningJournal?: NullableStringFieldUpdateOperationsInput | string | null
    eveningReflection?: NullableStringFieldUpdateOperationsInput | string | null
    gratitude?: WellBeingEntryUpdategratitudeInput | string[]
    dailyWin?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: NullableFloatFieldUpdateOperationsInput | number | null
    stressLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WellBeingEntryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    morningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    afternoonEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    eveningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    averageEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    exerciseMinutes?: IntFieldUpdateOperationsInput | number
    exerciseType?: NullableStringFieldUpdateOperationsInput | string | null
    readingMinutes?: IntFieldUpdateOperationsInput | number
    learningMinutes?: IntFieldUpdateOperationsInput | number
    meditationMinutes?: IntFieldUpdateOperationsInput | number
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    sleepQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    morningJournal?: NullableStringFieldUpdateOperationsInput | string | null
    eveningReflection?: NullableStringFieldUpdateOperationsInput | string | null
    gratitude?: WellBeingEntryUpdategratitudeInput | string[]
    dailyWin?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: NullableFloatFieldUpdateOperationsInput | number | null
    stressLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YearPlanUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    theme?: StringFieldUpdateOperationsInput | string
    vision?: StringFieldUpdateOperationsInput | string
    focusAreas?: YearPlanUpdatefocusAreasInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    goals?: GoalUpdateManyWithoutYearPlanNestedInput
    quarterPlans?: QuarterPlanUpdateManyWithoutYearPlanNestedInput
  }

  export type YearPlanUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    theme?: StringFieldUpdateOperationsInput | string
    vision?: StringFieldUpdateOperationsInput | string
    focusAreas?: YearPlanUpdatefocusAreasInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    goals?: GoalUncheckedUpdateManyWithoutYearPlanNestedInput
    quarterPlans?: QuarterPlanUncheckedUpdateManyWithoutYearPlanNestedInput
  }

  export type YearPlanUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    theme?: StringFieldUpdateOperationsInput | string
    vision?: StringFieldUpdateOperationsInput | string
    focusAreas?: YearPlanUpdatefocusAreasInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type GoalCreateManyYearPlanInput = {
    id?: string
    title: string
    description?: string | null
    category: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    kpis?: GoalCreatekpisInput | string[]
    priority?: string
    progress?: number
    risks?: GoalCreaterisksInput | string[]
    strategies?: GoalCreatestrategiesInput | string[]
    targetDate?: Date | string | null
  }

  export type QuarterPlanCreateManyYearPlanInput = {
    id?: string
    quarter: number
    theme: string
    startDate: Date | string
    endDate: Date | string
  }

  export type GoalUpdateWithoutYearPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kpis?: GoalUpdatekpisInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    risks?: GoalUpdaterisksInput | string[]
    strategies?: GoalUpdatestrategiesInput | string[]
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    keySteps?: KeyStepUpdateManyWithoutGoalNestedInput
    milestones?: MilestoneUpdateManyWithoutGoalNestedInput
    notes?: NoteUpdateManyWithoutGoalNestedInput
    quarterFocuses?: QuarterFocusUpdateManyWithoutGoalNestedInput
    researches?: ResearchUpdateManyWithoutGoalNestedInput
    tasks?: TaskUpdateManyWithoutGoalNestedInput
  }

  export type GoalUncheckedUpdateWithoutYearPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kpis?: GoalUpdatekpisInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    risks?: GoalUpdaterisksInput | string[]
    strategies?: GoalUpdatestrategiesInput | string[]
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    keySteps?: KeyStepUncheckedUpdateManyWithoutGoalNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutGoalNestedInput
    notes?: NoteUncheckedUpdateManyWithoutGoalNestedInput
    quarterFocuses?: QuarterFocusUncheckedUpdateManyWithoutGoalNestedInput
    researches?: ResearchUncheckedUpdateManyWithoutGoalNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutGoalNestedInput
  }

  export type GoalUncheckedUpdateManyWithoutYearPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kpis?: GoalUpdatekpisInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    risks?: GoalUpdaterisksInput | string[]
    strategies?: GoalUpdatestrategiesInput | string[]
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuarterPlanUpdateWithoutYearPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    quarter?: IntFieldUpdateOperationsInput | number
    theme?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    monthPlans?: MonthPlanUpdateManyWithoutQuarterPlanNestedInput
    quarterFocuses?: QuarterFocusUpdateManyWithoutQuarterPlanNestedInput
    objectives?: QuarterObjectiveUpdateManyWithoutQuarterPlanNestedInput
  }

  export type QuarterPlanUncheckedUpdateWithoutYearPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    quarter?: IntFieldUpdateOperationsInput | number
    theme?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    monthPlans?: MonthPlanUncheckedUpdateManyWithoutQuarterPlanNestedInput
    quarterFocuses?: QuarterFocusUncheckedUpdateManyWithoutQuarterPlanNestedInput
    objectives?: QuarterObjectiveUncheckedUpdateManyWithoutQuarterPlanNestedInput
  }

  export type QuarterPlanUncheckedUpdateManyWithoutYearPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    quarter?: IntFieldUpdateOperationsInput | number
    theme?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeyStepCreateManyGoalInput = {
    id?: string
    title: string
    description?: string | null
    order?: number
    completed?: boolean
    completedAt?: Date | string | null
    progress?: number
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MilestoneCreateManyGoalInput = {
    id?: string
    title: string
    targetDate?: Date | string | null
    completed?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NoteCreateManyGoalInput = {
    id?: string
    userId: string
    content: string
    keyStepId?: string | null
    dayPlanId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuarterFocusCreateManyGoalInput = {
    id?: string
    quarterPlanId: string
    priority?: number
    progress?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResearchCreateManyGoalInput = {
    id?: string
    userId: string
    title: string
    scope: $Enums.ResearchScope
    searchMethod?: $Enums.SearchMethod
    status?: $Enums.ResearchStatus
    originalPrompt: string
    refinedPrompt: string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    errorMessage?: string | null
    isFavorited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type TaskCreateManyGoalInput = {
    id?: string
    userId: string
    projectId?: string | null
    title: string
    description?: string | null
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    estimatedMinutes?: number | null
    actualMinutes?: number
    timerRunning?: boolean
    currentTimerStart?: Date | string | null
    scheduledDate?: Date | string | null
    dueDate?: Date | string | null
    priority: string
    type: string
    tags?: TaskCreatetagsInput | string[]
    parentTaskId?: string | null
    dependsOn?: TaskCreatedependsOnInput | string[]
    blocks?: TaskCreateblocksInput | string[]
    energyRequired?: number | null
    isAdHoc?: boolean
    isRecurring?: boolean
    recurringPattern?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meetingId?: string | null
    keyStepId?: string | null
  }

  export type KeyStepUpdateWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NoteUpdateManyWithoutKeyStepNestedInput
    tasks?: TaskUpdateManyWithoutKeyStepNestedInput
  }

  export type KeyStepUncheckedUpdateWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NoteUncheckedUpdateManyWithoutKeyStepNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutKeyStepNestedInput
  }

  export type KeyStepUncheckedUpdateManyWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneUpdateWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneUncheckedUpdateWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneUncheckedUpdateManyWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUpdateWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayPlan?: DayPlanUpdateOneWithoutNotesNestedInput
    keyStep?: KeyStepUpdateOneWithoutNotesNestedInput
    user?: UserUpdateOneRequiredWithoutNotesNestedInput
  }

  export type NoteUncheckedUpdateWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    keyStepId?: NullableStringFieldUpdateOperationsInput | string | null
    dayPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUncheckedUpdateManyWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    keyStepId?: NullableStringFieldUpdateOperationsInput | string | null
    dayPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuarterFocusUpdateWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monthFocuses?: MonthFocusUpdateManyWithoutQuarterFocusNestedInput
    quarterPlan?: QuarterPlanUpdateOneRequiredWithoutQuarterFocusesNestedInput
  }

  export type QuarterFocusUncheckedUpdateWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    quarterPlanId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monthFocuses?: MonthFocusUncheckedUpdateManyWithoutQuarterFocusNestedInput
  }

  export type QuarterFocusUncheckedUpdateManyWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    quarterPlanId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchUpdateWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    scope?: EnumResearchScopeFieldUpdateOperationsInput | $Enums.ResearchScope
    searchMethod?: EnumSearchMethodFieldUpdateOperationsInput | $Enums.SearchMethod
    status?: EnumResearchStatusFieldUpdateOperationsInput | $Enums.ResearchStatus
    originalPrompt?: StringFieldUpdateOperationsInput | string
    refinedPrompt?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isFavorited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionItems?: ActionItemUpdateManyWithoutResearchNestedInput
    leadData?: LeadDataUpdateOneWithoutResearchNestedInput
    user?: UserUpdateOneRequiredWithoutResearchesNestedInput
    insights?: ResearchInsightUpdateManyWithoutResearchNestedInput
    sources?: ResearchSourceUpdateManyWithoutResearchNestedInput
  }

  export type ResearchUncheckedUpdateWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    scope?: EnumResearchScopeFieldUpdateOperationsInput | $Enums.ResearchScope
    searchMethod?: EnumSearchMethodFieldUpdateOperationsInput | $Enums.SearchMethod
    status?: EnumResearchStatusFieldUpdateOperationsInput | $Enums.ResearchStatus
    originalPrompt?: StringFieldUpdateOperationsInput | string
    refinedPrompt?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isFavorited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionItems?: ActionItemUncheckedUpdateManyWithoutResearchNestedInput
    leadData?: LeadDataUncheckedUpdateOneWithoutResearchNestedInput
    insights?: ResearchInsightUncheckedUpdateManyWithoutResearchNestedInput
    sources?: ResearchSourceUncheckedUpdateManyWithoutResearchNestedInput
  }

  export type ResearchUncheckedUpdateManyWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    scope?: EnumResearchScopeFieldUpdateOperationsInput | $Enums.ResearchScope
    searchMethod?: EnumSearchMethodFieldUpdateOperationsInput | $Enums.SearchMethod
    status?: EnumResearchStatusFieldUpdateOperationsInput | $Enums.ResearchStatus
    originalPrompt?: StringFieldUpdateOperationsInput | string
    refinedPrompt?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    progress?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isFavorited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskUpdateWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    actualMinutes?: IntFieldUpdateOperationsInput | number
    timerRunning?: BoolFieldUpdateOperationsInput | boolean
    currentTimerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tags?: TaskUpdatetagsInput | string[]
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOn?: TaskUpdatedependsOnInput | string[]
    blocks?: TaskUpdateblocksInput | string[]
    energyRequired?: NullableFloatFieldUpdateOperationsInput | number | null
    isAdHoc?: BoolFieldUpdateOperationsInput | boolean
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionItem?: ActionItemUpdateOneWithoutConvertedToTaskNestedInput
    keyStep?: KeyStepUpdateOneWithoutTasksNestedInput
    meeting?: MeetingUpdateOneWithoutTasksNestedInput
    project?: ProjectUpdateOneWithoutTasksNestedInput
    user?: UserUpdateOneRequiredWithoutTasksNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutTaskNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    actualMinutes?: IntFieldUpdateOperationsInput | number
    timerRunning?: BoolFieldUpdateOperationsInput | boolean
    currentTimerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tags?: TaskUpdatetagsInput | string[]
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOn?: TaskUpdatedependsOnInput | string[]
    blocks?: TaskUpdateblocksInput | string[]
    energyRequired?: NullableFloatFieldUpdateOperationsInput | number | null
    isAdHoc?: BoolFieldUpdateOperationsInput | boolean
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    keyStepId?: NullableStringFieldUpdateOperationsInput | string | null
    actionItem?: ActionItemUncheckedUpdateOneWithoutConvertedToTaskNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutTaskNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    actualMinutes?: IntFieldUpdateOperationsInput | number
    timerRunning?: BoolFieldUpdateOperationsInput | boolean
    currentTimerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tags?: TaskUpdatetagsInput | string[]
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOn?: TaskUpdatedependsOnInput | string[]
    blocks?: TaskUpdateblocksInput | string[]
    energyRequired?: NullableFloatFieldUpdateOperationsInput | number | null
    isAdHoc?: BoolFieldUpdateOperationsInput | boolean
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    keyStepId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NoteCreateManyKeyStepInput = {
    id?: string
    userId: string
    content: string
    goalId?: string | null
    dayPlanId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateManyKeyStepInput = {
    id?: string
    userId: string
    projectId?: string | null
    title: string
    description?: string | null
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    estimatedMinutes?: number | null
    actualMinutes?: number
    timerRunning?: boolean
    currentTimerStart?: Date | string | null
    scheduledDate?: Date | string | null
    dueDate?: Date | string | null
    priority: string
    type: string
    tags?: TaskCreatetagsInput | string[]
    parentTaskId?: string | null
    dependsOn?: TaskCreatedependsOnInput | string[]
    blocks?: TaskCreateblocksInput | string[]
    energyRequired?: number | null
    isAdHoc?: boolean
    isRecurring?: boolean
    recurringPattern?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meetingId?: string | null
    goalId?: string | null
  }

  export type NoteUpdateWithoutKeyStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayPlan?: DayPlanUpdateOneWithoutNotesNestedInput
    goal?: GoalUpdateOneWithoutNotesNestedInput
    user?: UserUpdateOneRequiredWithoutNotesNestedInput
  }

  export type NoteUncheckedUpdateWithoutKeyStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    dayPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUncheckedUpdateManyWithoutKeyStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    dayPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutKeyStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    actualMinutes?: IntFieldUpdateOperationsInput | number
    timerRunning?: BoolFieldUpdateOperationsInput | boolean
    currentTimerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tags?: TaskUpdatetagsInput | string[]
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOn?: TaskUpdatedependsOnInput | string[]
    blocks?: TaskUpdateblocksInput | string[]
    energyRequired?: NullableFloatFieldUpdateOperationsInput | number | null
    isAdHoc?: BoolFieldUpdateOperationsInput | boolean
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionItem?: ActionItemUpdateOneWithoutConvertedToTaskNestedInput
    goal?: GoalUpdateOneWithoutTasksNestedInput
    meeting?: MeetingUpdateOneWithoutTasksNestedInput
    project?: ProjectUpdateOneWithoutTasksNestedInput
    user?: UserUpdateOneRequiredWithoutTasksNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutTaskNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutKeyStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    actualMinutes?: IntFieldUpdateOperationsInput | number
    timerRunning?: BoolFieldUpdateOperationsInput | boolean
    currentTimerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tags?: TaskUpdatetagsInput | string[]
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOn?: TaskUpdatedependsOnInput | string[]
    blocks?: TaskUpdateblocksInput | string[]
    energyRequired?: NullableFloatFieldUpdateOperationsInput | number | null
    isAdHoc?: BoolFieldUpdateOperationsInput | boolean
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    actionItem?: ActionItemUncheckedUpdateOneWithoutConvertedToTaskNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutTaskNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutKeyStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    actualMinutes?: IntFieldUpdateOperationsInput | number
    timerRunning?: BoolFieldUpdateOperationsInput | boolean
    currentTimerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tags?: TaskUpdatetagsInput | string[]
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOn?: TaskUpdatedependsOnInput | string[]
    blocks?: TaskUpdateblocksInput | string[]
    energyRequired?: NullableFloatFieldUpdateOperationsInput | number | null
    isAdHoc?: BoolFieldUpdateOperationsInput | boolean
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MonthPlanCreateManyQuarterPlanInput = {
    id?: string
    month: number
    year: number
    objectives?: MonthPlanCreateobjectivesInput | string[]
    completionRate?: number
    energyRating?: number | null
    rating?: number | null
    reviewNotes?: string | null
    theme?: string | null
  }

  export type QuarterFocusCreateManyQuarterPlanInput = {
    id?: string
    goalId: string
    priority?: number
    progress?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuarterObjectiveCreateManyQuarterPlanInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MonthPlanUpdateWithoutQuarterPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    objectives?: MonthPlanUpdateobjectivesInput | string[]
    completionRate?: FloatFieldUpdateOperationsInput | number
    energyRating?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    monthFocuses?: MonthFocusUpdateManyWithoutMonthPlanNestedInput
    weekPlans?: WeekPlanUpdateManyWithoutMonthPlanNestedInput
  }

  export type MonthPlanUncheckedUpdateWithoutQuarterPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    objectives?: MonthPlanUpdateobjectivesInput | string[]
    completionRate?: FloatFieldUpdateOperationsInput | number
    energyRating?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    monthFocuses?: MonthFocusUncheckedUpdateManyWithoutMonthPlanNestedInput
    weekPlans?: WeekPlanUncheckedUpdateManyWithoutMonthPlanNestedInput
  }

  export type MonthPlanUncheckedUpdateManyWithoutQuarterPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    objectives?: MonthPlanUpdateobjectivesInput | string[]
    completionRate?: FloatFieldUpdateOperationsInput | number
    energyRating?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuarterFocusUpdateWithoutQuarterPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monthFocuses?: MonthFocusUpdateManyWithoutQuarterFocusNestedInput
    goal?: GoalUpdateOneRequiredWithoutQuarterFocusesNestedInput
  }

  export type QuarterFocusUncheckedUpdateWithoutQuarterPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monthFocuses?: MonthFocusUncheckedUpdateManyWithoutQuarterFocusNestedInput
  }

  export type QuarterFocusUncheckedUpdateManyWithoutQuarterPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuarterObjectiveUpdateWithoutQuarterPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuarterObjectiveUncheckedUpdateWithoutQuarterPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuarterObjectiveUncheckedUpdateManyWithoutQuarterPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonthFocusCreateManyQuarterFocusInput = {
    id?: string
    monthPlanId: string
    priority?: number
    progress?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MonthFocusUpdateWithoutQuarterFocusInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monthPlan?: MonthPlanUpdateOneRequiredWithoutMonthFocusesNestedInput
    weekFocuses?: WeekFocusUpdateManyWithoutMonthFocusNestedInput
  }

  export type MonthFocusUncheckedUpdateWithoutQuarterFocusInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthPlanId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weekFocuses?: WeekFocusUncheckedUpdateManyWithoutMonthFocusNestedInput
  }

  export type MonthFocusUncheckedUpdateManyWithoutQuarterFocusInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthPlanId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonthFocusCreateManyMonthPlanInput = {
    id?: string
    quarterFocusId: string
    priority?: number
    progress?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeekPlanCreateManyMonthPlanInput = {
    id?: string
    weekNumber: number
    year: number
    startDate: Date | string
    endDate: Date | string
    topOutcomes?: WeekPlanCreatetopOutcomesInput | string[]
    plannedClientHours?: number | null
    plannedPersonalHours?: number | null
    userId: string
    challenges?: WeekPlanCreatechallengesInput | string[]
    keyWins?: WeekPlanCreatekeyWinsInput | string[]
    lessonsLearned?: WeekPlanCreatelessonsLearnedInput | string[]
    rating?: number | null
    reviewNotes?: string | null
  }

  export type MonthFocusUpdateWithoutMonthPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quarterFocus?: QuarterFocusUpdateOneRequiredWithoutMonthFocusesNestedInput
    weekFocuses?: WeekFocusUpdateManyWithoutMonthFocusNestedInput
  }

  export type MonthFocusUncheckedUpdateWithoutMonthPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    quarterFocusId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weekFocuses?: WeekFocusUncheckedUpdateManyWithoutMonthFocusNestedInput
  }

  export type MonthFocusUncheckedUpdateManyWithoutMonthPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    quarterFocusId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeekPlanUpdateWithoutMonthPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    topOutcomes?: WeekPlanUpdatetopOutcomesInput | string[]
    plannedClientHours?: NullableFloatFieldUpdateOperationsInput | number | null
    plannedPersonalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    challenges?: WeekPlanUpdatechallengesInput | string[]
    keyWins?: WeekPlanUpdatekeyWinsInput | string[]
    lessonsLearned?: WeekPlanUpdatelessonsLearnedInput | string[]
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dayPlans?: DayPlanUpdateManyWithoutWeekPlanNestedInput
    weekFocuses?: WeekFocusUpdateManyWithoutWeekPlanNestedInput
    user?: UserUpdateOneRequiredWithoutWeekPlansNestedInput
  }

  export type WeekPlanUncheckedUpdateWithoutMonthPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    topOutcomes?: WeekPlanUpdatetopOutcomesInput | string[]
    plannedClientHours?: NullableFloatFieldUpdateOperationsInput | number | null
    plannedPersonalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    challenges?: WeekPlanUpdatechallengesInput | string[]
    keyWins?: WeekPlanUpdatekeyWinsInput | string[]
    lessonsLearned?: WeekPlanUpdatelessonsLearnedInput | string[]
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dayPlans?: DayPlanUncheckedUpdateManyWithoutWeekPlanNestedInput
    weekFocuses?: WeekFocusUncheckedUpdateManyWithoutWeekPlanNestedInput
  }

  export type WeekPlanUncheckedUpdateManyWithoutMonthPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    topOutcomes?: WeekPlanUpdatetopOutcomesInput | string[]
    plannedClientHours?: NullableFloatFieldUpdateOperationsInput | number | null
    plannedPersonalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    challenges?: WeekPlanUpdatechallengesInput | string[]
    keyWins?: WeekPlanUpdatekeyWinsInput | string[]
    lessonsLearned?: WeekPlanUpdatelessonsLearnedInput | string[]
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WeekFocusCreateManyMonthFocusInput = {
    id?: string
    weekPlanId: string
    priority?: number
    progress?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeekFocusUpdateWithoutMonthFocusInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayFocuses?: DayFocusUpdateManyWithoutWeekFocusNestedInput
    weekPlan?: WeekPlanUpdateOneRequiredWithoutWeekFocusesNestedInput
  }

  export type WeekFocusUncheckedUpdateWithoutMonthFocusInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekPlanId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayFocuses?: DayFocusUncheckedUpdateManyWithoutWeekFocusNestedInput
  }

  export type WeekFocusUncheckedUpdateManyWithoutMonthFocusInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekPlanId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DayPlanCreateManyWeekPlanInput = {
    id?: string
    date: Date | string
    topPriorities?: DayPlanCreatetopPrioritiesInput | string[]
    morningEnergy?: number | null
    afternoonEnergy?: number | null
    eveningEnergy?: number | null
    dailyWin?: string | null
    gratitude?: DayPlanCreategratitudeInput | string[]
    tomorrowPrep?: DayPlanCreatetomorrowPrepInput | string[]
    completionRate?: number
    userId: string
  }

  export type WeekFocusCreateManyWeekPlanInput = {
    id?: string
    monthFocusId: string
    priority?: number
    progress?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DayPlanUpdateWithoutWeekPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topPriorities?: DayPlanUpdatetopPrioritiesInput | string[]
    morningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    afternoonEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    eveningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyWin?: NullableStringFieldUpdateOperationsInput | string | null
    gratitude?: DayPlanUpdategratitudeInput | string[]
    tomorrowPrep?: DayPlanUpdatetomorrowPrepInput | string[]
    completionRate?: FloatFieldUpdateOperationsInput | number
    dayFocuses?: DayFocusUpdateManyWithoutDayPlanNestedInput
    user?: UserUpdateOneRequiredWithoutDayPlansNestedInput
    notes?: NoteUpdateManyWithoutDayPlanNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutDayPlanNestedInput
  }

  export type DayPlanUncheckedUpdateWithoutWeekPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topPriorities?: DayPlanUpdatetopPrioritiesInput | string[]
    morningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    afternoonEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    eveningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyWin?: NullableStringFieldUpdateOperationsInput | string | null
    gratitude?: DayPlanUpdategratitudeInput | string[]
    tomorrowPrep?: DayPlanUpdatetomorrowPrepInput | string[]
    completionRate?: FloatFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    dayFocuses?: DayFocusUncheckedUpdateManyWithoutDayPlanNestedInput
    notes?: NoteUncheckedUpdateManyWithoutDayPlanNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutDayPlanNestedInput
  }

  export type DayPlanUncheckedUpdateManyWithoutWeekPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topPriorities?: DayPlanUpdatetopPrioritiesInput | string[]
    morningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    afternoonEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    eveningEnergy?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyWin?: NullableStringFieldUpdateOperationsInput | string | null
    gratitude?: DayPlanUpdategratitudeInput | string[]
    tomorrowPrep?: DayPlanUpdatetomorrowPrepInput | string[]
    completionRate?: FloatFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type WeekFocusUpdateWithoutWeekPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayFocuses?: DayFocusUpdateManyWithoutWeekFocusNestedInput
    monthFocus?: MonthFocusUpdateOneRequiredWithoutWeekFocusesNestedInput
  }

  export type WeekFocusUncheckedUpdateWithoutWeekPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthFocusId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayFocuses?: DayFocusUncheckedUpdateManyWithoutWeekFocusNestedInput
  }

  export type WeekFocusUncheckedUpdateManyWithoutWeekPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthFocusId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DayFocusCreateManyWeekFocusInput = {
    id?: string
    dayPlanId: string
    priority?: number
    completed?: boolean
    completedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DayFocusUpdateWithoutWeekFocusInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayPlan?: DayPlanUpdateOneRequiredWithoutDayFocusesNestedInput
  }

  export type DayFocusUncheckedUpdateWithoutWeekFocusInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayPlanId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DayFocusUncheckedUpdateManyWithoutWeekFocusInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayPlanId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DayFocusCreateManyDayPlanInput = {
    id?: string
    weekFocusId: string
    priority?: number
    completed?: boolean
    completedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoteCreateManyDayPlanInput = {
    id?: string
    userId: string
    content: string
    goalId?: string | null
    keyStepId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeBlockCreateManyDayPlanInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    duration: number
    type: string
    taskId?: string | null
    projectId?: string | null
    clientId?: string | null
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    actualDuration?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    focusQuality?: number | null
    notes?: string | null
  }

  export type DayFocusUpdateWithoutDayPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weekFocus?: WeekFocusUpdateOneRequiredWithoutDayFocusesNestedInput
  }

  export type DayFocusUncheckedUpdateWithoutDayPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekFocusId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DayFocusUncheckedUpdateManyWithoutDayPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekFocusId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUpdateWithoutDayPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goal?: GoalUpdateOneWithoutNotesNestedInput
    keyStep?: KeyStepUpdateOneWithoutNotesNestedInput
    user?: UserUpdateOneRequiredWithoutNotesNestedInput
  }

  export type NoteUncheckedUpdateWithoutDayPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    keyStepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUncheckedUpdateManyWithoutDayPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    keyStepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeBlockUpdateWithoutDayPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    energyBefore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneWithoutTimeBlocksNestedInput
    project?: ProjectUpdateOneWithoutTimeBlocksNestedInput
    task?: TaskUpdateOneWithoutTimeBlocksNestedInput
  }

  export type TimeBlockUncheckedUpdateWithoutDayPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    energyBefore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimeBlockUncheckedUpdateManyWithoutDayPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    energyBefore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskCreateManyProjectInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    estimatedMinutes?: number | null
    actualMinutes?: number
    timerRunning?: boolean
    currentTimerStart?: Date | string | null
    scheduledDate?: Date | string | null
    dueDate?: Date | string | null
    priority: string
    type: string
    tags?: TaskCreatetagsInput | string[]
    parentTaskId?: string | null
    dependsOn?: TaskCreatedependsOnInput | string[]
    blocks?: TaskCreateblocksInput | string[]
    energyRequired?: number | null
    isAdHoc?: boolean
    isRecurring?: boolean
    recurringPattern?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meetingId?: string | null
    goalId?: string | null
    keyStepId?: string | null
  }

  export type TimeBlockCreateManyProjectInput = {
    id?: string
    dayPlanId: string
    startTime: Date | string
    endTime: Date | string
    duration: number
    type: string
    taskId?: string | null
    clientId?: string | null
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    actualDuration?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    focusQuality?: number | null
    notes?: string | null
  }

  export type TimeEntryCreateManyProjectInput = {
    id?: string
    userId: string
    taskId?: string | null
    clientId?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    duration: number
    type: string
    description?: string | null
    tags?: TimeEntryCreatetagsInput | string[]
    focusQuality?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    distractions?: number
    billable?: boolean
    hourlyRate?: number | null
    amount?: number
    invoiced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    actualMinutes?: IntFieldUpdateOperationsInput | number
    timerRunning?: BoolFieldUpdateOperationsInput | boolean
    currentTimerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tags?: TaskUpdatetagsInput | string[]
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOn?: TaskUpdatedependsOnInput | string[]
    blocks?: TaskUpdateblocksInput | string[]
    energyRequired?: NullableFloatFieldUpdateOperationsInput | number | null
    isAdHoc?: BoolFieldUpdateOperationsInput | boolean
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionItem?: ActionItemUpdateOneWithoutConvertedToTaskNestedInput
    goal?: GoalUpdateOneWithoutTasksNestedInput
    keyStep?: KeyStepUpdateOneWithoutTasksNestedInput
    meeting?: MeetingUpdateOneWithoutTasksNestedInput
    user?: UserUpdateOneRequiredWithoutTasksNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutTaskNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    actualMinutes?: IntFieldUpdateOperationsInput | number
    timerRunning?: BoolFieldUpdateOperationsInput | boolean
    currentTimerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tags?: TaskUpdatetagsInput | string[]
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOn?: TaskUpdatedependsOnInput | string[]
    blocks?: TaskUpdateblocksInput | string[]
    energyRequired?: NullableFloatFieldUpdateOperationsInput | number | null
    isAdHoc?: BoolFieldUpdateOperationsInput | boolean
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    keyStepId?: NullableStringFieldUpdateOperationsInput | string | null
    actionItem?: ActionItemUncheckedUpdateOneWithoutConvertedToTaskNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutTaskNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    actualMinutes?: IntFieldUpdateOperationsInput | number
    timerRunning?: BoolFieldUpdateOperationsInput | boolean
    currentTimerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tags?: TaskUpdatetagsInput | string[]
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOn?: TaskUpdatedependsOnInput | string[]
    blocks?: TaskUpdateblocksInput | string[]
    energyRequired?: NullableFloatFieldUpdateOperationsInput | number | null
    isAdHoc?: BoolFieldUpdateOperationsInput | boolean
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    keyStepId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimeBlockUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    energyBefore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneWithoutTimeBlocksNestedInput
    dayPlan?: DayPlanUpdateOneRequiredWithoutTimeBlocksNestedInput
    task?: TaskUpdateOneWithoutTimeBlocksNestedInput
  }

  export type TimeBlockUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayPlanId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    energyBefore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimeBlockUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayPlanId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    energyBefore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimeEntryUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TimeEntryUpdatetagsInput | string[]
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    energyBefore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    distractions?: IntFieldUpdateOperationsInput | number
    billable?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    invoiced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutTimeEntriesNestedInput
    task?: TaskUpdateOneWithoutTimeEntriesNestedInput
    user?: UserUpdateOneRequiredWithoutTimeEntriesNestedInput
  }

  export type TimeEntryUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TimeEntryUpdatetagsInput | string[]
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    energyBefore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    distractions?: IntFieldUpdateOperationsInput | number
    billable?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    invoiced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeEntryUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TimeEntryUpdatetagsInput | string[]
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    energyBefore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    distractions?: IntFieldUpdateOperationsInput | number
    billable?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    invoiced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeBlockCreateManyTaskInput = {
    id?: string
    dayPlanId: string
    startTime: Date | string
    endTime: Date | string
    duration: number
    type: string
    projectId?: string | null
    clientId?: string | null
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    actualDuration?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    focusQuality?: number | null
    notes?: string | null
  }

  export type TimeEntryCreateManyTaskInput = {
    id?: string
    userId: string
    projectId?: string | null
    clientId?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    duration: number
    type: string
    description?: string | null
    tags?: TimeEntryCreatetagsInput | string[]
    focusQuality?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    distractions?: number
    billable?: boolean
    hourlyRate?: number | null
    amount?: number
    invoiced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeBlockUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    energyBefore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneWithoutTimeBlocksNestedInput
    dayPlan?: DayPlanUpdateOneRequiredWithoutTimeBlocksNestedInput
    project?: ProjectUpdateOneWithoutTimeBlocksNestedInput
  }

  export type TimeBlockUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayPlanId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    energyBefore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimeBlockUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayPlanId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    energyBefore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimeEntryUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TimeEntryUpdatetagsInput | string[]
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    energyBefore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    distractions?: IntFieldUpdateOperationsInput | number
    billable?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    invoiced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutTimeEntriesNestedInput
    project?: ProjectUpdateOneWithoutTimeEntriesNestedInput
    user?: UserUpdateOneRequiredWithoutTimeEntriesNestedInput
  }

  export type TimeEntryUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TimeEntryUpdatetagsInput | string[]
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    energyBefore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    distractions?: IntFieldUpdateOperationsInput | number
    billable?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    invoiced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeEntryUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TimeEntryUpdatetagsInput | string[]
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    energyBefore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    distractions?: IntFieldUpdateOperationsInput | number
    billable?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    invoiced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunicationCreateManyClientInput = {
    id?: string
    projectId?: string | null
    type: string
    direction: string
    subject: string
    content: string
    summary?: string | null
    from?: string | null
    to?: CommunicationCreatetoInput | string[]
    cc?: CommunicationCreateccInput | string[]
    attachments?: CommunicationCreateattachmentsInput | InputJsonValue[]
    meetingDate?: Date | string | null
    meetingDuration?: number | null
    attendees?: CommunicationCreateattendeesInput | string[]
    meetingNotes?: string | null
    sentiment?: string | null
    requiresFollowUp?: boolean
    followUpDate?: Date | string | null
    createdAt?: Date | string
    responseTime?: number | null
  }

  export type MeetingCreateManyClientInput = {
    id?: string
    projectId?: string | null
    title: string
    description?: string | null
    type?: string
    scheduledAt: Date | string
    duration: number
    timezone?: string
    organizer?: string
    requiredAttendees?: MeetingCreaterequiredAttendeesInput | string[]
    optionalAttendees?: MeetingCreateoptionalAttendeesInput | string[]
    location?: string | null
    meetingLink?: string | null
    agenda?: string | null
    meetingNotes?: string | null
    actionItems?: MeetingCreateactionItemsInput | InputJsonValue[]
    decisions?: MeetingCreatedecisionsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type ProjectCreateManyClientInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    type: string
    status: string
    billable?: boolean
    hourlyRate?: number | null
    budgetHours?: number | null
    startDate?: Date | string | null
    deadline?: Date | string | null
    estimatedHours?: number | null
    actualHoursSpent?: number
    completionPercentage?: number
    goalId?: string | null
    parentProjectId?: string | null
    priority: string
    tags?: ProjectCreatetagsInput | string[]
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    archivedAt?: Date | string | null
    icon?: string | null
  }

  export type TimeBlockCreateManyClientInput = {
    id?: string
    dayPlanId: string
    startTime: Date | string
    endTime: Date | string
    duration: number
    type: string
    taskId?: string | null
    projectId?: string | null
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    actualDuration?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    focusQuality?: number | null
    notes?: string | null
  }

  export type TimeEntryCreateManyClientInput = {
    id?: string
    userId: string
    taskId?: string | null
    projectId?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    duration: number
    type: string
    description?: string | null
    tags?: TimeEntryCreatetagsInput | string[]
    focusQuality?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    distractions?: number
    billable?: boolean
    hourlyRate?: number | null
    amount?: number
    invoiced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunicationUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    from?: NullableStringFieldUpdateOperationsInput | string | null
    to?: CommunicationUpdatetoInput | string[]
    cc?: CommunicationUpdateccInput | string[]
    attachments?: CommunicationUpdateattachmentsInput | InputJsonValue[]
    meetingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meetingDuration?: NullableIntFieldUpdateOperationsInput | number | null
    attendees?: CommunicationUpdateattendeesInput | string[]
    meetingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    requiresFollowUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CommunicationUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    from?: NullableStringFieldUpdateOperationsInput | string | null
    to?: CommunicationUpdatetoInput | string[]
    cc?: CommunicationUpdateccInput | string[]
    attachments?: CommunicationUpdateattachmentsInput | InputJsonValue[]
    meetingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meetingDuration?: NullableIntFieldUpdateOperationsInput | number | null
    attendees?: CommunicationUpdateattendeesInput | string[]
    meetingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    requiresFollowUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CommunicationUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    from?: NullableStringFieldUpdateOperationsInput | string | null
    to?: CommunicationUpdatetoInput | string[]
    cc?: CommunicationUpdateccInput | string[]
    attachments?: CommunicationUpdateattachmentsInput | InputJsonValue[]
    meetingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meetingDuration?: NullableIntFieldUpdateOperationsInput | number | null
    attendees?: CommunicationUpdateattendeesInput | string[]
    meetingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    requiresFollowUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MeetingUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    organizer?: StringFieldUpdateOperationsInput | string
    requiredAttendees?: MeetingUpdaterequiredAttendeesInput | string[]
    optionalAttendees?: MeetingUpdateoptionalAttendeesInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    meetingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    actionItems?: MeetingUpdateactionItemsInput | InputJsonValue[]
    decisions?: MeetingUpdatedecisionsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMeetingsNestedInput
    tasks?: TaskUpdateManyWithoutMeetingNestedInput
  }

  export type MeetingUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    organizer?: StringFieldUpdateOperationsInput | string
    requiredAttendees?: MeetingUpdaterequiredAttendeesInput | string[]
    optionalAttendees?: MeetingUpdateoptionalAttendeesInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    meetingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    actionItems?: MeetingUpdateactionItemsInput | InputJsonValue[]
    decisions?: MeetingUpdatedecisionsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    tasks?: TaskUncheckedUpdateManyWithoutMeetingNestedInput
  }

  export type MeetingUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    organizer?: StringFieldUpdateOperationsInput | string
    requiredAttendees?: MeetingUpdaterequiredAttendeesInput | string[]
    optionalAttendees?: MeetingUpdateoptionalAttendeesInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    meetingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    actionItems?: MeetingUpdateactionItemsInput | InputJsonValue[]
    decisions?: MeetingUpdatedecisionsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    billable?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetHours?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHoursSpent?: FloatFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    parentProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    tags?: ProjectUpdatetagsInput | string[]
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutProjectNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    billable?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetHours?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHoursSpent?: FloatFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    parentProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    tags?: ProjectUpdatetagsInput | string[]
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutProjectNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    billable?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetHours?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHoursSpent?: FloatFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    parentProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    tags?: ProjectUpdatetagsInput | string[]
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimeBlockUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    energyBefore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dayPlan?: DayPlanUpdateOneRequiredWithoutTimeBlocksNestedInput
    project?: ProjectUpdateOneWithoutTimeBlocksNestedInput
    task?: TaskUpdateOneWithoutTimeBlocksNestedInput
  }

  export type TimeBlockUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayPlanId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    energyBefore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimeBlockUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayPlanId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    energyBefore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimeEntryUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TimeEntryUpdatetagsInput | string[]
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    energyBefore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    distractions?: IntFieldUpdateOperationsInput | number
    billable?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    invoiced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutTimeEntriesNestedInput
    task?: TaskUpdateOneWithoutTimeEntriesNestedInput
    user?: UserUpdateOneRequiredWithoutTimeEntriesNestedInput
  }

  export type TimeEntryUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TimeEntryUpdatetagsInput | string[]
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    energyBefore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    distractions?: IntFieldUpdateOperationsInput | number
    billable?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    invoiced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeEntryUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TimeEntryUpdatetagsInput | string[]
    focusQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    energyBefore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    distractions?: IntFieldUpdateOperationsInput | number
    billable?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    invoiced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateManyMeetingInput = {
    id?: string
    userId: string
    projectId?: string | null
    title: string
    description?: string | null
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    estimatedMinutes?: number | null
    actualMinutes?: number
    timerRunning?: boolean
    currentTimerStart?: Date | string | null
    scheduledDate?: Date | string | null
    dueDate?: Date | string | null
    priority: string
    type: string
    tags?: TaskCreatetagsInput | string[]
    parentTaskId?: string | null
    dependsOn?: TaskCreatedependsOnInput | string[]
    blocks?: TaskCreateblocksInput | string[]
    energyRequired?: number | null
    isAdHoc?: boolean
    isRecurring?: boolean
    recurringPattern?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goalId?: string | null
    keyStepId?: string | null
  }

  export type TaskUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    actualMinutes?: IntFieldUpdateOperationsInput | number
    timerRunning?: BoolFieldUpdateOperationsInput | boolean
    currentTimerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tags?: TaskUpdatetagsInput | string[]
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOn?: TaskUpdatedependsOnInput | string[]
    blocks?: TaskUpdateblocksInput | string[]
    energyRequired?: NullableFloatFieldUpdateOperationsInput | number | null
    isAdHoc?: BoolFieldUpdateOperationsInput | boolean
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionItem?: ActionItemUpdateOneWithoutConvertedToTaskNestedInput
    goal?: GoalUpdateOneWithoutTasksNestedInput
    keyStep?: KeyStepUpdateOneWithoutTasksNestedInput
    project?: ProjectUpdateOneWithoutTasksNestedInput
    user?: UserUpdateOneRequiredWithoutTasksNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutTaskNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    actualMinutes?: IntFieldUpdateOperationsInput | number
    timerRunning?: BoolFieldUpdateOperationsInput | boolean
    currentTimerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tags?: TaskUpdatetagsInput | string[]
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOn?: TaskUpdatedependsOnInput | string[]
    blocks?: TaskUpdateblocksInput | string[]
    energyRequired?: NullableFloatFieldUpdateOperationsInput | number | null
    isAdHoc?: BoolFieldUpdateOperationsInput | boolean
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    keyStepId?: NullableStringFieldUpdateOperationsInput | string | null
    actionItem?: ActionItemUncheckedUpdateOneWithoutConvertedToTaskNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutTaskNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    actualMinutes?: IntFieldUpdateOperationsInput | number
    timerRunning?: BoolFieldUpdateOperationsInput | boolean
    currentTimerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tags?: TaskUpdatetagsInput | string[]
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOn?: TaskUpdatedependsOnInput | string[]
    blocks?: TaskUpdateblocksInput | string[]
    energyRequired?: NullableFloatFieldUpdateOperationsInput | number | null
    isAdHoc?: BoolFieldUpdateOperationsInput | boolean
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    keyStepId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActionItemCreateManyResearchInput = {
    id?: string
    description: string
    priority?: $Enums.ActionPriority
    effort?: number
    convertedToTaskId?: string | null
    convertedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ResearchInsightCreateManyResearchInput = {
    id?: string
    title: string
    content: string
    category: string
    visualData?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number
    order?: number
    createdAt?: Date | string
  }

  export type ResearchSourceCreateManyResearchInput = {
    id?: string
    url: string
    title: string
    content?: string
    excerpt: string
    credibility?: number
    citedInSections?: ResearchSourceCreatecitedInSectionsInput | string[]
    scrapedAt?: Date | string
  }

  export type ActionItemUpdateWithoutResearchInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumActionPriorityFieldUpdateOperationsInput | $Enums.ActionPriority
    effort?: IntFieldUpdateOperationsInput | number
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    convertedToTask?: TaskUpdateOneWithoutActionItemNestedInput
  }

  export type ActionItemUncheckedUpdateWithoutResearchInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumActionPriorityFieldUpdateOperationsInput | $Enums.ActionPriority
    effort?: IntFieldUpdateOperationsInput | number
    convertedToTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionItemUncheckedUpdateManyWithoutResearchInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumActionPriorityFieldUpdateOperationsInput | $Enums.ActionPriority
    effort?: IntFieldUpdateOperationsInput | number
    convertedToTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchInsightUpdateWithoutResearchInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    visualData?: NullableJsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchInsightUncheckedUpdateWithoutResearchInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    visualData?: NullableJsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchInsightUncheckedUpdateManyWithoutResearchInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    visualData?: NullableJsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchSourceUpdateWithoutResearchInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    credibility?: FloatFieldUpdateOperationsInput | number
    citedInSections?: ResearchSourceUpdatecitedInSectionsInput | string[]
    scrapedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchSourceUncheckedUpdateWithoutResearchInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    credibility?: FloatFieldUpdateOperationsInput | number
    citedInSections?: ResearchSourceUpdatecitedInSectionsInput | string[]
    scrapedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchSourceUncheckedUpdateManyWithoutResearchInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    credibility?: FloatFieldUpdateOperationsInput | number
    citedInSections?: ResearchSourceUpdatecitedInSectionsInput | string[]
    scrapedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadCreateManyLeadDataInput = {
    id?: string
    name: string
    company?: string | null
    email?: string | null
    phone?: string | null
    website?: string | null
    industry?: string | null
    location?: string | null
    painPoints?: LeadCreatepainPointsInput | string[]
    suggestedDM: string
    suggestedEmail: string
    personalization?: NullableJsonNullValueInput | InputJsonValue
    contacted?: boolean
    contactedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type LeadUpdateWithoutLeadDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    painPoints?: LeadUpdatepainPointsInput | string[]
    suggestedDM?: StringFieldUpdateOperationsInput | string
    suggestedEmail?: StringFieldUpdateOperationsInput | string
    personalization?: NullableJsonNullValueInput | InputJsonValue
    contacted?: BoolFieldUpdateOperationsInput | boolean
    contactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadUncheckedUpdateWithoutLeadDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    painPoints?: LeadUpdatepainPointsInput | string[]
    suggestedDM?: StringFieldUpdateOperationsInput | string
    suggestedEmail?: StringFieldUpdateOperationsInput | string
    personalization?: NullableJsonNullValueInput | InputJsonValue
    contacted?: BoolFieldUpdateOperationsInput | boolean
    contactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadUncheckedUpdateManyWithoutLeadDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    painPoints?: LeadUpdatepainPointsInput | string[]
    suggestedDM?: StringFieldUpdateOperationsInput | string
    suggestedEmail?: StringFieldUpdateOperationsInput | string
    personalization?: NullableJsonNullValueInput | InputJsonValue
    contacted?: BoolFieldUpdateOperationsInput | boolean
    contactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}